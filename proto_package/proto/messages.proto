//
//  Generated. Do not modify.
//

syntax = "proto3";

import "enums.proto";

// package:flutter/src/cupertino/dialog.dart
//
// Creates an iOS-style action sheet.
//
// An action sheet must have a non-null value for at least one of the
// following arguments: [actions], [title], [message], or [cancelButton].
//
// Generally, action sheets are used to give the user a choice between
// two or more choices for the current context.
message CupertinoActionSheet {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // An optional title of the action sheet. When the [message] is non-null,
  // the font of the [title] is bold.
  //
  // Typically a [Text] widget.
  WidgetType title = 3;
  // An optional descriptive message that provides more details about the
  // reason for the alert.
  //
  // Typically a [Text] widget.
  WidgetType message = 4;
  // The set of actions that are displayed for the user to select.
  //
  // Typically this is a list of [CupertinoActionSheetAction] widgets.
  repeated WidgetType actions = 5;
  // A scroll controller that can be used to control the scrolling of the
  // [message] in the action sheet.
  //
  // This attribute is typically not needed, as alert messages should be
  // short.
  FlutterScrollControllerType message_scroll_controller = 6;
  // A scroll controller that can be used to control the scrolling of the
  // [actions] in the action sheet.
  //
  // This attribute is typically not needed.
  FlutterScrollControllerType action_scroll_controller = 7;
  // The optional cancel button that is grouped separately from the other
  // actions.
  //
  // Typically this is an [CupertinoActionSheetAction] widget.
  WidgetType cancel_button = 8;
}

// package:flutter/src/cupertino/activity_indicator.dart
//
// Creates an iOS-style activity indicator that spins clockwise.
message CupertinoActivityIndicator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Color of the activity indicator.
  //
  // Defaults to color extracted from native iOS.
  DartColorType color = 3;
  // Whether the activity indicator is running its animation.
  //
  // Defaults to true.
  bool animating = 4;
  // Radius of the spinner widget.
  //
  // Defaults to 10 pixels. Must be positive.
  double radius = 5;
}

// package:flutter/src/cupertino/activity_indicator.dart
//
// Creates a non-animated iOS-style activity indicator that displays
// a partial count of ticks based on the value of [progress].
//
// When provided, the value of [progress] must be between 0.0 (zero ticks
// will be shown) and 1.0 (all ticks will be shown) inclusive. Defaults
// to 1.0.
message CupertinoActivityIndicatorNamedPartiallyRevealed {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Color of the activity indicator.
  //
  // Defaults to color extracted from native iOS.
  DartColorType color = 3;
  // Radius of the spinner widget.
  //
  // Defaults to 10 pixels. Must be positive.
  double radius = 4;
  // Determines the percentage of spinner ticks that will be shown. Typical usage would
  // display all ticks, however, this allows for more fine-grained control such as
  // during pull-to-refresh when the drag-down action shows one tick at a time as
  // the user continues to drag down.
  //
  // Defaults to one. Must be between zero and one, inclusive.
  double progress = 5;
}

// package:flutter/src/cupertino/adaptive_text_selection_toolbar.dart
//
// Create an instance of [CupertinoAdaptiveTextSelectionToolbar] with the
// given [children].
//
// See also:
//
// {@template flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.buttonItems}
// * [CupertinoAdaptiveTextSelectionToolbar.buttonItems], which takes a list
//   of [ContextMenuButtonItem]s instead of [children] widgets.
// {@endtemplate}
// {@template flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.editable}
// * [CupertinoAdaptiveTextSelectionToolbar.editable], which builds the
//   default Cupertino children for an editable field.
// {@endtemplate}
// {@template flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.editableText}
// * [CupertinoAdaptiveTextSelectionToolbar.editableText], which builds the
//   default Cupertino children for an [EditableText].
// {@endtemplate}
// {@template flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.selectable}
// * [CupertinoAdaptiveTextSelectionToolbar.selectable], which builds the
//   Cupertino children for content that is selectable but not editable.
// {@endtemplate}
message CupertinoAdaptiveTextSelectionToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The children of the toolbar, typically buttons.
  repeated WidgetType children = 3;
  // {@macro flutter.material.AdaptiveTextSelectionToolbar.anchors}
  FlutterTextSelectionToolbarAnchorsType anchors = 4;
}

// package:flutter/src/cupertino/adaptive_text_selection_toolbar.dart
//
// Create an instance of [CupertinoAdaptiveTextSelectionToolbar] whose
// children will be built from the given [buttonItems].
//
// See also:
//
// {@template flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.new}
// * [CupertinoAdaptiveTextSelectionToolbar.new], which takes the children
//   directly as a list of widgets.
// {@endtemplate}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.editable}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.editableText}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.selectable}
message CupertinoAdaptiveTextSelectionToolbarNamedButtonItems {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [ContextMenuButtonItem]s that will be turned into the correct button
  // widgets for the current platform.
  repeated FlutterContextMenuButtonItemType button_items = 3;
  // {@macro flutter.material.AdaptiveTextSelectionToolbar.anchors}
  FlutterTextSelectionToolbarAnchorsType anchors = 4;
}

// package:flutter/src/cupertino/adaptive_text_selection_toolbar.dart
//
// Create an instance of [CupertinoAdaptiveTextSelectionToolbar] with the
// default children for an editable field.
//
// If a callback is null, then its corresponding button will not be built.
//
// See also:
//
// * [AdaptiveTextSelectionToolbar.editable], which is similar to this but
//   includes Material and Cupertino toolbars.
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.new}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.editableText}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.buttonItems}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.selectable}
message CupertinoAdaptiveTextSelectionToolbarNamedEditable {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterClipboardStatusType.Enum clipboard_status = 3;
  // {@macro flutter.material.AdaptiveTextSelectionToolbar.anchors}
  FlutterTextSelectionToolbarAnchorsType anchors = 12;
}

// package:flutter/src/cupertino/adaptive_text_selection_toolbar.dart
//
// Create an instance of [CupertinoAdaptiveTextSelectionToolbar] with the
// default children for an [EditableText].
//
// See also:
//
// * [AdaptiveTextSelectionToolbar.editableText], which is similar to this
//   but includes Material and Cupertino toolbars.
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.new}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.editable}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.buttonItems}
// {@macro flutter.cupertino.CupertinoAdaptiveTextSelectionToolbar.selectable}
message CupertinoAdaptiveTextSelectionToolbarNamedEditableText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterEditableTextStateType editable_text_state = 3;
}

// package:flutter/src/cupertino/dialog.dart
//
// Creates an iOS-style alert dialog.
message CupertinoAlertDialog {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The (optional) title of the dialog is displayed in a large font at the top
  // of the dialog.
  //
  // Typically a [Text] widget.
  WidgetType title = 3;
  // The (optional) content of the dialog is displayed in the center of the
  // dialog in a lighter font.
  //
  // Typically a [Text] widget.
  WidgetType content = 4;
  // The (optional) set of actions that are displayed at the bottom of the
  // dialog.
  //
  // Typically this is a list of [CupertinoDialogAction] widgets.
  repeated WidgetType actions = 5;
  // A scroll controller that can be used to control the scrolling of the
  // [content] in the dialog.
  //
  // Defaults to null, and is typically not needed, since most alert messages
  // are short.
  //
  // See also:
  //
  //  * [actionScrollController], which can be used for controlling the actions
  //    section when there are many actions.
  FlutterScrollControllerType scroll_controller = 6;
  // A scroll controller that can be used to control the scrolling of the
  // actions in the dialog.
  //
  // Defaults to null, and is typically not needed.
  //
  // See also:
  //
  //  * [scrollController], which can be used for controlling the [content]
  //    section when it is long.
  FlutterScrollControllerType action_scroll_controller = 7;
  // {@macro flutter.material.dialog.insetAnimationDuration}
  DartDurationType inset_animation_duration = 8;
  // {@macro flutter.material.dialog.insetAnimationCurve}
  FlutterSrcAnimationCurveType inset_animation_curve = 9;
}

// package:flutter/src/cupertino/app.dart
//
// Creates a CupertinoApp.
//
// At least one of [home], [routes], [onGenerateRoute], or [builder] must be
// non-null. If only [routes] is given, it must include an entry for the
// [Navigator.defaultRouteName] (`/`), since that is the route used when the
// application is launched with an intent that specifies an otherwise
// unsupported route.
//
// This class creates an instance of [WidgetsApp].
message CupertinoApp {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.widgetsApp.home}
  WidgetType home = 4;
  // The top-level [CupertinoTheme] styling.
  //
  // A null [theme] or unspecified [theme] attributes will default to iOS
  // system values.
  CupertinoThemeDataType theme = 5;
  // {@macro flutter.widgets.widgetsApp.initialRoute}
  string initial_route = 7;
  // {@macro flutter.widgets.widgetsApp.navigatorObservers}
  repeated FlutterNavigatorObserverType navigator_observers = 12;
  // {@macro flutter.widgets.widgetsApp.title}
  //
  // This value is passed unmodified to [WidgetsApp.title].
  string title = 14;
  // {@macro flutter.widgets.widgetsApp.color}
  DartColorType color = 16;
  // {@macro flutter.widgets.widgetsApp.locale}
  DartLocaleType locale = 17;
  // {@macro flutter.widgets.widgetsApp.supportedLocales}
  //
  // It is passed along unmodified to the [WidgetsApp] built by this widget.
  repeated DartLocaleType supported_locales = 21;
  // Turns on a performance overlay.
  //
  // See also:
  //
  //  * <https://flutter.dev/debugging/#performance-overlay>
  bool show_performance_overlay = 22;
  // Turns on checkerboarding of raster cache images.
  bool checkerboard_raster_cache_images = 23;
  // Turns on checkerboarding of layers rendered to offscreen bitmaps.
  bool checkerboard_offscreen_layers = 24;
  // Turns on an overlay that shows the accessibility information
  // reported by the framework.
  bool show_semantics_debugger = 25;
  // {@macro flutter.widgets.widgetsApp.debugShowCheckedModeBanner}
  bool debug_show_checked_mode_banner = 26;
  // {@macro flutter.widgets.widgetsApp.restorationScopeId}
  string restoration_scope_id = 29;
  // {@macro flutter.material.materialApp.scrollBehavior}
  //
  // When null, defaults to [CupertinoScrollBehavior].
  //
  // See also:
  //
  //  * [ScrollConfiguration], which controls how [Scrollable] widgets behave
  //    in a subtree.
  FlutterScrollBehaviorType scroll_behavior = 30;
}

// package:flutter/src/cupertino/app.dart
//
// Creates a [CupertinoApp] that uses the [Router] instead of a [Navigator].
//
// {@macro flutter.widgets.WidgetsApp.router}
message CupertinoAppNamedRouter {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.widgetsApp.routeInformationProvider}
  FlutterRouteInformationProviderType route_information_provider = 3;
  // {@macro flutter.widgets.widgetsApp.backButtonDispatcher}
  FlutterBackButtonDispatcherType back_button_dispatcher = 6;
  // The top-level [CupertinoTheme] styling.
  //
  // A null [theme] or unspecified [theme] attributes will default to iOS
  // system values.
  CupertinoThemeDataType theme = 8;
  // {@macro flutter.widgets.widgetsApp.title}
  //
  // This value is passed unmodified to [WidgetsApp.title].
  string title = 10;
  // {@macro flutter.widgets.widgetsApp.color}
  DartColorType color = 13;
  // {@macro flutter.widgets.widgetsApp.locale}
  DartLocaleType locale = 14;
  // {@macro flutter.widgets.widgetsApp.supportedLocales}
  //
  // It is passed along unmodified to the [WidgetsApp] built by this widget.
  repeated DartLocaleType supported_locales = 18;
  // Turns on a performance overlay.
  //
  // See also:
  //
  //  * <https://flutter.dev/debugging/#performance-overlay>
  bool show_performance_overlay = 19;
  // Turns on checkerboarding of raster cache images.
  bool checkerboard_raster_cache_images = 20;
  // Turns on checkerboarding of layers rendered to offscreen bitmaps.
  bool checkerboard_offscreen_layers = 21;
  // Turns on an overlay that shows the accessibility information
  // reported by the framework.
  bool show_semantics_debugger = 22;
  // {@macro flutter.widgets.widgetsApp.debugShowCheckedModeBanner}
  bool debug_show_checked_mode_banner = 23;
  // {@macro flutter.widgets.widgetsApp.restorationScopeId}
  string restoration_scope_id = 26;
  // {@macro flutter.material.materialApp.scrollBehavior}
  //
  // When null, defaults to [CupertinoScrollBehavior].
  //
  // See also:
  //
  //  * [ScrollConfiguration], which controls how [Scrollable] widgets behave
  //    in a subtree.
  FlutterScrollBehaviorType scroll_behavior = 27;
}

// package:flutter/src/cupertino/button.dart
//
// Creates an iOS-style button.
message CupertinoButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // Typically a [Text] widget.
  WidgetType child = 3;
  // The amount of space to surround the child inside the bounds of the button.
  //
  // Defaults to 16.0 pixels.
  FlutterEdgeInsetsGeometryType padding = 4;
  // The color of the button's background.
  //
  // Defaults to null which produces a button with no background or border.
  //
  // Defaults to the [CupertinoTheme]'s `primaryColor` when the
  // [CupertinoButton.filled] constructor is used.
  DartColorType color = 5;
  // The color of the button's background when the button is disabled.
  //
  // Ignored if the [CupertinoButton] doesn't also have a [color].
  //
  // Defaults to [CupertinoColors.quaternarySystemFill] when [color] is
  // specified.
  DartColorType disabled_color = 6;
  // Minimum size of the button.
  //
  // Defaults to kMinInteractiveDimensionCupertino which the iOS Human
  // Interface Guidelines recommends as the minimum tappable area.
  double min_size = 7;
  // The opacity that the button will fade to when it is pressed.
  // The button will have an opacity of 1.0 when it is not pressed.
  //
  // This defaults to 0.4. If null, opacity will not change on pressed if using
  // your own custom effects is desired.
  double pressed_opacity = 8;
  // The radius of the button's corners when it has a background color.
  //
  // Defaults to round corners of 8 logical pixels.
  FlutterBorderRadiusType border_radius = 9;
  // The alignment of the button's [child].
  //
  // Typically buttons are sized to be just big enough to contain the child and its
  // [padding]. If the button's size is constrained to a fixed size, for example by
  // enclosing it with a [SizedBox], this property defines how the child is aligned
  // within the available space.
  //
  // Always defaults to [Alignment.center].
  FlutterAlignmentGeometryType alignment = 10;
}

// package:flutter/src/cupertino/button.dart
//
// Creates an iOS-style button with a filled background.
//
// The background color is derived from the [CupertinoTheme]'s `primaryColor`.
//
// To specify a custom background color, use the [color] argument of the
// default constructor.
message CupertinoButtonNamedFilled {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // Typically a [Text] widget.
  WidgetType child = 3;
  // The amount of space to surround the child inside the bounds of the button.
  //
  // Defaults to 16.0 pixels.
  FlutterEdgeInsetsGeometryType padding = 4;
  // The color of the button's background when the button is disabled.
  //
  // Ignored if the [CupertinoButton] doesn't also have a [color].
  //
  // Defaults to [CupertinoColors.quaternarySystemFill] when [color] is
  // specified.
  DartColorType disabled_color = 5;
  // Minimum size of the button.
  //
  // Defaults to kMinInteractiveDimensionCupertino which the iOS Human
  // Interface Guidelines recommends as the minimum tappable area.
  double min_size = 6;
  // The opacity that the button will fade to when it is pressed.
  // The button will have an opacity of 1.0 when it is not pressed.
  //
  // This defaults to 0.4. If null, opacity will not change on pressed if using
  // your own custom effects is desired.
  double pressed_opacity = 7;
  // The radius of the button's corners when it has a background color.
  //
  // Defaults to round corners of 8 logical pixels.
  FlutterBorderRadiusType border_radius = 8;
  // The alignment of the button's [child].
  //
  // Typically buttons are sized to be just big enough to contain the child and its
  // [padding]. If the button's size is constrained to a fixed size, for example by
  // enclosing it with a [SizedBox], this property defines how the child is aligned
  // within the available space.
  //
  // Always defaults to [Alignment.center].
  FlutterAlignmentGeometryType alignment = 9;
}

// package:flutter/src/cupertino/checkbox.dart
//
// Creates a macOS-styled checkbox.
//
// The checkbox itself does not maintain any state. Instead, when the state of
// the checkbox changes, the widget calls the [onChanged] callback. Most
// widgets that use a checkbox will listen for the [onChanged] callback and
// rebuild the checkbox with a new [value] to update the visual appearance of
// the checkbox.
//
// The following arguments are required:
//
// * [value], which determines whether the checkbox is checked. The [value]
//   can only be null if [tristate] is true.
// * [onChanged], which is called when the value of the checkbox should
//   change. It can be set to null to disable the checkbox.
message CupertinoCheckbox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this checkbox is checked.
  //
  // When [tristate] is true, a value of null corresponds to the mixed state.
  // When [tristate] is false, this value must not be null. This is asserted in
  // debug mode.
  bool value = 3;
  // If true, the checkbox's [value] can be true, false, or null.
  //
  // [CupertinoCheckbox] displays a dash when its value is null.
  //
  // When a tri-state checkbox ([tristate] is true) is tapped, its [onChanged]
  // callback will be applied to true if the current value is false, to null if
  // value is true, and to false if value is null (i.e. it cycles through false
  // => true => null => false when tapped).
  //
  // If tristate is false (the default), [value] must not be null, and
  // [onChanged] will only toggle between true and false.
  bool tristate = 4;
  // The color to use when this checkbox is checked.
  //
  // Defaults to [CupertinoColors.activeBlue].
  DartColorType active_color = 6;
  // The color used if the checkbox is inactive.
  //
  // By default, [CupertinoColors.inactiveGray] is used.
  DartColorType inactive_color = 7;
  // The color to use for the check icon when this checkbox is checked.
  //
  // If null, then the value of [CupertinoColors.white] is used.
  DartColorType check_color = 8;
  // The color for the checkbox's border shadow when it has the input focus.
  //
  // If null, then a paler form of the [activeColor] will be used.
  DartColorType focus_color = 9;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 10;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 11;
  // The color and width of the checkbox's border.
  //
  // If this property is null, then the side defaults to a one pixel wide
  // black, solid border.
  FlutterBorderSideType side = 12;
  // The shape of the checkbox.
  //
  // If this property is null then the shape defaults to a
  // [RoundedRectangleBorder] with a circular corner radius of 4.0.
  FlutterOutlinedBorderType shape = 13;
}

// package:flutter/src/cupertino/context_menu.dart
//
// Create a context menu.
//
// The [actions] parameter cannot be empty.
message CupertinoContextMenu {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The actions that are shown in the menu.
  //
  // These actions are typically [CupertinoContextMenuAction]s.
  //
  // This parameter must not be empty.
  repeated WidgetType actions = 3;
  // The widget that can be "opened" with the [CupertinoContextMenu].
  //
  // When the [CupertinoContextMenu] is long-pressed, the menu will open and
  // this widget (or the widget returned by [previewBuilder], if provided) will
  // be moved to the new route and placed inside of an [Expanded] widget. This
  // allows the child to resize to fit in its place in the new route, if it
  // doesn't size itself.
  //
  // When the [CupertinoContextMenu] is "closed", this widget acts like a
  // [Container], i.e. it does not constrain its child's size or affect its
  // position.
  WidgetType child = 4;
  // If true, clicking on the [CupertinoContextMenuAction]s will
  // produce haptic feedback.
  //
  // Uses [HapticFeedback.heavyImpact] when activated.
  // Defaults to false.
  bool enable_haptic_feedback = 5;
}

// package:flutter/src/cupertino/context_menu_action.dart
//
// Construct a CupertinoContextMenuAction.
message CupertinoContextMenuAction {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget that will be placed inside the action.
  WidgetType child = 3;
  // Indicates whether this action should receive the style of an emphasized,
  // default action.
  bool is_default_action = 4;
  // Indicates whether this action should receive the style of a destructive
  // action.
  bool is_destructive_action = 5;
  // An optional icon to display to the right of the child.
  //
  // Will be colored in the same way as the [TextStyle] used for [child] (for
  // example, if using [isDestructiveAction]).
  FlutterIconDataType trailing_icon = 7;
}

// package:flutter/src/cupertino/desktop_text_selection.dart
message CupertinoDesktopTextSelectionControls {
  
}

// package:flutter/src/cupertino/desktop_text_selection_toolbar.dart
//
// Creates a const instance of CupertinoTextSelectionToolbar.
message CupertinoDesktopTextSelectionToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.material.DesktopTextSelectionToolbar.anchor}
  DartOffsetType anchor = 3;
  // {@macro flutter.material.TextSelectionToolbar.children}
  //
  // See also:
  //   * [CupertinoDesktopTextSelectionToolbarButton], which builds a default
  //     macOS-style text selection toolbar text button.
  repeated WidgetType children = 4;
}

// package:flutter/src/cupertino/desktop_text_selection_toolbar_button.dart
//
// Creates an instance of CupertinoDesktopTextSelectionToolbarButton.
message CupertinoDesktopTextSelectionToolbarButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.cupertino.CupertinoTextSelectionToolbarButton.child}
  WidgetType child = 4;
}

// package:flutter/src/cupertino/desktop_text_selection_toolbar_button.dart
//
// Create an instance of [CupertinoDesktopTextSelectionToolbarButton] from
// the given [ContextMenuButtonItem].
message CupertinoDesktopTextSelectionToolbarButtonNamedButtonItem {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.cupertino.CupertinoTextSelectionToolbarButton.onPressed}
  FlutterContextMenuButtonItemType button_item = 3;
}

// package:flutter/src/cupertino/desktop_text_selection_toolbar_button.dart
//
// Create an instance of [CupertinoDesktopTextSelectionToolbarButton] whose child is
// a [Text] widget styled like the default Mac context menu button.
message CupertinoDesktopTextSelectionToolbarButtonNamedText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.cupertino.CupertinoTextSelectionToolbarButton.text}
  string text = 4;
}

// package:flutter/src/cupertino/dialog.dart
//
// Creates an action for an iOS-style dialog.
message CupertinoDialogAction {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Set to true if button is the default choice in the dialog.
  //
  // Default buttons have bold text. Similar to
  // [UIAlertController.preferredAction](https://developer.apple.com/documentation/uikit/uialertcontroller/1620102-preferredaction),
  // but more than one action can have this attribute set to true in the same
  // [CupertinoAlertDialog].
  //
  // This parameters defaults to false.
  bool is_default_action = 4;
  // Whether this action destroys an object.
  //
  // For example, an action that deletes an email is destructive.
  //
  // Defaults to false.
  bool is_destructive_action = 5;
  // [TextStyle] to apply to any text that appears in this button.
  //
  // Dialog actions have a built-in text resizing policy for long text. To
  // ensure that this resizing policy always works as expected, [textStyle]
  // must be used if a text size is desired other than that specified in
  // [_kCupertinoDialogActionStyle].
  FlutterTextStyleType text_style = 6;
  // The widget below this widget in the tree.
  //
  // Typically a [Text] widget.
  WidgetType child = 7;
}

// package:flutter/src/cupertino/colors.dart
//
// Creates an adaptive [Color] that changes its effective color based on the
// [BuildContext] given. The default effective color is [color].
message CupertinoDynamicColor {
  string debug_label = 2;
  DartColorType color = 3;
  DartColorType dark_color = 4;
  DartColorType high_contrast_color = 5;
  DartColorType dark_high_contrast_color = 6;
  DartColorType elevated_color = 7;
  DartColorType dark_elevated_color = 8;
  DartColorType high_contrast_elevated_color = 9;
  DartColorType dark_high_contrast_elevated_color = 10;
}

// package:flutter/src/cupertino/colors.dart
//
// Creates an adaptive [Color] that changes its effective color based on the given
// [BuildContext]'s brightness (from [MediaQueryData.platformBrightness] or
// [CupertinoThemeData.brightness]). The default effective color is [color].
message CupertinoDynamicColorNamedWithBrightness {
  string debug_label = 2;
  DartColorType color = 3;
  DartColorType dark_color = 4;
}

// package:flutter/src/cupertino/colors.dart
//
// Creates an adaptive [Color] that changes its effective color based on the
// given [BuildContext]'s brightness (from [MediaQueryData.platformBrightness]
// or [CupertinoThemeData.brightness]) and accessibility contrast setting
// ([MediaQueryData.highContrast]). The default effective color is [color].
message CupertinoDynamicColorNamedWithBrightnessAndContrast {
  string debug_label = 2;
  DartColorType color = 3;
  DartColorType dark_color = 4;
  DartColorType high_contrast_color = 5;
  DartColorType dark_high_contrast_color = 6;
}

// package:flutter/src/cupertino/form_row.dart
//
// Creates an iOS-style split form row with a standard prefix and child widget.
// Also provides a space for error and helper widgets that appear underneath.
//
// The [child] parameter is required. This widget is displayed at the end of
// the row.
//
// The [prefix] parameter is optional and is displayed at the start of the
// row. Standard iOS guidelines encourage passing a [Text] widget to [prefix]
// to detail the nature of the row's [child] widget.
//
// The [padding] parameter is used to pad the contents of the row. It defaults
// to the standard iOS padding. If no edge insets are intended, explicitly
// pass [EdgeInsets.zero] to [padding].
//
// The [helper] and [error] parameters are both optional widgets targeted at
// displaying more information about the row. Both widgets are placed
// underneath the [prefix] and [child], and will expand the row's height to
// accommodate for their presence. When a [Text] is given to [error], it will
// be shown in [CupertinoColors.destructiveRed] coloring and
// medium-weighted font.
message CupertinoFormRow {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Child widget.
  //
  // The [child] widget is primarily used for input. It end-aligned and
  // horizontally flexible, taking up the entire space trailing past the
  // [prefix] widget.
  WidgetType child = 3;
  // A widget that is displayed at the start of the row.
  //
  // The [prefix] parameter is displayed at the start of the row. Standard iOS
  // guidelines encourage passing a [Text] widget to [prefix] to detail the
  // nature of the row's [child] widget. If null, the [child] widget will take
  // up all horizontal space in the row.
  WidgetType prefix = 4;
  // Content padding for the row.
  //
  // Defaults to the standard iOS padding for form rows. If no edge insets are
  // intended, explicitly pass [EdgeInsets.zero] to [padding].
  FlutterEdgeInsetsGeometryType padding = 5;
  // A widget that is displayed underneath the [prefix] and [child] widgets.
  //
  // The [helper] appears in primary label coloring, and is meant to inform the
  // user about interaction with the child widget. The row becomes taller in
  // order to display the [helper] widget underneath [prefix] and [child]. If
  // null, the row is shorter.
  WidgetType helper = 6;
  // A widget that is displayed underneath the [prefix] and [child] widgets.
  //
  // The [error] widget is primarily used to inform users of input errors. When
  // a [Text] is given to [error], it will be shown in
  // [CupertinoColors.destructiveRed] coloring and medium-weighted font. The
  // row becomes taller in order to display the [helper] widget underneath
  // [prefix] and [child]. If null, the row is shorter.
  WidgetType error = 7;
}

// package:flutter/src/cupertino/form_section.dart
//
// Creates a section that mimics standard iOS forms.
//
// The base constructor for [CupertinoFormSection] constructs an
// edge-to-edge style section which includes an iOS-style header,
// rows, the dividers between rows, and borders on top and bottom of the rows.
//
// The [header] parameter sets the form section header. The section header
// lies above the [children] rows, with margins that match the iOS style.
//
// The [footer] parameter sets the form section footer. The section footer
// lies below the [children] rows.
//
// The [children] parameter is required and sets the list of rows shown in
// the section. The [children] parameter takes a list, as opposed to a more
// efficient builder function that lazy builds, because forms are intended to
// be short in row count. It is recommended that only [CupertinoFormRow] and
// [CupertinoTextFormFieldRow] widgets be included in the [children] list in
// order to retain the iOS look.
//
// The [margin] parameter sets the spacing around the content area of the
// section encapsulating [children], and defaults to zero padding.
//
// The [decoration] parameter sets the decoration around [children].
// If null, defaults to [CupertinoColors.secondarySystemGroupedBackground].
// If null, defaults to 10.0 circular radius when constructing with
// [CupertinoFormSection.insetGrouped]. Defaults to zero radius for the
// standard [CupertinoFormSection] constructor.
//
// The [backgroundColor] parameter sets the background color behind the
// section. If null, defaults to [CupertinoColors.systemGroupedBackground].
//
// {@macro flutter.material.Material.clipBehavior}
message CupertinoFormSection {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The list of rows in the section.
  //
  // This takes a list, as opposed to a more efficient builder function that
  // lazy builds, because forms are intended to be short in row count. It is
  // recommended that only [CupertinoFormRow] and [CupertinoTextFormFieldRow]
  // widgets be included in the [children] list in order to retain the iOS look.
  repeated WidgetType children = 3;
  // Sets the form section header. The section header lies above the
  // [children] rows.
  WidgetType header = 4;
  // Sets the form section footer. The section footer lies below the
  // [children] rows.
  WidgetType footer = 5;
  // Margin around the content area of the section encapsulating [children].
  //
  // Defaults to zero padding if constructed with standard
  // [CupertinoFormSection] constructor. Defaults to the standard notched-style
  // iOS margin when constructing with [CupertinoFormSection.insetGrouped].
  FlutterEdgeInsetsGeometryType margin = 6;
  // Sets the background color behind the section.
  //
  // Defaults to [CupertinoColors.systemGroupedBackground].
  DartColorType background_color = 7;
  // Sets the decoration around [children].
  //
  // If null, background color defaults to
  // [CupertinoColors.secondarySystemGroupedBackground].
  //
  // If null, border radius defaults to 10.0 circular radius when constructing
  // with [CupertinoFormSection.insetGrouped]. Defaults to zero radius for the
  // standard [CupertinoFormSection] constructor.
  FlutterBoxDecorationType decoration = 8;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 9;
}

// package:flutter/src/cupertino/form_section.dart
//
// Creates a section that mimics standard "Inset Grouped" iOS forms.
//
// The [CupertinoFormSection.insetGrouped] constructor creates a round-edged and
// padded section that is commonly seen in notched-displays like iPhone X and
// beyond. Creates an iOS-style header, rows, and the dividers
// between rows. Does not create borders on top and bottom of the rows.
//
// The [header] parameter sets the form section header. The section header
// lies above the [children] rows, with margins that match the iOS style.
//
// The [footer] parameter sets the form section footer. The section footer
// lies below the [children] rows.
//
// The [children] parameter is required and sets the list of rows shown in
// the section. The [children] parameter takes a list, as opposed to a more
// efficient builder function that lazy builds, because forms are intended to
// be short in row count. It is recommended that only [CupertinoFormRow] and
// [CupertinoTextFormFieldRow] widgets be included in the [children] list in
// order to retain the iOS look.
//
// The [margin] parameter sets the spacing around the content area of the
// section encapsulating [children], and defaults to the standard
// notched-style iOS form padding.
//
// The [decoration] parameter sets the decoration around [children].
// If null, defaults to [CupertinoColors.secondarySystemGroupedBackground].
// If null, defaults to 10.0 circular radius when constructing with
// [CupertinoFormSection.insetGrouped]. Defaults to zero radius for the
// standard [CupertinoFormSection] constructor.
//
// The [backgroundColor] parameter sets the background color behind the
// section. If null, defaults to [CupertinoColors.systemGroupedBackground].
//
// {@macro flutter.material.Material.clipBehavior}
message CupertinoFormSectionNamedInsetGrouped {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The list of rows in the section.
  //
  // This takes a list, as opposed to a more efficient builder function that
  // lazy builds, because forms are intended to be short in row count. It is
  // recommended that only [CupertinoFormRow] and [CupertinoTextFormFieldRow]
  // widgets be included in the [children] list in order to retain the iOS look.
  repeated WidgetType children = 3;
  // Sets the form section header. The section header lies above the
  // [children] rows.
  WidgetType header = 4;
  // Sets the form section footer. The section footer lies below the
  // [children] rows.
  WidgetType footer = 5;
  // Margin around the content area of the section encapsulating [children].
  //
  // Defaults to zero padding if constructed with standard
  // [CupertinoFormSection] constructor. Defaults to the standard notched-style
  // iOS margin when constructing with [CupertinoFormSection.insetGrouped].
  FlutterEdgeInsetsGeometryType margin = 6;
  // Sets the background color behind the section.
  //
  // Defaults to [CupertinoColors.systemGroupedBackground].
  DartColorType background_color = 7;
  // Sets the decoration around [children].
  //
  // If null, background color defaults to
  // [CupertinoColors.secondarySystemGroupedBackground].
  //
  // If null, border radius defaults to 10.0 circular radius when constructing
  // with [CupertinoFormSection.insetGrouped]. Defaults to zero radius for the
  // standard [CupertinoFormSection] constructor.
  FlutterBoxDecorationType decoration = 8;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 9;
}

// package:flutter/src/cupertino/icon_theme_data.dart
//
// Creates a [CupertinoIconThemeData].
message CupertinoIconThemeData {
  // The default for [Icon.size].
  //
  // Falls back to 24.0.
  double size = 2;
  // The default for [Icon.fill].
  //
  // Falls back to 0.0.
  double fill = 3;
  // The default for [Icon.weight].
  //
  // Falls back to 400.0.
  double weight = 4;
  // The default for [Icon.grade].
  //
  // Falls back to 0.0.
  double grade = 5;
  // The default for [Icon.opticalSize].
  //
  // Falls back to 48.0.
  double optical_size = 6;
  // The default for [Icon.color].
  //
  // In material apps, if there is a [Theme] without any [IconTheme]s
  // specified, icon colors default to white if [ThemeData.brightness] is dark
  // and black if [ThemeData.brightness] is light.
  //
  // Otherwise, falls back to black.
  DartColorType color = 7;
  double opacity = 8;
  // The default for [Icon.shadows].
  repeated DartShadowType shadows = 9;
  // The default for [Icon.applyTextScaling].
  bool apply_text_scaling = 10;
}

// package:flutter/src/cupertino/list_section.dart
//
// Creates a section that mimics standard iOS forms.
//
// The base constructor for [CupertinoListSection] constructs an
// edge-to-edge style section which includes an iOS-style header, the dividers
// between rows, and borders on top and bottom of the rows. An example of such
// list section are sections in iOS Settings app.
//
// The [header] parameter sets the form section header. The section header
// lies above the [children] rows, with margins that match the iOS style.
//
// The [footer] parameter sets the form section footer. The section footer
// lies below the [children] rows.
//
// The [children] parameter is required and sets the list of rows shown in
// the section. The [children] parameter takes a list, as opposed to a more
// efficient builder function that lazy builds, because forms are intended to
// be short in row count. It is recommended that only [CupertinoFormRow] and
// [CupertinoTextFormFieldRow] widgets be included in the [children] list in
// order to retain the iOS look.
//
// The [margin] parameter sets the spacing around the content area of the
// section encapsulating [children], and defaults to zero padding.
//
// The [decoration] parameter sets the decoration around [children].
// If null, defaults to [CupertinoColors.secondarySystemGroupedBackground].
// If null, defaults to 10.0 circular radius when constructing with
// [CupertinoListSection.insetGrouped]. Defaults to zero radius for the
// standard [CupertinoListSection] constructor.
//
// The [backgroundColor] parameter sets the background color behind the
// section. If null, defaults to [CupertinoColors.systemGroupedBackground].
//
// The [dividerMargin] parameter sets the starting offset of the divider
// between rows.
//
// The [additionalDividerMargin] parameter adds additional margin to existing
// [dividerMargin] when [hasLeading] is set to true. By default, it offsets
// for the width of leading and space between leading and title of
// [CupertinoListTile], but it can be overwritten for custom look.
//
// The [hasLeading] parameter specifies whether children [CupertinoListTile]
// widgets contain leading or not. Used for calculating correct starting
// margin for the divider between rows.
//
// The [topMargin] is used to specify the margin above the list section. It
// matches the iOS look by default.
//
// {@macro flutter.material.Material.clipBehavior}
message CupertinoListSection {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The list of rows in the section. Usually a list of [CupertinoListTile]s.
  //
  // This takes a list, as opposed to a more efficient builder function that
  // lazy builds, because such lists are intended to be short in row count.
  // It is recommended that only [CupertinoListTile] widget be included in the
  // [children] list in order to retain the iOS look.
  repeated WidgetType children = 3;
  // Sets the form section header. The section header lies above the [children]
  // rows. Usually a [Text] widget.
  WidgetType header = 4;
  // Sets the form section footer. The section footer lies below the [children]
  // rows. Usually a [Text] widget.
  WidgetType footer = 5;
  // Margin around the content area of the section encapsulating [children].
  //
  // Defaults to zero padding if constructed with standard
  // [CupertinoListSection] constructor. Defaults to the standard notched-style
  // iOS margin when constructing with [CupertinoListSection.insetGrouped].
  FlutterEdgeInsetsGeometryType margin = 6;
  // Sets the background color behind the section.
  //
  // Defaults to [CupertinoColors.systemGroupedBackground].
  DartColorType background_color = 7;
  // Sets the decoration around [children].
  //
  // If null, background color defaults to
  // [CupertinoColors.secondarySystemGroupedBackground].
  //
  // If null, border radius defaults to 10.0 circular radius when constructing
  // with [CupertinoListSection.insetGrouped]. Defaults to zero radius for the
  // standard [CupertinoListSection] constructor.
  FlutterBoxDecorationType decoration = 8;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 9;
  // The starting offset of a margin between two list tiles.
  double divider_margin = 10;
  double additional_divider_margin = 11;
  // Margin above the list section. Only used in edge-to-edge variant and it
  // matches iOS style by default.
  double top_margin = 12;
  bool has_leading = 13;
  // Sets the color for the dividers between rows, and borders on top and
  // bottom of the rows.
  //
  // If null, defaults to [CupertinoColors.separator].
  DartColorType separator_color = 14;
}

// package:flutter/src/cupertino/list_section.dart
//
// Creates a section that mimics standard "Inset Grouped" iOS list section.
//
// The [CupertinoListSection.insetGrouped] constructor creates a round-edged
// and padded section that is seen in iOS Notes and Reminders apps. It creates
// an iOS-style header, and the dividers between rows. Does not create borders
// on top and bottom of the rows.
//
// The [header] parameter sets the form section header. The section header
// lies above the [children] rows, with margins that match the iOS style.
//
// The [footer] parameter sets the form section footer. The section footer
// lies below the [children] rows.
//
// The [children] parameter is required and sets the list of rows shown in
// the section. The [children] parameter takes a list, as opposed to a more
// efficient builder function that lazy builds, because forms are intended to
// be short in row count. It is recommended that only [CupertinoListTile]
// widget be included in the [children] list in order to retain the iOS look.
//
// The [margin] parameter sets the spacing around the content area of the
// section encapsulating [children], and defaults to the standard
// notched-style iOS form padding.
//
// The [decoration] parameter sets the decoration around [children].
// If null, defaults to [CupertinoColors.secondarySystemGroupedBackground].
// If null, defaults to 10.0 circular radius when constructing with
// [CupertinoListSection.insetGrouped]. Defaults to zero radius for the
// standard [CupertinoListSection] constructor.
//
// The [backgroundColor] parameter sets the background color behind the
// section. If null, defaults to [CupertinoColors.systemGroupedBackground].
//
// The [dividerMargin] parameter sets the starting offset of the divider
// between rows.
//
// The [additionalDividerMargin] parameter adds additional margin to existing
// [dividerMargin] when [hasLeading] is set to true. By default, it offsets
// for the width of leading and space between leading and title of
// [CupertinoListTile], but it can be overwritten for custom look.
//
// The [hasLeading] parameter specifies whether children [CupertinoListTile]
// widgets contain leading or not. Used for calculating correct starting
// margin for the divider between rows.
//
// {@macro flutter.material.Material.clipBehavior}
message CupertinoListSectionNamedInsetGrouped {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The list of rows in the section. Usually a list of [CupertinoListTile]s.
  //
  // This takes a list, as opposed to a more efficient builder function that
  // lazy builds, because such lists are intended to be short in row count.
  // It is recommended that only [CupertinoListTile] widget be included in the
  // [children] list in order to retain the iOS look.
  repeated WidgetType children = 3;
  // Sets the form section header. The section header lies above the [children]
  // rows. Usually a [Text] widget.
  WidgetType header = 4;
  // Sets the form section footer. The section footer lies below the [children]
  // rows. Usually a [Text] widget.
  WidgetType footer = 5;
  FlutterEdgeInsetsGeometryType margin = 6;
  // Sets the background color behind the section.
  //
  // Defaults to [CupertinoColors.systemGroupedBackground].
  DartColorType background_color = 7;
  // Sets the decoration around [children].
  //
  // If null, background color defaults to
  // [CupertinoColors.secondarySystemGroupedBackground].
  //
  // If null, border radius defaults to 10.0 circular radius when constructing
  // with [CupertinoListSection.insetGrouped]. Defaults to zero radius for the
  // standard [CupertinoListSection] constructor.
  FlutterBoxDecorationType decoration = 8;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 9;
  // The starting offset of a margin between two list tiles.
  double divider_margin = 10;
  double additional_divider_margin = 11;
  // Margin above the list section. Only used in edge-to-edge variant and it
  // matches iOS style by default.
  double top_margin = 12;
  bool has_leading = 13;
  // Sets the color for the dividers between rows, and borders on top and
  // bottom of the rows.
  //
  // If null, defaults to [CupertinoColors.separator].
  DartColorType separator_color = 14;
}

// package:flutter/src/cupertino/list_tile.dart
//
// Creates an edge-to-edge iOS-style list tile like the tiles in iOS Settings
// app.
//
// The [title] parameter is required. It is used to convey the most important
// information of list tile. It is typically a [Text].
//
// The [subtitle] parameter is used to display additional information. It is
// placed below the [title].
//
// The [additionalInfo] parameter is used to display additional information.
// It is placed at the end of the tile, before the [trailing] if supplied.
//
// The [leading] parameter is typically an [Icon] or an [Image] and it comes
// at the start of the tile. If omitted in all list tiles, a `hasLeading` of
// enclosing [CupertinoListSection] should be set to `false` to ensure
// correct margin of divider between tiles.
//
// The [trailing] parameter is typically a [CupertinoListTileChevron], an
// [Icon], or a [CupertinoButton]. It is placed at the very end of the tile.
//
// The [onTap] parameter is used to provide an action that is called when the
// tile is tapped. It is mainly used for navigating to a new route. It should
// not be used to toggle a trailing [CupertinoSwitch] and similar use cases
// because when tile is tapped, it switches the background color and remains
// changed. This is according to iOS behavior.
//
// The [backgroundColor] provides a custom background color for the tile in
// a state before tapped. By default, it matches the theme's background color
// which is by default a [CupertinoColors.systemBackground].
//
// The [backgroundColorActivated] provides a custom background color for the
// tile after it was tapped. By default, it matches the theme's background
// color which is by default a [CupertinoColors.systemGrey4].
//
// The [padding] parameter sets the padding of the content inside the tile.
// It defaults to a value that matches the iOS look, depending on a type of
// [CupertinoListTile]. For native look, it should not be provided.
//
// The [leadingSize] constrains the width and height of the leading widget.
// By default, it is set to a value that matches the iOS look, depending on a
// type of [CupertinoListTile]. For native look, it should not be provided.
//
// The [leadingToTitle] specifies the horizontal space between [leading] and
// [title] widgets. By default, it is set to a value that matched the iOS
// look, depending on a type of [CupertinoListTile]. For native look, it
// should not be provided.
message CupertinoListTile {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // A [title] is used to convey the central information. Usually a [Text].
  WidgetType title = 3;
  // A [subtitle] is used to display additional information. It is located
  // below [title]. Usually a [Text] widget.
  WidgetType subtitle = 4;
  // Similar to [subtitle], an [additionalInfo] is used to display additional
  // information. However, instead of being displayed below [title], it is
  // displayed on the right, before [trailing]. Usually a [Text] widget.
  WidgetType additional_info = 5;
  // A widget displayed at the start of the [CupertinoListTile]. This is
  // typically an `Icon` or an `Image`.
  WidgetType leading = 6;
  // A widget displayed at the end of the [CupertinoListTile]. This is usually
  // a right chevron icon (e.g. `CupertinoListTileChevron`), or an `Icon`.
  WidgetType trailing = 7;
  // The [backgroundColor] of the tile in normal state. Once the tile is
  // tapped, the background color switches to [backgroundColorActivated]. It is
  // set to match the iOS look by default.
  DartColorType background_color = 9;
  // The [backgroundColorActivated] is the background color of the tile after
  // the tile was tapped. It is set to match the iOS look by default.
  DartColorType background_color_activated = 10;
  // Padding of the content inside [CupertinoListTile].
  FlutterEdgeInsetsGeometryType padding = 11;
  // The [leadingSize] is used to constrain the width and height of [leading]
  // widget.
  double leading_size = 12;
  // The horizontal space between [leading] widget and [title].
  double leading_to_title = 13;
}

// package:flutter/src/cupertino/list_tile.dart
//
// Creates a typical widget used to denote that a `CupertinoListTile` is a
// button with action.
message CupertinoListTileChevron {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
}

// package:flutter/src/cupertino/list_tile.dart
//
// Creates a notched iOS-style list tile like the tiles in iOS Notes app or
// Reminders app.
//
// The [title] parameter is required. It is used to convey the most important
// information of list tile. It is typically a [Text].
//
// The [subtitle] parameter is used to display additional information. It is
// placed below the [title].
//
// The [additionalInfo] parameter is used to display additional information.
// It is placed at the end of the tile, before the [trailing] if supplied.
//
// The [leading] parameter is typically an [Icon] or an [Image] and it comes
// at the start of the tile. If omitted in all list tiles, a `hasLeading` of
// enclosing [CupertinoListSection] should be set to `false` to ensure
// correct margin of divider between tiles. For Notes-like tile appearance,
// the [leading] can be left `null`.
//
// The [trailing] parameter is typically a [CupertinoListTileChevron], an
// [Icon], or a [CupertinoButton]. It is placed at the very end of the tile.
// For Notes-like tile appearance, the [trailing] can be left `null`.
//
// The [onTap] parameter is used to provide an action that is called when the
// tile is tapped. It is mainly used for navigating to a new route. It should
// not be used to toggle a trailing [CupertinoSwitch] and similar use cases
// because when tile is tapped, it switches the background color and remains
// changed. This is according to iOS behavior.
//
// The [backgroundColor] provides a custom background color for the tile in
// a state before tapped. By default, it matches the theme's background color
// which is by default a [CupertinoColors.systemBackground].
//
// The [backgroundColorActivated] provides a custom background color for the
// tile after it was tapped. By default, it matches the theme's background
// color which is by default a [CupertinoColors.systemGrey4].
//
// The [padding] parameter sets the padding of the content inside the tile.
// It defaults to a value that matches the iOS look, depending on a type of
// [CupertinoListTile]. For native look, it should not be provided.
//
// The [leadingSize] constrains the width and height of the leading widget.
// By default, it is set to a value that matches the iOS look, depending on a
// type of [CupertinoListTile]. For native look, it should not be provided.
//
// The [leadingToTitle] specifies the horizontal space between [leading] and
// [title] widgets. By default, it is set to a value that matched the iOS
// look, depending on a type of [CupertinoListTile]. For native look, it
// should not be provided.
message CupertinoListTileNamedNotched {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // A [title] is used to convey the central information. Usually a [Text].
  WidgetType title = 3;
  // A [subtitle] is used to display additional information. It is located
  // below [title]. Usually a [Text] widget.
  WidgetType subtitle = 4;
  // Similar to [subtitle], an [additionalInfo] is used to display additional
  // information. However, instead of being displayed below [title], it is
  // displayed on the right, before [trailing]. Usually a [Text] widget.
  WidgetType additional_info = 5;
  // A widget displayed at the start of the [CupertinoListTile]. This is
  // typically an `Icon` or an `Image`.
  WidgetType leading = 6;
  // A widget displayed at the end of the [CupertinoListTile]. This is usually
  // a right chevron icon (e.g. `CupertinoListTileChevron`), or an `Icon`.
  WidgetType trailing = 7;
  // The [backgroundColor] of the tile in normal state. Once the tile is
  // tapped, the background color switches to [backgroundColorActivated]. It is
  // set to match the iOS look by default.
  DartColorType background_color = 9;
  // The [backgroundColorActivated] is the background color of the tile after
  // the tile was tapped. It is set to match the iOS look by default.
  DartColorType background_color_activated = 10;
  // Padding of the content inside [CupertinoListTile].
  FlutterEdgeInsetsGeometryType padding = 11;
  // The [leadingSize] is used to constrain the width and height of [leading]
  // widget.
  double leading_size = 12;
  // The horizontal space between [leading] widget and [title].
  double leading_to_title = 13;
}

// package:flutter/src/cupertino/magnifier.dart
//
// Creates a [RawMagnifier] in the Cupertino style.
//
// The default constructor parameters and constants were eyeballed on
// an iPhone XR iOS v15.5.
message CupertinoMagnifier {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The size of this magnifier.
  DartSizeType size = 3;
  // The border radius of this magnifier.
  FlutterBorderRadiusType border_radius = 4;
  // Any additional focal point offset, applied over the regular focal
  // point offset defined in [kMagnifierAboveFocalPoint].
  DartOffsetType additional_focal_point_offset = 5;
  // The shadows displayed under the magnifier.
  repeated FlutterBoxShadowType shadows = 6;
  // The border, or "rim", of this magnifier.
  FlutterBorderSideType border_side = 7;
}

// package:flutter/src/cupertino/nav_bar.dart
//
// Creates a navigation bar in the iOS style.
message CupertinoNavigationBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.cupertino.CupertinoNavigationBar.leading}
  // Widget to place at the start of the navigation bar. Normally a back button
  // for a normal page or a cancel button for full page dialogs.
  //
  // If null and [automaticallyImplyLeading] is true, an appropriate button
  // will be automatically created.
  // {@endtemplate}
  WidgetType leading = 3;
  // {@template flutter.cupertino.CupertinoNavigationBar.automaticallyImplyLeading}
  // Controls whether we should try to imply the leading widget if null.
  //
  // If true and [leading] is null, automatically try to deduce what the [leading]
  // widget should be. If [leading] widget is not null, this parameter has no effect.
  //
  // Specifically this navigation bar will:
  //
  // 1. Show a 'Close' button if the current route is a `fullscreenDialog`.
  // 2. Show a back chevron with [previousPageTitle] if [previousPageTitle] is
  //    not null.
  // 3. Show a back chevron with the previous route's `title` if the current
  //    route is a [CupertinoPageRoute] and the previous route is also a
  //    [CupertinoPageRoute].
  // {@endtemplate}
  bool automatically_imply_leading = 4;
  // Controls whether we should try to imply the middle widget if null.
  //
  // If true and [middle] is null, automatically fill in a [Text] widget with
  // the current route's `title` if the route is a [CupertinoPageRoute].
  // If [middle] widget is not null, this parameter has no effect.
  bool automatically_imply_middle = 5;
  // {@template flutter.cupertino.CupertinoNavigationBar.previousPageTitle}
  // Manually specify the previous route's title when automatically implying
  // the leading back button.
  //
  // Overrides the text shown with the back chevron instead of automatically
  // showing the previous [CupertinoPageRoute]'s `title` when
  // [automaticallyImplyLeading] is true.
  //
  // Has no effect when [leading] is not null or if [automaticallyImplyLeading]
  // is false.
  // {@endtemplate}
  string previous_page_title = 6;
  // Widget to place in the middle of the navigation bar. Normally a title or
  // a segmented control.
  //
  // If null and [automaticallyImplyMiddle] is true, an appropriate [Text]
  // title will be created if the current route is a [CupertinoPageRoute] and
  // has a `title`.
  WidgetType middle = 7;
  // {@template flutter.cupertino.CupertinoNavigationBar.trailing}
  // Widget to place at the end of the navigation bar. Normally additional actions
  // taken on the page such as a search or edit function.
  // {@endtemplate}
  WidgetType trailing = 8;
  // {@template flutter.cupertino.CupertinoNavigationBar.border}
  // The border of the navigation bar. By default renders a single pixel bottom border side.
  //
  // If a border is null, the navigation bar will not display a border.
  // {@endtemplate}
  FlutterBorderType border = 9;
  // {@template flutter.cupertino.CupertinoNavigationBar.backgroundColor}
  // The background color of the navigation bar. If it contains transparency, the
  // tab bar will automatically produce a blurring effect to the content
  // behind it.
  //
  // Defaults to [CupertinoTheme]'s `barBackgroundColor` if null.
  // {@endtemplate}
  DartColorType background_color = 10;
  // {@template flutter.cupertino.CupertinoNavigationBar.brightness}
  // The brightness of the specified [backgroundColor].
  //
  // Setting this value changes the style of the system status bar. Typically
  // used to increase the contrast ratio of the system status bar over
  // [backgroundColor].
  //
  // If set to null, the value of the property will be inferred from the relative
  // luminance of [backgroundColor].
  // {@endtemplate}
  DartBrightnessType.Enum brightness = 11;
  // {@template flutter.cupertino.CupertinoNavigationBar.padding}
  // Padding for the contents of the navigation bar.
  //
  // If null, the navigation bar will adopt the following defaults:
  //
  //  * Vertically, contents will be sized to the same height as the navigation
  //    bar itself minus the status bar.
  //  * Horizontally, padding will be 16 pixels according to iOS specifications
  //    unless the leading widget is an automatically inserted back button, in
  //    which case the padding will be 0.
  //
  // Vertical padding won't change the height of the nav bar.
  // {@endtemplate}
  FlutterEdgeInsetsDirectionalType padding = 12;
  // {@template flutter.cupertino.CupertinoNavigationBar.transitionBetweenRoutes}
  // Whether to transition between navigation bars.
  //
  // When [transitionBetweenRoutes] is true, this navigation bar will transition
  // on top of the routes instead of inside it if the route being transitioned
  // to also has a [CupertinoNavigationBar] or a [CupertinoSliverNavigationBar]
  // with [transitionBetweenRoutes] set to true.
  //
  // This transition will also occur on edge back swipe gestures like on iOS
  // but only if the previous page below has `maintainState` set to true on the
  // [PageRoute].
  //
  // When set to true, only one navigation bar can be present per route unless
  // [heroTag] is also set.
  //
  // This value defaults to true.
  // {@endtemplate}
  bool transition_between_routes = 13;
}

// package:flutter/src/cupertino/nav_bar.dart
//
// Construct a [CupertinoNavigationBarBackButton] that can be used to pop
// the current route.
message CupertinoNavigationBarBackButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [Color] of the back button.
  //
  // Can be used to override the color of the back button chevron and label.
  //
  // Defaults to [CupertinoTheme]'s `primaryColor` if null.
  DartColorType color = 3;
  // An override for showing the previous route's title. If null, it will be
  // automatically derived from [CupertinoPageRoute.title] if the current and
  // previous routes are both [CupertinoPageRoute]s.
  string previous_page_title = 4;
}

// package:flutter/src/cupertino/page_scaffold.dart
//
// Creates a layout for pages with a navigation bar at the top.
message CupertinoPageScaffold {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [navigationBar], typically a [CupertinoNavigationBar], is drawn at the
  // top of the screen.
  //
  // If translucent, the main content may slide behind it.
  // Otherwise, the main content's top margin will be offset by its height.
  //
  // The scaffold assumes the navigation bar will account for the [MediaQuery]
  // top padding, also consume it if the navigation bar is opaque.
  //
  // By default [navigationBar] disables text scaling to match the native iOS
  // behavior. To override such behavior, wrap each of the [navigationBar]'s
  // components inside a [MediaQuery] with the desired [TextScaler].
  ObstructingPreferredSizeWidgetType navigation_bar = 3;
  // The color of the widget that underlies the entire scaffold.
  //
  // By default uses [CupertinoTheme]'s `scaffoldBackgroundColor` when null.
  DartColorType background_color = 4;
  // Whether the [child] should size itself to avoid the window's bottom inset.
  //
  // For example, if there is an onscreen keyboard displayed above the
  // scaffold, the body can be resized to avoid overlapping the keyboard, which
  // prevents widgets inside the body from being obscured by the keyboard.
  //
  // Defaults to true.
  bool resize_to_avoid_bottom_inset = 5;
  // Widget to show in the main content area.
  //
  // Content can slide under the [navigationBar] when they're translucent.
  // In that case, the child's [BuildContext]'s [MediaQuery] will have a
  // top padding indicating the area of obstructing overlap from the
  // [navigationBar].
  WidgetType child = 6;
}

// package:flutter/src/cupertino/picker.dart
//
// Creates a picker from a concrete list of children.
//
// The [itemExtent] must be greater than zero.
//
// The [backgroundColor] defaults to null, which disables background painting entirely.
// (i.e. the picker is going to have a completely transparent background), to match
// the native UIPicker and UIDatePicker. Also, if it has transparency, no gradient
// effect will be rendered.
//
// The [scrollController] argument can be used to specify a custom
// [FixedExtentScrollController] for programmatically reading or changing
// the current picker index or for selecting an initial index value.
//
// The [looping] argument decides whether the child list loops and can be
// scrolled infinitely. If set to true, scrolling past the end of the list
// will loop the list back to the beginning. If set to false, the list will
// stop scrolling when you reach the end or the beginning.
message CupertinoPicker {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Relative ratio between this picker's height and the simulated cylinder's diameter.
  //
  // Smaller values creates more pronounced curvatures in the scrollable wheel.
  //
  // For more details, see [ListWheelScrollView.diameterRatio].
  //
  // Defaults to 1.1 to visually mimic iOS.
  double diameter_ratio = 3;
  // Background color behind the children.
  //
  // Defaults to null, which disables background painting entirely.
  // (i.e. the picker is going to have a completely transparent background), to match
  // the native UIPicker and UIDatePicker.
  //
  // Any alpha value less 255 (fully opaque) will cause the removal of the
  // wheel list edge fade gradient from rendering of the widget.
  DartColorType background_color = 4;
  // {@macro flutter.rendering.RenderListWheelViewport.offAxisFraction}
  double off_axis_fraction = 5;
  // {@macro flutter.rendering.RenderListWheelViewport.useMagnifier}
  bool use_magnifier = 6;
  // {@macro flutter.rendering.RenderListWheelViewport.magnification}
  double magnification = 7;
  // A [FixedExtentScrollController] to read and control the current item, and
  // to set the initial item.
  //
  // If null, an implicit one will be created internally.
  FlutterFixedExtentScrollControllerType scroll_controller = 8;
  // {@macro flutter.rendering.RenderListWheelViewport.squeeze}
  //
  // Defaults to `1.45` to visually mimic iOS.
  double squeeze = 9;
  // {@template flutter.cupertino.picker.itemExtent}
  // The uniform height of all children.
  //
  // All children will be given the [BoxConstraints] to match this exact
  // height. Must be a positive value.
  // {@endtemplate}
  double item_extent = 10;
  repeated WidgetType children = 12;
  // A widget overlaid on the picker to highlight the currently selected entry.
  //
  // The [selectionOverlay] widget drawn above the [CupertinoPicker]'s picker
  // wheel.
  // It is vertically centered in the picker and is constrained to have the
  // same height as the center row.
  //
  // If unspecified, it defaults to a [CupertinoPickerDefaultSelectionOverlay]
  // which is a gray rounded rectangle overlay in iOS 14 style.
  // This property can be set to null to remove the overlay.
  WidgetType selection_overlay = 13;
  bool looping = 14;
}

// package:flutter/src/cupertino/picker.dart
//
// Creates an iOS 14 style selection overlay that highlights the magnified
// area (or the currently selected item, depending on how you described it
// elsewhere) of a [CupertinoPicker].
//
// The [background] argument default value is
// [CupertinoColors.tertiarySystemFill].
//
// The [capStartEdge] and [capEndEdge] arguments decide whether to add a
// default margin and use rounded corners on the left and right side of the
// rectangular overlay, and they both default to true.
message CupertinoPickerDefaultSelectionOverlay {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The color to fill in the background of the [CupertinoPickerDefaultSelectionOverlay].
  // It Support for use [CupertinoDynamicColor].
  //
  // Typically this should not be set to a fully opaque color, as the currently
  // selected item of the underlying [CupertinoPicker] should remain visible.
  // Defaults to [CupertinoColors.tertiarySystemFill].
  DartColorType background = 3;
  // Whether to use the default use rounded corners and margin on the start side.
  bool cap_start_edge = 4;
  // Whether to use the default use rounded corners and margin on the end side.
  bool cap_end_edge = 5;
}

// package:flutter/src/cupertino/dialog.dart
//
// Creates an iOS-style rounded rectangle popup surface.
message CupertinoPopupSurface {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether or not to paint a translucent white on top of this surface's
  // blurred background. [isSurfacePainted] should be true for a typical popup
  // that contains content without any dividers. A popup that requires dividers
  // should set [isSurfacePainted] to false and then paint its own surface area.
  //
  // Some popups, like iOS's volume control popup, choose to render a blurred
  // area without any white paint covering it. To achieve this effect,
  // [isSurfacePainted] should be set to false.
  bool is_surface_painted = 3;
  // The widget below this widget in the tree.
  WidgetType child = 4;
}

// package:flutter/src/cupertino/app.dart
//
// Creates a CupertinoScrollBehavior that uses [BouncingScrollPhysics] and
// adds [CupertinoScrollbar]s on desktop platforms.
message CupertinoScrollBehavior {
  
}

// package:flutter/src/cupertino/scrollbar.dart
//
// Creates an iOS style scrollbar that wraps the given [child].
//
// The [child] should be a source of [ScrollNotification] notifications,
// typically a [Scrollable] widget.
message CupertinoScrollbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.Scrollbar.child}
  // The widget below this widget in the tree.
  //
  // The scrollbar will be stacked on top of this child. This child (and its
  // subtree) should include a source of [ScrollNotification] notifications.
  // Typically a [Scrollbar] is created on desktop platforms by a
  // [ScrollBehavior.buildScrollbar] method, in which case the child is usually
  // the one provided as an argument to that method.
  //
  // Typically a [ListView] or [CustomScrollView].
  // {@endtemplate}
  WidgetType child = 3;
  // {@template flutter.widgets.Scrollbar.controller}
  // The [ScrollController] used to implement Scrollbar dragging.
  //
  // If nothing is passed to controller, the default behavior is to automatically
  // enable scrollbar dragging on the nearest ScrollController using
  // [PrimaryScrollController.of].
  //
  // If a ScrollController is passed, then dragging on the scrollbar thumb will
  // update the [ScrollPosition] attached to the controller. A stateful ancestor
  // of this widget needs to manage the ScrollController and either pass it to
  // a scrollable descendant or use a PrimaryScrollController to share it.
  //
  // {@tool snippet}
  // Here is an example of using the [controller] attribute to enable
  // scrollbar dragging for multiple independent ListViews:
  //
  // ```dart
  // // (e.g. in a stateful widget)
  //
  // final ScrollController controllerOne = ScrollController();
  // final ScrollController controllerTwo = ScrollController();
  //
  // @override
  // Widget build(BuildContext context) {
  //   return Column(
  //     children: <Widget>[
  //       SizedBox(
  //        height: 200,
  //        child: CupertinoScrollbar(
  //          controller: controllerOne,
  //          child: ListView.builder(
  //            controller: controllerOne,
  //            itemCount: 120,
  //            itemBuilder: (BuildContext context, int index) => Text('item $index'),
  //          ),
  //        ),
  //      ),
  //      SizedBox(
  //        height: 200,
  //        child: CupertinoScrollbar(
  //          controller: controllerTwo,
  //          child: ListView.builder(
  //            controller: controllerTwo,
  //            itemCount: 120,
  //            itemBuilder: (BuildContext context, int index) => Text('list 2 item $index'),
  //          ),
  //        ),
  //      ),
  //    ],
  //   );
  // }
  // ```
  // {@end-tool}
  // {@endtemplate}
  FlutterScrollControllerType controller = 4;
  bool thumb_visibility = 5;
  // The thickness of the scrollbar in the cross axis of the scrollable.
  //
  // If null, will default to 6.0 pixels.
  double thickness = 6;
  // The thickness of the scrollbar when it's being dragged by the user.
  //
  // When the user starts dragging the scrollbar, the thickness will animate
  // from [thickness] to this value, then animate back when the user stops
  // dragging the scrollbar.
  double thickness_while_dragging = 7;
  // The [Radius] of the scrollbar thumb's rounded rectangle corners.
  //
  // Scrollbar will be rectangular if [radius] is null, which is the default
  // behavior.
  DartRadiusType radius = 8;
  // The radius of the scrollbar edges when the scrollbar is being dragged by
  // the user.
  //
  // When the user starts dragging the scrollbar, the radius will animate
  // from [radius] to this value, then animate back when the user stops
  // dragging the scrollbar.
  DartRadiusType radius_while_dragging = 9;
  // {@macro flutter.widgets.Scrollbar.scrollbarOrientation}
  FlutterScrollbarOrientationType.Enum scrollbar_orientation = 11;
}

// package:flutter/src/cupertino/search_field.dart
//
// Creates a [CupertinoTextField] that mimics the look and behavior of
// UIKit's `UISearchTextField`.
//
// Similar to [CupertinoTextField], to provide a prefilled text entry, pass
// in a [TextEditingController] with an initial value to the [controller]
// parameter.
//
// The [onChanged] parameter takes a [ValueChanged<String>] which is invoked
// upon a change in the text field's value.
//
// The [onSubmitted] parameter takes a [ValueChanged<String>] which is
// invoked when the keyboard submits.
//
// To provide a hint placeholder text that appears when the text entry is
// empty, pass a [String] to the [placeholder] parameter. This defaults to
// 'Search'.
//
// The [style] and [placeholderStyle] properties allow changing the style of
// the text and placeholder of the text field. [placeholderStyle] defaults
// to the gray [CupertinoColors.secondaryLabel] iOS color.
//
// To set the text field's background color and border radius, pass a
// [BoxDecoration] to the [decoration] parameter. This defaults to the
// default translucent tertiarySystemFill iOS color and 9 px corner radius.
//
// The [itemColor] and [itemSize] properties allow changing the icon color
// and icon size of the search icon (prefix) and X-Mark (suffix).
// They default to [CupertinoColors.secondaryLabel] and `20.0`.
//
// The [padding], [prefixInsets], and [suffixInsets] let you set the padding
// insets for text, the search icon (prefix), and the X-Mark icon (suffix).
// They default to values that replicate the `UISearchTextField` look. These
// default fields were determined using the comparison tool in
// https://github.com/flutter/platform_tests/.
//
// To customize the prefix icon, pass a [Widget] to [prefixIcon]. This
// defaults to the search icon.
//
// To customize the suffix icon, pass an [Icon] to [suffixIcon]. This
// defaults to the X-Mark.
//
// To dictate when the X-Mark (suffix) should be visible, a.k.a. only on when
// editing, not editing, on always, or on never, pass a
// [OverlayVisibilityMode] to [suffixMode]. This defaults to only on when
// editing.
//
// To customize the X-Mark (suffix) action, pass a [VoidCallback] to
// [onSuffixTap]. This defaults to clearing the text.
message CupertinoSearchTextField {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Controls the text being edited.
  //
  // Similar to [CupertinoTextField], to provide a prefilled text entry, pass
  // in a [TextEditingController] with an initial value to the [controller]
  // parameter. Defaults to creating its own [TextEditingController].
  FlutterTextEditingControllerType controller = 3;
  // Allows changing the style of the text.
  //
  // Defaults to the gray [CupertinoColors.secondaryLabel] iOS color.
  FlutterTextStyleType style = 6;
  // A hint placeholder text that appears when the text entry is empty.
  //
  // Defaults to 'Search' localized in each supported language.
  string placeholder = 7;
  // Sets the style of the placeholder of the text field.
  //
  // Defaults to the gray [CupertinoColors.secondaryLabel] iOS color.
  FlutterTextStyleType placeholder_style = 8;
  // Sets the decoration for the text field.
  //
  // This property is automatically set using the [backgroundColor] and
  // [borderRadius] properties, which both have default values. Therefore,
  // [decoration] has a default value upon building the widget. It is designed
  // to mimic the look of a `UISearchTextField`.
  FlutterBoxDecorationType decoration = 9;
  // Set the [decoration] property's background color.
  //
  // Can't be set along with the [decoration]. Defaults to the translucent
  // [CupertinoColors.tertiarySystemFill] iOS color.
  DartColorType background_color = 10;
  // Sets the [decoration] property's border radius.
  //
  // Can't be set along with the [decoration]. Defaults to 9 px circular
  // corner radius.
  FlutterBorderRadiusType border_radius = 11;
  // The keyboard type for this search field.
  //
  // Defaults to [TextInputType.text].
  FlutterTextInputTypeType keyboard_type = 12;
  // Sets the padding insets for the text and placeholder.
  //
  // Defaults to padding that replicates the `UISearchTextField` look. The
  // inset values were determined using the comparison tool in
  // https://github.com/flutter/platform_tests/.
  FlutterEdgeInsetsGeometryType padding = 13;
  // Sets the color for the suffix and prefix icons.
  //
  // Defaults to [CupertinoColors.secondaryLabel].
  DartColorType item_color = 14;
  // Sets the base icon size for the suffix and prefix icons.
  //
  // The size of the icon is scaled using the accessibility font scale
  // settings. Defaults to `20.0`.
  double item_size = 15;
  // Sets the padding insets for the suffix.
  //
  // Defaults to padding that replicates the `UISearchTextField` suffix look.
  // The inset values were determined using the comparison tool in
  // https://github.com/flutter/platform_tests/.
  FlutterEdgeInsetsGeometryType prefix_insets = 16;
  // Sets a prefix widget.
  //
  // Defaults to an [Icon] widget with the [CupertinoIcons.search] icon.
  WidgetType prefix_icon = 17;
  // Sets the padding insets for the prefix.
  //
  // Defaults to padding that replicates the `UISearchTextField` prefix look.
  // The inset values were determined using the comparison tool in
  // https://github.com/flutter/platform_tests/.
  FlutterEdgeInsetsGeometryType suffix_insets = 18;
  // Sets the suffix widget's icon.
  //
  // Defaults to the X-Mark [CupertinoIcons.xmark_circle_fill]. "To change the
  // functionality of the suffix icon, provide a custom onSuffixTap callback
  // and specify an intuitive suffixIcon.
  FlutterIconType suffix_icon = 19;
  // Dictates when the X-Mark (suffix) should be visible.
  //
  // Defaults to only on when editing.
  OverlayVisibilityModeType.Enum suffix_mode = 20;
  // {@macro flutter.material.textfield.restorationId}
  string restoration_id = 22;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 23;
  // Whether to allow the platform to automatically format quotes.
  //
  // This flag only affects iOS, where it is equivalent to [`UITextSmartQuotesType`](https://developer.apple.com/documentation/uikit/uitextsmartquotestype?language=objc).
  //
  // When set to [SmartQuotesType.enabled], it passes
  // [`UITextSmartQuotesTypeYes`](https://developer.apple.com/documentation/uikit/uitextsmartquotestype/uitextsmartquotestypeyes?language=objc),
  // and when set to [SmartQuotesType.disabled], it passes
  // [`UITextSmartQuotesTypeNo`](https://developer.apple.com/documentation/uikit/uitextsmartquotestype/uitextsmartquotestypeno?language=objc).
  //
  // If set to null, [SmartQuotesType.enabled] will be used.
  //
  // As an example of what this does, a standard vertical double quote
  // character will be automatically replaced by a left or right double quote
  // depending on its position in a word.
  //
  // Defaults to null.
  //
  // See also:
  //
  //  * [smartDashesType]
  //  * <https://developer.apple.com/documentation/uikit/uitextinputtraits>
  FlutterSmartQuotesTypeType.Enum smart_quotes_type = 24;
  // Whether to allow the platform to automatically format dashes.
  //
  // This flag only affects iOS versions 11 and above, where it is equivalent to [`UITextSmartDashesType`](https://developer.apple.com/documentation/uikit/uitextsmartdashestype?language=objc).
  //
  // When set to [SmartDashesType.enabled], it passes
  // [`UITextSmartDashesTypeYes`](https://developer.apple.com/documentation/uikit/uitextsmartdashestype/uitextsmartdashestypeyes?language=objc),
  // and when set to [SmartDashesType.disabled], it passes
  // [`UITextSmartDashesTypeNo`](https://developer.apple.com/documentation/uikit/uitextsmartdashestype/uitextsmartdashestypeno?language=objc).
  //
  // If set to null, [SmartDashesType.enabled] will be used.
  //
  // As an example of what this does, two consecutive hyphen characters will be
  // automatically replaced with one en dash, and three consecutive hyphens
  // will become one em dash.
  //
  // Defaults to null.
  //
  // See also:
  //
  //  * [smartQuotesType]
  //  * <https://developer.apple.com/documentation/uikit/uitextinputtraits>
  FlutterSmartDashesTypeType.Enum smart_dashes_type = 25;
  // {@macro flutter.services.TextInputConfiguration.enableIMEPersonalizedLearning}
  bool enable_i_m_e_personalized_learning = 26;
  // {@macro flutter.widgets.editableText.autofocus}
  bool autofocus = 27;
  // {@macro flutter.widgets.editableText.autocorrect}
  bool autocorrect = 29;
  // Disables the text field when false.
  //
  // Text fields in disabled states have a light grey background and don't
  // respond to touch events including the [prefixIcon] and [suffixIcon] button.
  bool enabled = 30;
}

// package:flutter/src/cupertino/slider.dart
//
// Creates an iOS-style slider.
//
// The slider itself does not maintain any state. Instead, when the state of
// the slider changes, the widget calls the [onChanged] callback. Most widgets
// that use a slider will listen for the [onChanged] callback and rebuild the
// slider with a new [value] to update the visual appearance of the slider.
//
// * [value] determines currently selected value for this slider.
// * [onChanged] is called when the user selects a new value for the slider.
// * [onChangeStart] is called when the user starts to select a new value for
//   the slider.
// * [onChangeEnd] is called when the user is done selecting a new value for
//   the slider.
message CupertinoSlider {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The currently selected value for this slider.
  //
  // The slider's thumb is drawn at a position that corresponds to this value.
  double value = 3;
  // The minimum value the user can select.
  //
  // Defaults to 0.0.
  double min = 7;
  // The maximum value the user can select.
  //
  // Defaults to 1.0.
  double max = 8;
  // The number of discrete divisions.
  //
  // If null, the slider is continuous.
  int32 divisions = 9;
  // The color to use for the portion of the slider that has been selected.
  //
  // Defaults to the [CupertinoTheme]'s primary color if null.
  DartColorType active_color = 10;
  // The color to use for the thumb of the slider.
  //
  // Defaults to [CupertinoColors.white].
  DartColorType thumb_color = 11;
}

// package:flutter/src/cupertino/nav_bar.dart
//
// Creates a navigation bar for scrolling lists.
//
// If [automaticallyImplyTitle] is false, then the [largeTitle] argument is
// required.
message CupertinoSliverNavigationBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The navigation bar's title.
  //
  // This text will appear in the top static navigation bar when collapsed and
  // below the navigation bar, in a larger font, when expanded.
  //
  // A suitable [DefaultTextStyle] is provided around this widget as it is
  // moved around, to change its font size.
  //
  // If [middle] is null, then the [largeTitle] widget will be inserted into
  // the tree in two places when transitioning from the collapsed state to the
  // expanded state. It is therefore imperative that this subtree not contain
  // any [GlobalKey]s, and that it not rely on maintaining state (for example,
  // animations will not survive the transition from one location to the other,
  // and may in fact be visible in two places at once during the transition).
  //
  // If null and [automaticallyImplyTitle] is true, an appropriate [Text]
  // title will be created if the current route is a [CupertinoPageRoute] and
  // has a `title`.
  //
  // This parameter must either be non-null or the route must have a title
  // ([CupertinoPageRoute.title]) and [automaticallyImplyTitle] must be true.
  WidgetType large_title = 3;
  // {@macro flutter.cupertino.CupertinoNavigationBar.leading}
  //
  // This widget is visible in both collapsed and expanded states.
  WidgetType leading = 4;
  // {@macro flutter.cupertino.CupertinoNavigationBar.automaticallyImplyLeading}
  bool automatically_imply_leading = 5;
  // Controls whether we should try to imply the [largeTitle] widget if null.
  //
  // If true and [largeTitle] is null, automatically fill in a [Text] widget
  // with the current route's `title` if the route is a [CupertinoPageRoute].
  // If [largeTitle] widget is not null, this parameter has no effect.
  bool automatically_imply_title = 6;
  // Controls whether [middle] widget should always be visible (even in
  // expanded state).
  //
  // If true (default) and [middle] is not null, [middle] widget is always
  // visible. If false, [middle] widget is visible only in collapsed state if
  // it is provided.
  //
  // This should be set to false if you only want to show [largeTitle] in
  // expanded state and [middle] in collapsed state.
  bool always_show_middle = 7;
  // {@macro flutter.cupertino.CupertinoNavigationBar.previousPageTitle}
  string previous_page_title = 8;
  // A widget to place in the middle of the static navigation bar instead of
  // the [largeTitle].
  //
  // This widget is visible in both collapsed and expanded states if
  // [alwaysShowMiddle] is true, otherwise just in collapsed state. The text
  // supplied in [largeTitle] will no longer appear in collapsed state if a
  // [middle] widget is provided.
  WidgetType middle = 9;
  // {@macro flutter.cupertino.CupertinoNavigationBar.trailing}
  //
  // This widget is visible in both collapsed and expanded states.
  WidgetType trailing = 10;
  // {@macro flutter.cupertino.CupertinoNavigationBar.border}
  FlutterBorderType border = 11;
  // {@macro flutter.cupertino.CupertinoNavigationBar.backgroundColor}
  DartColorType background_color = 12;
  // {@macro flutter.cupertino.CupertinoNavigationBar.brightness}
  DartBrightnessType.Enum brightness = 13;
  // {@macro flutter.cupertino.CupertinoNavigationBar.padding}
  FlutterEdgeInsetsDirectionalType padding = 14;
  // {@macro flutter.cupertino.CupertinoNavigationBar.transitionBetweenRoutes}
  bool transition_between_routes = 15;
  // Whether the nav bar should stretch to fill the over-scroll area.
  //
  // The nav bar can still expand and contract as the user scrolls, but it will
  // also stretch when the user over-scrolls if the [stretch] value is `true`.
  //
  // When set to `true`, the nav bar will prevent subsequent slivers from
  // accessing overscrolls. This may be undesirable for using overscroll-based
  // widgets like the [CupertinoSliverRefreshControl].
  //
  // Defaults to `false`.
  bool stretch = 17;
}

// package:flutter/src/cupertino/refresh.dart
//
// Create a new refresh control for inserting into a list of slivers.
//
// The [refreshTriggerPullDistance] and [refreshIndicatorExtent] arguments
// must be greater than or equal to 0.
//
// The [builder] argument may be null, in which case no indicator UI will be
// shown but the [onRefresh] will still be invoked. By default, [builder]
// shows a [CupertinoActivityIndicator].
//
// The [onRefresh] argument will be called when pulled far enough to trigger
// a refresh.
message CupertinoSliverRefreshControl {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The amount of overscroll the scrollable must be dragged to trigger a reload.
  //
  // Must be larger than zero and larger than [refreshIndicatorExtent].
  // Defaults to 100 pixels when not specified.
  //
  // When overscrolled past this distance, [onRefresh] will be called if not
  // null and the [builder] will build in the [RefreshIndicatorMode.armed] state.
  double refresh_trigger_pull_distance = 3;
  // The amount of space the refresh indicator sliver will keep holding while
  // [onRefresh]'s [Future] is still running.
  //
  // Must be a positive number, but can be zero, in which case the sliver will
  // start retracting back to zero as soon as the refresh is started. Defaults
  // to 60 pixels when not specified.
  //
  // Must be smaller than [refreshTriggerPullDistance], since the sliver
  // shouldn't grow further after triggering the refresh.
  double refresh_indicator_extent = 4;
}

// package:flutter/src/cupertino/spell_check_suggestions_toolbar.dart
//
// Constructs a [CupertinoSpellCheckSuggestionsToolbar].
//
// [buttonItems] must not contain more than three items.
message CupertinoSpellCheckSuggestionsToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The location on which to anchor the menu.
  FlutterTextSelectionToolbarAnchorsType anchors = 3;
  // The [ContextMenuButtonItem]s that will be turned into the correct button
  // widgets and displayed in the spell check suggestions toolbar.
  //
  // Must not contain more than three items.
  //
  // See also:
  //
  //  * [AdaptiveTextSelectionToolbar.buttonItems], the list of
  //    [ContextMenuButtonItem]s that are used to build the buttons of the
  //    text selection toolbar.
  //  * [SpellCheckSuggestionsToolbar.buttonItems], the list of
  //    [ContextMenuButtonItem]s used to build the Material style spell check
  //    suggestions toolbar.
  repeated FlutterContextMenuButtonItemType button_items = 4;
}

// package:flutter/src/cupertino/spell_check_suggestions_toolbar.dart
//
// Constructs a [CupertinoSpellCheckSuggestionsToolbar] with the default
// children for an [EditableText].
//
// See also:
//  * [SpellCheckSuggestionsToolbar.editableText], which is similar but
//    builds an Android-style toolbar.
message CupertinoSpellCheckSuggestionsToolbarNamedEditableText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterEditableTextStateType editable_text_state = 3;
}

// package:flutter/src/cupertino/switch.dart
//
// Creates an iOS-style switch.
//
// The [dragStartBehavior] parameter defaults to [DragStartBehavior.start].
message CupertinoSwitch {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this switch is on or off.
  bool value = 3;
  // The color to use for the track when the switch is on.
  //
  // If null and [applyTheme] is false, defaults to [CupertinoColors.systemGreen]
  // in accordance to native iOS behavior. Otherwise, defaults to
  // [CupertinoThemeData.primaryColor].
  DartColorType active_color = 5;
  // The color to use for the track when the switch is off.
  //
  // Defaults to [CupertinoColors.secondarySystemFill] when null.
  DartColorType track_color = 6;
  // The color to use for the thumb of the switch.
  //
  // Defaults to [CupertinoColors.white] when null.
  DartColorType thumb_color = 7;
  // {@template flutter.cupertino.CupertinoSwitch.applyTheme}
  // Whether to apply the ambient [CupertinoThemeData].
  //
  // If true, the track uses [CupertinoThemeData.primaryColor] for the track
  // when the switch is on.
  //
  // Defaults to [CupertinoThemeData.applyThemeToAll].
  // {@endtemplate}
  bool apply_theme = 8;
  // The color to use for the focus highlight for keyboard interactions.
  //
  // Defaults to a slightly transparent [activeColor].
  DartColorType focus_color = 9;
  // The color to use for the accessibility label when the switch is on.
  //
  // Defaults to [CupertinoColors.white] when null.
  DartColorType on_label_color = 10;
  // The color to use for the accessibility label when the switch is off.
  //
  // Defaults to [Color.fromARGB(255, 179, 179, 179)]
  // (or [Color.fromARGB(255, 255, 255, 255)] in high contrast) when null.
  DartColorType off_label_color = 11;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 12;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 14;
  // {@template flutter.cupertino.CupertinoSwitch.dragStartBehavior}
  // Determines the way that drag start behavior is handled.
  //
  // If set to [DragStartBehavior.start], the drag behavior used to move the
  // switch from on to off will begin at the position where the drag gesture won
  // the arena. If set to [DragStartBehavior.down] it will begin at the position
  // where a down event was first detected.
  //
  // In general, setting this to [DragStartBehavior.start] will make drag
  // animation smoother and setting it to [DragStartBehavior.down] will make
  // drag behavior feel slightly more reactive.
  //
  // By default, the drag start behavior is [DragStartBehavior.start].
  //
  // See also:
  //
  //  * [DragGestureRecognizer.dragStartBehavior], which gives an example for
  //    the different behaviors.
  //
  // {@endtemplate}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 15;
}

// package:flutter/src/cupertino/bottom_tab_bar.dart
//
// Creates a tab bar in the iOS style.
message CupertinoTabBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The interactive items laid out within the bottom navigation bar.
  repeated FlutterBottomNavigationBarItemType items = 3;
  // The index into [items] of the current active item.
  //
  // Must be between 0 and the number of tabs minus 1, inclusive.
  int32 current_index = 5;
  // The background color of the tab bar. If it contains transparency, the
  // tab bar will automatically produce a blurring effect to the content
  // behind it.
  //
  // Defaults to [CupertinoTheme]'s `barBackgroundColor` when null.
  DartColorType background_color = 6;
  // The foreground color of the icon and title for the [BottomNavigationBarItem]
  // of the selected tab.
  //
  // Defaults to [CupertinoTheme]'s `primaryColor` if null.
  DartColorType active_color = 7;
  // The foreground color of the icon and title for the [BottomNavigationBarItem]s
  // in the unselected state.
  //
  // Defaults to a [CupertinoDynamicColor] that matches the disabled foreground
  // color of the native `UITabBar` component.
  DartColorType inactive_color = 8;
  // The size of all of the [BottomNavigationBarItem] icons.
  //
  // This value is used to configure the [IconTheme] for the navigation bar.
  // When a [BottomNavigationBarItem.icon] widget is not an [Icon] the widget
  // should configure itself to match the icon theme's size and color.
  double icon_size = 9;
  // The height of the [CupertinoTabBar].
  //
  // Defaults to 50.
  double height = 10;
  // The border of the [CupertinoTabBar].
  //
  // The default value is a one physical pixel top border with grey color.
  FlutterBorderType border = 11;
}

// package:flutter/src/cupertino/tab_view.dart
//
// Creates the content area for a tab in a [CupertinoTabScaffold].
message CupertinoTabView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The title of the default route.
  string default_title = 5;
  // The list of observers for the [Navigator] created in this tab view.
  //
  // This list of observers is not shared with ancestor or descendant [Navigator]s.
  repeated FlutterNavigatorObserverType navigator_observers = 9;
  // Restoration ID to save and restore the state of the [Navigator] built by
  // this [CupertinoTabView].
  //
  // {@macro flutter.widgets.navigator.restorationScopeId}
  string restoration_scope_id = 10;
}

// package:flutter/src/cupertino/text_field.dart
//
// Creates an iOS-style text field.
//
// To provide a prefilled text entry, pass in a [TextEditingController] with
// an initial value to the [controller] parameter.
//
// To provide a hint placeholder text that appears when the text entry is
// empty, pass a [String] to the [placeholder] parameter.
//
// The [maxLines] property can be set to null to remove the restriction on
// the number of lines. In this mode, the intrinsic height of the widget will
// grow as the number of lines of text grows. By default, it is `1`, meaning
// this is a single-line text field and will scroll horizontally when
// it overflows. [maxLines] must not be zero.
//
// The text cursor is not shown if [showCursor] is false or if [showCursor]
// is null (the default) and [readOnly] is true.
//
// If specified, the [maxLength] property must be greater than zero.
//
// The [selectionHeightStyle] and [selectionWidthStyle] properties allow
// changing the shape of the selection highlighting. These properties default
// to [ui.BoxHeightStyle.tight] and [ui.BoxWidthStyle.tight], respectively.
//
// The [autocorrect], [autofocus], [clearButtonMode], [dragStartBehavior],
// [expands], [obscureText], [prefixMode], [readOnly], [scrollPadding],
// [suffixMode], [textAlign], [selectionHeightStyle], [selectionWidthStyle],
// [enableSuggestions], and [enableIMEPersonalizedLearning] properties must
// not be null.
//
// {@macro flutter.widgets.editableText.accessibility}
//
// See also:
//
//  * [minLines], which is the minimum number of lines to occupy when the
//    content spans fewer lines.
//  * [expands], to allow the widget to size itself to its parent's height.
//  * [maxLength], which discusses the precise meaning of "number of
//    characters" and how it may differ from the intuitive meaning.
message CupertinoTextField {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Controls the text being edited.
  //
  // If null, this widget will create its own [TextEditingController].
  FlutterTextEditingControllerType controller = 3;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 4;
  // {@macro flutter.widgets.undoHistory.controller}
  FlutterUndoHistoryControllerType undo_controller = 5;
  // Controls the [BoxDecoration] of the box behind the text input.
  //
  // Defaults to having a rounded rectangle grey border and can be null to have
  // no box decoration.
  FlutterBoxDecorationType decoration = 6;
  // Padding around the text entry area between the [prefix] and [suffix]
  // or the clear button when [clearButtonMode] is not never.
  //
  // Defaults to a padding of 6 pixels on all sides and can be null.
  FlutterEdgeInsetsGeometryType padding = 7;
  // A lighter colored placeholder hint that appears on the first line of the
  // text field when the text entry is empty.
  //
  // Defaults to having no placeholder text.
  //
  // The text style of the placeholder text matches that of the text field's
  // main text entry except a lighter font weight and a grey font color.
  string placeholder = 8;
  // The style to use for the placeholder text.
  //
  // The [placeholderStyle] is merged with the [style] [TextStyle] when applied
  // to the [placeholder] text. To avoid merging with [style], specify
  // [TextStyle.inherit] as false.
  //
  // Defaults to the [style] property with w300 font weight and grey color.
  //
  // If specifically set to null, placeholder's style will be the same as [style].
  FlutterTextStyleType placeholder_style = 9;
  // An optional [Widget] to display before the text.
  WidgetType prefix = 10;
  // Controls the visibility of the [prefix] widget based on the state of
  // text entry when the [prefix] argument is not null.
  //
  // Defaults to [OverlayVisibilityMode.always].
  //
  // Has no effect when [prefix] is null.
  OverlayVisibilityModeType.Enum prefix_mode = 11;
  // An optional [Widget] to display after the text.
  WidgetType suffix = 12;
  // Controls the visibility of the [suffix] widget based on the state of
  // text entry when the [suffix] argument is not null.
  //
  // Defaults to [OverlayVisibilityMode.always].
  //
  // Has no effect when [suffix] is null.
  OverlayVisibilityModeType.Enum suffix_mode = 13;
  // Show an iOS-style clear button to clear the current text entry.
  //
  // Can be made to appear depending on various text states of the
  // [TextEditingController].
  //
  // Will only appear if no [suffix] widget is appearing.
  //
  // Defaults to [OverlayVisibilityMode.never].
  OverlayVisibilityModeType.Enum clear_button_mode = 14;
  // The semantic label for the clear button used by screen readers.
  //
  // This will be used by screen reading software to identify the clear button
  // widget. Defaults to "Clear".
  string clear_button_semantic_label = 15;
  FlutterTextInputTypeType keyboard_type = 16;
  // The type of action button to use for the keyboard.
  //
  // Defaults to [TextInputAction.newline] if [keyboardType] is
  // [TextInputType.multiline] and [TextInputAction.done] otherwise.
  FlutterTextInputActionType.Enum text_input_action = 17;
  // {@macro flutter.widgets.editableText.textCapitalization}
  FlutterTextCapitalizationType.Enum text_capitalization = 18;
  // The style to use for the text being edited.
  //
  // Also serves as a base for the [placeholder] text's style.
  //
  // Defaults to the standard iOS font style from [CupertinoTheme] if null.
  FlutterTextStyleType style = 19;
  // {@macro flutter.widgets.editableText.strutStyle}
  FlutterStrutStyleType strut_style = 20;
  // {@macro flutter.widgets.editableText.textAlign}
  DartTextAlignType.Enum text_align = 21;
  // {@macro flutter.material.InputDecorator.textAlignVertical}
  FlutterTextAlignVerticalType text_align_vertical = 22;
  // {@macro flutter.widgets.editableText.textDirection}
  DartTextDirectionType.Enum text_direction = 23;
  // {@macro flutter.widgets.editableText.readOnly}
  bool read_only = 24;
  // {@macro flutter.widgets.editableText.showCursor}
  bool show_cursor = 25;
  // {@macro flutter.widgets.editableText.autofocus}
  bool autofocus = 26;
  // {@macro flutter.widgets.editableText.obscuringCharacter}
  string obscuring_character = 27;
  // {@macro flutter.widgets.editableText.obscureText}
  bool obscure_text = 28;
  // {@macro flutter.widgets.editableText.autocorrect}
  bool autocorrect = 29;
  FlutterSmartDashesTypeType.Enum smart_dashes_type = 30;
  FlutterSmartQuotesTypeType.Enum smart_quotes_type = 31;
  // {@macro flutter.services.TextInputConfiguration.enableSuggestions}
  bool enable_suggestions = 32;
  // {@macro flutter.widgets.editableText.maxLines}
  //  * [expands], which determines whether the field should fill the height of
  //    its parent.
  int32 max_lines = 33;
  // {@macro flutter.widgets.editableText.minLines}
  //  * [expands], which determines whether the field should fill the height of
  //    its parent.
  int32 min_lines = 34;
  // {@macro flutter.widgets.editableText.expands}
  bool expands = 35;
  // The maximum number of characters (Unicode grapheme clusters) to allow in
  // the text field.
  //
  // After [maxLength] characters have been input, additional input
  // is ignored, unless [maxLengthEnforcement] is set to
  // [MaxLengthEnforcement.none].
  //
  // The TextField enforces the length with a
  // [LengthLimitingTextInputFormatter], which is evaluated after the supplied
  // [inputFormatters], if any.
  //
  // This value must be either null or greater than zero. If set to null
  // (the default), there is no limit to the number of characters allowed.
  //
  // Whitespace characters (e.g. newline, space, tab) are included in the
  // character count.
  //
  // {@macro flutter.services.lengthLimitingTextInputFormatter.maxLength}
  int32 max_length = 36;
  // Determines how the [maxLength] limit should be enforced.
  //
  // If [MaxLengthEnforcement.none] is set, additional input beyond [maxLength]
  // will not be enforced by the limit.
  //
  // {@macro flutter.services.textFormatter.effectiveMaxLengthEnforcement}
  //
  // {@macro flutter.services.textFormatter.maxLengthEnforcement}
  FlutterMaxLengthEnforcementType.Enum max_length_enforcement = 37;
  // {@macro flutter.widgets.editableText.inputFormatters}
  repeated FlutterTextInputFormatterType input_formatters = 42;
  // Disables the text field when false.
  //
  // Text fields in disabled states have a light grey background and don't
  // respond to touch events including the [prefix], [suffix] and the clear
  // button.
  //
  // Defaults to true.
  bool enabled = 43;
  // {@macro flutter.widgets.editableText.cursorWidth}
  double cursor_width = 44;
  // {@macro flutter.widgets.editableText.cursorHeight}
  double cursor_height = 45;
  // {@macro flutter.widgets.editableText.cursorRadius}
  DartRadiusType cursor_radius = 46;
  // {@macro flutter.widgets.editableText.cursorOpacityAnimates}
  bool cursor_opacity_animates = 47;
  // The color to use when painting the cursor.
  //
  // Defaults to the [DefaultSelectionStyle.cursorColor]. If that color is
  // null, it uses the [CupertinoThemeData.primaryColor] of the ambient theme,
  // which itself defaults to [CupertinoColors.activeBlue] in the light theme
  // and [CupertinoColors.activeOrange] in the dark theme.
  DartColorType cursor_color = 48;
  // Controls how tall the selection highlight boxes are computed to be.
  //
  // See [ui.BoxHeightStyle] for details on available styles.
  DartBoxHeightStyleType.Enum selection_height_style = 49;
  // Controls how wide the selection highlight boxes are computed to be.
  //
  // See [ui.BoxWidthStyle] for details on available styles.
  DartBoxWidthStyleType.Enum selection_width_style = 50;
  // The appearance of the keyboard.
  //
  // This setting is only honored on iOS devices.
  //
  // If null, defaults to [Brightness.light].
  DartBrightnessType.Enum keyboard_appearance = 51;
  // {@macro flutter.widgets.editableText.scrollPadding}
  FlutterEdgeInsetsType scroll_padding = 52;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 53;
  bool enable_interactive_selection = 54;
  // {@macro flutter.widgets.editableText.selectionControls}
  FlutterTextSelectionControlsType selection_controls = 55;
  // {@macro flutter.widgets.editableText.scrollController}
  FlutterScrollControllerType scroll_controller = 57;
  // {@macro flutter.widgets.editableText.scrollPhysics}
  FlutterScrollPhysicsType scroll_physics = 58;
  // {@macro flutter.widgets.editableText.autofillHints}
  // {@macro flutter.services.AutofillConfiguration.autofillHints}
  repeated string autofill_hints = 59;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 61;
  // {@macro flutter.material.textfield.restorationId}
  string restoration_id = 62;
  // {@macro flutter.widgets.editableText.scribbleEnabled}
  bool scribble_enabled = 63;
  // {@macro flutter.services.TextInputConfiguration.enableIMEPersonalizedLearning}
  bool enable_i_m_e_personalized_learning = 64;
  // {@macro flutter.widgets.EditableText.spellCheckConfiguration}
  //
  // If [SpellCheckConfiguration.misspelledTextStyle] is not specified in this
  // configuration, then [cupertinoMisspelledTextStyle] is used by default.
  FlutterSpellCheckConfigurationType spell_check_configuration = 66;
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
  //
  // {@macro flutter.widgets.magnifier.intro}
  //
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.details}
  //
  // By default, builds a [CupertinoTextMagnifier] on iOS and Android nothing on all other
  // platforms. If it is desired to suppress the magnifier, consider passing
  // [TextMagnifierConfiguration.disabled].
  //
  // {@tool dartpad}
  // This sample demonstrates how to customize the magnifier that this text field uses.
  //
  // ** See code in examples/api/lib/widgets/text_magnifier/text_magnifier.0.dart **
  // {@end-tool}
  FlutterTextMagnifierConfigurationType magnifier_configuration = 67;
}

// package:flutter/src/cupertino/text_field.dart
//
// Creates a borderless iOS-style text field.
//
// To provide a prefilled text entry, pass in a [TextEditingController] with
// an initial value to the [controller] parameter.
//
// To provide a hint placeholder text that appears when the text entry is
// empty, pass a [String] to the [placeholder] parameter.
//
// The [maxLines] property can be set to null to remove the restriction on
// the number of lines. In this mode, the intrinsic height of the widget will
// grow as the number of lines of text grows. By default, it is `1`, meaning
// this is a single-line text field and will scroll horizontally when
// it overflows. [maxLines] must not be zero.
//
// The text cursor is not shown if [showCursor] is false or if [showCursor]
// is null (the default) and [readOnly] is true.
//
// If specified, the [maxLength] property must be greater than zero.
//
// The [selectionHeightStyle] and [selectionWidthStyle] properties allow
// changing the shape of the selection highlighting. These properties default
// to [ui.BoxHeightStyle.tight] and [ui.BoxWidthStyle.tight] respectively.
//
// See also:
//
//  * [minLines], which is the minimum number of lines to occupy when the
//    content spans fewer lines.
//  * [expands], to allow the widget to size itself to its parent's height.
//  * [maxLength], which discusses the precise meaning of "number of
//    characters" and how it may differ from the intuitive meaning.
message CupertinoTextFieldNamedBorderless {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Controls the text being edited.
  //
  // If null, this widget will create its own [TextEditingController].
  FlutterTextEditingControllerType controller = 3;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 4;
  // {@macro flutter.widgets.undoHistory.controller}
  FlutterUndoHistoryControllerType undo_controller = 5;
  // Controls the [BoxDecoration] of the box behind the text input.
  //
  // Defaults to having a rounded rectangle grey border and can be null to have
  // no box decoration.
  FlutterBoxDecorationType decoration = 6;
  // Padding around the text entry area between the [prefix] and [suffix]
  // or the clear button when [clearButtonMode] is not never.
  //
  // Defaults to a padding of 6 pixels on all sides and can be null.
  FlutterEdgeInsetsGeometryType padding = 7;
  // A lighter colored placeholder hint that appears on the first line of the
  // text field when the text entry is empty.
  //
  // Defaults to having no placeholder text.
  //
  // The text style of the placeholder text matches that of the text field's
  // main text entry except a lighter font weight and a grey font color.
  string placeholder = 8;
  // The style to use for the placeholder text.
  //
  // The [placeholderStyle] is merged with the [style] [TextStyle] when applied
  // to the [placeholder] text. To avoid merging with [style], specify
  // [TextStyle.inherit] as false.
  //
  // Defaults to the [style] property with w300 font weight and grey color.
  //
  // If specifically set to null, placeholder's style will be the same as [style].
  FlutterTextStyleType placeholder_style = 9;
  // An optional [Widget] to display before the text.
  WidgetType prefix = 10;
  // Controls the visibility of the [prefix] widget based on the state of
  // text entry when the [prefix] argument is not null.
  //
  // Defaults to [OverlayVisibilityMode.always].
  //
  // Has no effect when [prefix] is null.
  OverlayVisibilityModeType.Enum prefix_mode = 11;
  // An optional [Widget] to display after the text.
  WidgetType suffix = 12;
  // Controls the visibility of the [suffix] widget based on the state of
  // text entry when the [suffix] argument is not null.
  //
  // Defaults to [OverlayVisibilityMode.always].
  //
  // Has no effect when [suffix] is null.
  OverlayVisibilityModeType.Enum suffix_mode = 13;
  // Show an iOS-style clear button to clear the current text entry.
  //
  // Can be made to appear depending on various text states of the
  // [TextEditingController].
  //
  // Will only appear if no [suffix] widget is appearing.
  //
  // Defaults to [OverlayVisibilityMode.never].
  OverlayVisibilityModeType.Enum clear_button_mode = 14;
  // The semantic label for the clear button used by screen readers.
  //
  // This will be used by screen reading software to identify the clear button
  // widget. Defaults to "Clear".
  string clear_button_semantic_label = 15;
  FlutterTextInputTypeType keyboard_type = 16;
  // The type of action button to use for the keyboard.
  //
  // Defaults to [TextInputAction.newline] if [keyboardType] is
  // [TextInputType.multiline] and [TextInputAction.done] otherwise.
  FlutterTextInputActionType.Enum text_input_action = 17;
  // {@macro flutter.widgets.editableText.textCapitalization}
  FlutterTextCapitalizationType.Enum text_capitalization = 18;
  // The style to use for the text being edited.
  //
  // Also serves as a base for the [placeholder] text's style.
  //
  // Defaults to the standard iOS font style from [CupertinoTheme] if null.
  FlutterTextStyleType style = 19;
  // {@macro flutter.widgets.editableText.strutStyle}
  FlutterStrutStyleType strut_style = 20;
  // {@macro flutter.widgets.editableText.textAlign}
  DartTextAlignType.Enum text_align = 21;
  // {@macro flutter.material.InputDecorator.textAlignVertical}
  FlutterTextAlignVerticalType text_align_vertical = 22;
  // {@macro flutter.widgets.editableText.textDirection}
  DartTextDirectionType.Enum text_direction = 23;
  // {@macro flutter.widgets.editableText.readOnly}
  bool read_only = 24;
  // {@macro flutter.widgets.editableText.showCursor}
  bool show_cursor = 25;
  // {@macro flutter.widgets.editableText.autofocus}
  bool autofocus = 26;
  // {@macro flutter.widgets.editableText.obscuringCharacter}
  string obscuring_character = 27;
  // {@macro flutter.widgets.editableText.obscureText}
  bool obscure_text = 28;
  // {@macro flutter.widgets.editableText.autocorrect}
  bool autocorrect = 29;
  FlutterSmartDashesTypeType.Enum smart_dashes_type = 30;
  FlutterSmartQuotesTypeType.Enum smart_quotes_type = 31;
  // {@macro flutter.services.TextInputConfiguration.enableSuggestions}
  bool enable_suggestions = 32;
  // {@macro flutter.widgets.editableText.maxLines}
  //  * [expands], which determines whether the field should fill the height of
  //    its parent.
  int32 max_lines = 33;
  // {@macro flutter.widgets.editableText.minLines}
  //  * [expands], which determines whether the field should fill the height of
  //    its parent.
  int32 min_lines = 34;
  // {@macro flutter.widgets.editableText.expands}
  bool expands = 35;
  // The maximum number of characters (Unicode grapheme clusters) to allow in
  // the text field.
  //
  // After [maxLength] characters have been input, additional input
  // is ignored, unless [maxLengthEnforcement] is set to
  // [MaxLengthEnforcement.none].
  //
  // The TextField enforces the length with a
  // [LengthLimitingTextInputFormatter], which is evaluated after the supplied
  // [inputFormatters], if any.
  //
  // This value must be either null or greater than zero. If set to null
  // (the default), there is no limit to the number of characters allowed.
  //
  // Whitespace characters (e.g. newline, space, tab) are included in the
  // character count.
  //
  // {@macro flutter.services.lengthLimitingTextInputFormatter.maxLength}
  int32 max_length = 36;
  // Determines how the [maxLength] limit should be enforced.
  //
  // If [MaxLengthEnforcement.none] is set, additional input beyond [maxLength]
  // will not be enforced by the limit.
  //
  // {@macro flutter.services.textFormatter.effectiveMaxLengthEnforcement}
  //
  // {@macro flutter.services.textFormatter.maxLengthEnforcement}
  FlutterMaxLengthEnforcementType.Enum max_length_enforcement = 37;
  // {@macro flutter.widgets.editableText.inputFormatters}
  repeated FlutterTextInputFormatterType input_formatters = 42;
  // Disables the text field when false.
  //
  // Text fields in disabled states have a light grey background and don't
  // respond to touch events including the [prefix], [suffix] and the clear
  // button.
  //
  // Defaults to true.
  bool enabled = 43;
  // {@macro flutter.widgets.editableText.cursorWidth}
  double cursor_width = 44;
  // {@macro flutter.widgets.editableText.cursorHeight}
  double cursor_height = 45;
  // {@macro flutter.widgets.editableText.cursorRadius}
  DartRadiusType cursor_radius = 46;
  // {@macro flutter.widgets.editableText.cursorOpacityAnimates}
  bool cursor_opacity_animates = 47;
  // The color to use when painting the cursor.
  //
  // Defaults to the [DefaultSelectionStyle.cursorColor]. If that color is
  // null, it uses the [CupertinoThemeData.primaryColor] of the ambient theme,
  // which itself defaults to [CupertinoColors.activeBlue] in the light theme
  // and [CupertinoColors.activeOrange] in the dark theme.
  DartColorType cursor_color = 48;
  // Controls how tall the selection highlight boxes are computed to be.
  //
  // See [ui.BoxHeightStyle] for details on available styles.
  DartBoxHeightStyleType.Enum selection_height_style = 49;
  // Controls how wide the selection highlight boxes are computed to be.
  //
  // See [ui.BoxWidthStyle] for details on available styles.
  DartBoxWidthStyleType.Enum selection_width_style = 50;
  // The appearance of the keyboard.
  //
  // This setting is only honored on iOS devices.
  //
  // If null, defaults to [Brightness.light].
  DartBrightnessType.Enum keyboard_appearance = 51;
  // {@macro flutter.widgets.editableText.scrollPadding}
  FlutterEdgeInsetsType scroll_padding = 52;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 53;
  bool enable_interactive_selection = 54;
  // {@macro flutter.widgets.editableText.selectionControls}
  FlutterTextSelectionControlsType selection_controls = 55;
  // {@macro flutter.widgets.editableText.scrollController}
  FlutterScrollControllerType scroll_controller = 57;
  // {@macro flutter.widgets.editableText.scrollPhysics}
  FlutterScrollPhysicsType scroll_physics = 58;
  // {@macro flutter.widgets.editableText.autofillHints}
  // {@macro flutter.services.AutofillConfiguration.autofillHints}
  repeated string autofill_hints = 59;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 61;
  // {@macro flutter.material.textfield.restorationId}
  string restoration_id = 62;
  // {@macro flutter.widgets.editableText.scribbleEnabled}
  bool scribble_enabled = 63;
  // {@macro flutter.services.TextInputConfiguration.enableIMEPersonalizedLearning}
  bool enable_i_m_e_personalized_learning = 64;
  // {@macro flutter.widgets.EditableText.spellCheckConfiguration}
  //
  // If [SpellCheckConfiguration.misspelledTextStyle] is not specified in this
  // configuration, then [cupertinoMisspelledTextStyle] is used by default.
  FlutterSpellCheckConfigurationType spell_check_configuration = 66;
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
  //
  // {@macro flutter.widgets.magnifier.intro}
  //
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.details}
  //
  // By default, builds a [CupertinoTextMagnifier] on iOS and Android nothing on all other
  // platforms. If it is desired to suppress the magnifier, consider passing
  // [TextMagnifierConfiguration.disabled].
  //
  // {@tool dartpad}
  // This sample demonstrates how to customize the magnifier that this text field uses.
  //
  // ** See code in examples/api/lib/widgets/text_magnifier/text_magnifier.0.dart **
  // {@end-tool}
  FlutterTextMagnifierConfigurationType magnifier_configuration = 67;
}

// package:flutter/src/cupertino/text_form_field_row.dart
//
// Creates a [CupertinoFormRow] containing a [FormField] that wraps
// a [CupertinoTextField].
//
// When a [controller] is specified, [initialValue] must be null (the
// default). If [controller] is null, then a [TextEditingController]
// will be constructed automatically and its `text` will be initialized
// to [initialValue] or the empty string.
//
// The [prefix] parameter is displayed at the start of the row. Standard iOS
// guidelines encourage passing a [Text] widget to [prefix] to detail the
// nature of the input.
//
// The [padding] parameter is used to pad the contents of the row. It is
// directly passed to [CupertinoFormRow]. If the [padding]
// parameter is null, [CupertinoFormRow] constructs its own default
// padding (which is the standard form row padding in iOS.) If no edge
// insets are intended, explicitly pass [EdgeInsets.zero] to [padding].
//
// For documentation about the various parameters, see the
// [CupertinoTextField] class and [CupertinoTextField.borderless],
// the constructor.
message CupertinoTextFormFieldRow {
  FlutterKeyType key = 2;
  // A widget that is displayed at the start of the row.
  //
  // The [prefix] widget is displayed at the start of the row. Standard iOS
  // guidelines encourage passing a [Text] widget to [prefix] to detail the
  // nature of the input.
  WidgetType prefix = 3;
  // Content padding for the row.
  //
  // The [padding] widget is passed to [CupertinoFormRow]. If the [padding]
  // parameter is null, [CupertinoFormRow] constructs its own default
  // padding, which is the standard form row padding in iOS.
  //
  // If no edge insets are intended, explicitly pass [EdgeInsets.zero] to
  // [padding].
  FlutterEdgeInsetsGeometryType padding = 4;
  // Controls the text being edited.
  //
  // If null, this widget will create its own [TextEditingController] and
  // initialize its [TextEditingController.text] with [initialValue].
  FlutterTextEditingControllerType controller = 5;
  string initial_value = 6;
  FlutterFocusNodeType focus_node = 7;
  FlutterBoxDecorationType decoration = 8;
  FlutterTextInputTypeType keyboard_type = 9;
  FlutterTextCapitalizationType.Enum text_capitalization = 10;
  FlutterTextInputActionType.Enum text_input_action = 11;
  FlutterTextStyleType style = 12;
  FlutterStrutStyleType strut_style = 13;
  DartTextDirectionType.Enum text_direction = 14;
  DartTextAlignType.Enum text_align = 15;
  FlutterTextAlignVerticalType text_align_vertical = 16;
  bool autofocus = 17;
  bool read_only = 18;
  bool show_cursor = 19;
  string obscuring_character = 20;
  bool obscure_text = 21;
  bool autocorrect = 22;
  FlutterSmartDashesTypeType.Enum smart_dashes_type = 23;
  FlutterSmartQuotesTypeType.Enum smart_quotes_type = 24;
  bool enable_suggestions = 25;
  int32 max_lines = 26;
  int32 min_lines = 27;
  bool expands = 28;
  int32 max_length = 29;
  repeated FlutterTextInputFormatterType input_formatters = 36;
  bool enabled = 37;
  double cursor_width = 38;
  double cursor_height = 39;
  DartColorType cursor_color = 40;
  DartBrightnessType.Enum keyboard_appearance = 41;
  FlutterEdgeInsetsType scroll_padding = 42;
  bool enable_interactive_selection = 43;
  FlutterTextSelectionControlsType selection_controls = 44;
  FlutterScrollPhysicsType scroll_physics = 45;
  repeated string autofill_hints = 46;
  FlutterAutovalidateModeType.Enum autovalidate_mode = 47;
  string placeholder = 48;
  FlutterTextStyleType placeholder_style = 49;
}

// package:flutter/src/cupertino/text_selection.dart
message CupertinoTextSelectionControls {
  
}

// package:flutter/src/cupertino/text_selection_toolbar.dart
//
// Creates an instance of CupertinoTextSelectionToolbar.
message CupertinoTextSelectionToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.material.TextSelectionToolbar.anchorAbove}
  DartOffsetType anchor_above = 3;
  // {@macro flutter.material.TextSelectionToolbar.anchorBelow}
  DartOffsetType anchor_below = 4;
  // {@macro flutter.material.TextSelectionToolbar.children}
  //
  // See also:
  //   * [CupertinoTextSelectionToolbarButton], which builds a default
  //     Cupertino-style text selection toolbar text button.
  repeated WidgetType children = 5;
}

// package:flutter/src/cupertino/text_selection_toolbar_button.dart
//
// Create an instance of [CupertinoTextSelectionToolbarButton].
message CupertinoTextSelectionToolbarButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.cupertino.CupertinoTextSelectionToolbarButton.child}
  // The child of this button.
  //
  // Usually a [Text] or an [Icon].
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/cupertino/text_selection_toolbar_button.dart
//
// Create an instance of [CupertinoTextSelectionToolbarButton] from the given
// [ContextMenuButtonItem].
message CupertinoTextSelectionToolbarButtonNamedButtonItem {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.cupertino.CupertinoTextSelectionToolbarButton.onPressed}
  // The buttonItem used to generate the button when using
  // [CupertinoTextSelectionToolbarButton.buttonItem].
  // {@endtemplate}
  FlutterContextMenuButtonItemType button_item = 3;
}

// package:flutter/src/cupertino/text_selection_toolbar_button.dart
//
// Create an instance of [CupertinoTextSelectionToolbarButton] whose child is
// a [Text] widget styled like the default iOS text selection toolbar button.
message CupertinoTextSelectionToolbarButtonNamedText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.cupertino.CupertinoTextSelectionToolbarButton.text}
  // The text used in the button's label when using
  // [CupertinoTextSelectionToolbarButton.text].
  // {@endtemplate}
  string text = 4;
}

// package:flutter/src/cupertino/text_theme.dart
//
// Create a [CupertinoTextThemeData].
//
// The [primaryColor] is used to derive TextStyle defaults of other attributes
// such as [navActionTextStyle] and [actionTextStyle]. It must not be null when
// either [navActionTextStyle] or [actionTextStyle] is null. Defaults to
// [CupertinoColors.systemBlue].
//
// Other [TextStyle] parameters default to default iOS text styles when
// unspecified.
message CupertinoTextThemeData {
  DartColorType primary_color = 2;
  FlutterTextStyleType text_style = 3;
  FlutterTextStyleType action_text_style = 4;
  FlutterTextStyleType tab_label_text_style = 5;
  FlutterTextStyleType nav_title_text_style = 6;
  FlutterTextStyleType nav_large_title_text_style = 7;
  FlutterTextStyleType nav_action_text_style = 8;
  FlutterTextStyleType picker_text_style = 9;
  FlutterTextStyleType date_time_picker_text_style = 10;
}

// package:flutter/src/cupertino/theme.dart
//
// Creates a [CupertinoTheme] to change descendant Cupertino widgets' styling.
message CupertinoTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [CupertinoThemeData] styling for this theme.
  CupertinoThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/cupertino/theme.dart
//
// Creates a [CupertinoTheme] styling specification.
//
// Unspecified parameters default to a reasonable iOS default style.
message CupertinoThemeData {
  DartBrightnessType.Enum brightness = 2;
  DartColorType primary_color = 3;
  DartColorType primary_contrasting_color = 4;
  CupertinoTextThemeDataType text_theme = 5;
  DartColorType bar_background_color = 6;
  DartColorType scaffold_background_color = 7;
  bool apply_theme_to_all = 8;
}

// package:flutter/src/cupertino/theme.dart
//
// Same as the default constructor but with positional arguments to avoid
// forgetting any and to specify all arguments.
//
// Used by subclasses to get the superclass's defaulting behaviors.
message CupertinoThemeDataNamedRaw {
  DartBrightnessType.Enum brightness = 2;
  DartColorType primary_color = 3;
  DartColorType primary_contrasting_color = 4;
  CupertinoTextThemeDataType text_theme = 5;
  DartColorType bar_background_color = 6;
  DartColorType scaffold_background_color = 7;
  bool apply_theme_to_all = 8;
}

// package:flutter/src/cupertino/interface_level.dart
//
// Creates a [CupertinoUserInterfaceLevel] to change descendant Cupertino widget's
// visual level.
message CupertinoUserInterfaceLevel {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  CupertinoUserInterfaceLevelDataType.Enum data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// dart:typed_data
//
// Creates a [ByteData] of the specified length (in elements), all of
// whose bytes are initially zero.
message DartByteData {
  int32 length = 2;
}

// dart:typed_data
//
// Creates a [ByteData] view on a range of elements of [data].
//
// Creates a view on the range of `data.buffer` which corresponds
// to the elements of [data] from [start] until [end].
// If [data] is a typed data list, like [Uint16List], then the view is on
// the bytes of the elements with indices from [start] until [end].
// If [data] is a [ByteData], it's treated like a list of bytes.
//
// If provided, [start] and [end] must satisfy
//
// 0 &le; `start` &le; `end` &le; *elementCount*
//
// where *elementCount* is the number of elements in [data], which
// is the same as the [List.length] of a typed data list.
//
// If omitted, [start] defaults to zero and [end] to *elementCount*.
message DartByteDataNamedSublistView {
  DartTypedDataType data = 2;
  int32 start = 3;
  int32 end = 4;
}

// dart:typed_data
//
// Creates an [ByteData] _view_ of the specified region in [buffer].
//
// Changes in the [ByteData] will be visible in the byte
// buffer and vice versa.
// If the [offsetInBytes] index of the region is not specified,
// it defaults to zero (the first byte in the byte buffer).
// If the length is not provided,
// the view extends to the end of the byte buffer.
//
// The [offsetInBytes] and [length] must be non-negative, and
// [offsetInBytes] + [length] must be less than or
// equal to the length of [buffer].
//
// Note that when creating a view from a [TypedData] list or byte data,
// that list or byte data may itself be a view on a larger buffer
// with a [TypedData.offsetInBytes] greater than zero.
// Merely doing `ByteData.view(other.buffer, 0, count)` may not
// point to the bytes you intended. Instead you may need to do:
// ```dart
// ByteData.view(other.buffer, other.offsetInBytes, count)
// ```
// Alternatively, use [ByteData.sublistView]
// which includes this computation:
// ```dart
// ByteData.sublistView(other, 0, count);
// ```
// (The third argument is an end index rather than a length, so if
// you start from a position greater than zero, you need not
// reduce the count correspondingly).
message DartByteDataNamedView {
  int32 offset_in_bytes = 3;
  int32 length = 4;
}

// dart:ui
//
// Construct a color from the lower 32 bits of an [int].
//
// The bits are interpreted as follows:
//
// * Bits 24-31 are the alpha value.
// * Bits 16-23 are the red value.
// * Bits 8-15 are the green value.
// * Bits 0-7 are the blue value.
//
// In other words, if AA is the alpha value in hex, RR the red value in hex,
// GG the green value in hex, and BB the blue value in hex, a color can be
// expressed as `const Color(0xAARRGGBB)`.
//
// For example, to get a fully opaque orange, you would use `const
// Color(0xFFFF9000)` (`FF` for the alpha, `FF` for the red, `90` for the
// green, and `00` for the blue).
message DartColor {
  int32 value = 2;
}

// dart:ui
//
// Construct a color filter that applies the sRGB gamma curve to the RGB
// channels.
message DartColorFilterNamedLinearToSrgbGamma {
  
}

// dart:ui
//
// Construct a color filter from a 4x5 row-major matrix. The matrix is
// interpreted as a 5x5 matrix, where the fifth row is the identity
// configuration.
//
// Every pixel's color value, represented as an `[R, G, B, A]`, is matrix
// multiplied to create a new color:
//
//     | R' |   | a00 a01 a02 a03 a04 |   | R |
//     | G' |   | a10 a11 a12 a13 a14 |   | G |
//     | B' | = | a20 a21 a22 a23 a24 | * | B |
//     | A' |   | a30 a31 a32 a33 a34 |   | A |
//     | 1  |   |  0   0   0   0   1  |   | 1 |
//
// The matrix is in row-major order and the translation column is specified
// in unnormalized, 0...255, space. For example, the identity matrix is:
//
// ```dart
// const ColorFilter identity = ColorFilter.matrix(<double>[
//   1, 0, 0, 0, 0,
//   0, 1, 0, 0, 0,
//   0, 0, 1, 0, 0,
//   0, 0, 0, 1, 0,
// ]);
// ```
//
// ## Examples
//
// An inversion color matrix:
//
// ```dart
// const ColorFilter invert = ColorFilter.matrix(<double>[
//   -1,  0,  0, 0, 255,
//    0, -1,  0, 0, 255,
//    0,  0, -1, 0, 255,
//    0,  0,  0, 1,   0,
// ]);
// ```
//
// A sepia-toned color matrix (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#sepiaEquivalent)):
//
// ```dart
// const ColorFilter sepia = ColorFilter.matrix(<double>[
//   0.393, 0.769, 0.189, 0, 0,
//   0.349, 0.686, 0.168, 0, 0,
//   0.272, 0.534, 0.131, 0, 0,
//   0,     0,     0,     1, 0,
// ]);
// ```
//
// A greyscale color filter (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#grayscaleEquivalent)):
//
// ```dart
// const ColorFilter greyscale = ColorFilter.matrix(<double>[
//   0.2126, 0.7152, 0.0722, 0, 0,
//   0.2126, 0.7152, 0.0722, 0, 0,
//   0.2126, 0.7152, 0.0722, 0, 0,
//   0,      0,      0,      1, 0,
// ]);
// ```
message DartColorFilterNamedMatrix {
  repeated double matrix = 2;
}

// dart:ui
//
// Creates a color filter that applies the blend mode given as the second
// argument. The source color is the one given as the first argument, and the
// destination color is the one from the layer being composited.
//
// The output of this filter is then composited into the background according
// to the [Paint.blendMode], using the output of this filter as the source
// and the background as the destination.
message DartColorFilterNamedMode {
  DartColorType color = 2;
  DartBlendModeType.Enum blend_mode = 3;
}

// dart:ui
//
// Creates a color filter that applies the inverse of the sRGB gamma curve
// to the RGB channels.
message DartColorFilterNamedSrgbToLinearGamma {
  
}

// dart:ui
//
// Construct a color from the lower 8 bits of four integers.
//
// * `a` is the alpha value, with 0 being transparent and 255 being fully
//   opaque.
// * `r` is [red], from 0 to 255.
// * `g` is [green], from 0 to 255.
// * `b` is [blue], from 0 to 255.
//
// Out of range values are brought into range using modulo 255.
//
// See also [fromRGBO], which takes the alpha value as a floating point
// value.
message DartColorNamedFromARGB {
  int32 a = 2;
  int32 r = 3;
  int32 g = 4;
  int32 b = 5;
}

// dart:ui
//
// Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
//
// * `r` is [red], from 0 to 255.
// * `g` is [green], from 0 to 255.
// * `b` is [blue], from 0 to 255.
// * `opacity` is alpha channel of this color as a double, with 0.0 being
//   transparent and 1.0 being fully opaque.
//
// Out of range values are brought into range using modulo 255.
//
// See also [fromARGB], which takes the opacity as an integer value.
message DartColorNamedFromRGBO {
  int32 r = 2;
  int32 g = 3;
  int32 b = 4;
  double opacity = 5;
}

// dart:core
//
// Constructs a [DateTime] instance specified in the local time zone.
//
// For example,
// to create a `DateTime` object representing the 7th of September 2017,
// 5:30pm
//
// ```dart
// final dentistAppointment = DateTime(2017, 9, 7, 17, 30);
// ```
message DartDateTime {
  int32 year = 2;
  int32 month = 3;
  int32 day = 4;
  int32 hour = 5;
  int32 minute = 6;
  int32 second = 7;
  int32 millisecond = 8;
  int32 microsecond = 9;
}

// dart:core
//
// Constructs a new [DateTime] instance
// with the given [microsecondsSinceEpoch].
//
// If [isUtc] is false, then the date is in the local time zone.
//
// The constructed [DateTime] represents
// 1970-01-01T00:00:00Z + [microsecondsSinceEpoch] us in the given
// time zone (local or UTC).
// ```dart
// final newYearsEve =
//     DateTime.fromMicrosecondsSinceEpoch(1640979000000000, isUtc:true);
// print(newYearsEve); // 2021-12-31 19:30:00.000Z
// ```
message DartDateTimeNamedFromMicrosecondsSinceEpoch {
  int32 microseconds_since_epoch = 2;
  bool is_utc = 3;
}

// dart:core
//
// Constructs a new [DateTime] instance
// with the given [millisecondsSinceEpoch].
//
// If [isUtc] is false then the date is in the local time zone.
//
// The constructed [DateTime] represents
// 1970-01-01T00:00:00Z + [millisecondsSinceEpoch] ms in the given
// time zone (local or UTC).
// ```dart
// final newYearsDay =
//     DateTime.fromMillisecondsSinceEpoch(1641031200000, isUtc:true);
// print(newYearsDay); // 2022-01-01 10:00:00.000Z
// ```
message DartDateTimeNamedFromMillisecondsSinceEpoch {
  int32 milliseconds_since_epoch = 2;
  bool is_utc = 3;
}

// dart:core
//
// Constructs a [DateTime] instance with current date and time in the
// local time zone.
//
// ```dart
// final now = DateTime.now();
// ```
message DartDateTimeNamedNow {
  
}

// dart:core
//
// Constructs a [DateTime] with the current UTC date and time.
//
//
// ```dart
// final mark = DateTime.timestamp();
// ```
message DartDateTimeNamedTimestamp {
  
}

// dart:core
//
// Constructs a [DateTime] instance specified in the UTC time zone.
//
// ```dart
// final moonLanding = DateTime.utc(1969, 7, 20, 20, 18, 04);
// ```
//
// When dealing with dates or historic events, preferably use UTC DateTimes,
// since they are unaffected by daylight-saving changes and are unaffected
// by the local timezone.
message DartDateTimeNamedUtc {
  int32 year = 2;
  int32 month = 3;
  int32 day = 4;
  int32 hour = 5;
  int32 minute = 6;
  int32 second = 7;
  int32 millisecond = 8;
  int32 microsecond = 9;
}

// dart:ui
message DartDisplayFeature {
  // The area of the flutter view occupied by this display feature, measured in logical pixels.
  //
  // On devices with two screens, the Flutter view spans from the top-left corner
  // of the left or top screen to the bottom-right corner of the right or bottom screen,
  // including the visual area occupied by any display feature. Bounds of display
  // features are reported in this coordinate system.
  //
  // For example, on a dual screen device in portrait mode:
  //
  // * [Rect.left] gives you the size of left screen, in logical pixels.
  // * [Rect.right] gives you the size of the left screen + the hinge width.
  DartRectType bounds = 2;
  // Type of display feature, e.g. hinge, fold, cutout.
  DartDisplayFeatureTypeType.Enum type = 3;
  // Posture of display feature, which is populated only for folds and hinges.
  //
  // For cutouts, this is [DisplayFeatureState.unknown]
  DartDisplayFeatureStateType.Enum state = 4;
}

// dart:core
//
// Creates a new [Duration] object whose value
// is the sum of all individual parts.
//
// Individual parts can be larger than the number of those
// parts in the next larger unit.
// For example, [hours] can be greater than 23.
// If this happens, the value overflows into the next larger
// unit, so 26 [hours] is the same as 2 [hours] and
// one more [days].
// Likewise, values can be negative, in which case they
// underflow and subtract from the next larger unit.
//
// If the total number of microseconds cannot be represented
// as an integer value, the number of microseconds might overflow
// and be truncated to a smaller number of bits,
// or it might lose precision.
//
// All arguments are 0 by default.
// ```dart
// const duration = Duration(days: 1, hours: 8, minutes: 56, seconds: 59,
//   milliseconds: 30, microseconds: 10);
// print(duration); // 32:56:59.030010
// ```
message DartDuration {
  int32 days = 2;
  int32 hours = 3;
  int32 minutes = 4;
  int32 seconds = 5;
  int32 milliseconds = 6;
  int32 microseconds = 7;
}

// dart:io
//
// Creates a [File] object.
//
// If [path] is a relative path, it will be interpreted relative to the
// current working directory (see [Directory.current]), when used.
//
// If [path] is an absolute path, it will be immune to changes to the
// current working directory.
message DartFile {
  string path = 2;
}

// dart:io
//
// Creates a [File] object from a raw path.
//
// A raw path is a sequence of bytes, as paths are represented by the OS.
message DartFileNamedFromRawPath {
  DartUint8ListType raw_path = 2;
}

// dart:io
//
// Create a [File] object from a URI.
//
// If [uri] cannot reference a file this throws [UnsupportedError].
message DartFileNamedFromUri {
  DartUriType uri = 2;
}

// dart:typed_data
//
// Creates a [Float32List] of the specified length (in elements), all of
// whose elements are initially zero.
//
// The list is backed by a [ByteBuffer] containing precisely
// [length] times 4 bytes.
message DartFloat32List {
  int32 length = 2;
}

// dart:typed_data
//
// Creates a [Float32List] with the same length as the [elements] list
// and copies over the elements.
//
// Values are truncated to fit in the list when they are copied,
// the same way storing values truncates them.
//
// The list is backed by a [ByteBuffer] containing precisely
// `elements.length` times 4 bytes.
message DartFloat32ListNamedFromList {
  repeated double elements = 2;
}

// dart:typed_data
//
// Creates an [Float32List] view on a range of elements of [data].
//
// Creates a view on the range of `data.buffer` which corresponds
// to the elements of [data] from [start] until [end].
// If [data] is a typed data list, like [Uint16List], then the view is on
// the bytes of the elements with indices from [start] until [end].
// If [data] is a [ByteData], it's treated like a list of bytes.
//
// If provided, [start] and [end] must satisfy
//
// 0 &le; `start` &le; `end` &le; *elementCount*
//
// where *elementCount* is the number of elements in [data], which
// is the same as the [List.length] of a typed data list.
//
// If omitted, [start] defaults to zero and [end] to *elementCount*.
//
// The start and end indices of the range of bytes being viewed must be
// multiples of four.
message DartFloat32ListNamedSublistView {
  DartTypedDataType data = 2;
  int32 start = 3;
  int32 end = 4;
}

// dart:typed_data
//
// Creates a [Float32List] _view_ of the specified region in [buffer].
//
// Changes in the [Float32List] will be visible in the byte
// buffer and vice versa.
// If the [offsetInBytes] index of the region is not specified,
// it defaults to zero (the first byte in the byte buffer).
// If the length is not provided,
// the view extends to the end of the byte buffer.
//
// The [offsetInBytes] and [length] must be non-negative, and
// [offsetInBytes] + ([length] * [bytesPerElement]) must be less than or
// equal to the length of [buffer].
//
// The [offsetInBytes] must be a multiple of [bytesPerElement].
//
// Note that when creating a view from a [TypedData] list or byte data,
// that list or byte data may itself be a view on a larger buffer
// with a [TypedData.offsetInBytes] greater than zero.
// Merely doing `Float32List.view(other.buffer, 0, count)` may not
// point to the bytes you intended. Instead you may need to do:
// ```dart
// Float32List.view(other.buffer, other.offsetInBytes, count)
// ```
// Alternatively, use [Float32List.sublistView]
// which includes this computation:
// ```dart
// Float32List.sublistView(other, 0, count);
// ```
// (The third argument is an end index rather than a length, so if
// you start from a position greater than zero, you need not
// reduce the count correspondingly).
message DartFloat32ListNamedView {
  int32 offset_in_bytes = 3;
  int32 length = 4;
}

// dart:typed_data
//
// Creates a [Float64List] of the specified length (in elements), all of
// whose elements are initially zero.
//
// The list is backed by a [ByteBuffer] containing precisely
// [length] times 8 bytes.
message DartFloat64List {
  int32 length = 2;
}

// dart:typed_data
//
// Creates a [Float64List] with the same length as the [elements] list
// and copies over the elements.
//
// The list is backed by a [ByteBuffer] containing precisely
// `elements.length` times 8 bytes.
message DartFloat64ListNamedFromList {
  repeated double elements = 2;
}

// dart:typed_data
//
// Creates a [Float64List] view on a range of elements of [data].
//
// Creates a view on the range of `data.buffer` which corresponds
// to the elements of [data] from [start] until [end].
// If [data] is a typed data list, like [Uint16List], then the view is on
// the bytes of the elements with indices from [start] until [end].
// If [data] is a [ByteData], it's treated like a list of bytes.
//
// If provided, [start] and [end] must satisfy
//
// 0 &le; `start` &le; `end` &le; *elementCount*
//
// where *elementCount* is the number of elements in [data], which
// is the same as the [List.length] of a typed data list.
//
// If omitted, [start] defaults to zero and [end] to *elementCount*.
//
// The start and end indices of the range of bytes being viewed must be
// multiples of eight.
message DartFloat64ListNamedSublistView {
  DartTypedDataType data = 2;
  int32 start = 3;
  int32 end = 4;
}

// dart:typed_data
//
// Creates a [Float64List] _view_ of the specified region in [buffer].
//
// Changes in the [Float64List] will be visible in the byte
// buffer and vice versa.
// If the [offsetInBytes] index of the region is not specified,
// it defaults to zero (the first byte in the byte buffer).
// If the length is not provided,
// the view extends to the end of the byte buffer.
//
// The [offsetInBytes] and [length] must be non-negative, and
// [offsetInBytes] + ([length] * [bytesPerElement]) must be less than or
// equal to the length of [buffer].
//
// The [offsetInBytes] must be a multiple of [bytesPerElement].
//
// Note that when creating a view from a [TypedData] list or byte data,
// that list or byte data may itself be a view on a larger buffer
// with a [TypedData.offsetInBytes] greater than zero.
// Merely doing `Float64List.view(other.buffer, 0, count)` may not
// point to the bytes you intended. Instead you may need to do:
// ```dart
// Float64List.view(other.buffer, other.offsetInBytes, count)
// ```
// Alternatively, use [Float64List.sublistView]
// which includes this computation:
// ```dart
// Float64List.sublistView(other, 0, count);
// ```
// (The third argument is an end index rather than a length, so if
// you start from a position greater than zero, you need not
// reduce the count correspondingly).
message DartFloat64ListNamedView {
  int32 offset_in_bytes = 3;
  int32 length = 4;
}

// dart:ui
//
// Creates a [FontFeature] object, which can be added to a [TextStyle] to
// change how the engine selects glyphs when rendering text.
//
// `feature` is the four-character tag that identifies the feature.
// These tags are specified by font formats such as OpenType.
//
// `value` is the value that the feature will be set to. The behavior
// of the value depends on the specific feature. Many features are
// flags whose value can be 1 (when enabled) or 0 (when disabled).
//
// See <https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags>
message DartFontFeature {
  // The tag that identifies the effect of this feature.  Must consist of 4
  // ASCII characters (typically lowercase letters).
  //
  // These features are defined in a registry maintained by Microsoft:
  // <https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags>
  string feature = 2;
  // The value assigned to this feature.
  //
  // Must be a positive integer. Many features are Boolean values that accept
  // values of either 0 (feature is disabled) or 1 (feature is enabled). Other
  // features have a bound range of values (which may be documented in these
  // API docs for features that have dedicated constructors, and are generally
  // documented in the official registry). In some cases the precise supported
  // range depends on the font.
  //
  // See also:
  //
  //  * <https://docs.microsoft.com/en-us/typography/opentype/spec/featurelist>
  int32 value = 3;
}

// dart:ui
//
// Access alternative glyphs. (`aalt`)
//
// This feature selects the given glyph variant for glyphs in the span.
//
// {@tool sample}
// The Raleway font supports several alternate glyphs. The code
// below shows how specific glyphs can be selected. With `aalt` set
// to zero, the default, the normal glyphs are used. With a
// non-zero value, Raleway substitutes small caps for lower case
// letters. With value 2, the lowercase "a" changes to a stemless
// "a", whereas the lowercase "t" changes to a vertical bar instead
// of having a curve. By targeting specific letters in the text
// (using [widgets.Text.rich]), the desired rendering for each glyph can be
// achieved.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_aalt.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_alternative.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ae#aalt>
message DartFontFeatureNamedAlternative {
  // The value assigned to this feature.
  //
  // Must be a positive integer. Many features are Boolean values that accept
  // values of either 0 (feature is disabled) or 1 (feature is enabled). Other
  // features have a bound range of values (which may be documented in these
  // API docs for features that have dedicated constructors, and are generally
  // documented in the official registry). In some cases the precise supported
  // range depends on the font.
  //
  // See also:
  //
  //  * <https://docs.microsoft.com/en-us/typography/opentype/spec/featurelist>
  int32 value = 2;
}

// dart:ui
//
// Use alternative ligatures to represent fractions. (`afrc`)
//
// When this feature is enabled (and the font supports it),
// sequences of digits separated by U+002F SOLIDUS character (/) or
// U+2044 FRACTION SLASH () are replaced by ligatures that
// represent the corresponding fraction. These ligatures may differ
// from those used by the [FontFeature.fractions] feature.
//
// This feature overrides all other features.
//
// {@tool sample}
// The Ubuntu Mono font supports the `afrc` feature. It causes digits
// before slashes to become superscripted and digits after slashes to become
// subscripted. This contrasts to the effect seen with [FontFeature.fractions].
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_afrc.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_alternative_fractions.0.dart **
// {@end-tool}
//
// See also:
//
//  * [FontFeature.fractions], which has a similar (but different) effect.
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ae#afrc>
message DartFontFeatureNamedAlternativeFractions {
  
}

// dart:ui
//
// Enable case-sensitive forms. (`case`)
//
// Some glyphs, for example parentheses or operators, are typically
// designed to fit nicely with mixed case, or even predominantly
// lowercase, text. When these glyphs are placed near strings of
// capital letters, they appear a little off-center.
//
// This feature, when supported by the font, causes these glyphs to
// be shifted slightly, or otherwise adjusted, so as to form a more
// aesthetically pleasing combination with capital letters.
//
// {@tool sample}
// The Piazzolla font supports the `case` feature. It causes
// parentheses, brackets, braces, guillemets, slashes, bullets, and
// some other glyphs (not shown below) to be shifted up slightly so
// that capital letters appear centered in comparison. When the
// feature is disabled, those glyphs are optimized for use with
// lowercase letters, and so capital letters appear to ride higher
// relative to the punctuation marks.
//
// The difference is very subtle. It may be most obvious when
// examining the square brackets compared to the capital A.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_case.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_case_sensitive_forms.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ae#case>
message DartFontFeatureNamedCaseSensitiveForms {
  
}

// dart:ui
//
// Select a character variant. (`cv01` through `cv99`)
//
// Fonts may have up to 99 character variant sets, numbered 1
// through 99, each of which can be independently enabled or
// disabled.
//
// Related character variants are typically grouped into stylistic
// sets, controlled by the [FontFeature.stylisticSet] feature
// (`ssXX`).
//
// {@tool sample}
// The Source Code Pro font supports the `cvXX` feature for several
// characters. In the example below, variants 1 (`cv01`), 2
// (`cv02`), and 4 (`cv04`) are selected. Variant 1 changes the
// rendering of the "a" character, variant 2 changes the lowercase
// "g" character, and variant 4 changes the lowercase "i" and "l"
// characters. There are also variants (not shown here) that
// control the rendering of various greek characters such as beta
// and theta.
//
// Notably, this can be contrasted with the stylistic sets, where
// the set which affects the "a" character also affects beta, and
// the set which affects the "g" character also affects theta and
// delta.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_cvXX.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_character_variant.0.dart **
// {@end-tool}
//
// See also:
//
//  * [FontFeature.stylisticSet], which allows for groups of characters
//    variants to be selected at once, as opposed to individual character variants.
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ae#cv01-cv99>
message DartFontFeatureNamedCharacterVariant {
  int32 value = 2;
}

// dart:ui
//
// Enable contextual alternates. (`calt`)
//
// With this feature enabled, specific glyphs may be replaced by
// alternatives based on nearby text.
//
// {@tool sample}
// The Barriecito font supports the `calt` feature. It causes some
// letters in close proximity to other instances of themselves to
// use different glyphs, to give the appearance of more variation
// in the glyphs, rather than having each letter always use a
// particular glyph.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_calt.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_contextual_alternates.0.dart **
// {@end-tool}
//
// See also:
//
//  * [FontFeature.randomize], which is more a rarely supported but more
//    powerful way to get a similar effect.
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ae#calt>
message DartFontFeatureNamedContextualAlternates {
  
}

// dart:ui
//
// Display digits as denominators. (`dnom`)
//
// This is typically used automatically by the font rendering
// system as part of the implementation of `frac` for the denominator
// part of fractions (see [FontFeature.fractions]).
//
// {@tool sample}
// The Piazzolla font supports the `dnom` feature. It causes
// the digits to be rendered smaller and near the bottom of the EM box.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_dnom.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_denominator.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ae#dnom>
message DartFontFeatureNamedDenominator {
  
}

// dart:ui
//
// Create a [FontFeature] object that disables the feature with the given tag.
message DartFontFeatureNamedDisable {
  string feature = 2;
}

// dart:ui
//
// Create a [FontFeature] object that enables the feature with the given tag.
message DartFontFeatureNamedEnable {
  string feature = 2;
}

// dart:ui
//
// Use ligatures to represent fractions. (`afrc`)
//
// When this feature is enabled (and the font supports it),
// sequences of digits separated by U+002F SOLIDUS character (/) or
// U+2044 FRACTION SLASH () are replaced by ligatures that
// represent the corresponding fraction.
//
// This feature may imply the [FontFeature.numerators] and
// [FontFeature.denominator] features.
//
// {@tool sample}
// The Ubuntu Mono font supports the `frac` feature. It causes
// digits around slashes to be turned into dedicated fraction
// glyphs. This contrasts to the effect seen with
// [FontFeature.alternativeFractions].
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_frac.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_fractions.0.dart **
// {@end-tool}
//
// See also:
//
//  * [FontFeature.alternativeFractions], which has a similar (but different) effect.
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_fj#frac>
message DartFontFeatureNamedFractions {
  
}

// dart:ui
//
// Use historical forms. (`hist`)
//
// Some fonts have alternatives for letters whose forms have changed
// through the ages. In the Latin alphabet, this is common for
// example with the long-form "s" or the Fraktur "k". This feature enables
// those alternative glyphs.
//
// This does not enable legacy ligatures, only single-character alternatives.
// To enable historical ligatures, use [FontFeature.historicalLigatures].
//
// This feature may override other glyph-substitution features.
//
// {@tool sample}
// The Cardo font supports the `hist` feature specifically for the
// letter "s": it changes occurrences of that letter for the glyph
// used by U+017F LATIN SMALL LETTER LONG S.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_historical.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_historical_forms.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_fj#hist>
message DartFontFeatureNamedHistoricalForms {
  
}

// dart:ui
//
// Use historical ligatures. (`hlig`)
//
// Some fonts support ligatures that have fallen out of favor today,
// but were historically in common use. This feature enables those
// ligatures.
//
// For example, the "long s" glyph was historically typeset with
// characters such as "t" and "h" as a single ligature.
//
// This does not enable the legacy forms, only ligatures. See
// [FontFeature.historicalForms] to enable single characters to be
// replaced with their historical alternatives. Combining both is
// usually desired since the ligatures typically apply specifically
// to characters that have historical forms as well. For example,
// the historical forms feature might replace the "s" character
// with the "long s" () character, while the historical ligatures
// feature might specifically apply to cases where "long s" is
// followed by other characters such as "t". In such cases, without
// the historical forms being enabled, the ligatures would only
// apply when the "long s" is used explicitly.
//
// This feature may override other glyph-substitution features.
//
// {@tool sample}
// The Cardo font supports the `hlig` feature. It has legacy
// ligatures for "VI" and "NT", and various ligatures involving the
// "long s". In the example below, both historical forms (`hist 1`)
// and historical ligatures (`hlig 1`) are enabled, so, for
// instance, "fish" becomes "fih" which is then rendered using a
// ligature for the last two characters.
//
// Similarly, the word "business" is turned into "buine" by
// `hist`, and the `i` and `` pairs are ligated by `hlig`.
// Observe in particular the position of the dot of the "i" in
// "business" in the various combinations of these features.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_historical.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_historical_ligatures.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_fj#hlig>
message DartFontFeatureNamedHistoricalLigatures {
  
}

// dart:ui
//
// Use lining figures. (`lnum`)
//
// Some fonts have digits that, like lowercase latin letters, have
// both descenders and ascenders. In some situations, especially in
// conjunction with capital letters, this leads to an aesthetically
// questionable irregularity. Lining figures, on the other hand,
// have a uniform height, and align with the baseline and the
// height of capital letters. Conceptually, they can be thought of
// as "capital digits".
//
// This feature may conflict with [FontFeature.oldstyleFigures].
//
// {@tool sample}
// The Sorts Mill Goudy font supports the `lnum` feature. It causes
// digits to fit more seamlessly with capital letters.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_lnum.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_lining_figures.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ko#lnum>
message DartFontFeatureNamedLiningFigures {
  
}

// dart:ui
//
// Use locale-specific glyphs. (`locl`)
//
// Some characters, most notably those in the Unicode Han
// Unification blocks, vary in presentation based on the locale in
// use. For example, the ideograph for "grass" (U+8349, ) has a
// broken top line in Traditional Chinese, but a solid top line in
// Simplified Chinese, Japanese, Korean, and Vietnamese. This kind
// of variation also exists with other alphabets, for example
// Cyrillic characters as used in the Bulgarian and Serbian
// alphabets vary from their Russian counterparts.
//
// A particular font may default to the forms for the locale for
// which it was constructed, but still support alternative forms
// for other locales. When this feature is enabled, the locale (as
// specified using [painting.TextStyle.locale], for instance) is
// used to determine which glyphs to use when locale-specific
// alternatives exist. Disabling this feature causes the font
// rendering to ignore locale information and only use the default
// glyphs.
//
// This feature is enabled by default. Using
// `FontFeature.localeAware(enable: false)` disables the
// locale-awareness. (So does not specifying the locale in the
// first place, of course.)
//
// {@tool sample}
// The Noto Sans CJK font supports the `locl` feature for CJK characters.
// In this example, the `localeAware` feature is not explicitly used, as it is
// enabled by default. This example instead shows how to set the locale,
// thus demonstrating how Noto Sans adapts the glyph shapes to the locale.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_locl.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_locale_aware.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ko#locl>
//  * <https://en.wikipedia.org/wiki/Han_unification>
//  * <https://en.wikipedia.org/wiki/Cyrillic_script>
message DartFontFeatureNamedLocaleAware {
  bool enable = 2;
}

// dart:ui
//
// Display alternative glyphs for numerals (alternate annotation forms). (`nalt`)
//
// Replaces glyphs used in numbering lists (e.g. 1, 2, 3...; or a, b, c...) with notational
// variants that might be more typographically interesting.
//
// Fonts sometimes support multiple alternatives, and the argument
// selects the set to use (a positive integer, or 0 to disable the
// feature). The default set if none is specified is 1.
//
// {@tool sample}
// The Gothic A1 font supports several notational variant sets via
// the `nalt` feature.
//
// Set 1 changes the spacing of the glyphs. Set 2 parenthesizes the
// latin letters and reduces the numerals to subscripts. Set 3
// circles the glyphs. Set 4 parenthesizes the digits. Set 5 uses
// reverse-video circles for the digits. Set 7 superscripts the
// digits.
//
// The code below shows how to select set 3.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_nalt.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_notational_forms.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ko#nalt>
message DartFontFeatureNamedNotationalForms {
  // The value assigned to this feature.
  //
  // Must be a positive integer. Many features are Boolean values that accept
  // values of either 0 (feature is disabled) or 1 (feature is enabled). Other
  // features have a bound range of values (which may be documented in these
  // API docs for features that have dedicated constructors, and are generally
  // documented in the official registry). In some cases the precise supported
  // range depends on the font.
  //
  // See also:
  //
  //  * <https://docs.microsoft.com/en-us/typography/opentype/spec/featurelist>
  int32 value = 2;
}

// dart:ui
//
// Display digits as numerators. (`numr`)
//
// This is typically used automatically by the font rendering
// system as part of the implementation of `frac` for the numerator
// part of fractions (see [FontFeature.fractions]).
//
// {@tool sample}
// The Piazzolla font supports the `numr` feature. It causes
// the digits to be rendered smaller and near the top of the EM box.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_numr.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_numerators.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ko#numr>
message DartFontFeatureNamedNumerators {
  
}

// dart:ui
//
// Use old style figures. (`onum`)
//
// Some fonts have variants of the figures (e.g. the digit 9) that,
// when this feature is enabled, render with descenders under the
// baseline instead of being entirely above the baseline. If the
// default digits are lining figures, this allows the selection of
// digits that fit better with mixed case (uppercase and lowercase)
// text.
//
// This overrides [FontFeature.slashedZero] and may conflict with
// [FontFeature.liningFigures].
//
// {@tool sample}
// The Piazzolla font supports the `onum` feature. It causes
// digits to extend below the baseline.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_onum.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_oldstyle_figures.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ko#onum>
//  * <https://en.wikipedia.org/wiki/Text_figures>
message DartFontFeatureNamedOldstyleFigures {
  
}

// dart:ui
//
// Use ordinal forms for alphabetic glyphs. (`ordn`)
//
// Some fonts have variants of the alphabetic glyphs intended for
// use after numbers when expressing ordinals, as in "1st", "2nd",
// "3rd". This feature enables those alternative glyphs.
//
// This may override other features that substitute glyphs.
//
// {@tool sample}
// The Piazzolla font supports the `ordn` feature. It causes
// alphabetic glyphs to become smaller and superscripted.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_ordn.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_ordinal_forms.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_ko#ordn>
message DartFontFeatureNamedOrdinalForms {
  
}

// dart:ui
//
// Use proportional (varying width) figures. (`pnum`)
//
// For fonts that have both proportional and tabular (monospace) figures,
// this enables the proportional figures.
//
// This is mutually exclusive with [FontFeature.tabularFigures].
//
// The default behavior varies from font to font.
//
// {@tool sample}
// The Kufam font supports the `pnum` feature. It causes the digits
// to become proportionally-sized, rather than all being the same
// width. In this font this is especially noticeable with the digit
// "1": normally, the 1 has very noticeable serifs in this
// sans-serif font, but with the proportionally figures enabled,
// the digit becomes much narrower.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_pnum.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_proportional_figures.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#pnum>
message DartFontFeatureNamedProportionalFigures {
  
}

// dart:ui
//
// Randomize the alternate forms used in text. (`rand`)
//
// For example, this can be used with suitably-prepared handwriting fonts to
// vary the forms used for each character, so that, for instance, the word
// "cross-section" would be rendered with two different "c"s, two different "o"s,
// and three different "s"s.
//
// Contextual alternates ([FontFeature.contextualAlternates])
// provide a similar effect in some fonts, without using
// randomness.
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#rand>
message DartFontFeatureNamedRandomize {
  
}

// dart:ui
//
// Use scientific inferiors. (`sinf`)
//
// Some fonts have variants of the figures (e.g. the digit 2) that,
// when this feature is enabled, render in a manner more
// appropriate for subscripted digits ("inferiors") used in
// scientific contexts, e.g. the subscripts in chemical formulae.
//
// This may override other features that substitute glyphs.
//
// {@tool sample}
// The Piazzolla font supports the `sinf` feature. It causes
// digits to be smaller and subscripted.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_sinf.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_scientific_inferiors.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#sinf>
message DartFontFeatureNamedScientificInferiors {
  
}

// dart:ui
//
// Use the slashed zero. (`zero`)
//
// Some fonts contain both a circular zero and a zero with a slash. This
// enables the use of the latter form.
//
// This is overridden by [FontFeature.oldstyleFigures].
//
// {@tool sample}
// The Source Code Pro font supports the `zero` feature. It causes the
// zero digit to be drawn with a slash rather than the default rendering,
// which in this case has a dot through the zero rather than a slash.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_zero.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_slashed_zero.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_uz#zero>
message DartFontFeatureNamedSlashedZero {
  
}

// dart:ui
//
// Enable stylistic alternates. (`salt`)
//
// Some fonts have alternative forms that are not tied to a
// particular purpose (such as being historical forms, or
// contextually relevant alternatives, or ligatures, etc). This
// font feature enables these purely stylistic alternatives.
//
// This may override other features that substitute glyphs.
//
// {@tool sample}
// The Source Code Pro font supports the `salt` feature. It causes
// some glyphs to be rendered differently, for example the "a" and
// "g" glyphs change from their typographically common
// double-storey forms to simpler single-storey forms, the dollar
// sign's line changes from discontinuous to continuous (and is
// angled), and the "0" rendering changes from a center dot to a
// slash.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_salt.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_stylistic_alternates.0.dart **
// {@end-tool}
//
// See also:
//
//  * [FontFeature.contextualAlternates], which is enables alternates specific to certain contexts.
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#salt>
message DartFontFeatureNamedStylisticAlternates {
  
}

// dart:ui
//
// Select a stylistic set. (`ss01` through `ss20`)
//
// Fonts may have up to 20 stylistic sets, numbered 1 through 20,
// each of which can be independently enabled or disabled.
//
// For more fine-grained control, in some fonts individual
// character variants can also be controlled by the
// [FontFeature.characterVariant] feature (`cvXX`).
//
// {@tool sample}
// The Source Code Pro font supports the `ssXX` feature for several
// sets. In the example below, stylistic sets 2 (`ss02`), 3
// (`ss03`), and 4 (`ss04`) are selected. Stylistic set 2 changes
// the rendering of the "a" character and the beta character,
// stylistic set 3 changes the lowercase "g", theta, and delta
// characters, and stylistic set 4 changes the lowercase "i" and
// "l" characters.
//
// This font also supports character variants (see
// [FontFeature.characterVariant]).
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_ssXX_1.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_stylistic_set.0.dart **
// {@end-tool}
//
// {@tool sample}
// The Piazzolla font supports the `ssXX` feature for more
// elaborate stylistic effects. Set 1 turns some Latin characters
// into Roman numerals, set 2 enables some ASCII characters to be
// used to create pretty arrows, and so forth.
//
// _These_ stylistic sets do _not_ correspond to character variants.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_ssXX_2.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_stylistic_set.1.dart **
// {@end-tool}
//
// See also:
//
//  * [FontFeature.characterVariant], which allows for individual character
//    variants to be selected, as opposed to entire sets.
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#ssxx>
message DartFontFeatureNamedStylisticSet {
  int32 value = 2;
}

// dart:ui
//
// Enable subscripts. (`subs`)
//
// This feature causes some fonts to change some glyphs to their subscripted form.
//
// It typically does not affect all glyphs, and so is not appropriate for generally causing
// all text to be subscripted.
//
// This may override other features that substitute glyphs.
//
// {@tool sample}
// The Piazzolla font supports the `subs` feature. It causes
// digits to be smaller and subscripted.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_subs.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_subscripts.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#subs>
//  * [FontFeature.scientificInferiors], which is similar but intended specifically for
//    subscripts used in scientific contexts.
//  * [FontFeature.superscripts], which is similar but for subscripting.
message DartFontFeatureNamedSubscripts {
  
}

// dart:ui
//
// Enable superscripts. (`sups`)
//
// This feature causes some fonts to change some glyphs to their
// superscripted form. This may be more than just changing their
// position. For example, digits might change to lining figures
// (see [FontFeature.liningFigures]) in addition to being raised
// and shrunk.
//
// It typically does not affect all glyphs, and so is not
// appropriate for generally causing all text to be superscripted.
//
// This may override other features that substitute glyphs.
//
// {@tool sample}
// The Sorts Mill Goudy font supports the `sups` feature. It causes
// digits to be smaller, superscripted, and changes them to lining
// figures (so they are all the same height).
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_sups.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_superscripts.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#sups>
//  * [FontFeature.subscripts], which is similar but for subscripting.
message DartFontFeatureNamedSuperscripts {
  
}

// dart:ui
//
// Enable swash glyphs. (`swsh`)
//
// Some fonts have beautiful flourishes on some characters. These
// come in many forms, such as exaggerated serifs, long tails, long
// entry strokes, or other forms of decorative extensions to the
// base character.
//
// This feature enables the rendering of these flourishes. Some
// fonts have many swashes per character; the argument, if
// specified, selects which swash to use (0 disables them
// altogether).
//
// Some fonts have an absurd number of alternative swashes. For
// example, Adobe's Poetica famously has 63 different ampersand
// forms available through this feature!
//
// {@tool sample}
// The BioRhyme Expanded font supports the `swsh` feature specifically
// for the capital "Q" and "R" glyphs and the ampersand.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_swsh.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_swash.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#swsh>
//  * <https://en.wikipedia.org/wiki/Swash_(typography)>
message DartFontFeatureNamedSwash {
  // The value assigned to this feature.
  //
  // Must be a positive integer. Many features are Boolean values that accept
  // values of either 0 (feature is disabled) or 1 (feature is enabled). Other
  // features have a bound range of values (which may be documented in these
  // API docs for features that have dedicated constructors, and are generally
  // documented in the official registry). In some cases the precise supported
  // range depends on the font.
  //
  // See also:
  //
  //  * <https://docs.microsoft.com/en-us/typography/opentype/spec/featurelist>
  int32 value = 2;
}

// dart:ui
//
// Use tabular (monospace) figures. (`tnum`)
//
// For fonts that have both proportional (varying width) and tabular figures,
// this enables the tabular figures. Tabular figures are monospaced (all the
// same width), so that they align in tables of figures.
//
// This is mutually exclusive with [FontFeature.proportionalFigures].
//
// The default behavior varies from font to font.
//
// {@tool sample}
// The Piazzolla font supports the `tnum` feature. It causes the
// digits to become uniformly-sized, rather than having variable
// widths. In this font this is especially noticeable with the
// digit "1"; with tabular figures enabled, the "1" digit is more
// widely spaced.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/font_feature_tnum.png)
//
// ** See code in examples/api/lib/ui/text/font_feature.font_feature_tabular_figures.0.dart **
// {@end-tool}
//
// See also:
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#tnum>
message DartFontFeatureNamedTabularFigures {
  
}

// dart:ui
//
// Creates a [FontVariation] object, which can be added to a [TextStyle] to
// change the variable attributes of a font.
//
// `axis` is the four-character tag that identifies the design axis.
// OpenType lists the [currently registered axis
// tags](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg).
//
// `value` is the value that the axis will be set to. The behavior
// depends on how the font implements the axis.
message DartFontVariation {
  // The tag that identifies the design axis.
  //
  // An axis tag must consist of 4 ASCII characters.
  string axis = 2;
  // The value assigned to this design axis.
  //
  // The range of usable values depends on the specification of the axis.
  //
  // While this property is represented as a [double] in this API
  // ([binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)),
  // fonts use the fixed-point 16.16 format to represent the value of font
  // variations. This means that the actual range is -32768.0 to approximately
  // 32767.999985 and in principle the smallest increment between two values is
  // approximately 0.000015 (1/65536).
  //
  // Unfortunately for technical reasons the value is first converted to the
  // [binary32 floating point
  // format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format),
  // which only has 24 bits of precision. This means that for values outside
  // the range -256.0 to 256.0, the smallest increment is larger than what is
  // technically supported by OpenType. At the extreme edge of the range, the
  // smallest increment is only approximately 0.002.
  double value = 3;
}

// dart:ui
//
// Variable font style. (`ital`)
//
// Varies the style of glyphs in the font between normal and italic.
//
// Values must in the range 0.0 (meaning normal, or Roman, as in
// [FontStyle.normal]) to 1.0 (meaning fully italic, as in
// [FontStyle.italic]).
//
// This is distinct from [FontVariation.slant], which leans the characters
// without changing the font style.
//
// See also:
//
//  * <https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_ital>
message DartFontVariationNamedItalic {
  // The value assigned to this design axis.
  //
  // The range of usable values depends on the specification of the axis.
  //
  // While this property is represented as a [double] in this API
  // ([binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)),
  // fonts use the fixed-point 16.16 format to represent the value of font
  // variations. This means that the actual range is -32768.0 to approximately
  // 32767.999985 and in principle the smallest increment between two values is
  // approximately 0.000015 (1/65536).
  //
  // Unfortunately for technical reasons the value is first converted to the
  // [binary32 floating point
  // format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format),
  // which only has 24 bits of precision. This means that for values outside
  // the range -256.0 to 256.0, the smallest increment is larger than what is
  // technically supported by OpenType. At the extreme edge of the range, the
  // smallest increment is only approximately 0.002.
  double value = 2;
}

// dart:ui
//
// Optical size optimization. (`opzs`)
//
// Changes the rendering of the font to be optimized for the given text size.
// Normally, the optical size of the font will be derived from the font size.
//
// This feature could be used when the text represents a particular physical
// font size, for example text in the representation of a hardcopy magazine,
// which does not correspond to the actual font size being used to render the
// text. By setting the optical size explicitly, font variations that might
// be applied as the text is zoomed will be fixed at the size being
// represented by the text.
//
// This feature could also be used to smooth animations. If a font varies its
// rendering as the font size is adjusted, it may appear to "quiver" (or, one
// might even say, "flutter") if the font size is animated. By setting a
// fixed optical size, the rendering can be fixed to one particular style as
// the text size animates.
//
// Values must be greater than zero, and are interpreted as points. A point
// is 1/72 of an inch, or 1.333 logical pixels (96/72).
//
// See also:
//
//  * <https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_opsz>
message DartFontVariationNamedOpticalSize {
  // The value assigned to this design axis.
  //
  // The range of usable values depends on the specification of the axis.
  //
  // While this property is represented as a [double] in this API
  // ([binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)),
  // fonts use the fixed-point 16.16 format to represent the value of font
  // variations. This means that the actual range is -32768.0 to approximately
  // 32767.999985 and in principle the smallest increment between two values is
  // approximately 0.000015 (1/65536).
  //
  // Unfortunately for technical reasons the value is first converted to the
  // [binary32 floating point
  // format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format),
  // which only has 24 bits of precision. This means that for values outside
  // the range -256.0 to 256.0, the smallest increment is larger than what is
  // technically supported by OpenType. At the extreme edge of the range, the
  // smallest increment is only approximately 0.002.
  double value = 2;
}

// dart:ui
//
// Variable font width. (`slnt`)
//
// Varies the slant of glyphs in the font.
//
// Values must be greater than -90.0 and less than +90.0, and represents the
// angle in _counter-clockwise_ degrees relative to "normal", at 0.0.
//
// For example, to lean the glyphs forward by 45 degrees, one would use
// `FontVariation.slant(-45.0)`.
//
// This is distinct from [FontVariation.italic], in that slant leans the
// characters without changing the font style.
//
// See also:
//
//  * <https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_slnt>
message DartFontVariationNamedSlant {
  // The value assigned to this design axis.
  //
  // The range of usable values depends on the specification of the axis.
  //
  // While this property is represented as a [double] in this API
  // ([binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)),
  // fonts use the fixed-point 16.16 format to represent the value of font
  // variations. This means that the actual range is -32768.0 to approximately
  // 32767.999985 and in principle the smallest increment between two values is
  // approximately 0.000015 (1/65536).
  //
  // Unfortunately for technical reasons the value is first converted to the
  // [binary32 floating point
  // format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format),
  // which only has 24 bits of precision. This means that for values outside
  // the range -256.0 to 256.0, the smallest increment is larger than what is
  // technically supported by OpenType. At the extreme edge of the range, the
  // smallest increment is only approximately 0.002.
  double value = 2;
}

// dart:ui
//
// Variable font weight. (`wght`)
//
// Varies the stroke thickness of the font, similar to [FontWeight] but on a
// continuous axis.
//
// Values must be in the range 1..1000, and are to be interpreted in a manner
// consistent with the values of [FontWeight]. For instance, `400` is the
// "normal" weight, and `700` is "bold".
//
// See also:
//
//  * <https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_wght>
message DartFontVariationNamedWeight {
  // The value assigned to this design axis.
  //
  // The range of usable values depends on the specification of the axis.
  //
  // While this property is represented as a [double] in this API
  // ([binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)),
  // fonts use the fixed-point 16.16 format to represent the value of font
  // variations. This means that the actual range is -32768.0 to approximately
  // 32767.999985 and in principle the smallest increment between two values is
  // approximately 0.000015 (1/65536).
  //
  // Unfortunately for technical reasons the value is first converted to the
  // [binary32 floating point
  // format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format),
  // which only has 24 bits of precision. This means that for values outside
  // the range -256.0 to 256.0, the smallest increment is larger than what is
  // technically supported by OpenType. At the extreme edge of the range, the
  // smallest increment is only approximately 0.002.
  double value = 2;
}

// dart:ui
//
// Variable font width. (`wdth`)
//
// Varies the width of glyphs in the font.
//
// Values must be greater than zero, with no upper limit. 100.0 represents
// the "normal" width. Smaller values are "condensed", greater values are
// "extended".
//
// See also:
//
//  * <https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_wdth>
message DartFontVariationNamedWidth {
  // The value assigned to this design axis.
  //
  // The range of usable values depends on the specification of the axis.
  //
  // While this property is represented as a [double] in this API
  // ([binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)),
  // fonts use the fixed-point 16.16 format to represent the value of font
  // variations. This means that the actual range is -32768.0 to approximately
  // 32767.999985 and in principle the smallest increment between two values is
  // approximately 0.000015 (1/65536).
  //
  // Unfortunately for technical reasons the value is first converted to the
  // [binary32 floating point
  // format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format),
  // which only has 24 bits of precision. This means that for values outside
  // the range -256.0 to 256.0, the smallest increment is larger than what is
  // technically supported by OpenType. At the extreme edge of the range, the
  // smallest increment is only approximately 0.002.
  double value = 2;
}

// dart:ui
//
// Creates an image filter that applies a Gaussian blur.
message DartImageFilterNamedBlur {
  double sigma_x = 2;
  double sigma_y = 3;
  DartTileModeType.Enum tile_mode = 4;
}

// dart:ui
//
// Composes the `inner` filter with `outer`, to combine their effects.
//
// Creates a single [ImageFilter] that when applied, has the same effect as
// subsequently applying `inner` and `outer`, i.e.,
// result = outer(inner(source)).
message DartImageFilterNamedCompose {
  DartImageFilterType outer = 2;
  DartImageFilterType inner = 3;
}

// dart:ui
//
// Creates an image filter that dilates each input pixel's channel values
// to the max value within the given radii along the x and y axes.
message DartImageFilterNamedDilate {
  double radius_x = 2;
  double radius_y = 3;
}

// dart:ui
//
// Create a filter that erodes each input pixel's channel values
// to the minimum channel value within the given radii along the x and y axes.
message DartImageFilterNamedErode {
  double radius_x = 2;
  double radius_y = 3;
}

// dart:ui
//
// Creates an image filter that applies a matrix transformation.
//
// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
// when used with [BackdropFilter] would magnify the background image.
message DartImageFilterNamedMatrix {
  DartFloat64ListType matrix4 = 2;
  DartFilterQualityType.Enum filter_quality = 3;
}

// dart:ui
//
// Creates an image-tiling shader.
//
// The first argument specifies the image to render. The
// [decodeImageFromList] function can be used to decode an image from bytes
// into the form expected here. (In production code, starting from
// [instantiateImageCodec] may be preferable.)
//
// The second and third arguments specify the [TileMode] for the x direction
// and y direction respectively. [TileMode.repeated] can be used for tiling
// images.
//
// The fourth argument gives the matrix to apply to the effect. The
// expression `Matrix4.identity().storage` creates a [Float64List]
// prepopulated with the identity matrix.
//
// All the arguments are required and must not be null, except for
// [filterQuality]. If [filterQuality] is not specified at construction time
// it will be deduced from the environment where it is used, such as from
// [Paint.filterQuality].
message DartImageShader {
  DartTileModeType.Enum tmx = 3;
  DartTileModeType.Enum tmy = 4;
  DartFloat64ListType matrix4 = 5;
  DartFilterQualityType.Enum filter_quality = 6;
}

// dart:typed_data
//
// Creates an [Int32List] of the specified length (in elements), all of
// whose elements are initially zero.
//
// The list is backed by a [ByteBuffer] containing precisely
// [length] times 4 bytes.
message DartInt32List {
  int32 length = 2;
}

// dart:typed_data
//
// Creates a [Int32List] with the same length as the [elements] list
// and copies over the elements.
//
// Values are truncated to fit in the list when they are copied,
// the same way storing values truncates them.
//
// The list is backed by a [ByteBuffer] containing precisely
// `elements.length` times 4 bytes.
message DartInt32ListNamedFromList {
  repeated int32 elements = 2;
}

// dart:typed_data
//
// Creates an [Int32List] view on a range of elements of [data].
//
// Creates a view on the range of `data.buffer` which corresponds
// to the elements of [data] from [start] until [end].
// If [data] is a typed data list, like [Uint16List], then the view is on
// the bytes of the elements with indices from [start] until [end].
// If [data] is a [ByteData], it's treated like a list of bytes.
//
// If provided, [start] and [end] must satisfy
//
// 0 &le; `start` &le; `end` &le; *elementCount*
//
// where *elementCount* is the number of elements in [data], which
// is the same as the [List.length] of a typed data list.
//
// If omitted, [start] defaults to zero and [end] to *elementCount*.
//
// The start and end indices of the range of bytes being viewed must be
// multiples of four.
message DartInt32ListNamedSublistView {
  DartTypedDataType data = 2;
  int32 start = 3;
  int32 end = 4;
}

// dart:typed_data
//
// Creates an [Int32List] _view_ of the specified region in [buffer].
//
// Changes in the [Int32List] will be visible in the byte
// buffer and vice versa.
// If the [offsetInBytes] index of the region is not specified,
// it defaults to zero (the first byte in the byte buffer).
// If the length is not provided,
// the view extends to the end of the byte buffer.
//
// The [offsetInBytes] and [length] must be non-negative, and
// [offsetInBytes] + ([length] * [bytesPerElement]) must be less than or
// equal to the length of [buffer].
//
// The [offsetInBytes] must be a multiple of [bytesPerElement].
//
// Note that when creating a view from a [TypedData] list or byte data,
// that list or byte data may itself be a view on a larger buffer
// with a [TypedData.offsetInBytes] greater than zero.
// Merely doing `Int32List.view(other.buffer, 0, count)` may not
// point to the bytes you intended. Instead you may need to do:
// ```dart
// Int32List.view(other.buffer, other.offsetInBytes, count)
// ```
// Alternatively, use [Int32List.sublistView]
// which includes this computation:
// ```dart
// Int32List.sublistView(other, 0, count);
// ```
// (The third argument is an end index rather than a length, so if
// you start from a position greater than zero, you need not
// reduce the count correspondingly).
message DartInt32ListNamedView {
  int32 offset_in_bytes = 3;
  int32 length = 4;
}

// dart:typed_data
//
// Creates an [Int64List] of the specified length (in elements), all of
// whose elements are initially zero.
//
// The list is backed by a [ByteBuffer] containing precisely
// [length] times 8 bytes.
message DartInt64List {
  int32 length = 2;
}

// dart:typed_data
//
// Creates a [Int64List] with the same length as the [elements] list
// and copies over the elements.
//
// Values are truncated to fit in the list when they are copied,
// the same way storing values truncates them.
//
// The list is backed by a [ByteBuffer] containing precisely
// `elements.length` times 8 bytes.
message DartInt64ListNamedFromList {
  repeated int32 elements = 2;
}

// dart:typed_data
//
// Creates an [Int64List] view on a range of elements of [data].
//
// Creates a view on the range of `data.buffer` which corresponds
// to the elements of [data] from [start] until [end].
// If [data] is a typed data list, like [Uint16List], then the view is on
// the bytes of the elements with indices from [start] until [end].
// If [data] is a [ByteData], it's treated like a list of bytes.
//
// If provided, [start] and [end] must satisfy
//
// 0 &le; `start` &le; `end` &le; *elementCount*
//
// where *elementCount* is the number of elements in [data], which
// is the same as the [List.length] of a typed data list.
//
// If omitted, [start] defaults to zero and [end] to *elementCount*.
//
// The start and end indices of the range of bytes being viewed must be
// multiples of eight.
message DartInt64ListNamedSublistView {
  DartTypedDataType data = 2;
  int32 start = 3;
  int32 end = 4;
}

// dart:typed_data
//
// Creates an [Int64List] _view_ of the specified region in [buffer].
//
// Changes in the [Int64List] will be visible in the byte buffer
// and vice versa.
// If the [offsetInBytes] index of the region is not specified,
// it defaults to zero (the first byte in the byte buffer).
// If the length is not provided,
// the view extends to the end of the byte buffer.
//
// The [offsetInBytes] and [length] must be non-negative, and
// [offsetInBytes] + ([length] * [bytesPerElement]) must be less than or
// equal to the length of [buffer].
//
// The [offsetInBytes] must be a multiple of [bytesPerElement].
//
// Note that when creating a view from a [TypedData] list or byte data,
// that list or byte data may itself be a view on a larger buffer
// with a [TypedData.offsetInBytes] greater than zero.
// Merely doing `Int64List.view(other.buffer, 0, count)` may not
// point to the bytes you intended. Instead you may need to do:
// ```dart
// Int64List.view(other.buffer, other.offsetInBytes, count)
// ```
// Alternatively, use [Int64List.sublistView]
// which includes this computation:
// ```dart
// Int64List.sublistView(other, 0, count);
// ```
// (The third argument is an end index rather than a length, so if
// you start from a position greater than zero, you need not
// reduce the count correspondingly).
message DartInt64ListNamedView {
  int32 offset_in_bytes = 3;
  int32 length = 4;
}

// dart:ui
//
// Creates a new Locale object. The first argument is the
// primary language subtag, the second is the region (also
// referred to as 'country') subtag.
//
// For example:
//
// ```dart
// const Locale swissFrench = Locale('fr', 'CH');
// const Locale canadianFrench = Locale('fr', 'CA');
// ```
//
// The primary language subtag must not be null. The region subtag is
// optional. When there is no region/country subtag, the parameter should
// be omitted or passed `null` instead of an empty-string.
//
// The subtag values are _case sensitive_ and must be one of the valid
// subtags according to CLDR supplemental data:
// [language](https://github.com/unicode-org/cldr/blob/master/common/validity/language.xml),
// [region](https://github.com/unicode-org/cldr/blob/master/common/validity/region.xml). The
// primary language subtag must be at least two and at most eight lowercase
// letters, but not four letters. The region subtag must be two
// uppercase letters or three digits. See the [Unicode Language
// Identifier](https://www.unicode.org/reports/tr35/#Unicode_language_identifier)
// specification.
//
// Validity is not checked by default, but some methods may throw away
// invalid data.
//
// See also:
//
//  * [Locale.fromSubtags], which also allows a [scriptCode] to be
//    specified.
message DartLocale {
  string language_code = 2;
  string country_code = 3;
}

// dart:ui
//
// Creates a new Locale object.
//
// The keyword arguments specify the subtags of the Locale.
//
// The subtag values are _case sensitive_ and must be valid subtags according
// to CLDR supplemental data:
// [language](https://github.com/unicode-org/cldr/blob/master/common/validity/language.xml),
// [script](https://github.com/unicode-org/cldr/blob/master/common/validity/script.xml) and
// [region](https://github.com/unicode-org/cldr/blob/master/common/validity/region.xml) for
// each of languageCode, scriptCode and countryCode respectively.
//
// The [languageCode] subtag is optional. When there is no language subtag,
// the parameter should be omitted or set to "und". When not supplied, the
// [languageCode] defaults to "und", an undefined language code.
//
// The [countryCode] subtag is optional. When there is no country subtag,
// the parameter should be omitted or passed `null` instead of an empty-string.
//
// Validity is not checked by default, but some methods may throw away
// invalid data.
message DartLocaleNamedFromSubtags {
  string language_code = 2;
  // The script subtag for the locale.
  //
  // This may be null, indicating that there is no specified script subtag.
  //
  // This must be a valid Unicode Language Identifier script subtag as listed
  // in [Unicode CLDR supplemental
  // data](https://github.com/unicode-org/cldr/blob/master/common/validity/script.xml).
  //
  // See also:
  //
  //  * [Locale.fromSubtags], which describes the conventions for creating
  //    [Locale] objects.
  string script_code = 3;
  string country_code = 4;
}

// dart:ui
//
// Creates a string attribute that denotes the text in [range] must be
// treated as the language specified by the [locale] when the assistive
// technologies announce the string.
message DartLocaleStringAttribute {
  DartTextRangeType range = 2;
  // The lanuage of this attribute.
  DartLocaleType locale = 3;
}

// dart:ui
//
// Creates an offset. The first argument sets [dx], the horizontal component,
// and the second sets [dy], the vertical component.
message DartOffset {
  double dx = 2;
  double dy = 3;
}

// dart:ui
//
// Creates an offset from its [direction] and [distance].
//
// The direction is in radians clockwise from the positive x-axis.
//
// The distance can be omitted, to create a unit vector (distance = 1.0).
message DartOffsetNamedFromDirection {
  double direction = 2;
  double distance = 3;
}

// dart:ui
//
// Constructs an empty [Paint] object with all fields initialized to
// their defaults.
message DartPaint {
  
}

// dart:ui
message DartPath {
  
}

// dart:ui
//
// Creates a copy of another [Path].
//
// This copy is fast and does not require additional memory unless either
// the `source` path or the path returned by this constructor are modified.
message DartPathNamedFrom {
  DartPathType source = 2;
}

// dart:ui
//
// Construct a rounded rectangle from its left, top, right, and bottom edges,
// and topLeft, topRight, bottomRight, and bottomLeft radii.
//
// The corner radii default to [Radius.zero], i.e. right-angled corners. Will
// assert in debug mode if any of the radii are negative in either x or y.
message DartRRectNamedFromLTRBAndCorners {
  double left = 2;
  double top = 3;
  double right = 4;
  double bottom = 5;
  DartRadiusType top_left = 6;
  DartRadiusType top_right = 7;
  DartRadiusType bottom_right = 8;
  DartRadiusType bottom_left = 9;
}

// dart:ui
//
// Construct a rounded rectangle from its left, top, right, and bottom edges,
// and the same radius in each corner.
//
// Will assert in debug mode if the `radius` is negative in either x or y.
message DartRRectNamedFromLTRBR {
  double left = 2;
  double top = 3;
  double right = 4;
  double bottom = 5;
  DartRadiusType radius = 6;
}

// dart:ui
//
// Construct a rounded rectangle from its left, top, right, and bottom edges,
// and the same radii along its horizontal axis and its vertical axis.
//
// Will assert in debug mode if `radiusX` or `radiusY` are negative.
message DartRRectNamedFromLTRBXY {
  double left = 2;
  double top = 3;
  double right = 4;
  double bottom = 5;
  double radius_x = 6;
  double radius_y = 7;
}

// dart:ui
//
// Construct a rounded rectangle from its bounding box and topLeft,
// topRight, bottomRight, and bottomLeft radii.
//
// The corner radii default to [Radius.zero], i.e. right-angled corners. Will
// assert in debug mode if any of the radii are negative in either x or y.
message DartRRectNamedFromRectAndCorners {
  DartRectType rect = 2;
  DartRadiusType top_left = 3;
  DartRadiusType top_right = 4;
  DartRadiusType bottom_right = 5;
  DartRadiusType bottom_left = 6;
}

// dart:ui
//
// Construct a rounded rectangle from its bounding box and a radius that is
// the same in each corner.
//
// Will assert in debug mode if the `radius` is negative in either x or y.
message DartRRectNamedFromRectAndRadius {
  DartRectType rect = 2;
  DartRadiusType radius = 3;
}

// dart:ui
//
// Construct a rounded rectangle from its bounding box and the same radii
// along its horizontal axis and its vertical axis.
//
// Will assert in debug mode if `radiusX` or `radiusY` are negative.
message DartRRectNamedFromRectXY {
  DartRectType rect = 2;
  double radius_x = 3;
  double radius_y = 4;
}

// dart:ui
//
// Constructs a circular radius. [x] and [y] will have the same radius value.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/radius_circular.png#gh-light-mode-only)
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/radius_circular_dark.png#gh-dark-mode-only)
message DartRadiusNamedCircular {
  double radius = 2;
}

// dart:ui
//
// Constructs an elliptical radius with the given radii.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/radius_elliptical.png#gh-light-mode-only)
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/radius_elliptical_dark.png#gh-dark-mode-only)
message DartRadiusNamedElliptical {
  // The radius value on the horizontal axis.
  double x = 2;
  // The radius value on the vertical axis.
  double y = 3;
}

// dart:math
//
// Creates a random number generator.
//
// The optional parameter [seed] is used to initialize the
// internal state of the generator. The implementation of the
// random stream can change between releases of the library.
message DartRandom {
  int32 seed = 2;
}

// dart:math
//
// Creates a cryptographically secure random number generator.
//
// If the program cannot provide a cryptographically secure
// source of random numbers, it throws an [UnsupportedError].
message DartRandomNamedSecure {
  
}

// dart:ui
//
// Constructs a rectangle from its center point, width, and height.
//
// The `center` argument is assumed to be an offset from the origin.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_center.png#gh-light-mode-only)
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_center_dark.png#gh-dark-mode-only)
message DartRectNamedFromCenter {
  DartOffsetType center = 2;
  double width = 3;
  double height = 4;
}

// dart:ui
//
// Construct a rectangle that bounds the given circle.
//
// The `center` argument is assumed to be an offset from the origin.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_circle.png#gh-light-mode-only)
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_circle_dark.png#gh-dark-mode-only)
message DartRectNamedFromCircle {
  DartOffsetType center = 2;
  double radius = 3;
}

// dart:ui
//
// Construct a rectangle from its left, top, right, and bottom edges.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_ltrb.png#gh-light-mode-only)
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_ltrb_dark.png#gh-dark-mode-only)
message DartRectNamedFromLTRB {
  // The offset of the left edge of this rectangle from the x axis.
  double left = 2;
  // The offset of the top edge of this rectangle from the y axis.
  double top = 3;
  // The offset of the right edge of this rectangle from the x axis.
  double right = 4;
  // The offset of the bottom edge of this rectangle from the y axis.
  double bottom = 5;
}

// dart:ui
//
// Construct a rectangle from its left and top edges, its width, and its
// height.
//
// To construct a [Rect] from an [Offset] and a [Size], you can use the
// rectangle constructor operator `&`. See [Offset.&].
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_ltwh.png#gh-light-mode-only)
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_ltwh_dark.png#gh-dark-mode-only)
message DartRectNamedFromLTWH {
  double left = 2;
  double top = 3;
  double width = 4;
  double height = 5;
}

// dart:ui
//
// Construct the smallest rectangle that encloses the given offsets, treating
// them as vectors from the origin.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_points.png#gh-light-mode-only)
// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/rect_from_points_dark.png#gh-dark-mode-only)
message DartRectNamedFromPoints {
  DartOffsetType a = 2;
  DartOffsetType b = 3;
}

// dart:ui
//
// Construct a shadow.
//
// The default shadow is a black shadow with zero offset and zero blur.
// Default shadows should be completely covered by the casting element,
// and not be visible.
//
// Transparency should be adjusted through the [color] alpha.
//
// Shadow order matters due to compositing multiple translucent objects not
// being commutative.
message DartShadow {
  // Color that the shadow will be drawn with.
  //
  // The shadows are shapes composited directly over the base canvas, and do not
  // represent optical occlusion.
  DartColorType color = 2;
  // The displacement of the shadow from the casting element.
  //
  // Positive x/y offsets will shift the shadow to the right and down, while
  // negative offsets shift the shadow to the left and up. The offsets are
  // relative to the position of the element that is casting it.
  DartOffsetType offset = 3;
  // The standard deviation of the Gaussian to convolve with the shadow's shape.
  double blur_radius = 4;
}

// dart:ui
//
// Creates a [Size] with the given [width] and [height].
message DartSize {
  double width = 2;
  double height = 3;
}

// dart:ui
//
// Creates an instance of [Size] that has the same values as another.
message DartSizeNamedCopy {
  DartSizeType source = 2;
}

// dart:ui
//
// Creates a [Size] with the given [height] and an infinite [width].
message DartSizeNamedFromHeight {
  double height = 2;
}

// dart:ui
//
// Creates a square [Size] whose [width] and [height] are twice the given
// dimension.
//
// This is a square that contains a circle with the given radius.
//
// See also:
//
//  * [Size.square], which creates a square with the given dimension.
message DartSizeNamedFromRadius {
  double radius = 2;
}

// dart:ui
//
// Creates a [Size] with the given [width] and an infinite [height].
message DartSizeNamedFromWidth {
  double width = 2;
}

// dart:ui
//
// Creates a square [Size] whose [width] and [height] are the given dimension.
//
// See also:
//
//  * [Size.fromRadius], which is more convenient when the available size
//    is the radius of a circle.
message DartSizeNamedSquare {
  double dimension = 2;
}

// dart:ui
//
// Creates a string attribute that denotes the text in [range] must be
// spell out when the assistive technologies announce the string.
message DartSpellOutStringAttribute {
  DartTextRangeType range = 2;
}

// dart:core
//
// Create a `StackTrace` object from [stackTraceString].
//
// The created stack trace will have a `toString` method returning
// `stackTraceString`.
//
// The `stackTraceString` can be a string returned by some other
// stack trace, or it can be any string at all.
// If the string doesn't look like a stack trace, code that interprets
// stack traces is likely to fail, so fake stack traces should be used
// with care.
message DartStackTraceNamedFromString {
  string stack_trace_string = 2;
}

// dart:ui
//
// Creates a decoration that paints the union of all the given decorations.
message DartTextDecorationNamedCombine {
  repeated DartTextDecorationType decorations = 2;
}

// dart:ui
//
// Creates a new TextHeightBehavior object.
//
//  * applyHeightToFirstAscent: When true, the [TextStyle.height] modifier
//    will be applied to the ascent of the first line. When false, the font's
//    default ascent will be used.
//  * applyHeightToLastDescent: When true, the [TextStyle.height] modifier
//    will be applied to the descent of the last line. When false, the font's
//    default descent will be used.
//  * leadingDistribution: How the leading is distributed over and under
//    text.
//
// All properties default to true (height modifications applied as normal).
message DartTextHeightBehavior {
  // Whether to apply the [TextStyle.height] modifier to the ascent of the first
  // line in the paragraph.
  //
  // When true, the [TextStyle.height] modifier will be applied to the ascent
  // of the first line. When false, the font's default ascent will be used and
  // the [TextStyle.height] will have no effect on the ascent of the first line.
  //
  // This property only has effect if a non-null [TextStyle.height] is specified.
  //
  // Defaults to true (height modifications applied as normal).
  bool apply_height_to_first_ascent = 2;
  // Whether to apply the [TextStyle.height] modifier to the descent of the last
  // line in the paragraph.
  //
  // When true, the [TextStyle.height] modifier will be applied to the descent
  // of the last line. When false, the font's default descent will be used and
  // the [TextStyle.height] will have no effect on the descent of the last line.
  //
  // This property only has effect if a non-null [TextStyle.height] is specified.
  //
  // Defaults to true (height modifications applied as normal).
  bool apply_height_to_last_descent = 3;
  // {@template dart.ui.textLeadingDistribution}
  // How the ["leading"](https://en.wikipedia.org/wiki/Leading) is distributed
  // over and under the text.
  //
  // Does not affect layout when [TextStyle.height] is not specified. The
  // leading can become negative, for example, when [TextLeadingDistribution.even]
  // is used with a [TextStyle.height] much smaller than 1.0.
  // {@endtemplate}
  //
  // Defaults to [TextLeadingDistribution.proportional],
  DartTextLeadingDistributionType.Enum leading_distribution = 4;
}

// dart:ui
//
// Creates an object representing a particular position in a string.
//
// The arguments must not be null (so the [offset] argument is required).
message DartTextPosition {
  // The index of the character that immediately follows the position in the
  // string representation of the text.
  //
  // For example, given the string `'Hello'`, offset 0 represents the cursor
  // being before the `H`, while offset 5 represents the cursor being just
  // after the `o`.
  int32 offset = 2;
  // Disambiguates cases where the position in the string given by [offset]
  // could represent two different visual positions in the rendered text. For
  // example, this can happen when text is forced to wrap, or when one string
  // of text is rendered with multiple text directions.
  //
  // See the documentation for [TextAffinity] for more information on how
  // TextAffinity disambiguates situations like these.
  DartTextAffinityType.Enum affinity = 3;
}

// dart:ui
//
// Creates a text range.
//
// The [start] and [end] arguments must not be null. Both the [start] and
// [end] must either be greater than or equal to zero or both exactly -1.
//
// The text included in the range includes the character at [start], but not
// the one at [end].
//
// Instead of creating an empty text range, consider using the [empty]
// constant.
message DartTextRange {
  // The index of the first character in the range.
  //
  // If [start] and [end] are both -1, the text range is empty.
  int32 start = 2;
  // The next index after the characters in this range.
  //
  // If [start] and [end] are both -1, the text range is empty.
  int32 end = 3;
}

// dart:ui
//
// A text range that starts and ends at offset.
//
// The [offset] argument must be non-null and greater than or equal to -1.
message DartTextRangeNamedCollapsed {
  int32 offset = 2;
}

// dart:typed_data
//
// Creates a [Uint8List] of the specified length (in elements), all of
// whose elements are initially zero.
//
// The list is backed by a [ByteBuffer] containing precisely [length] bytes.
message DartUint8List {
  int32 length = 2;
}

// dart:typed_data
//
// Creates a [Uint8List] with the same length as the [elements] list
// and copies over the elements.
//
// Values are truncated to fit in the list when they are copied,
// the same way storing values truncates them.
//
// The list is backed by a [ByteBuffer] containing precisely `elements.length`
// bytes.
message DartUint8ListNamedFromList {
  repeated int32 elements = 2;
}

// dart:typed_data
//
// Creates a [Uint8List] view on a range of elements of [data].
//
// Creates a view on the range of `data.buffer` which corresponds
// to the elements of [data] from [start] until [end].
// If [data] is a typed data list, like [Uint16List], then the view is on
// the bytes of the elements with indices from [start] until [end].
// If [data] is a [ByteData], it's treated like a list of bytes.
//
// If provided, [start] and [end] must satisfy
//
// 0 &le; `start` &le; `end` &le; *elementCount*
//
// where *elementCount* is the number of elements in [data], which
// is the same as the [List.length] of a typed data list.
//
// If omitted, [start] defaults to zero and [end] to *elementCount*.
message DartUint8ListNamedSublistView {
  DartTypedDataType data = 2;
  int32 start = 3;
  int32 end = 4;
}

// dart:typed_data
//
// Creates a [Uint8List] _view_ of the specified region in [buffer].
//
// Changes in the [Uint8List] will be visible in the byte
// buffer and vice versa.
// If the [offsetInBytes] index of the region is not specified,
// it defaults to zero (the first byte in the byte buffer).
// If the length is not provided,
// the view extends to the end of the byte buffer.
//
// The [offsetInBytes] and [length] must be non-negative, and
// [offsetInBytes] + ([length] * [bytesPerElement]) must be less than or
// equal to the length of [buffer].
//
// Note that when creating a view from a [TypedData] list or byte data,
// that list or byte data may itself be a view on a larger buffer
// with a [TypedData.offsetInBytes] greater than zero.
// Merely doing `Uint8List.view(other.buffer, 0, count)` may not
// point to the bytes you intended. Instead you may need to do:
// ```dart
// Uint8List.view(other.buffer, other.offsetInBytes, count)
// ```
// Alternatively, use [Uint8List.sublistView]
// which includes this computation:
// ```dart
// Uint8List.sublistView(other, 0, count);
// ```
// (The third argument is an end index rather than a length, so if
// you start from a position greater than zero, you need not
// reduce the count correspondingly).
message DartUint8ListNamedView {
  int32 offset_in_bytes = 3;
  int32 length = 4;
}

// dart:core
//
// Creates a new URI from its components.
//
// Each component is set through a named argument. Any number of
// components can be provided. The [path] and [query] components can be set
// using either of two different named arguments.
//
// The scheme component is set through [scheme]. The scheme is
// normalized to all lowercase letters. If the scheme is omitted or empty,
// the URI will not have a scheme part.
//
// The user info part of the authority component is set through
// [userInfo]. It defaults to the empty string, which will be omitted
// from the string representation of the URI.
//
// The host part of the authority component is set through
// [host]. The host can either be a hostname, an IPv4 address or an
// IPv6 address, contained in `'['` and `']'`. If the host contains a
// ':' character, the `'['` and `']'` are added if not already provided.
// The host is normalized to all lowercase letters.
//
// The port part of the authority component is set through
// [port].
// If [port] is omitted or `null`, it implies the default port for
// the URI's scheme, and is equivalent to passing that port explicitly.
// The recognized schemes, and their default ports, are "http" (80) and
// "https" (443). All other schemes are considered as having zero as the
// default port.
//
// If any of `userInfo`, `host` or `port` are provided,
// the URI has an authority according to [hasAuthority].
//
// The path component is set through either [path] or
// [pathSegments].
// When [path] is used, it should be a valid URI path,
// but invalid characters, except the general delimiters ':/@[]?#',
// will be escaped if necessary. A backslash, `\`, will be converted
// to a slash `/`.
// When [pathSegments] is used, each of the provided segments
// is first percent-encoded and then joined using the forward slash
// separator.
//
// The percent-encoding of the path segments encodes all
// characters except for the unreserved characters and the following
// list of characters: `!$&'()*+,;=:@`. If the other components
// necessitate an absolute path, a leading slash `/` is prepended if
// not already there.
//
// The query component is set through either [query] or [queryParameters].
// When [query] is used, the provided string should be a valid URI query,
// but invalid characters, other than general delimiters,
// will be escaped if necessary.
// When [queryParameters] is used, the query is built from the
// provided map. Each key and value in the map is percent-encoded
// and joined using equal and ampersand characters.
// A value in the map must be either `null`, a string, or an [Iterable] of
// strings. An iterable corresponds to multiple values for the same key,
// and an empty iterable or `null` corresponds to no value for the key.
//
// The percent-encoding of the keys and values encodes all characters
// except for the unreserved characters, and replaces spaces with `+`.
// If [query] is the empty string, it is equivalent to omitting it.
// To have an actual empty query part,
// use an empty map for [queryParameters].
//
// If both [query] and [queryParameters] are omitted or `null`,
// the URI has no query part.
//
// The fragment component is set through [fragment].
// It should be a valid URI fragment, but invalid characters other than
// general delimiters are escaped if necessary.
// If [fragment] is omitted or `null`, the URI has no fragment part.
//
// Example:
// ```dart
// final httpsUri = Uri(
//     scheme: 'https',
//     host: 'dart.dev',
//     path: 'guides/libraries/library-tour',
//     fragment: 'numbers');
// print(httpsUri); // https://dart.dev/guides/libraries/library-tour#numbers
//
// final mailtoUri = Uri(
//     scheme: 'mailto',
//     path: 'John.Doe@example.com',
//     queryParameters: {'subject': 'Example'});
// print(mailtoUri); // mailto:John.Doe@example.com?subject=Example
// ```
message DartUri {
  string scheme = 2;
  string user_info = 3;
  string host = 4;
  int32 port = 5;
  string path = 6;
  repeated string path_segments = 7;
  string query = 8;
  string fragment = 10;
}

// dart:core
//
// Creates a `data:` URI containing an encoding of [bytes].
//
// Defaults to Base64 encoding the bytes, but if [percentEncoded]
// is `true`, the bytes will instead be percent encoded (any non-ASCII
// or non-valid-ASCII-character byte is replaced by a percent encoding).
//
// To read the bytes back, use [UriData.contentAsBytes].
//
// It defaults to having the mime-type `application/octet-stream`.
// The [mimeType] and [parameters] are added to the created URI.
// If any of these contain characters that are not allowed
// in the data URI, the character is percent-escaped. If the character is
// non-ASCII, it is first UTF-8 encoded and then the bytes are percent
// encoded.
//
// Example:
// ```dart
// final uri = Uri.dataFromBytes([68, 97, 114, 116]);
// print(uri); // data:application/octet-stream;base64,RGFydA==
// ```
message DartUriNamedDataFromBytes {
  repeated int32 bytes = 2;
  string mime_type = 3;
  bool percent_encoded = 5;
}

// dart:core
//
// Creates a `data:` URI containing the [content] string.
//
// Converts the content to bytes using [encoding] or the charset specified
// in [parameters] (defaulting to US-ASCII if not specified or unrecognized),
// then encodes the bytes into the resulting data URI.
//
// Defaults to encoding using percent-encoding (any non-ASCII or
// non-URI-valid bytes is replaced by a percent encoding). If [base64] is
// true, the bytes are instead encoded using [base64].
//
// If [encoding] is not provided and [parameters] has a `charset` entry,
// that name is looked up using [Encoding.getByName],
// and if the lookup returns an encoding, that encoding is used to convert
// [content] to bytes.
// If providing both an [encoding] and a charset in [parameters], they should
// agree, otherwise decoding won't be able to use the charset parameter
// to determine the encoding.
//
// If [mimeType] and/or [parameters] are supplied, they are added to the
// created URI. If any of these contain characters that are not allowed
// in the data URI, the character is percent-escaped. If the character is
// non-ASCII, it is first UTF-8 encoded and then the bytes are percent
// encoded. An omitted [mimeType] in a data URI means `text/plain`, just
// as an omitted `charset` parameter defaults to meaning `US-ASCII`.
//
// To read the content back, use [UriData.contentAsString].
//
// Example:
// ```dart
// final uri = Uri.dataFromString(
//   'example content',
//   mimeType: 'text/plain',
//   parameters: <String, String>{'search': 'file', 'max': '10'},
// );
// print(uri); // data:;search=name;max=10,example%20content
// ```
message DartUriNamedDataFromString {
  string content = 2;
  string mime_type = 3;
  bool base64 = 6;
}

// dart:core
//
// Like [Uri.file] except that a non-empty URI path ends in a slash.
//
// If [path] is not empty, and it doesn't end in a directory separator,
// then a slash is added to the returned URI's path.
// In all other cases, the result is the same as returned by `Uri.file`.
//
// Example:
// ```dart
// final fileDirectory = Uri.directory('data/images', windows: false);
// print(fileDirectory); // data/images/
//
// final fileDirectoryWindows =
//    Uri.directory(r'C:\data\images', windows: true);
// print(fileDirectoryWindows); // file:///C:/data/images/
// ```
message DartUriNamedDirectory {
  string path = 2;
  bool windows = 3;
}

// dart:core
//
// Creates a new file URI from an absolute or relative file path.
//
// The file path is passed in [path].
//
// This path is interpreted using either Windows or non-Windows
// semantics.
//
// With non-Windows semantics, the slash (`/`) is used to separate
// path segments in the input [path].
//
// With Windows semantics, backslash (`\`) and forward-slash (`/`)
// are used to separate path segments in the input [path],
// except if the path starts with `\\?\` in which case
// only backslash (`\`) separates path segments in [path].
//
// If the path starts with a path separator, an absolute URI (with the
// `file` scheme and an empty authority) is created.
// Otherwise a relative URI reference with no scheme or authority is created.
// One exception to this rule is that when Windows semantics is used
// and the path starts with a drive letter followed by a colon (":") and a
// path separator, then an absolute URI is created.
//
// The default for whether to use Windows or non-Windows semantics
// is determined from the platform Dart is running on. When running in
// the standalone VM, this is detected by the VM based on the
// operating system. When running in a browser, non-Windows semantics
// is always used.
//
// To override the automatic detection of which semantics to use pass
// a value for [windows]. Passing `true` will use Windows
// semantics and passing `false` will use non-Windows semantics.
//
// Examples using non-Windows semantics:
// ```dart
// // xxx/yyy
// Uri.file('xxx/yyy', windows: false);
//
// // xxx/yyy/
// Uri.file('xxx/yyy/', windows: false);
//
// // file:///xxx/yyy
// Uri.file('/xxx/yyy', windows: false);
//
// // file:///xxx/yyy/
// Uri.file('/xxx/yyy/', windows: false);
//
// // C%3A
// Uri.file('C:', windows: false);
// ```
//
// Examples using Windows semantics:
// ```dart
// // xxx/yyy
// Uri.file(r'xxx\yyy', windows: true);
//
// // xxx/yyy/
// Uri.file(r'xxx\yyy\', windows: true);
//
// file:///xxx/yyy
// Uri.file(r'\xxx\yyy', windows: true);
//
// file:///xxx/yyy/
// Uri.file(r'\xxx\yyy/', windows: true);
//
// // file:///C:/xxx/yyy
// Uri.file(r'C:\xxx\yyy', windows: true);
//
// // This throws an error. A path with a drive letter, but no following
// // path, is not allowed.
// Uri.file(r'C:', windows: true);
//
// // This throws an error. A path with a drive letter is not absolute.
// Uri.file(r'C:xxx\yyy', windows: true);
//
// // file://server/share/file
// Uri.file(r'\\server\share\file', windows: true);
// ```
//
// If the path passed is not a valid file path, an error is thrown.
message DartUriNamedFile {
  string path = 2;
  bool windows = 3;
}

// dart:core
//
// Creates a new `http` URI from authority, path and query.
//
// Example:
// ```dart
// var uri = Uri.http('example.org', '/path', { 'q' : 'dart' });
// print(uri); // http://example.org/path?q=dart
//
// uri = Uri.http('user:password@localhost:8080', '');
// print(uri); // http://user:password@localhost:8080
//
// uri = Uri.http('example.org', 'a b');
// print(uri); // http://example.org/a%20b
//
// uri = Uri.http('example.org', '/a%2F');
// print(uri); // http://example.org/a%252F
// ```
//
// The `scheme` is always set to `http`.
//
// The `userInfo`, `host` and `port` components are set from the
// [authority] argument. If `authority` is `null` or empty,
// the created `Uri` has no authority, and isn't directly usable
// as an HTTP URL, which must have a non-empty host.
//
// The `path` component is set from the [unencodedPath]
// argument. The path passed must not be encoded as this constructor
// encodes the path. Only `/` is recognized as path separator.
// If omitted, the path defaults to being empty.
//
// The `query` component is set from the optional [queryParameters]
// argument.
message DartUriNamedHttp {
  string authority = 2;
  string unencoded_path = 3;
}

// dart:core
//
// Creates a new `https` URI from authority, path and query.
//
// This constructor is the same as [Uri.http] except for the scheme
// which is set to `https`.
//
// Example:
// ```dart
// var uri = Uri.https('example.org', '/path', {'q': 'dart'});
// print(uri); // https://example.org/path?q=dart
//
// uri = Uri.https('user:password@localhost:8080', '');
// print(uri); // https://user:password@localhost:8080
//
// uri = Uri.https('example.org', 'a b');
// print(uri); // https://example.org/a%20b
//
// uri = Uri.https('example.org', '/a%2F');
// print(uri); // https://example.org/a%252F
// ```
message DartUriNamedHttps {
  string authority = 2;
  string unencoded_path = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that absorbs pointers during hit testing.
message FlutterAbsorbPointer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this widget absorbs pointers during hit testing.
  //
  // Regardless of whether this render object absorbs pointers during hit
  // testing, it will still consume space during layout and be visible during
  // painting.
  //
  // {@macro flutter.widgets.AbsorbPointer.semantics}
  //
  // Defaults to true.
  bool absorbing = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/actions.dart
//
// Creates an intent that activates the currently focused control.
message FlutterActivateIntent {
  
}

// package:flutter/src/widgets/basic.dart
//
// Creates an alignment widget.
//
// The alignment defaults to [Alignment.center].
message FlutterAlign {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How to align the child.
  //
  // The x and y values of the [Alignment] control the horizontal and vertical
  // alignment, respectively. An x value of -1.0 means that the left edge of
  // the child is aligned with the left edge of the parent whereas an x value
  // of 1.0 means that the right edge of the child is aligned with the right
  // edge of the parent. Other values interpolate (and extrapolate) linearly.
  // For example, a value of 0.0 means that the center of the child is aligned
  // with the center of the parent.
  //
  // See also:
  //
  //  * [Alignment], which has more details and some convenience constants for
  //    common positions.
  //  * [AlignmentDirectional], which has a horizontal coordinate orientation
  //    that depends on the [TextDirection].
  FlutterAlignmentGeometryType alignment = 3;
  // If non-null, sets its width to the child's width multiplied by this factor.
  //
  // Can be both greater and less than 1.0 but must be non-negative.
  double width_factor = 4;
  // If non-null, sets its height to the child's height multiplied by this factor.
  //
  // Can be both greater and less than 1.0 but must be non-negative.
  double height_factor = 5;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 6;
}

// package:flutter/src/painting/alignment.dart
//
// Creates an alignment.
message FlutterAlignment {
  // The distance fraction in the horizontal direction.
  //
  // A value of -1.0 corresponds to the leftmost edge. A value of 1.0
  // corresponds to the rightmost edge. Values are not limited to that range;
  // values less than -1.0 represent positions to the left of the left edge,
  // and values greater than 1.0 represent positions to the right of the right
  // edge.
  double x = 2;
  // The distance fraction in the vertical direction.
  //
  // A value of -1.0 corresponds to the topmost edge. A value of 1.0
  // corresponds to the bottommost edge. Values are not limited to that range;
  // values less than -1.0 represent positions above the top, and values
  // greater than 1.0 represent positions below the bottom.
  double y = 3;
}

// package:flutter/src/painting/alignment.dart
//
// Creates a directional alignment.
message FlutterAlignmentDirectional {
  // The distance fraction in the horizontal direction.
  //
  // A value of -1.0 corresponds to the edge on the "start" side, which is the
  // left side in [TextDirection.ltr] contexts and the right side in
  // [TextDirection.rtl] contexts. A value of 1.0 corresponds to the opposite
  // edge, the "end" side. Values are not limited to that range; values less
  // than -1.0 represent positions beyond the start edge, and values greater than
  // 1.0 represent positions beyond the end edge.
  //
  // This value is normalized into an [Alignment.x] value by the [resolve]
  // method.
  double start = 2;
  // The distance fraction in the vertical direction.
  //
  // A value of -1.0 corresponds to the topmost edge. A value of 1.0
  // corresponds to the bottommost edge. Values are not limited to that range;
  // values less than -1.0 represent positions above the top, and values
  // greater than 1.0 represent positions below the bottom.
  //
  // This value is passed through to [Alignment.y] unmodified by the
  // [resolve] method.
  double y = 3;
}

// package:flutter/src/widgets/scroll_physics.dart
//
// Creates scroll physics that always lets the user scroll.
message FlutterAlwaysScrollableScrollPhysics {
  // If non-null, determines the default behavior for each method.
  //
  // If a subclass of [ScrollPhysics] does not override a method, that subclass
  // will inherit an implementation from this base class that defers to
  // [parent]. This mechanism lets you assemble novel combinations of
  // [ScrollPhysics] subclasses at runtime. For example:
  //
  // ```dart
  // const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
  // ```
  //
  // will result in a [ScrollPhysics] that has the combined behavior
  // of [BouncingScrollPhysics] and [AlwaysScrollableScrollPhysics]:
  // behaviors that are not specified in [BouncingScrollPhysics]
  // (e.g. [shouldAcceptUserOffset]) will defer to [AlwaysScrollableScrollPhysics].
  FlutterScrollPhysicsType parent = 2;
}

// package:flutter/src/widgets/platform_view.dart
//
// Creates a widget that embeds an Android view.
//
// {@template flutter.widgets.AndroidView.constructorArgs}
// If `creationParams` is not null then `creationParamsCodec` must not be null.
// {@endtemplate}
message FlutterAndroidView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The unique identifier for Android view type to be embedded by this widget.
  //
  // A [PlatformViewFactory](/javadoc/io/flutter/plugin/platform/PlatformViewFactory.html)
  // for this type must have been registered.
  //
  // See also:
  //
  //  * [AndroidView] for an example of registering a platform view factory.
  string view_type = 3;
  // {@template flutter.widgets.AndroidView.hitTestBehavior}
  // How this widget should behave during hit testing.
  //
  // This defaults to [PlatformViewHitTestBehavior.opaque].
  // {@endtemplate}
  FlutterPlatformViewHitTestBehaviorType.Enum hit_test_behavior = 5;
  // {@template flutter.widgets.AndroidView.layoutDirection}
  // The text direction to use for the embedded view.
  //
  // If this is null, the ambient [Directionality] is used instead.
  // {@endtemplate}
  DartTextDirectionType.Enum layout_direction = 6;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 10;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that positions its child by an alignment that animates
// implicitly.
message FlutterAnimatedAlign {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How to align the child.
  //
  // The x and y values of the [Alignment] control the horizontal and vertical
  // alignment, respectively. An x value of -1.0 means that the left edge of
  // the child is aligned with the left edge of the parent whereas an x value
  // of 1.0 means that the right edge of the child is aligned with the right
  // edge of the parent. Other values interpolate (and extrapolate) linearly.
  // For example, a value of 0.0 means that the center of the child is aligned
  // with the center of the parent.
  //
  // See also:
  //
  //  * [Alignment], which has more details and some convenience constants for
  //    common positions.
  //  * [AlignmentDirectional], which has a horizontal coordinate orientation
  //    that depends on the [TextDirection].
  FlutterAlignmentGeometryType alignment = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
  // If non-null, sets its height to the child's height multiplied by this factor.
  //
  // Must be greater than or equal to 0.0, defaults to null.
  double height_factor = 5;
  // If non-null, sets its width to the child's width multiplied by this factor.
  //
  // Must be greater than or equal to 0.0, defaults to null.
  double width_factor = 6;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 7;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 8;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a container that animates its parameters implicitly.
message FlutterAnimatedContainer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Align the [child] within the container.
  //
  // If non-null, the container will expand to fill its parent and position its
  // child within itself according to the given value. If the incoming
  // constraints are unbounded, then the child will be shrink-wrapped instead.
  //
  // Ignored if [child] is null.
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 3;
  // Empty space to inscribe inside the [decoration]. The [child], if any, is
  // placed inside this padding.
  FlutterEdgeInsetsGeometryType padding = 4;
  DartColorType color = 5;
  FlutterDecorationType decoration = 6;
  // The decoration to paint in front of the child.
  FlutterDecorationType foreground_decoration = 7;
  double width = 8;
  double height = 9;
  FlutterBoxConstraintsType constraints = 10;
  // Empty space to surround the [decoration] and [child].
  FlutterEdgeInsetsGeometryType margin = 11;
  // The transformation matrix to apply before painting the container.
  VectorMathMatrix4Type transform = 12;
  // The alignment of the origin, relative to the size of the container, if [transform] is specified.
  //
  // When [transform] is null, the value of this property is ignored.
  //
  // See also:
  //
  //  * [Transform.alignment], which is set by this property.
  FlutterAlignmentGeometryType transform_alignment = 13;
  // The [child] contained by the container.
  //
  // If null, and if the [constraints] are unbounded or also null, the
  // container will expand to fill all available space in its parent, unless
  // the parent provides unbounded constraints, in which case the container
  // will attempt to be as small as possible.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 14;
  // The clip behavior when [AnimatedContainer.decoration] is not null.
  //
  // Defaults to [Clip.none]. Must be [Clip.none] if [decoration] is null.
  //
  // Unlike other properties of [AnimatedContainer], changes to this property
  // apply immediately and have no animation.
  //
  // If a clip is to be applied, the [Decoration.getClipPath] method
  // for the provided decoration must return a clip path. (This is not
  // supported by all decorations; the default implementation of that
  // method throws an [UnsupportedError].)
  DartClipType.Enum clip_behavior = 15;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 16;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 17;
}

// package:flutter/src/widgets/animated_cross_fade.dart
//
// Creates a cross-fade animation widget.
//
// The [duration] of the animation is the same for all components (fade in,
// fade out, and size), and you can pass [Interval]s instead of [Curve]s in
// order to have finer control, e.g., creating an overlap between the fades.
message FlutterAnimatedCrossFade {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The child that is visible when [crossFadeState] is
  // [CrossFadeState.showFirst]. It fades out when transitioning
  // [crossFadeState] from [CrossFadeState.showFirst] to
  // [CrossFadeState.showSecond] and vice versa.
  WidgetType first_child = 3;
  // The child that is visible when [crossFadeState] is
  // [CrossFadeState.showSecond]. It fades in when transitioning
  // [crossFadeState] from [CrossFadeState.showFirst] to
  // [CrossFadeState.showSecond] and vice versa.
  WidgetType second_child = 4;
  // The fade curve of the first child.
  //
  // Defaults to [Curves.linear].
  FlutterSrcAnimationCurveType first_curve = 5;
  // The fade curve of the second child.
  //
  // Defaults to [Curves.linear].
  FlutterSrcAnimationCurveType second_curve = 6;
  // The curve of the animation between the two children's sizes.
  //
  // Defaults to [Curves.linear].
  FlutterSrcAnimationCurveType size_curve = 7;
  // How the children should be aligned while the size is animating.
  //
  // Defaults to [Alignment.topCenter].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 8;
  // The child that will be shown when the animation has completed.
  FlutterCrossFadeStateType.Enum cross_fade_state = 9;
  // The duration of the whole orchestrated animation.
  DartDurationType duration = 10;
  // The duration of the whole orchestrated animation when running in reverse.
  //
  // If not supplied, this defaults to [duration].
  DartDurationType reverse_duration = 11;
  // When true, this is equivalent to wrapping the bottom widget with an [ExcludeFocus]
  // widget while it is at the bottom of the cross-fade stack.
  //
  // Defaults to true. When it is false, the bottom widget in the cross-fade stack
  // can remain in focus until the top widget requests focus. This is useful for
  // animating between different [TextField]s so the keyboard remains open during the
  // cross-fade animation.
  bool exclude_bottom_focus = 13;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates the default text style implicitly.
message FlutterAnimatedDefaultTextStyle {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The target text style.
  //
  // When this property is changed, the style will be animated over [duration] time.
  FlutterTextStyleType style = 4;
  // How the text should be aligned horizontally.
  //
  // This property takes effect immediately when changed, it is not animated.
  DartTextAlignType.Enum text_align = 5;
  // Whether the text should break at soft line breaks.
  //
  // This property takes effect immediately when changed, it is not animated.
  //
  // See [DefaultTextStyle.softWrap] for more details.
  bool soft_wrap = 6;
  // How visual overflow should be handled.
  //
  // This property takes effect immediately when changed, it is not animated.
  FlutterTextOverflowType.Enum overflow = 7;
  // An optional maximum number of lines for the text to span, wrapping if necessary.
  //
  // This property takes effect immediately when changed, it is not animated.
  //
  // See [DefaultTextStyle.maxLines] for more details.
  int32 max_lines = 8;
  // The strategy to use when calculating the width of the Text.
  //
  // See [TextWidthBasis] for possible values and their implications.
  FlutterTextWidthBasisType.Enum text_width_basis = 9;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 10;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 11;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 12;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that sizes its child to a fraction of the total available
// space that animates implicitly, and positions its child by an alignment
// that animates implicitly.
//
// If non-null, the [widthFactor] and [heightFactor] arguments must be
// non-negative.
message FlutterAnimatedFractionallySizedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.basic.fractionallySizedBox.alignment}
  FlutterAlignmentGeometryType alignment = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
  // {@macro flutter.widgets.basic.fractionallySizedBox.heightFactor}
  double height_factor = 5;
  // {@macro flutter.widgets.basic.fractionallySizedBox.widthFactor}
  double width_factor = 6;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 7;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 8;
}

// package:flutter/src/widgets/animated_scroll_view.dart
message FlutterAnimatedGridState {
  
}

// package:flutter/src/widgets/animated_scroll_view.dart
message FlutterAnimatedListState {
  
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates its opacity implicitly.
//
// The [opacity] argument must be between zero and one, inclusive.
message FlutterAnimatedOpacity {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The target opacity.
  //
  // An opacity of 1.0 is fully opaque. An opacity of 0.0 is fully transparent
  // (i.e., invisible).
  double opacity = 4;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 5;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 6;
  // Whether the semantic information of the children is always included.
  //
  // Defaults to false.
  //
  // When true, regardless of the opacity settings the child semantic
  // information is exposed as if the widget were fully visible. This is
  // useful in cases where labels may be hidden during animations that
  // would otherwise contribute relevant semantics.
  bool always_include_semantics = 8;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that insets its child by a value that animates
// implicitly.
message FlutterAnimatedPadding {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The amount of space by which to inset the child.
  FlutterEdgeInsetsGeometryType padding = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 5;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 6;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates the properties of a [PhysicalModel].
//
// The [elevation] must be non-negative.
//
// Animating [color] is optional and is controlled by the [animateColor] flag.
//
// Animating [shadowColor] is optional and is controlled by the [animateShadowColor] flag.
message FlutterAnimatedPhysicalModel {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The type of shape.
  //
  // This property is not animated.
  FlutterBoxShapeType.Enum shape = 4;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 5;
  // The target border radius of the rounded corners for a rectangle shape.
  FlutterBorderRadiusType border_radius = 6;
  // The target z-coordinate relative to the parent at which to place this
  // physical object.
  //
  // The value will always be non-negative.
  double elevation = 7;
  // The target background color.
  DartColorType color = 8;
  // Whether the color should be animated.
  bool animate_color = 9;
  // The target shadow color.
  DartColorType shadow_color = 10;
  // Whether the shadow color should be animated.
  bool animate_shadow_color = 11;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 12;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 13;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates its position implicitly.
//
// Only two out of the three horizontal values ([left], [right],
// [width]), and only two out of the three vertical values ([top],
// [bottom], [height]), can be set. In each case, at least one of
// the three must be null.
message FlutterAnimatedPositioned {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The offset of the child's left edge from the left of the stack.
  double left = 4;
  // The offset of the child's top edge from the top of the stack.
  double top = 5;
  // The offset of the child's right edge from the right of the stack.
  double right = 6;
  // The offset of the child's bottom edge from the bottom of the stack.
  double bottom = 7;
  // The child's width.
  //
  // Only two out of the three horizontal values ([left], [right], [width]) can
  // be set. The third must be null.
  double width = 8;
  // The child's height.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can
  // be set. The third must be null.
  double height = 9;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 10;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 11;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates its position implicitly.
//
// Only two out of the three horizontal values ([start], [end], [width]), and
// only two out of the three vertical values ([top], [bottom], [height]), can
// be set. In each case, at least one of the three must be null.
message FlutterAnimatedPositionedDirectional {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The offset of the child's start edge from the start of the stack.
  double start = 4;
  // The offset of the child's top edge from the top of the stack.
  double top = 5;
  // The offset of the child's end edge from the end of the stack.
  double end = 6;
  // The offset of the child's bottom edge from the bottom of the stack.
  double bottom = 7;
  // The child's width.
  //
  // Only two out of the three horizontal values ([start], [end], [width]) can
  // be set. The third must be null.
  double width = 8;
  // The child's height.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can
  // be set. The third must be null.
  double height = 9;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 10;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 11;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates the rectangle it occupies implicitly.
message FlutterAnimatedPositionedNamedFromRect {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  DartRectType rect = 4;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 5;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 6;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates its rotation implicitly.
message FlutterAnimatedRotation {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The animation that controls the rotation of the child.
  //
  // If the current value of the turns animation is v, the child will be
  // rotated v * 2 * pi radians before being painted.
  double turns = 4;
  // The alignment of the origin of the coordinate system in which the rotation
  // takes place, relative to the size of the box.
  //
  // For example, to set the origin of the rotation to bottom middle, you can use
  // an alignment of (0.0, 1.0).
  FlutterAlignmentType alignment = 5;
  // The filter quality with which to apply the transform as a bitmap operation.
  //
  // {@macro flutter.widgets.Transform.optional.FilterQuality}
  DartFilterQualityType.Enum filter_quality = 6;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 7;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 8;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates its scale implicitly.
message FlutterAnimatedScale {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The target scale.
  double scale = 4;
  // The alignment of the origin of the coordinate system in which the scale
  // takes place, relative to the size of the box.
  //
  // For example, to set the origin of the scale to bottom middle, you can use
  // an alignment of (0.0, 1.0).
  FlutterAlignmentType alignment = 5;
  // The filter quality with which to apply the transform as a bitmap operation.
  //
  // {@macro flutter.widgets.Transform.optional.FilterQuality}
  DartFilterQualityType.Enum filter_quality = 6;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 7;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 8;
}

// package:flutter/src/widgets/animated_size.dart
//
// Creates a widget that animates its size to match that of its child.
message FlutterAnimatedSize {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The alignment of the child within the parent when the parent is not yet
  // the same size as the child.
  //
  // The x and y values of the alignment control the horizontal and vertical
  // alignment, respectively. An x value of -1.0 means that the left edge of
  // the child is aligned with the left edge of the parent whereas an x value
  // of 1.0 means that the right edge of the child is aligned with the right
  // edge of the parent. Other values interpolate (and extrapolate) linearly.
  // For example, a value of 0.0 means that the center of the child is aligned
  // with the center of the parent.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 4;
  // The animation curve when transitioning this widget's size to match the
  // child's size.
  FlutterSrcAnimationCurveType curve = 5;
  // The duration when transitioning this widget's size to match the child's
  // size.
  DartDurationType duration = 6;
  // The duration when transitioning this widget's size to match the child's
  // size when going in reverse.
  //
  // If not specified, defaults to [duration].
  DartDurationType reverse_duration = 7;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 8;
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates its offset translation implicitly.
message FlutterAnimatedSlide {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The target offset.
  // The child will be translated horizontally by `width * dx` and vertically by `height * dy`
  DartOffsetType offset = 4;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 5;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 6;
}

// package:flutter/src/widgets/animated_switcher.dart
//
// Creates an [AnimatedSwitcher].
message FlutterAnimatedSwitcher {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The current child widget to display. If there was a previous child, then
  // that child will be faded out using the [switchOutCurve], while the new
  // child is faded in with the [switchInCurve], over the [duration].
  //
  // If there was no previous child, then this child will fade in using the
  // [switchInCurve] over the [duration].
  //
  // The child is considered to be "new" if it has a different type or [Key]
  // (see [Widget.canUpdate]).
  //
  // To change the kind of transition used, see [transitionBuilder].
  WidgetType child = 3;
  // The duration of the transition from the old [child] value to the new one.
  //
  // This duration is applied to the given [child] when that property is set to
  // a new child. The same duration is used when fading out, unless
  // [reverseDuration] is set. Changing [duration] will not affect the
  // durations of transitions already in progress.
  DartDurationType duration = 4;
  // The duration of the transition from the new [child] value to the old one.
  //
  // This duration is applied to the given [child] when that property is set to
  // a new child. Changing [reverseDuration] will not affect the durations of
  // transitions already in progress.
  //
  // If not set, then the value of [duration] is used by default.
  DartDurationType reverse_duration = 5;
  // The animation curve to use when transitioning in a new [child].
  //
  // This curve is applied to the given [child] when that property is set to a
  // new child. Changing [switchInCurve] will not affect the curve of a
  // transition already in progress.
  //
  // The [switchOutCurve] is used when fading out, except that if [child] is
  // changed while the current child is in the middle of fading in,
  // [switchInCurve] will be run in reverse from that point instead of jumping
  // to the corresponding point on [switchOutCurve].
  FlutterSrcAnimationCurveType switch_in_curve = 6;
  // The animation curve to use when transitioning a previous [child] out.
  //
  // This curve is applied to the [child] when the child is faded in (or when
  // the widget is created, for the first child). Changing [switchOutCurve]
  // will not affect the curves of already-visible widgets, it only affects the
  // curves of future children.
  //
  // If [child] is changed while the current child is in the middle of fading
  // in, [switchInCurve] will be run in reverse from that point instead of
  // jumping to the corresponding point on [switchOutCurve].
  FlutterSrcAnimationCurveType switch_out_curve = 7;
}

// package:flutter/src/widgets/platform_view.dart
//
// Creates a widget that embeds a macOS AppKit NSView.
message FlutterAppKitView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The unique identifier for iOS view type to be embedded by this widget.
  //
  // A PlatformViewFactory for this type must have been registered.
  string view_type = 3;
  // {@macro flutter.widgets.AndroidView.hitTestBehavior}
  FlutterPlatformViewHitTestBehaviorType.Enum hit_test_behavior = 5;
  // {@macro flutter.widgets.AndroidView.layoutDirection}
  DartTextDirectionType.Enum layout_direction = 6;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget with a specific aspect ratio.
//
// The [aspectRatio] argument must be a finite number greater than zero.
message FlutterAspectRatio {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The aspect ratio to attempt to use.
  //
  // The aspect ratio is expressed as a ratio of width to height. For example,
  // a 16:9 width:height aspect ratio would have a value of 16.0/9.0.
  double aspect_ratio = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/autocomplete.dart
//
// Creates an instance of AutocompleteNextOptionIntent.
message FlutterAutocompleteNextOptionIntent {
  
}

// package:flutter/src/widgets/autocomplete.dart
//
// Creates an instance of AutocompletePreviousOptionIntent.
message FlutterAutocompletePreviousOptionIntent {
  
}

// package:flutter/src/widgets/autofill.dart
//
// Creates a scope for autofillable input fields.
message FlutterAutofillGroup {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The [AutofillContextAction] to be run when this [AutofillGroup] is the
  // topmost [AutofillGroup] and it's being disposed, in order to clean up the
  // current autofill context.
  //
  // {@macro flutter.services.TextInput.finishAutofillContext}
  //
  // Defaults to [AutofillContextAction.commit], which prompts the platform to
  // save the user input and destroy the current autofill context.
  FlutterAutofillContextActionType.Enum on_dispose_action = 4;
}

// package:flutter/src/widgets/automatic_keep_alive.dart
//
// Creates a widget that listens to [KeepAliveNotification]s and maintains a
// [KeepAlive] widget appropriately.
message FlutterAutomaticKeepAlive {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/painting/notched_shapes.dart
//
// Creates a [NotchedShape] that is defined by two [ShapeBorder]s.
//
// The [guest] may be null, in which case no notch is created even
// if a guest rectangle is provided to [getOuterPath].
message FlutterAutomaticNotchedShape {
  // The shape of the widget that uses the [NotchedShape] (typically a
  // [BottomAppBar]).
  //
  // This shape cannot depend on the [TextDirection], as no text direction
  // is available to [NotchedShape]s.
  FlutterShapeBorderType host = 2;
  // The shape to subtract from the [host] to make the notch.
  //
  // This shape cannot depend on the [TextDirection], as no text direction
  // is available to [NotchedShape]s.
  //
  // If this is null, [getOuterPath] ignores the guest rectangle.
  FlutterShapeBorderType guest = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a backdrop filter.
//
// The [blendMode] argument will default to [BlendMode.srcOver] and must not be
// null if provided.
message FlutterBackdropFilter {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The image filter to apply to the existing painted content before painting the child.
  //
  // For example, consider using [ImageFilter.blur] to create a backdrop
  // blur effect.
  DartImageFilterType filter = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
  // The blend mode to use to apply the filtered background content onto the background
  // surface.
  //
  // {@macro flutter.widgets.BackdropFilter.blendMode}
  DartBlendModeType.Enum blend_mode = 5;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a backdrop filter layer.
//
// The [filter] property must be non-null before the compositing phase of the
// pipeline.
//
// The [blendMode] property defaults to [BlendMode.srcOver].
message FlutterBackdropFilterLayer {
  DartImageFilterType filter = 2;
  DartBlendModeType.Enum blend_mode = 3;
}

// package:flutter/src/widgets/banner.dart
//
// Creates a banner.
message FlutterBanner {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget to show behind the banner.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The message to show in the banner.
  string message = 4;
  // The directionality of the text.
  //
  // This is used to disambiguate how to render bidirectional text. For
  // example, if the message is an English phrase followed by a Hebrew phrase,
  // in a [TextDirection.ltr] context the English phrase will be on the left
  // and the Hebrew phrase to its right, while in a [TextDirection.rtl]
  // context, the English phrase will be on the right and the Hebrew phrase on
  // its left.
  //
  // Defaults to the ambient [Directionality], if any.
  //
  // See also:
  //
  //  * [layoutDirection], which controls the interpretation of the [location].
  DartTextDirectionType.Enum text_direction = 5;
  // Where to show the banner (e.g., the upper right corner).
  FlutterBannerLocationType.Enum location = 6;
  // The directionality of the layout.
  //
  // This is used to resolve the [location] values.
  //
  // Defaults to the ambient [Directionality], if any.
  //
  // See also:
  //
  //  * [textDirection], which controls the reading direction of the [message].
  DartTextDirectionType.Enum layout_direction = 7;
  // The color of the banner.
  DartColorType color = 8;
  // The style of the text shown on the banner.
  FlutterTextStyleType text_style = 9;
}

// package:flutter/src/widgets/banner.dart
//
// Creates a banner painter.
message FlutterBannerPainter {
  // The message to show in the banner.
  string message = 2;
  // The directionality of the text.
  //
  // This value is used to disambiguate how to render bidirectional text. For
  // example, if the message is an English phrase followed by a Hebrew phrase,
  // in a [TextDirection.ltr] context the English phrase will be on the left
  // and the Hebrew phrase to its right, while in a [TextDirection.rtl]
  // context, the English phrase will be on the right and the Hebrew phrase on
  // its left.
  //
  // See also:
  //
  //  * [layoutDirection], which controls the interpretation of values in
  //    [location].
  DartTextDirectionType.Enum text_direction = 3;
  // Where to show the banner (e.g., the upper right corner).
  FlutterBannerLocationType.Enum location = 4;
  // The directionality of the layout.
  //
  // This value is used to interpret the [location] of the banner.
  //
  // See also:
  //
  //  * [textDirection], which controls the reading direction of the [message].
  DartTextDirectionType.Enum layout_direction = 5;
  // The color to paint behind the [message].
  //
  // Defaults to a dark red.
  DartColorType color = 6;
  // The text style to use for the [message].
  //
  // Defaults to bold, white text.
  FlutterTextStyleType text_style = 7;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that positions its child according to the child's baseline.
message FlutterBaseline {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The number of logical pixels from the top of this box at which to position
  // the child's baseline.
  double baseline = 3;
  // The type of baseline to use for positioning the child.
  DartTextBaselineType.Enum baseline_type = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/painting/beveled_rectangle_border.dart
//
// Creates a border like a [RoundedRectangleBorder] except that the corners
// are joined by straight lines instead of arcs.
message FlutterBeveledRectangleBorder {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  // The radii for each corner.
  //
  // Each corner [Radius] defines the endpoints of a line segment that
  // spans the corner. The endpoints are located in the same place as
  // they would be for [RoundedRectangleBorder], but they're connected
  // by a straight line instead of an arc.
  //
  // Negative radius values are clamped to 0.0 by [getInnerPath] and
  // [getOuterPath].
  FlutterBorderRadiusGeometryType border_radius = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that excludes the semantics of all widgets painted before
// it in the same semantic container.
message FlutterBlockSemantics {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this widget is blocking semantics of all widget that were painted
  // before it in the same semantic container.
  bool blocking = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/painting/box_border.dart
//
// Creates a border.
//
// All the sides of the border default to [BorderSide.none].
message FlutterBorder {
  FlutterBorderSideType top = 2;
  // The right side of this border.
  FlutterBorderSideType right = 3;
  FlutterBorderSideType bottom = 4;
  // The left side of this border.
  FlutterBorderSideType left = 5;
}

// package:flutter/src/painting/box_border.dart
//
// Creates a border.
//
// The [start] and [end] sides represent the horizontal sides; the start side
// is on the leading edge given the reading direction, and the end side is on
// the trailing edge. They are resolved during [paint].
//
// All the sides of the border default to [BorderSide.none].
message FlutterBorderDirectional {
  FlutterBorderSideType top = 2;
  // The start side of this border.
  //
  // This is the side on the left in left-to-right text and on the right in
  // right-to-left text.
  //
  // See also:
  //
  //  * [TextDirection], which is used to describe the reading direction.
  FlutterBorderSideType start = 3;
  // The end side of this border.
  //
  // This is the side on the right in left-to-right text and on the left in
  // right-to-left text.
  //
  // See also:
  //
  //  * [TextDirection], which is used to describe the reading direction.
  FlutterBorderSideType end = 4;
  FlutterBorderSideType bottom = 5;
}

// package:flutter/src/painting/box_border.dart
//
// A uniform border with all sides the same color and width.
//
// The sides default to black solid borders, one logical pixel wide.
message FlutterBorderNamedAll {
  DartColorType color = 2;
  double width = 3;
  FlutterBorderStyleType.Enum style = 4;
  double stroke_align = 5;
}

// package:flutter/src/painting/box_border.dart
//
// Creates a border whose sides are all the same.
message FlutterBorderNamedFromBorderSide {
  FlutterBorderSideType side = 2;
}

// package:flutter/src/painting/box_border.dart
//
// Creates a border with symmetrical vertical and horizontal sides.
//
// The `vertical` argument applies to the [left] and [right] sides, and the
// `horizontal` argument applies to the [top] and [bottom] sides.
//
// All arguments default to [BorderSide.none].
message FlutterBorderNamedSymmetric {
  FlutterBorderSideType vertical = 2;
  FlutterBorderSideType horizontal = 3;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a border radius where all radii are [radius].
message FlutterBorderRadiusDirectionalNamedAll {
  DartRadiusType radius = 2;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a border radius where all radii are [Radius.circular(radius)].
message FlutterBorderRadiusDirectionalNamedCircular {
  double radius = 2;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a horizontally symmetrical border radius where the start and end
// sides of the rectangle have the same radii.
message FlutterBorderRadiusDirectionalNamedHorizontal {
  DartRadiusType start = 2;
  DartRadiusType end = 3;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a border radius with only the given non-zero values. The other
// corners will be right angles.
message FlutterBorderRadiusDirectionalNamedOnly {
  // The top-start [Radius].
  DartRadiusType top_start = 2;
  // The top-end [Radius].
  DartRadiusType top_end = 3;
  // The bottom-start [Radius].
  DartRadiusType bottom_start = 4;
  // The bottom-end [Radius].
  DartRadiusType bottom_end = 5;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a vertically symmetric border radius where the top and bottom
// sides of the rectangle have the same radii.
message FlutterBorderRadiusDirectionalNamedVertical {
  DartRadiusType top = 2;
  DartRadiusType bottom = 3;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a border radius where all radii are [radius].
message FlutterBorderRadiusNamedAll {
  DartRadiusType radius = 2;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a border radius where all radii are [Radius.circular(radius)].
message FlutterBorderRadiusNamedCircular {
  double radius = 2;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a horizontally symmetrical border radius where the left and right
// sides of the rectangle have the same radii.
message FlutterBorderRadiusNamedHorizontal {
  DartRadiusType left = 2;
  DartRadiusType right = 3;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a border radius with only the given non-zero values. The other
// corners will be right angles.
message FlutterBorderRadiusNamedOnly {
  // The top-left [Radius].
  DartRadiusType top_left = 2;
  // The top-right [Radius].
  DartRadiusType top_right = 3;
  // The bottom-left [Radius].
  DartRadiusType bottom_left = 4;
  // The bottom-right [Radius].
  DartRadiusType bottom_right = 5;
}

// package:flutter/src/painting/border_radius.dart
//
// Creates a vertically symmetric border radius where the top and bottom
// sides of the rectangle have the same radii.
message FlutterBorderRadiusNamedVertical {
  DartRadiusType top = 2;
  DartRadiusType bottom = 3;
}

// package:flutter/src/painting/borders.dart
//
// Creates the side of a border.
//
// By default, the border is 1.0 logical pixels wide and solid black.
message FlutterBorderSide {
  // The color of this side of the border.
  DartColorType color = 2;
  // The width of this side of the border, in logical pixels.
  //
  // Setting width to 0.0 will result in a hairline border. This means that
  // the border will have the width of one physical pixel. Hairline
  // rendering takes shortcuts when the path overlaps a pixel more than once.
  // This means that it will render faster than otherwise, but it might
  // double-hit pixels, giving it a slightly darker/lighter result.
  //
  // To omit the border entirely, set the [style] to [BorderStyle.none].
  double width = 3;
  // The style of this side of the border.
  //
  // To omit a side, set [style] to [BorderStyle.none]. This skips
  // painting the border, but the border still has a [width].
  FlutterBorderStyleType.Enum style = 4;
  // The relative position of the stroke on a [BorderSide] in an
  // [OutlinedBorder] or [Border].
  //
  // Values typically range from -1.0 ([strokeAlignInside], inside border,
  // default) to 1.0 ([strokeAlignOutside], outside border), without any
  // bound constraints (e.g., a value of -2.0 is not typical, but allowed).
  // A value of 0 ([strokeAlignCenter]) will center the border on the edge
  // of the widget.
  //
  // When set to [strokeAlignInside], the stroke is drawn completely inside
  // the widget. For [strokeAlignCenter] and [strokeAlignOutside], a property
  // such as [Container.clipBehavior] can be used in an outside widget to clip
  // it. If [Container.decoration] has a border, the container may incorporate
  // [width] as additional padding:
  // - [strokeAlignInside] provides padding with full [width].
  // - [strokeAlignCenter] provides padding with half [width].
  // - [strokeAlignOutside] provides zero padding, as stroke is drawn entirely outside.
  //
  // This property is not honored by [toPaint] (because the [Paint] object
  // cannot represent it); it is intended that classes that use [BorderSide]
  // objects implement this property when painting borders by suitably
  // inflating or deflating their regions.
  //
  // {@tool dartpad}
  // This example shows an animation of how [strokeAlign] affects the drawing
  // when applied to borders of various shapes.
  //
  // ** See code in examples/api/lib/painting/borders/border_side.stroke_align.0.dart **
  // {@end-tool}
  double stroke_align = 5;
}

// package:flutter/src/widgets/bottom_navigation_bar_item.dart
//
// Creates an item that is used with [BottomNavigationBar.items].
//
// The argument [icon] should not be null and the argument [label] should not be null when used in a Material Design's [BottomNavigationBar].
message FlutterBottomNavigationBarItem {
  // A key to be passed through to the resultant widget.
  //
  // This allows the identification of different [BottomNavigationBarItem]s through their keys.
  //
  // When changing the number of bar items in response to a bar item being tapped, giving
  // each item a key will allow the inkwell / splash animation to be correctly positioned.
  FlutterKeyType key = 2;
  // The icon of the item.
  //
  // Typically the icon is an [Icon] or an [ImageIcon] widget. If another type
  // of widget is provided then it should configure itself to match the current
  // [IconTheme] size and color.
  //
  // If [activeIcon] is provided, this will only be displayed when the item is
  // not selected.
  //
  // To make the bottom navigation bar more accessible, consider choosing an
  // icon with a stroked and filled version, such as [Icons.cloud] and
  // [Icons.cloud_queue]. [icon] should be set to the stroked version and
  // [activeIcon] to the filled version.
  //
  // If a particular icon doesn't have a stroked or filled version, then don't
  // pair unrelated icons. Instead, make sure to use a
  // [BottomNavigationBarType.shifting].
  WidgetType icon = 3;
  // The text label for this [BottomNavigationBarItem].
  //
  // This will be used to create a [Text] widget to put in the bottom navigation bar.
  string label = 4;
  WidgetType active_icon = 5;
  // The color of the background radial animation for material [BottomNavigationBar].
  //
  // If the navigation bar's type is [BottomNavigationBarType.shifting], then
  // the entire bar is flooded with the [backgroundColor] when this item is
  // tapped. This will override [BottomNavigationBar.backgroundColor].
  //
  // Not used for [CupertinoTabBar]. Control the invariant bar color directly
  // via [CupertinoTabBar.backgroundColor].
  //
  // See also:
  //
  //  * [Icon.color] and [ImageIcon.color] to control the foreground color of
  //    the icons themselves.
  DartColorType background_color = 6;
  // The text to display in the [Tooltip] for this [BottomNavigationBarItem].
  //
  // A [Tooltip] will only appear on this item if [tooltip] is set to a non-empty string.
  //
  // Defaults to null, in which case the tooltip is not shown.
  string tooltip = 7;
}

// package:flutter/src/widgets/scroll_physics.dart
//
// Creates scroll physics that bounce back from the edge.
message FlutterBouncingScrollPhysics {
  // Used to determine parameters for friction simulations.
  FlutterScrollDecelerationRateType.Enum deceleration_rate = 2;
  // If non-null, determines the default behavior for each method.
  //
  // If a subclass of [ScrollPhysics] does not override a method, that subclass
  // will inherit an implementation from this base class that defers to
  // [parent]. This mechanism lets you assemble novel combinations of
  // [ScrollPhysics] subclasses at runtime. For example:
  //
  // ```dart
  // const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
  // ```
  //
  // will result in a [ScrollPhysics] that has the combined behavior
  // of [BouncingScrollPhysics] and [AlwaysScrollableScrollPhysics]:
  // behaviors that are not specified in [BouncingScrollPhysics]
  // (e.g. [shouldAcceptUserOffset]) will defer to [AlwaysScrollableScrollPhysics].
  FlutterScrollPhysicsType parent = 3;
}

// package:flutter/src/rendering/box.dart
//
// Creates box constraints with the given constraints.
message FlutterBoxConstraints {
  // The minimum width that satisfies the constraints.
  double min_width = 2;
  // The maximum width that satisfies the constraints.
  //
  // Might be [double.infinity].
  double max_width = 3;
  // The minimum height that satisfies the constraints.
  double min_height = 4;
  // The maximum height that satisfies the constraints.
  //
  // Might be [double.infinity].
  double max_height = 5;
}

// package:flutter/src/rendering/box.dart
//
// Creates box constraints that expand to fill another box constraints.
//
// If width or height is given, the constraints will require exactly the
// given value in the given dimension.
message FlutterBoxConstraintsNamedExpand {
  double width = 2;
  double height = 3;
}

// package:flutter/src/rendering/box.dart
//
// Creates box constraints that forbid sizes larger than the given size.
message FlutterBoxConstraintsNamedLoose {
  DartSizeType size = 2;
}

// package:flutter/src/rendering/box.dart
//
// Creates box constraints that is respected only by the given size.
message FlutterBoxConstraintsNamedTight {
  DartSizeType size = 2;
}

// package:flutter/src/rendering/box.dart
//
// Creates box constraints that require the given width or height.
//
// See also:
//
//  * [BoxConstraints.tightForFinite], which is similar but instead of
//    being tight if the value is non-null, is tight if the value is not
//    infinite.
message FlutterBoxConstraintsNamedTightFor {
  double width = 2;
  double height = 3;
}

// package:flutter/src/rendering/box.dart
//
// Creates box constraints that require the given width or height, except if
// they are infinite.
//
// See also:
//
//  * [BoxConstraints.tightFor], which is similar but instead of being
//    tight if the value is not infinite, is tight if the value is non-null.
message FlutterBoxConstraintsNamedTightForFinite {
  double width = 2;
  double height = 3;
}

// package:flutter/src/painting/box_decoration.dart
//
// Creates a box decoration.
//
// * If [color] is null, this decoration does not paint a background color.
// * If [image] is null, this decoration does not paint a background image.
// * If [border] is null, this decoration does not paint a border.
// * If [borderRadius] is null, this decoration uses more efficient background
//   painting commands. The [borderRadius] argument must be null if [shape] is
//   [BoxShape.circle].
// * If [boxShadow] is null, this decoration does not paint a shadow.
// * If [gradient] is null, this decoration does not paint gradients.
// * If [backgroundBlendMode] is null, this decoration paints with [BlendMode.srcOver]
message FlutterBoxDecoration {
  // The color to fill in the background of the box.
  //
  // The color is filled into the [shape] of the box (e.g., either a rectangle,
  // potentially with a [borderRadius], or a circle).
  //
  // This is ignored if [gradient] is non-null.
  //
  // The [color] is drawn under the [image].
  DartColorType color = 2;
  // A border to draw above the background [color], [gradient], or [image].
  //
  // Follows the [shape] and [borderRadius].
  //
  // Use [Border] objects to describe borders that do not depend on the reading
  // direction.
  //
  // Use [BoxBorder] objects to describe borders that should flip their left
  // and right edges based on whether the text is being read left-to-right or
  // right-to-left.
  FlutterBoxBorderType border = 4;
  // If non-null, the corners of this box are rounded by this [BorderRadius].
  //
  // Applies only to boxes with rectangular shapes; ignored if [shape] is not
  // [BoxShape.rectangle].
  //
  // {@macro flutter.painting.BoxDecoration.clip}
  FlutterBorderRadiusGeometryType border_radius = 5;
  // A list of shadows cast by this box behind the box.
  //
  // The shadow follows the [shape] of the box.
  //
  // See also:
  //
  //  * [kElevationToShadow], for some predefined shadows used in Material
  //    Design.
  //  * [PhysicalModel], a widget for showing shadows.
  repeated FlutterBoxShadowType box_shadow = 6;
  // A gradient to use when filling the box.
  //
  // If this is specified, [color] has no effect.
  //
  // The [gradient] is drawn under the [image].
  FlutterGradientType gradient = 7;
  // The blend mode applied to the [color] or [gradient] background of the box.
  //
  // If no [backgroundBlendMode] is provided then the default painting blend
  // mode is used.
  //
  // If no [color] or [gradient] is provided then the blend mode has no impact.
  DartBlendModeType.Enum background_blend_mode = 8;
  // The shape to fill the background [color], [gradient], and [image] into and
  // to cast as the [boxShadow].
  //
  // If this is [BoxShape.circle] then [borderRadius] is ignored.
  //
  // The [shape] cannot be interpolated; animating between two [BoxDecoration]s
  // with different [shape]s will result in a discontinuity in the rendering.
  // To interpolate between two shapes, consider using [ShapeDecoration] and
  // different [ShapeBorder]s; in particular, [CircleBorder] instead of
  // [BoxShape.circle] and [RoundedRectangleBorder] instead of
  // [BoxShape.rectangle].
  //
  // {@macro flutter.painting.BoxDecoration.clip}
  FlutterBoxShapeType.Enum shape = 9;
}

// package:flutter/src/painting/box_shadow.dart
//
// Creates a box shadow.
//
// By default, the shadow is solid black with zero [offset], zero [blurRadius],
// zero [spreadRadius], and [BlurStyle.normal].
message FlutterBoxShadow {
  // Color that the shadow will be drawn with.
  //
  // The shadows are shapes composited directly over the base canvas, and do not
  // represent optical occlusion.
  DartColorType color = 2;
  // The displacement of the shadow from the casting element.
  //
  // Positive x/y offsets will shift the shadow to the right and down, while
  // negative offsets shift the shadow to the left and up. The offsets are
  // relative to the position of the element that is casting it.
  DartOffsetType offset = 3;
  // The standard deviation of the Gaussian to convolve with the shadow's shape.
  double blur_radius = 4;
  // The amount the box should be inflated prior to applying the blur.
  double spread_radius = 5;
  // The [BlurStyle] to use for this shadow.
  //
  // Defaults to [BlurStyle.normal].
  DartBlurStyleType.Enum blur_style = 6;
}

// package:flutter/src/widgets/actions.dart
//
// Creates an intent that activates the currently focused control,
// if it's a button.
message FlutterButtonActivateIntent {
  
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that centers its child.
message FlutterCenter {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If non-null, sets its width to the child's width multiplied by this factor.
  //
  // Can be both greater and less than 1.0 but must be non-negative.
  double width_factor = 3;
  // If non-null, sets its height to the child's height multiplied by this factor.
  //
  // Can be both greater and less than 1.0 but must be non-negative.
  double height_factor = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/widgets/banner.dart
//
// Creates a const debug mode banner.
message FlutterCheckedModeBanner {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget to show behind the banner.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/router.dart
//
// Creates a back button dispatcher that acts as the child of another.
message FlutterChildBackButtonDispatcher {
  // The back button dispatcher that this object will attempt to take priority
  // over when [takePriority] is called.
  //
  // The parent must have a listener registered before this child object can
  // have its [takePriority] or [deferTo] methods used.
  FlutterBackButtonDispatcherType parent = 2;
}

// package:flutter/src/painting/circle_border.dart
//
// Create a circle border.
message FlutterCircleBorder {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  // Defines the ratio (0.0-1.0) from which the border will deform
  // to fit a rectangle.
  // When 0.0, it draws a circle touching at least two sides of the rectangle.
  // When 1.0, it draws an oval touching all sides of the rectangle.
  double eccentricity = 3;
}

// package:flutter/src/painting/notched_shapes.dart
//
// Creates a [CircularNotchedRectangle].
//
// The same object can be used to create multiple shapes.
message FlutterCircularNotchedRectangle {
  
}

// package:flutter/src/widgets/scroll_physics.dart
//
// Creates scroll physics that prevent the scroll offset from exceeding the
// bounds of the content.
message FlutterClampingScrollPhysics {
  // If non-null, determines the default behavior for each method.
  //
  // If a subclass of [ScrollPhysics] does not override a method, that subclass
  // will inherit an implementation from this base class that defers to
  // [parent]. This mechanism lets you assemble novel combinations of
  // [ScrollPhysics] subclasses at runtime. For example:
  //
  // ```dart
  // const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
  // ```
  //
  // will result in a [ScrollPhysics] that has the combined behavior
  // of [BouncingScrollPhysics] and [AlwaysScrollableScrollPhysics]:
  // behaviors that are not specified in [BouncingScrollPhysics]
  // (e.g. [shouldAcceptUserOffset]) will defer to [AlwaysScrollableScrollPhysics].
  FlutterScrollPhysicsType parent = 2;
}

// package:flutter/src/widgets/basic.dart
//
// Creates an oval-shaped clip.
//
// If [clipper] is null, the oval will be inscribed into the layout size and
// position of the child.
//
// If [clipBehavior] is [Clip.none], no clipping will be applied.
message FlutterClipOval {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.rendering.ClipRectLayer.clipBehavior}
  //
  // Defaults to [Clip.antiAlias].
  DartClipType.Enum clip_behavior = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a path clip.
//
// If [clipper] is null, the clip will be a rectangle that matches the layout
// size and location of the child. However, rather than use this default,
// consider using a [ClipRect], which can achieve the same effect more
// efficiently.
//
// If [clipBehavior] is [Clip.none], no clipping will be applied.
message FlutterClipPath {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.rendering.ClipRectLayer.clipBehavior}
  //
  // Defaults to [Clip.antiAlias].
  DartClipType.Enum clip_behavior = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a layer with a path-based clip.
//
// The [clipPath] and [clipBehavior] properties must be non-null before the
// compositing phase of the pipeline.
message FlutterClipPathLayer {
  DartPathType clip_path = 2;
  DartClipType.Enum clip_behavior = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a rounded-rectangular clip.
//
// The [borderRadius] defaults to [BorderRadius.zero], i.e. a rectangle with
// right-angled corners.
//
// If [clipper] is non-null, then [borderRadius] is ignored.
//
// If [clipBehavior] is [Clip.none], no clipping will be applied.
message FlutterClipRRect {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The border radius of the rounded corners.
  //
  // Values are clamped so that horizontal and vertical radii sums do not
  // exceed width/height.
  //
  // This value is ignored if [clipper] is non-null.
  FlutterBorderRadiusGeometryType border_radius = 3;
  // {@macro flutter.rendering.ClipRectLayer.clipBehavior}
  //
  // Defaults to [Clip.antiAlias].
  DartClipType.Enum clip_behavior = 5;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 6;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a layer with a rounded-rectangular clip.
//
// The [clipRRect] and [clipBehavior] properties must be non-null before the
// compositing phase of the pipeline.
message FlutterClipRRectLayer {
  DartRRectType clip_r_rect = 2;
  DartClipType.Enum clip_behavior = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a rectangular clip.
//
// If [clipper] is null, the clip will match the layout size and position of
// the child.
//
// If [clipBehavior] is [Clip.none], no clipping will be applied.
message FlutterClipRect {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.rendering.ClipRectLayer.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a layer with a rectangular clip.
//
// The [clipRect] argument must not be null before the compositing phase of
// the pipeline.
//
// The [clipBehavior] argument must not be [Clip.none].
message FlutterClipRectLayer {
  DartRectType clip_rect = 2;
  DartClipType.Enum clip_behavior = 3;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a layer that applies a [ColorFilter] to its children.
//
// The [colorFilter] property must be non-null before the compositing phase
// of the pipeline.
message FlutterColorFilterLayer {
  DartColorFilterType color_filter = 2;
}

// package:flutter/src/widgets/color_filter.dart
//
// Creates a widget that applies a [ColorFilter] to its child.
message FlutterColorFiltered {
  // The color filter to apply to the child of this widget.
  DartColorFilterType color_filter = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 4;
}

// package:flutter/src/painting/colors.dart
//
// Create a diagnostics property for [Color].
message FlutterColorProperty {
  string name = 2;
  DartColorType value = 3;
  bool show_name = 4;
  FlutterDiagnosticsTreeStyleType.Enum style = 6;
  FlutterDiagnosticLevelType.Enum level = 7;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that paints its area with the specified [Color].
message FlutterColoredBox {
  // The color to paint the background area with.
  DartColorType color = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a vertical array of children.
//
// If [crossAxisAlignment] is [CrossAxisAlignment.baseline], then
// [textBaseline] must not be null.
//
// The [textDirection] argument defaults to the ambient [Directionality], if
// any. If there is no ambient directionality, and a text direction is going
// to be necessary to disambiguate `start` or `end` values for the
// [crossAxisAlignment], the [textDirection] must not be null.
message FlutterColumn {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How the children should be placed along the main axis.
  //
  // For example, [MainAxisAlignment.start], the default, places the children
  // at the start (i.e., the left for a [Row] or the top for a [Column]) of the
  // main axis.
  FlutterMainAxisAlignmentType.Enum main_axis_alignment = 3;
  // How much space should be occupied in the main axis.
  //
  // After allocating space to children, there might be some remaining free
  // space. This value controls whether to maximize or minimize the amount of
  // free space, subject to the incoming layout constraints.
  //
  // If some children have a non-zero flex factors (and none have a fit of
  // [FlexFit.loose]), they will expand to consume all the available space and
  // there will be no remaining free space to maximize or minimize, making this
  // value irrelevant to the final layout.
  FlutterMainAxisSizeType.Enum main_axis_size = 4;
  // How the children should be placed along the cross axis.
  //
  // For example, [CrossAxisAlignment.center], the default, centers the
  // children in the cross axis (e.g., horizontally for a [Column]).
  FlutterCrossAxisAlignmentType.Enum cross_axis_alignment = 5;
  // Determines the order to lay children out horizontally and how to interpret
  // `start` and `end` in the horizontal direction.
  //
  // Defaults to the ambient [Directionality].
  //
  // If [textDirection] is [TextDirection.rtl], then the direction in which
  // text flows starts from right to left. Otherwise, if [textDirection] is
  // [TextDirection.ltr], then the direction in which text flows starts from
  // left to right.
  //
  // If the [direction] is [Axis.horizontal], this controls the order in which
  // the children are positioned (left-to-right or right-to-left), and the
  // meaning of the [mainAxisAlignment] property's [MainAxisAlignment.start] and
  // [MainAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.horizontal], and either the
  // [mainAxisAlignment] is either [MainAxisAlignment.start] or
  // [MainAxisAlignment.end], or there's more than one child, then the
  // [textDirection] (or the ambient [Directionality]) must not be null.
  //
  // If the [direction] is [Axis.vertical], this controls the meaning of the
  // [crossAxisAlignment] property's [CrossAxisAlignment.start] and
  // [CrossAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.vertical], and the [crossAxisAlignment] is
  // either [CrossAxisAlignment.start] or [CrossAxisAlignment.end], then the
  // [textDirection] (or the ambient [Directionality]) must not be null.
  DartTextDirectionType.Enum text_direction = 6;
  // Determines the order to lay children out vertically and how to interpret
  // `start` and `end` in the vertical direction.
  //
  // Defaults to [VerticalDirection.down].
  //
  // If the [direction] is [Axis.vertical], this controls which order children
  // are painted in (down or up), the meaning of the [mainAxisAlignment]
  // property's [MainAxisAlignment.start] and [MainAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.vertical], and either the [mainAxisAlignment]
  // is either [MainAxisAlignment.start] or [MainAxisAlignment.end], or there's
  // more than one child, then the [verticalDirection] must not be null.
  //
  // If the [direction] is [Axis.horizontal], this controls the meaning of the
  // [crossAxisAlignment] property's [CrossAxisAlignment.start] and
  // [CrossAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.horizontal], and the [crossAxisAlignment] is
  // either [CrossAxisAlignment.start] or [CrossAxisAlignment.end], then the
  // [verticalDirection] must not be null.
  FlutterVerticalDirectionType.Enum vertical_direction = 7;
  // If aligning items according to their baseline, which baseline to use.
  //
  // This must be set if using baseline alignment. There is no default because there is no
  // way for the framework to know the correct baseline _a priori_.
  DartTextBaselineType.Enum text_baseline = 8;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 9;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a composited transform target widget.
//
// If the [link] property was also provided to a [CompositedTransformTarget],
// that widget must come earlier in the paint order.
//
// The [showWhenUnlinked] and [offset] properties must also not be null.
message FlutterCompositedTransformFollower {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The link object that connects this [CompositedTransformFollower] with a
  // [CompositedTransformTarget].
  FlutterLayerLinkType link = 3;
  // Whether to show the widget's contents when there is no corresponding
  // [CompositedTransformTarget] with the same [link].
  //
  // When the widget is linked, the child is positioned such that it has the
  // same global position as the linked [CompositedTransformTarget].
  //
  // When the widget is not linked, then: if [showWhenUnlinked] is true, the
  // child is visible and not repositioned; if it is false, then child is
  // hidden.
  bool show_when_unlinked = 4;
  // The additional offset to apply to the [targetAnchor] of the linked
  // [CompositedTransformTarget] to obtain this widget's [followerAnchor]
  // position.
  DartOffsetType offset = 5;
  // The anchor point on the linked [CompositedTransformTarget] that
  // [followerAnchor] will line up with.
  //
  // {@template flutter.widgets.CompositedTransformFollower.targetAnchor}
  // For example, when [targetAnchor] and [followerAnchor] are both
  // [Alignment.topLeft], this widget will be top left aligned with the linked
  // [CompositedTransformTarget]. When [targetAnchor] is
  // [Alignment.bottomLeft] and [followerAnchor] is [Alignment.topLeft], this
  // widget will be left aligned with the linked [CompositedTransformTarget],
  // and its top edge will line up with the [CompositedTransformTarget]'s
  // bottom edge.
  // {@endtemplate}
  //
  // Defaults to [Alignment.topLeft].
  FlutterAlignmentType target_anchor = 6;
  // The anchor point on this widget that will line up with [targetAnchor] on
  // the linked [CompositedTransformTarget].
  //
  // {@macro flutter.widgets.CompositedTransformFollower.targetAnchor}
  //
  // Defaults to [Alignment.topLeft].
  FlutterAlignmentType follower_anchor = 7;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 8;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a composited transform target widget.
//
// The [link] property must not be currently used by any other
// [CompositedTransformTarget] object that is in the tree.
message FlutterCompositedTransformTarget {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The link object that connects this [CompositedTransformTarget] with one or
  // more [CompositedTransformFollower]s.
  //
  // The link must not be associated with another [CompositedTransformTarget]
  // that is also being painted.
  FlutterLayerLinkType link = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that imposes additional constraints on its child.
message FlutterConstrainedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The additional constraints to impose on the child.
  FlutterBoxConstraintsType constraints = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/container.dart
//
// Creates a widget that combines common painting, positioning, and sizing widgets.
//
// The `height` and `width` values include the padding.
//
// The `color` and `decoration` arguments cannot both be supplied, since
// it would potentially result in the decoration drawing over the background
// color. To supply a decoration with a color, use `decoration:
// BoxDecoration(color: color)`.
message FlutterContainer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Align the [child] within the container.
  //
  // If non-null, the container will expand to fill its parent and position its
  // child within itself according to the given value. If the incoming
  // constraints are unbounded, then the child will be shrink-wrapped instead.
  //
  // Ignored if [child] is null.
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 3;
  // Empty space to inscribe inside the [decoration]. The [child], if any, is
  // placed inside this padding.
  //
  // This padding is in addition to any padding inherent in the [decoration];
  // see [Decoration.padding].
  FlutterEdgeInsetsGeometryType padding = 4;
  // The color to paint behind the [child].
  //
  // This property should be preferred when the background is a simple color.
  // For other cases, such as gradients or images, use the [decoration]
  // property.
  //
  // If the [decoration] is used, this property must be null. A background
  // color may still be painted by the [decoration] even if this property is
  // null.
  DartColorType color = 5;
  // The decoration to paint behind the [child].
  //
  // Use the [color] property to specify a simple solid color.
  //
  // The [child] is not clipped to the decoration. To clip a child to the shape
  // of a particular [ShapeDecoration], consider using a [ClipPath] widget.
  FlutterDecorationType decoration = 6;
  // The decoration to paint in front of the [child].
  FlutterDecorationType foreground_decoration = 7;
  double width = 8;
  double height = 9;
  FlutterBoxConstraintsType constraints = 10;
  // Empty space to surround the [decoration] and [child].
  FlutterEdgeInsetsGeometryType margin = 11;
  // The transformation matrix to apply before painting the container.
  VectorMathMatrix4Type transform = 12;
  // The alignment of the origin, relative to the size of the container, if [transform] is specified.
  //
  // When [transform] is null, the value of this property is ignored.
  //
  // See also:
  //
  //  * [Transform.alignment], which is set by this property.
  FlutterAlignmentGeometryType transform_alignment = 13;
  // The [child] contained by the container.
  //
  // If null, and if the [constraints] are unbounded or also null, the
  // container will expand to fill all available space in its parent, unless
  // the parent provides unbounded constraints, in which case the container
  // will attempt to be as small as possible.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 14;
  // The clip behavior when [Container.decoration] is not null.
  //
  // Defaults to [Clip.none]. Must be [Clip.none] if [decoration] is null.
  //
  // If a clip is to be applied, the [Decoration.getClipPath] method
  // for the provided decoration must return a clip path. (This is not
  // supported by all decorations; the default implementation of that
  // method throws an [UnsupportedError].)
  DartClipType.Enum clip_behavior = 15;
}

// package:flutter/src/rendering/layer.dart
message FlutterContainerLayer {
  
}

// package:flutter/src/widgets/context_menu_button_item.dart
//
// Creates a const instance of [ContextMenuButtonItem].
message FlutterContextMenuButtonItem {
  // The type of button this represents.
  FlutterContextMenuButtonTypeType.Enum type = 3;
  // The label to display on the button.
  //
  // If a [type] other than [ContextMenuButtonType.custom] is given
  // and a label is not provided, then the default label for that type for the
  // platform will be looked up.
  string label = 4;
}

// package:flutter/src/painting/continuous_rectangle_border.dart
//
// Creates a [ContinuousRectangleBorder].
message FlutterContinuousRectangleBorder {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  // The radius for each corner.
  //
  // Negative radius values are clamped to 0.0 by [getInnerPath] and
  // [getOuterPath].
  FlutterBorderRadiusGeometryType border_radius = 3;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [Intent] that represents a user interaction that attempts to
// cut the current selection in the field.
message FlutterCopySelectionTextIntentNamedCut {
  FlutterSelectionChangedCauseType.Enum cause = 2;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a custom multi-child layout.
message FlutterCustomMultiChildLayout {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that delegates its painting.
message FlutterCustomPaint {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The painter that paints before the children.
  FlutterCustomPainterType painter = 3;
  // The painter that paints after the children.
  FlutterCustomPainterType foreground_painter = 4;
  // The size that this [CustomPaint] should aim for, given the layout
  // constraints, if there is no child.
  //
  // Defaults to [Size.zero].
  //
  // If there's a child, this is ignored, and the size of the child is used
  // instead.
  DartSizeType size = 5;
  // Whether the painting is complex enough to benefit from caching.
  //
  // The compositor contains a raster cache that holds bitmaps of layers in
  // order to avoid the cost of repeatedly rendering those layers on each
  // frame. If this flag is not set, then the compositor will apply its own
  // heuristics to decide whether the layer containing this widget is complex
  // enough to benefit from caching.
  //
  // This flag can't be set to true if both [painter] and [foregroundPainter]
  // are null because this flag will be ignored in such case.
  bool is_complex = 6;
  // Whether the raster cache should be told that this painting is likely
  // to change in the next frame.
  //
  // This hint tells the compositor not to cache the layer containing this
  // widget because the cache will not be used in the future. If this hint is
  // not set, the compositor will apply its own heuristics to decide whether
  // the layer is likely to be reused in the future.
  //
  // This flag can't be set to true if both [painter] and [foregroundPainter]
  // are null because this flag will be ignored in such case.
  bool will_change = 7;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 8;
}

// package:flutter/src/widgets/scroll_view.dart
//
// Creates a [ScrollView] that creates custom scroll effects using slivers.
//
// See the [ScrollView] constructor for more details on these arguments.
message FlutterCustomScrollView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.scroll_view.scrollDirection}
  // The [Axis] along which the scroll view's offset increases.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.vertical].
  // {@endtemplate}
  FlutterAxisType.Enum scroll_direction = 3;
  // {@template flutter.widgets.scroll_view.reverse}
  // Whether the scroll view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  // {@endtemplate}
  bool reverse = 4;
  // {@template flutter.widgets.scroll_view.controller}
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // Must be null if [primary] is true.
  //
  // A [ScrollController] serves several purposes. It can be used to control
  // the initial scroll position (see [ScrollController.initialScrollOffset]).
  // It can be used to control whether the scroll view should automatically
  // save and restore its scroll position in the [PageStorage] (see
  // [ScrollController.keepScrollOffset]). It can be used to read the current
  // scroll position (see [ScrollController.offset]), or change it (see
  // [ScrollController.animateTo]).
  // {@endtemplate}
  FlutterScrollControllerType controller = 5;
  // {@template flutter.widgets.scroll_view.primary}
  // Whether this is the primary scroll view associated with the parent
  // [PrimaryScrollController].
  //
  // When this is true, the scroll view is scrollable even if it does not have
  // sufficient content to actually scroll. Otherwise, by default the user can
  // only scroll the view if it has sufficient content. See [physics].
  //
  // Also when true, the scroll view is used for default [ScrollAction]s. If a
  // ScrollAction is not handled by an otherwise focused part of the application,
  // the ScrollAction will be evaluated using this scroll view, for example,
  // when executing [Shortcuts] key events like page up and down.
  //
  // On iOS, this also identifies the scroll view that will scroll to top in
  // response to a tap in the status bar.
  //
  // Cannot be true while a [ScrollController] is provided to `controller`,
  // only one ScrollController can be associated with a ScrollView.
  //
  // Setting to false will explicitly prevent inheriting any
  // [PrimaryScrollController].
  //
  // Defaults to null. When null, and a controller is not provided,
  // [PrimaryScrollController.shouldInherit] is used to decide automatic
  // inheritance.
  //
  // By default, the [PrimaryScrollController] that is injected by each
  // [ModalRoute] is configured to automatically be inherited on
  // [TargetPlatformVariant.mobile] for ScrollViews in the [Axis.vertical]
  // scroll direction. Adding another to your app will override the
  // PrimaryScrollController above it.
  //
  // The following video contains more information about scroll controllers,
  // the PrimaryScrollController widget, and their impact on your apps:
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=33_0ABjFJUU}
  //
  // {@endtemplate}
  bool primary = 6;
  FlutterScrollPhysicsType physics = 7;
  // {@macro flutter.widgets.shadow.scrollBehavior}
  //
  // [ScrollBehavior]s also provide [ScrollPhysics]. If an explicit
  // [ScrollPhysics] is provided in [physics], it will take precedence,
  // followed by [scrollBehavior], and then the inherited ancestor
  // [ScrollBehavior].
  FlutterScrollBehaviorType scroll_behavior = 8;
  // {@template flutter.widgets.scroll_view.shrinkWrap}
  // Whether the extent of the scroll view in the [scrollDirection] should be
  // determined by the contents being viewed.
  //
  // If the scroll view does not shrink wrap, then the scroll view will expand
  // to the maximum allowed size in the [scrollDirection]. If the scroll view
  // has unbounded constraints in the [scrollDirection], then [shrinkWrap] must
  // be true.
  //
  // Shrink wrapping the content of the scroll view is significantly more
  // expensive than expanding to the maximum allowed size because the content
  // can expand and contract during scrolling, which means the size of the
  // scroll view needs to be recomputed whenever the scroll position changes.
  //
  // Defaults to false.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=LUqDNnv_dh0}
  // {@endtemplate}
  bool shrink_wrap = 9;
  // The first child in the [GrowthDirection.forward] growth direction.
  //
  // Children after [center] will be placed in the [AxisDirection] determined
  // by [scrollDirection] and [reverse] relative to the [center]. Children
  // before [center] will be placed in the opposite of the axis direction
  // relative to the [center]. This makes the [center] the inflection point of
  // the growth direction.
  //
  // The [center] must be the key of one of the slivers built by [buildSlivers].
  //
  // Of the built-in subclasses of [ScrollView], only [CustomScrollView]
  // supports [center]; for that class, the given key must be the key of one of
  // the slivers in the [CustomScrollView.slivers] list.
  //
  // Most scroll views by default are ordered [GrowthDirection.forward].
  // Changing the default values of [ScrollView.anchor],
  // [ScrollView.center], or both, can configure a scroll view for
  // [GrowthDirection.reverse].
  //
  // {@tool dartpad}
  // This sample shows a [CustomScrollView], with [Radio] buttons in the
  // [AppBar.bottom] that change the [AxisDirection] to illustrate different
  // configurations. The [CustomScrollView.anchor] and [CustomScrollView.center]
  // properties are also set to have the 0 scroll offset positioned in the middle
  // of the viewport, with [GrowthDirection.forward] and [GrowthDirection.reverse]
  // illustrated on either side. The sliver that shares the
  // [CustomScrollView.center] key is positioned at the [CustomScrollView.anchor].
  //
  // ** See code in examples/api/lib/rendering/growth_direction/growth_direction.0.dart **
  // {@end-tool}
  //
  // See also:
  //
  //  * [anchor], which controls where the [center] as aligned in the viewport.
  FlutterKeyType center = 10;
  // {@template flutter.widgets.scroll_view.anchor}
  // The relative position of the zero scroll offset.
  //
  // For example, if [anchor] is 0.5 and the [AxisDirection] determined by
  // [scrollDirection] and [reverse] is [AxisDirection.down] or
  // [AxisDirection.up], then the zero scroll offset is vertically centered
  // within the viewport. If the [anchor] is 1.0, and the axis direction is
  // [AxisDirection.right], then the zero scroll offset is on the left edge of
  // the viewport.
  //
  // Most scroll views by default are ordered [GrowthDirection.forward].
  // Changing the default values of [ScrollView.anchor],
  // [ScrollView.center], or both, can configure a scroll view for
  // [GrowthDirection.reverse].
  //
  // {@tool dartpad}
  // This sample shows a [CustomScrollView], with [Radio] buttons in the
  // [AppBar.bottom] that change the [AxisDirection] to illustrate different
  // configurations. The [CustomScrollView.anchor] and [CustomScrollView.center]
  // properties are also set to have the 0 scroll offset positioned in the middle
  // of the viewport, with [GrowthDirection.forward] and [GrowthDirection.reverse]
  // illustrated on either side. The sliver that shares the
  // [CustomScrollView.center] key is positioned at the [CustomScrollView.anchor].
  //
  // ** See code in examples/api/lib/rendering/growth_direction/growth_direction.0.dart **
  // {@end-tool}
  // {@endtemplate}
  double anchor = 11;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtent}
  double cache_extent = 12;
  // The slivers to place inside the viewport.
  //
  // ## What is a sliver?
  //
  // > _**sliver** (noun): a small, thin piece of something._
  //
  // A _sliver_ is a widget backed by a [RenderSliver] subclass, i.e. one that
  // implements the constraint/geometry protocol that uses [SliverConstraints]
  // and [SliverGeometry].
  //
  // This is as distinct from those widgets that are backed by [RenderBox]
  // subclasses, which use [BoxConstraints] and [Size] respectively, and are
  // known as box widgets. (Widgets like [Container], [Row], and [SizedBox] are
  // box widgets.)
  //
  // While boxes are much more straightforward (implementing a simple
  // two-dimensional Cartesian layout system), slivers are much more powerful,
  // and are optimized for one-axis scrolling environments.
  //
  // Slivers are hosted in viewports, also known as scroll views, most notably
  // [CustomScrollView].
  //
  // ## Examples of slivers
  //
  // The Flutter framework has many built-in sliver widgets, and custom widgets
  // can be created in the same manner. By convention, sliver widgets always
  // start with the prefix `Sliver` and are always used in properties called
  // `sliver` or `slivers` (as opposed to `child` and `children` which are used
  // for box widgets).
  //
  // Examples of widgets unique to the sliver world include:
  //
  // * [SliverList], a lazily-loading list of variably-sized box widgets.
  // * [SliverFixedExtentList], a lazily-loading list of box widgets that are
  //   all forced to the same height.
  // * [SliverPrototypeExtentList], a lazily-loading list of box widgets that
  //   are all forced to the same height as a given prototype widget.
  // * [SliverGrid], a lazily-loading grid of box widgets.
  // * [SliverAnimatedList] and [SliverAnimatedGrid], animated variants of
  //   [SliverList] and [SliverGrid].
  // * [SliverFillRemaining], a widget that fills all remaining space in a
  //   scroll view, and lays a box widget out inside that space.
  // * [SliverFillViewport], a widget that lays a list of boxes out, each
  //   being sized to fit the whole viewport.
  // * [SliverPersistentHeader], a sliver that implements pinned and floating
  //   headers, e.g. used to implement [SliverAppBar].
  // * [SliverToBoxAdapter], a sliver that wraps a box widget.
  //
  // Examples of sliver variants of common box widgets include:
  //
  // * [SliverOpacity], [SliverAnimatedOpacity], and [SliverFadeTransition],
  //   sliver versions of [Opacity], [AnimatedOpacity], and [FadeTransition].
  // * [SliverIgnorePointer], a sliver version of [IgnorePointer].
  // * [SliverLayoutBuilder], a sliver version of [LayoutBuilder].
  // * [SliverOffstage], a sliver version of [Offstage].
  // * [SliverPadding], a sliver version of [Padding].
  // * [SliverReorderableList], a sliver version of [ReorderableList]
  // * [SliverSafeArea], a sliver version of [SafeArea].
  // * [SliverVisibility], a sliver version of [Visibility].
  //
  // ## Benefits of slivers over boxes
  //
  // The sliver protocol ([SliverConstraints] and [SliverGeometry]) enables
  // _scroll effects_, such as floating app bars, widgets that expand and
  // shrink during scroll, section headers that are pinned only while the
  // section's children are visible, etc.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=Mz3kHQxBjGg}
  //
  // ## Mixing slivers and boxes
  //
  // In general, slivers always wrap box widgets to actually render anything
  // (for example, there is no sliver equivalent of [Text] or [Container]);
  // the sliver part of the equation is mostly about how these boxes should
  // be laid out in a viewport (i.e. when scrolling).
  //
  // Typically, the simplest way to combine boxes into a sliver environment is
  // to use a [SliverList] (maybe using a [ListView, which is a convenient
  // combination of a [CustomScrollView] and a [SliverList]). In rare cases,
  // e.g. if a single [Divider] widget is needed between two [SliverGrid]s,
  // a [SliverToBoxAdapter] can be used to wrap the box widgets.
  //
  // ## Performance considerations
  //
  // Because the purpose of scroll views is to, well, scroll, it is common
  // for scroll views to contain more contents than are rendered on the screen
  // at any particular time.
  //
  // To improve the performance of scroll views, the content can be rendered in
  // _lazy_ widgets, notably [SliverList] and [SliverGrid] (and their variants,
  // such as [SliverFixedExtentList] and [SliverAnimatedGrid]). These widgets
  // ensure that only the portion of their child lists that are actually
  // visible get built, laid out, and painted.
  //
  // The [ListView] and [GridView] widgets provide a convenient way to combine
  // a [CustomScrollView] and a [SliverList] or [SliverGrid] (respectively).
  repeated WidgetType slivers = 13;
  // The number of children that will contribute semantic information.
  //
  // Some subtypes of [ScrollView] can infer this value automatically. For
  // example [ListView] will use the number of widgets in the child list,
  // while the [ListView.separated] constructor will use half that amount.
  //
  // For [CustomScrollView] and other types which do not receive a builder
  // or list of widgets, the child count must be explicitly provided. If the
  // number is unknown or unbounded this should be left unset or set to null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.scrollChildCount], the corresponding semantics property.
  int32 semantic_child_count = 14;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 15;
  // {@template flutter.widgets.scroll_view.keyboardDismissBehavior}
  // [ScrollViewKeyboardDismissBehavior] the defines how this [ScrollView] will
  // dismiss the keyboard automatically.
  // {@endtemplate}
  FlutterScrollViewKeyboardDismissBehaviorType.Enum keyboard_dismiss_behavior = 16;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 17;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 18;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a custom single child layout.
message FlutterCustomSingleChildLayout {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The delegate that controls the layout of the child.
  FlutterSingleChildLayoutDelegateType delegate = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/container.dart
//
// Creates a widget that paints a [Decoration].
//
// By default the decoration paints behind the child.
message FlutterDecoratedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // What decoration to paint.
  //
  // Commonly a [BoxDecoration].
  FlutterDecorationType decoration = 3;
  // Whether to paint the box decoration behind or in front of the child.
  FlutterDecorationPositionType.Enum position = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/widgets/decorated_sliver.dart
//
// Creates a widget that paints a [Decoration].
//
// By default the decoration paints behind the child.
message FlutterDecoratedSliver {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // What decoration to paint.
  //
  // Commonly a [BoxDecoration].
  FlutterDecorationType decoration = 3;
  // Whether to paint the box decoration behind or in front of the child.
  FlutterDecorationPositionType.Enum position = 4;
  WidgetType sliver = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that determines the default asset bundle for its descendants.
message FlutterDefaultAssetBundle {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The bundle to use as a default.
  FlutterAssetBundleType bundle = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/default_selection_style.dart
//
// Creates a default selection style widget that specifies the selection
// properties for all widgets below it in the widget tree.
message FlutterDefaultSelectionStyle {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The color of the text field's cursor.
  //
  // The cursor indicates the current location of the text insertion point in
  // the field.
  DartColorType cursor_color = 3;
  // The background color of selected text.
  DartColorType selection_color = 4;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 6;
}

// package:flutter/src/widgets/default_selection_style.dart
//
// A const-constructable default selection style that provides fallback
// values (null).
//
// Returned from [of] when the given [BuildContext] doesn't have an enclosing
// default selection style.
//
// This constructor creates a [DefaultTextStyle] with an invalid [child],
// which means the constructed value cannot be incorporated into the tree.
message FlutterDefaultSelectionStyleNamedFallback {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
}

// package:flutter/src/services/spell_check.dart
//
// Creates service to spell check text input by default via communication
// over the spell check [MethodChannel].
message FlutterDefaultSpellCheckService {
  
}

// package:flutter/src/widgets/default_text_editing_shortcuts.dart
//
// Creates a [DefaultTextEditingShortcuts] widget that provides the default text editing
// shortcuts on the current platform.
message FlutterDefaultTextEditingShortcuts {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/text.dart
//
// Creates a default text height behavior for the given subtree.
message FlutterDefaultTextHeightBehavior {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/text.dart
//
// Creates a default text style for the given subtree.
//
// Consider using [DefaultTextStyle.merge] to inherit styling information
// from the current default text style for a given [BuildContext].
//
// The [maxLines] property may be null (and indeed defaults to null), but if
// it is not null, it must be greater than zero.
message FlutterDefaultTextStyle {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The text style to apply.
  FlutterTextStyleType style = 3;
  // How each line of text in the Text widget should be aligned horizontally.
  DartTextAlignType.Enum text_align = 4;
  // Whether the text should break at soft line breaks.
  //
  // If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.
  //
  // This also decides the [overflow] property's behavior. If this is true or null,
  // the glyph causing overflow, and those that follow, will not be rendered.
  bool soft_wrap = 5;
  // How visual overflow should be handled.
  //
  // If [softWrap] is true or null, the glyph causing overflow, and those that follow,
  // will not be rendered. Otherwise, it will be shown with the given overflow option.
  FlutterTextOverflowType.Enum overflow = 6;
  // An optional maximum number of lines for the text to span, wrapping if necessary.
  // If the text exceeds the given number of lines, it will be truncated according
  // to [overflow].
  //
  // If this is 1, text will not wrap. Otherwise, text will be wrapped at the
  // edge of the box.
  //
  // If this is non-null, it will override even explicit null values of
  // [Text.maxLines].
  int32 max_lines = 7;
  // The strategy to use when calculating the width of the Text.
  //
  // See [TextWidthBasis] for possible values and their implications.
  FlutterTextWidthBasisType.Enum text_width_basis = 8;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 9;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 10;
}

// package:flutter/src/widgets/text.dart
//
// A const-constructable default text style that provides fallback values.
//
// Returned from [of] when the given [BuildContext] doesn't have an enclosing default text style.
//
// This constructor creates a [DefaultTextStyle] with an invalid [child], which
// means the constructed value cannot be incorporated into the tree.
message FlutterDefaultTextStyleNamedFallback {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
}

// package:flutter/src/gestures/multidrag.dart
//
// Creates a drag recognizer that works on a per-pointer basis after a delay.
//
// In order for a drag to be recognized by this recognizer, the pointer must
// remain in the same place for [delay] (up to [kTouchSlop]). The [delay]
// defaults to [kLongPressTimeout] to match [LongPressGestureRecognizer] but
// can be changed for specific behaviors.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterDelayedMultiDragGestureRecognizer {
  // The amount of time the pointer must remain in the same place for the drag
  // to be recognized.
  DartDurationType delay = 2;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates a [DeleteCharacterIntent].
message FlutterDeleteCharacterIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates a [DeleteToLineBreakIntent].
message FlutterDeleteToLineBreakIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates a [DeleteToNextWordBoundaryIntent].
message FlutterDeleteToNextWordBoundaryIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/desktop_text_selection_toolbar_layout_delegate.dart
//
// Creates an instance of TextSelectionToolbarLayoutDelegate.
message FlutterDesktopTextSelectionToolbarLayoutDelegate {
  // The point at which to render the menu, if possible.
  //
  // Should be provided in local coordinates.
  DartOffsetType anchor = 2;
}

// package:flutter/src/widgets/widget_inspector.dart
//
// Creates a diagnostics property that displays a deep link to Flutter DevTools.
//
// The [value] of this property will return a map of data for the Flutter
// DevTools deep link, including the full `url`, the Flutter DevTools `screenId`,
// and the `objectId` in Flutter DevTools that this diagnostic references.
message FlutterDevToolsDeepLinkProperty {
  string description = 2;
  string url = 3;
}

// package:flutter/src/gestures/gesture_settings.dart
//
// Create a new [DeviceGestureSettings] with configured settings in logical
// pixels.
message FlutterDeviceGestureSettings {
  // The touch slop value in logical pixels, or `null` if it was not set.
  double touch_slop = 2;
}

// package:flutter/src/gestures/gesture_settings.dart
//
// Create a new [DeviceGestureSettings] from the provided [view].
message FlutterDeviceGestureSettingsNamedFromView {
  
}

// package:flutter/src/foundation/diagnostics.dart
//
// Creates a [DiagnosticableTreeNode].
message FlutterDiagnosticableTreeNode {
  string name = 2;
  FlutterDiagnosticableTreeType value = 3;
  FlutterDiagnosticsTreeStyleType.Enum style = 4;
}

// package:flutter/src/foundation/diagnostics.dart
//
// Creates a diagnostic with properties specified by [properties] and
// children specified by [children].
message FlutterDiagnosticsBlock {
  // Label describing the [DiagnosticsNode], typically shown before a separator
  // (see [showSeparator]).
  //
  // The name will be omitted if the [showName] property is false.
  string name = 2;
  // Hint for how the node should be displayed.
  FlutterDiagnosticsTreeStyleType.Enum style = 3;
  bool show_name = 4;
  // Whether to show a separator between [name] and description.
  //
  // If false, name and description should be shown with no separation.
  // `:` is typically used as a separator when displaying as text.
  bool show_separator = 5;
  // Prefix to include at the start of each line.
  string line_prefix = 6;
  string description = 8;
  FlutterDiagnosticLevelType.Enum level = 9;
  bool allow_truncate = 10;
  repeated FlutterDiagnosticsNodeType children = 11;
  repeated FlutterDiagnosticsNodeType properties = 12;
}

// package:flutter/src/foundation/diagnostics.dart
//
// Diagnostics containing just a string `message` and not a concrete name or
// value.
//
// See also:
//
//  * [MessageProperty], which is better suited to messages that are to be
//    formatted like a property with a separate name and message.
message FlutterDiagnosticsNodeNamedMessage {
  string message = 2;
  FlutterDiagnosticsTreeStyleType.Enum style = 3;
  FlutterDiagnosticLevelType.Enum level = 4;
  bool allow_wrap = 5;
}

// package:flutter/src/foundation/assertions.dart
//
// Creates a diagnostic for a stack trace.
//
// [name] describes a name the stack trace is given, e.g.
// `When the exception was thrown, this was the stack`.
// [stackFilter] provides an optional filter to use to filter which frames
// are included. If no filter is specified, [FlutterError.defaultStackFilter]
// is used.
// [showSeparator] indicates whether to include a ':' after the [name].
message FlutterDiagnosticsStackTrace {
  string name = 2;
  DartStackTraceType stack = 3;
  // Whether to show a separator between [name] and description.
  //
  // If false, name and description should be shown with no separation.
  // `:` is typically used as a separator when displaying as text.
  bool show_separator = 5;
}

// package:flutter/src/foundation/assertions.dart
//
// Creates a diagnostic describing a single frame from a StackTrace.
message FlutterDiagnosticsStackTraceNamedSingleFrame {
  string name = 2;
  string frame = 3;
  // Whether to show a separator between [name] and description.
  //
  // If false, name and description should be shown with no separation.
  // `:` is typically used as a separator when displaying as text.
  bool show_separator = 4;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Creates an intent used to move the focus in the given [direction].
message FlutterDirectionalFocusIntent {
  // The direction in which to look for the next focusable node when the
  // associated [DirectionalFocusAction] is invoked.
  FlutterTraversalDirectionType.Enum direction = 2;
  // If true, then directional focus actions that occur within a text field
  // will not happen when the focus node which received the key is a text
  // field.
  //
  // Defaults to true.
  bool ignore_text_fields = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that determines the directionality of text and
// text-direction-sensitive render objects.
message FlutterDirectionality {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The text direction for this subtree.
  DartTextDirectionType.Enum text_direction = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/actions.dart
//
// Creates an intent that dismisses the currently focused widget.
message FlutterDismissIntent {
  
}

// package:flutter/src/widgets/dismissible.dart
//
// Creates a widget that can be dismissed.
//
// The [key] argument is required because [Dismissible]s are commonly used in
// lists and removed from the list when dismissed. Without keys, the default
// behavior is to sync widgets based on their index in the list, which means
// the item after the dismissed item would be synced with the state of the
// dismissed item. Using keys causes the widgets to sync according to their
// keys and avoids this pitfall.
message FlutterDismissible {
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // A widget that is stacked behind the child. If secondaryBackground is also
  // specified then this widget only appears when the child has been dragged
  // down or to the right.
  WidgetType background = 4;
  // A widget that is stacked behind the child and is exposed when the child
  // has been dragged up or to the left. It may only be specified when background
  // has also been specified.
  WidgetType secondary_background = 5;
  // The direction in which the widget can be dismissed.
  FlutterDismissDirectionType.Enum direction = 10;
  // The amount of time the widget will spend contracting before [onDismissed] is called.
  //
  // If null, the widget will not contract and [onDismissed] will be called
  // immediately after the widget is dismissed.
  DartDurationType resize_duration = 11;
  // Defines the duration for card to dismiss or to come back to original position if not dismissed.
  DartDurationType movement_duration = 13;
  // Defines the end offset across the main axis after the card is dismissed.
  //
  // If non-zero value is given then widget moves in cross direction depending on whether
  // it is positive or negative.
  double cross_axis_end_offset = 14;
  // Determines the way that drag start behavior is handled.
  //
  // If set to [DragStartBehavior.start], the drag gesture used to dismiss a
  // dismissible will begin at the position where the drag gesture won the arena.
  // If set to [DragStartBehavior.down] it will begin at the position where
  // a down event is first detected.
  //
  // In general, setting this to [DragStartBehavior.start] will make drag
  // animation smoother and setting it to [DragStartBehavior.down] will make
  // drag behavior feel slightly more reactive.
  //
  // By default, the drag start behavior is [DragStartBehavior.start].
  //
  // See also:
  //
  //  * [DragGestureRecognizer.dragStartBehavior], which gives an example for the different behaviors.
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 15;
  // How to behave during hit tests.
  //
  // This defaults to [HitTestBehavior.opaque].
  FlutterHitTestBehaviorType.Enum behavior = 16;
}

// package:flutter/src/widgets/display_feature_sub_screen.dart
//
// Creates a widget that positions its child so that it avoids display
// features.
message FlutterDisplayFeatureSubScreen {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  // The anchor point used to pick the closest sub-screen.
  //
  // If the anchor point sits inside one of these sub-screens, then that
  // sub-screen is picked. If not, then the sub-screen with the closest edge to
  // the point is used.
  //
  // [Offset.zero] is the top-left corner of the available screen space. For a
  // vertically split dual-screen device, this is the top-left corner of the
  // left screen.
  //
  // When this is null, [Directionality] is used:
  //
  //   * for [TextDirection.ltr], [anchorPoint] is [Offset.zero], which will
  //     cause the top-left sub-screen to be picked.
  //   * for [TextDirection.rtl], [anchorPoint] is
  //     `Offset(double.maxFinite, 0)`, which will cause the top-right
  //     sub-screen to be picked.
  // {@endtemplate}
  DartOffsetType anchor_point = 3;
  // The widget below this widget in the tree.
  //
  // The padding on the [MediaQuery] for the [child] will be suitably adjusted
  // to zero out any sides that were avoided by this widget. The [MediaQuery]
  // for the [child] will no longer contain any display features that split the
  // screen into sub-screens.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/actions.dart
//
// Creates a const [DoNothingAndStopPropagationIntent].
message FlutterDoNothingAndStopPropagationIntent {
  
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an instance of [DoNothingAndStopPropagationTextIntent].
message FlutterDoNothingAndStopPropagationTextIntent {
  
}

// package:flutter/src/widgets/actions.dart
//
// Creates a const [DoNothingIntent].
message FlutterDoNothingIntent {
  
}

// package:flutter/src/foundation/diagnostics.dart
//
// If specified, [unit] describes the unit for the [value] (e.g. px).
message FlutterDoubleProperty {
  string name = 2;
  double value = 3;
  string if_null = 4;
  // Optional unit the [value] is measured in.
  //
  // Unit must be acceptable to display immediately after a number with no
  // spaces. For example: 'physical pixels per logical pixel' should be a
  // [tooltip] not a [unit].
  string unit = 5;
  string tooltip = 6;
  bool show_name = 8;
  FlutterDiagnosticsTreeStyleType.Enum style = 9;
  FlutterDiagnosticLevelType.Enum level = 10;
}

// package:flutter/src/gestures/multitap.dart
//
// Create a gesture recognizer for double taps.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterDoubleTapGestureRecognizer {
  
}

// package:flutter/src/widgets/drag_target.dart
//
// Creates a widget that can be dragged to a [DragTarget].
//
// If [maxSimultaneousDrags] is non-null, it must be non-negative.
message FlutterDraggable {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // This widget displays [child] when zero drags are under way. If
  // [childWhenDragging] is non-null, this widget instead displays
  // [childWhenDragging] when one or more drags are underway. Otherwise, this
  // widget always displays [child].
  //
  // The [feedback] widget is shown under the pointer when a drag is under way.
  //
  // To limit the number of simultaneous drags on multitouch devices, see
  // [maxSimultaneousDrags].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The widget to show under the pointer when a drag is under way.
  //
  // See [child] and [childWhenDragging] for information about what is shown
  // at the location of the [Draggable] itself when a drag is under way.
  WidgetType feedback = 4;
  // The [Axis] to restrict this draggable's movement, if specified.
  //
  // When axis is set to [Axis.horizontal], this widget can only be dragged
  // horizontally. Behavior is similar for [Axis.vertical].
  //
  // Defaults to allowing drag on both [Axis.horizontal] and [Axis.vertical].
  //
  // When null, allows drag on both [Axis.horizontal] and [Axis.vertical].
  //
  // For the direction of gestures this widget competes with to start a drag
  // event, see [Draggable.affinity].
  FlutterAxisType.Enum axis = 6;
  // The widget to display instead of [child] when one or more drags are under way.
  //
  // If this is null, then this widget will always display [child] (and so the
  // drag source representation will not change while a drag is under
  // way).
  //
  // The [feedback] widget is shown under the pointer when a drag is under way.
  //
  // To limit the number of simultaneous drags on multitouch devices, see
  // [maxSimultaneousDrags].
  WidgetType child_when_dragging = 7;
  // The feedbackOffset can be used to set the hit test target point for the
  // purposes of finding a drag target. It is especially useful if the feedback
  // is transformed compared to the child.
  DartOffsetType feedback_offset = 8;
  // Controls how this widget competes with other gestures to initiate a drag.
  //
  // If affinity is null, this widget initiates a drag as soon as it recognizes
  // a tap down gesture, regardless of any directionality. If affinity is
  // horizontal (or vertical), then this widget will compete with other
  // horizontal (or vertical, respectively) gestures.
  //
  // For example, if this widget is placed in a vertically scrolling region and
  // has horizontal affinity, pointer motion in the vertical direction will
  // result in a scroll and pointer motion in the horizontal direction will
  // result in a drag. Conversely, if the widget has a null or vertical
  // affinity, pointer motion in any direction will result in a drag rather
  // than in a scroll because the draggable widget, being the more specific
  // widget, will out-compete the [Scrollable] for vertical gestures.
  //
  // For the directions this widget can be dragged in after the drag event
  // starts, see [Draggable.axis].
  FlutterAxisType.Enum affinity = 10;
  // How many simultaneous drags to support.
  //
  // When null, no limit is applied. Set this to 1 if you want to only allow
  // the drag source to have one item dragged at a time. Set this to 0 if you
  // want to prevent the draggable from actually being dragged.
  //
  // If you set this property to 1, consider supplying an "empty" widget for
  // [childWhenDragging] to create the illusion of actually moving [child].
  int32 max_simultaneous_drags = 11;
  // Whether the semantics of the [feedback] widget is ignored when building
  // the semantics tree.
  //
  // This value should be set to false when the [feedback] widget is intended
  // to be the same object as the [child]. Placing a [GlobalKey] on this
  // widget will ensure semantic focus is kept on the element as it moves in
  // and out of the feedback position.
  //
  // Defaults to true.
  bool ignoring_feedback_semantics = 17;
  // Whether the [feedback] widget is ignored during hit testing.
  //
  // Regardless of whether this widget is ignored during hit testing, it will
  // still consume space during layout and be visible during painting.
  //
  // Defaults to true.
  bool ignoring_feedback_pointer = 18;
  // Whether the feedback widget will be put on the root [Overlay].
  //
  // When false, the feedback widget will be put on the closest [Overlay]. When
  // true, the [feedback] widget will be put on the farthest (aka root)
  // [Overlay].
  //
  // Defaults to false.
  bool root_overlay = 19;
  // How to behave during hit test.
  //
  // Defaults to [HitTestBehavior.deferToChild].
  FlutterHitTestBehaviorType.Enum hit_test_behavior = 20;
}

// package:flutter/src/widgets/draggable_scrollable_sheet.dart
//
// Creates a widget that can notify descendent [DraggableScrollableSheet]s
// to reset to their initial position.
//
// The [child] parameter is required.
message FlutterDraggableScrollableActuator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // This child's [DraggableScrollableSheet] descendant will be reset when the
  // [reset] method is applied to a context that includes it.
  WidgetType child = 3;
}

// package:flutter/src/gestures/eager.dart
//
// Create an eager gesture recognizer.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterEagerGestureRecognizer {
  
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets where all the offsets are `value`.
//
// {@tool snippet}
//
// Typical eight-pixel margin on all sides:
//
// ```dart
// const EdgeInsetsDirectional.all(8.0)
// ```
// {@end-tool}
message FlutterEdgeInsetsDirectionalNamedAll {
  double value = 2;
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets from offsets from the start, top, end, and bottom.
message FlutterEdgeInsetsDirectionalNamedFromSTEB {
  // The offset from the start side, the side from which the user will start
  // reading text.
  //
  // This value is normalized into an [EdgeInsets.left] or [EdgeInsets.right]
  // value by the [resolve] method.
  double start = 2;
  // The offset from the top.
  //
  // This value is passed through to [EdgeInsets.top] unmodified by the
  // [resolve] method.
  double top = 3;
  // The offset from the end side, the side on which the user ends reading
  // text.
  //
  // This value is normalized into an [EdgeInsets.left] or [EdgeInsets.right]
  // value by the [resolve] method.
  double end = 4;
  // The offset from the bottom.
  //
  // This value is passed through to [EdgeInsets.bottom] unmodified by the
  // [resolve] method.
  double bottom = 5;
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets with only the given values non-zero.
//
// {@tool snippet}
//
// A margin indent of 40 pixels on the leading side:
//
// ```dart
// const EdgeInsetsDirectional.only(start: 40.0)
// ```
// {@end-tool}
message FlutterEdgeInsetsDirectionalNamedOnly {
  // The offset from the start side, the side from which the user will start
  // reading text.
  //
  // This value is normalized into an [EdgeInsets.left] or [EdgeInsets.right]
  // value by the [resolve] method.
  double start = 2;
  // The offset from the top.
  //
  // This value is passed through to [EdgeInsets.top] unmodified by the
  // [resolve] method.
  double top = 3;
  // The offset from the end side, the side on which the user ends reading
  // text.
  //
  // This value is normalized into an [EdgeInsets.left] or [EdgeInsets.right]
  // value by the [resolve] method.
  double end = 4;
  // The offset from the bottom.
  //
  // This value is passed through to [EdgeInsets.bottom] unmodified by the
  // [resolve] method.
  double bottom = 5;
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets with symmetric vertical and horizontal offsets.
//
// This is equivalent to [EdgeInsets.symmetric], since the inset is the same
// with either [TextDirection]. This constructor is just a convenience for
// type compatibility.
//
// {@tool snippet}
// Eight pixel margin above and below, no horizontal margins:
//
// ```dart
// const EdgeInsetsDirectional.symmetric(vertical: 8.0)
// ```
// {@end-tool}
message FlutterEdgeInsetsDirectionalNamedSymmetric {
  double horizontal = 2;
  double vertical = 3;
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets where all the offsets are `value`.
//
// {@tool snippet}
//
// Typical eight-pixel margin on all sides:
//
// ```dart
// const EdgeInsets.all(8.0)
// ```
// {@end-tool}
message FlutterEdgeInsetsNamedAll {
  double value = 2;
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets from offsets from the left, top, right, and bottom.
message FlutterEdgeInsetsNamedFromLTRB {
  // The offset from the left.
  double left = 2;
  // The offset from the top.
  double top = 3;
  // The offset from the right.
  double right = 4;
  // The offset from the bottom.
  double bottom = 5;
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets that match the given view padding.
//
// If you need the current system padding or view insets in the context of a
// widget, consider using [MediaQuery.paddingOf] to obtain these values rather than
// using the value from a [FlutterView] directly, so that you get notified of
// changes.
message FlutterEdgeInsetsNamedFromViewPadding {
  double device_pixel_ratio = 3;
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets with only the given values non-zero.
//
// {@tool snippet}
//
// Left margin indent of 40 pixels:
//
// ```dart
// const EdgeInsets.only(left: 40.0)
// ```
// {@end-tool}
message FlutterEdgeInsetsNamedOnly {
  // The offset from the left.
  double left = 2;
  // The offset from the top.
  double top = 3;
  // The offset from the right.
  double right = 4;
  // The offset from the bottom.
  double bottom = 5;
}

// package:flutter/src/painting/edge_insets.dart
//
// Creates insets with symmetrical vertical and horizontal offsets.
//
// {@tool snippet}
//
// Eight pixel margin above and below, no horizontal margins:
//
// ```dart
// const EdgeInsets.symmetric(vertical: 8.0)
// ```
// {@end-tool}
message FlutterEdgeInsetsNamedSymmetric {
  double vertical = 2;
  double horizontal = 3;
}

// package:flutter/src/widgets/editable_text.dart
//
// Creates a basic text input control.
//
// The [maxLines] property can be set to null to remove the restriction on
// the number of lines. By default, it is one, meaning this is a single-line
// text field. [maxLines] must be null or greater than zero.
//
// If [keyboardType] is not set or is null, its value will be inferred from
// [autofillHints], if [autofillHints] is not empty. Otherwise it defaults to
// [TextInputType.text] if [maxLines] is exactly one, and
// [TextInputType.multiline] if [maxLines] is null or greater than one.
//
// The text cursor is not shown if [showCursor] is false or if [showCursor]
// is null (the default) and [readOnly] is true.
message FlutterEditableText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Controls the text being edited.
  FlutterTextEditingControllerType controller = 3;
  // Controls whether this widget has keyboard focus.
  FlutterFocusNodeType focus_node = 4;
  // {@template flutter.widgets.editableText.readOnly}
  // Whether the text can be changed.
  //
  // When this is set to true, the text cannot be modified
  // by any shortcut or keyboard operation. The text is still selectable.
  //
  // Defaults to false.
  // {@endtemplate}
  bool read_only = 5;
  // {@template flutter.widgets.editableText.obscuringCharacter}
  // Character used for obscuring text if [obscureText] is true.
  //
  // Must be only a single character.
  //
  // Defaults to the character U+2022 BULLET ().
  // {@endtemplate}
  string obscuring_character = 6;
  // {@template flutter.widgets.editableText.obscureText}
  // Whether to hide the text being edited (e.g., for passwords).
  //
  // When this is set to true, all the characters in the text field are
  // replaced by [obscuringCharacter], and the text in the field cannot be
  // copied with copy or cut. If [readOnly] is also true, then the text cannot
  // be selected.
  //
  // Defaults to false.
  // {@endtemplate}
  bool obscure_text = 7;
  // {@template flutter.widgets.editableText.autocorrect}
  // Whether to enable autocorrection.
  //
  // Defaults to true.
  // {@endtemplate}
  bool autocorrect = 8;
  FlutterSmartDashesTypeType.Enum smart_dashes_type = 9;
  FlutterSmartQuotesTypeType.Enum smart_quotes_type = 10;
  // {@macro flutter.services.TextInputConfiguration.enableSuggestions}
  bool enable_suggestions = 11;
  // The text style to use for the editable text.
  FlutterTextStyleType style = 12;
  FlutterStrutStyleType strut_style = 13;
  // The color to use when painting the cursor.
  DartColorType cursor_color = 14;
  // The color to use when painting the background cursor aligned with the text
  // while rendering the floating cursor.
  //
  // Typically this would be set to [CupertinoColors.inactiveGray].
  DartColorType background_cursor_color = 15;
  // {@template flutter.widgets.editableText.textAlign}
  // How the text should be aligned horizontally.
  //
  // Defaults to [TextAlign.start].
  // {@endtemplate}
  DartTextAlignType.Enum text_align = 16;
  // {@template flutter.widgets.editableText.textDirection}
  // The directionality of the text.
  //
  // This decides how [textAlign] values like [TextAlign.start] and
  // [TextAlign.end] are interpreted.
  //
  // This is also used to disambiguate how to render bidirectional text. For
  // example, if the text is an English phrase followed by a Hebrew phrase,
  // in a [TextDirection.ltr] context the English phrase will be on the left
  // and the Hebrew phrase to its right, while in a [TextDirection.rtl]
  // context, the English phrase will be on the right and the Hebrew phrase on
  // its left.
  //
  // Defaults to the ambient [Directionality], if any.
  // {@endtemplate}
  DartTextDirectionType.Enum text_direction = 17;
  // Used to select a font when the same Unicode character can
  // be rendered differently, depending on the locale.
  //
  // It's rarely necessary to set this property. By default its value
  // is inherited from the enclosing app with `Localizations.localeOf(context)`.
  //
  // See [RenderEditable.locale] for more information.
  DartLocaleType locale = 18;
  // {@macro flutter.painting.textPainter.textScaler}
  FlutterTextScalerType text_scaler = 19;
  // {@template flutter.widgets.editableText.maxLines}
  // The maximum number of lines to show at one time, wrapping if necessary.
  //
  // This affects the height of the field itself and does not limit the number
  // of lines that can be entered into the field.
  //
  // If this is 1 (the default), the text will not wrap, but will scroll
  // horizontally instead.
  //
  // If this is null, there is no limit to the number of lines, and the text
  // container will start with enough vertical space for one line and
  // automatically grow to accommodate additional lines as they are entered, up
  // to the height of its constraints.
  //
  // If this is not null, the value must be greater than zero, and it will lock
  // the input to the given number of lines and take up enough horizontal space
  // to accommodate that number of lines. Setting [minLines] as well allows the
  // input to grow and shrink between the indicated range.
  //
  // The full set of behaviors possible with [minLines] and [maxLines] are as
  // follows. These examples apply equally to [TextField], [TextFormField],
  // [CupertinoTextField], and [EditableText].
  //
  // Input that occupies a single line and scrolls horizontally as needed.
  // ```dart
  // const TextField()
  // ```
  //
  // Input whose height grows from one line up to as many lines as needed for
  // the text that was entered. If a height limit is imposed by its parent, it
  // will scroll vertically when its height reaches that limit.
  // ```dart
  // const TextField(maxLines: null)
  // ```
  //
  // The input's height is large enough for the given number of lines. If
  // additional lines are entered the input scrolls vertically.
  // ```dart
  // const TextField(maxLines: 2)
  // ```
  //
  // Input whose height grows with content between a min and max. An infinite
  // max is possible with `maxLines: null`.
  // ```dart
  // const TextField(minLines: 2, maxLines: 4)
  // ```
  //
  // See also:
  //
  //  * [minLines], which sets the minimum number of lines visible.
  // {@endtemplate}
  //  * [expands], which determines whether the field should fill the height of
  //    its parent.
  int32 max_lines = 20;
  // {@template flutter.widgets.editableText.minLines}
  // The minimum number of lines to occupy when the content spans fewer lines.
  //
  // This affects the height of the field itself and does not limit the number
  // of lines that can be entered into the field.
  //
  // If this is null (default), text container starts with enough vertical space
  // for one line and grows to accommodate additional lines as they are entered.
  //
  // This can be used in combination with [maxLines] for a varying set of behaviors.
  //
  // If the value is set, it must be greater than zero. If the value is greater
  // than 1, [maxLines] should also be set to either null or greater than
  // this value.
  //
  // When [maxLines] is set as well, the height will grow between the indicated
  // range of lines. When [maxLines] is null, it will grow as high as needed,
  // starting from [minLines].
  //
  // A few examples of behaviors possible with [minLines] and [maxLines] are as follows.
  // These apply equally to [TextField], [TextFormField], [CupertinoTextField],
  // and [EditableText].
  //
  // Input that always occupies at least 2 lines and has an infinite max.
  // Expands vertically as needed.
  // ```dart
  // TextField(minLines: 2)
  // ```
  //
  // Input whose height starts from 2 lines and grows up to 4 lines at which
  // point the height limit is reached. If additional lines are entered it will
  // scroll vertically.
  // ```dart
  // const TextField(minLines:2, maxLines: 4)
  // ```
  //
  // Defaults to null.
  //
  // See also:
  //
  //  * [maxLines], which sets the maximum number of lines visible, and has
  //    several examples of how minLines and maxLines interact to produce
  //    various behaviors.
  // {@endtemplate}
  //  * [expands], which determines whether the field should fill the height of
  //    its parent.
  int32 min_lines = 21;
  // {@template flutter.widgets.editableText.expands}
  // Whether this widget's height will be sized to fill its parent.
  //
  // If set to true and wrapped in a parent widget like [Expanded] or
  // [SizedBox], the input will expand to fill the parent.
  //
  // [maxLines] and [minLines] must both be null when this is set to true,
  // otherwise an error is thrown.
  //
  // Defaults to false.
  //
  // See the examples in [maxLines] for the complete picture of how [maxLines],
  // [minLines], and [expands] interact to produce various behaviors.
  //
  // Input that matches the height of its parent:
  // ```dart
  // const Expanded(
  //   child: TextField(maxLines: null, expands: true),
  // )
  // ```
  // {@endtemplate}
  bool expands = 22;
  // Whether the text will take the full width regardless of the text width.
  //
  // When this is set to false, the width will be based on text width, which
  // will also be affected by [textWidthBasis].
  //
  // Defaults to true.
  //
  // See also:
  //
  //  * [textWidthBasis], which controls the calculation of text width.
  bool force_line = 23;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 24;
  // {@macro flutter.painting.textPainter.textWidthBasis}
  FlutterTextWidthBasisType.Enum text_width_basis = 25;
  // {@template flutter.widgets.editableText.autofocus}
  // Whether this text field should focus itself if nothing else is already
  // focused.
  //
  // If true, the keyboard will open as soon as this text field obtains focus.
  // Otherwise, the keyboard is only shown after the user taps the text field.
  //
  // Defaults to false.
  // {@endtemplate}
  bool autofocus = 26;
  bool show_cursor = 27;
  // Whether to show selection handles.
  //
  // When a selection is active, there will be two handles at each side of
  // boundary, or one handle if the selection is collapsed. The handles can be
  // dragged to adjust the selection.
  //
  // See also:
  //
  //  * [showCursor], which controls the visibility of the cursor.
  bool show_selection_handles = 28;
  // The color to use when painting the selection.
  //
  // If this property is null, this widget gets the selection color from the
  // [DefaultSelectionStyle].
  //
  // For [CupertinoTextField]s, the value is set to the ambient
  // [CupertinoThemeData.primaryColor] with 20% opacity. For [TextField]s, the
  // value is set to the ambient [TextSelectionThemeData.selectionColor].
  DartColorType selection_color = 29;
  // {@template flutter.widgets.editableText.selectionControls}
  // Optional delegate for building the text selection handles.
  //
  // Historically, this field also controlled the toolbar. This is now handled
  // by [contextMenuBuilder] instead. However, for backwards compatibility, when
  // [selectionControls] is set to an object that does not mix in
  // [TextSelectionHandleControls], [contextMenuBuilder] is ignored and the
  // [TextSelectionControls.buildToolbar] method is used instead.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [CupertinoTextField], which wraps an [EditableText] and which shows the
  //    selection toolbar upon user events that are appropriate on the iOS
  //    platform.
  //  * [TextField], a Material Design themed wrapper of [EditableText], which
  //    shows the selection toolbar upon appropriate user events based on the
  //    user's platform set in [ThemeData.platform].
  FlutterTextSelectionControlsType selection_controls = 30;
  FlutterTextInputTypeType keyboard_type = 31;
  // The type of action button to use with the soft keyboard.
  FlutterTextInputActionType.Enum text_input_action = 32;
  // {@template flutter.widgets.editableText.textCapitalization}
  // Configures how the platform keyboard will select an uppercase or
  // lowercase keyboard.
  //
  // Only supports text keyboards, other keyboard types will ignore this
  // configuration. Capitalization is locale-aware.
  //
  // Defaults to [TextCapitalization.none].
  //
  // See also:
  //
  //  * [TextCapitalization], for a description of each capitalization behavior.
  //
  // {@endtemplate}
  FlutterTextCapitalizationType.Enum text_capitalization = 33;
  repeated FlutterTextInputFormatterType input_formatters = 41;
  // Whether the caller will provide gesture handling (true), or if the
  // [EditableText] is expected to handle basic gestures (false).
  //
  // When this is false, the [EditableText] (or more specifically, the
  // [RenderEditable]) enables some rudimentary gestures (tap to position the
  // cursor, long-press to select all, and some scrolling behavior).
  //
  // These behaviors are sufficient for debugging purposes but are inadequate
  // for user-facing applications. To enable platform-specific behaviors, use a
  // [TextSelectionGestureDetectorBuilder] to wrap the [EditableText], and set
  // [rendererIgnoresPointer] to true.
  //
  // When [rendererIgnoresPointer] is true true, the [RenderEditable] created
  // by this widget will not handle pointer events.
  //
  // This property is false by default.
  //
  // See also:
  //
  //  * [RenderEditable.ignorePointer], which implements this feature.
  //  * [TextSelectionGestureDetectorBuilder], which implements platform-specific
  //    gestures and behaviors.
  bool renderer_ignores_pointer = 43;
  // {@template flutter.widgets.editableText.cursorWidth}
  // How thick the cursor will be.
  //
  // Defaults to 2.0.
  //
  // The cursor will draw under the text. The cursor width will extend
  // to the right of the boundary between characters for left-to-right text
  // and to the left for right-to-left text. This corresponds to extending
  // downstream relative to the selected position. Negative values may be used
  // to reverse this behavior.
  // {@endtemplate}
  double cursor_width = 44;
  // {@template flutter.widgets.editableText.cursorHeight}
  // How tall the cursor will be.
  //
  // If this property is null, [RenderEditable.preferredLineHeight] will be used.
  // {@endtemplate}
  double cursor_height = 45;
  // {@template flutter.widgets.editableText.cursorRadius}
  // How rounded the corners of the cursor should be.
  //
  // By default, the cursor has no radius.
  // {@endtemplate}
  DartRadiusType cursor_radius = 46;
  // {@template flutter.widgets.editableText.cursorOpacityAnimates}
  // Whether the cursor will animate from fully transparent to fully opaque
  // during each cursor blink.
  //
  // By default, the cursor opacity will animate on iOS platforms and will not
  // animate on Android platforms.
  // {@endtemplate}
  bool cursor_opacity_animates = 47;
  //{@macro flutter.rendering.RenderEditable.cursorOffset}
  DartOffsetType cursor_offset = 48;
  //{@macro flutter.rendering.RenderEditable.paintCursorAboveText}
  bool paint_cursor_above_text = 49;
  // Controls how tall the selection highlight boxes are computed to be.
  //
  // See [ui.BoxHeightStyle] for details on available styles.
  DartBoxHeightStyleType.Enum selection_height_style = 50;
  // Controls how wide the selection highlight boxes are computed to be.
  //
  // See [ui.BoxWidthStyle] for details on available styles.
  DartBoxWidthStyleType.Enum selection_width_style = 51;
  // {@template flutter.widgets.editableText.scrollPadding}
  // Configures padding to edges surrounding a [Scrollable] when the Textfield scrolls into view.
  //
  // When this widget receives focus and is not completely visible (for example scrolled partially
  // off the screen or overlapped by the keyboard)
  // then it will attempt to make itself visible by scrolling a surrounding [Scrollable], if one is present.
  // This value controls how far from the edges of a [Scrollable] the TextField will be positioned after the scroll.
  //
  // Defaults to EdgeInsets.all(20.0).
  // {@endtemplate}
  FlutterEdgeInsetsType scroll_padding = 52;
  // The appearance of the keyboard.
  //
  // This setting is only honored on iOS devices.
  //
  // Defaults to [Brightness.light].
  DartBrightnessType.Enum keyboard_appearance = 53;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 54;
  bool enable_interactive_selection = 55;
  // {@template flutter.widgets.editableText.scrollController}
  // The [ScrollController] to use when vertically scrolling the input.
  //
  // If null, it will instantiate a new ScrollController.
  //
  // See [Scrollable.controller].
  // {@endtemplate}
  FlutterScrollControllerType scroll_controller = 56;
  // {@template flutter.widgets.editableText.scrollPhysics}
  // The [ScrollPhysics] to use when vertically scrolling the input.
  //
  // If not specified, it will behave according to the current platform.
  //
  // See [Scrollable.physics].
  // {@endtemplate}
  //
  // If an explicit [ScrollBehavior] is provided to [scrollBehavior], the
  // [ScrollPhysics] provided by that behavior will take precedence after
  // [scrollPhysics].
  FlutterScrollPhysicsType scroll_physics = 57;
  // The color to use when painting the autocorrection Rect.
  //
  // For [CupertinoTextField]s, the value is set to the ambient
  // [CupertinoThemeData.primaryColor] with 20% opacity. For [TextField]s, the
  // value is null on non-iOS platforms and the same color used in [CupertinoTextField]
  // on iOS.
  //
  // Currently the autocorrection Rect only appears on iOS.
  //
  // Defaults to null, which disables autocorrection Rect painting.
  DartColorType autocorrection_text_rect_color = 58;
  // {@template flutter.widgets.editableText.autofillHints}
  // A list of strings that helps the autofill service identify the type of this
  // text input.
  //
  // When set to null, this text input will not send its autofill information
  // to the platform, preventing it from participating in autofills triggered
  // by a different [AutofillClient], even if they're in the same
  // [AutofillScope]. Additionally, on Android and web, setting this to null
  // will disable autofill for this text field.
  //
  // The minimum platform SDK version that supports Autofill is API level 26
  // for Android, and iOS 10.0 for iOS.
  //
  // Defaults to an empty list.
  //
  // ### Setting up iOS autofill:
  //
  // To provide the best user experience and ensure your app fully supports
  // password autofill on iOS, follow these steps:
  //
  // * Set up your iOS app's
  //   [associated domains](https://developer.apple.com/documentation/safariservices/supporting_associated_domains_in_your_app).
  // * Some autofill hints only work with specific [keyboardType]s. For example,
  //   [AutofillHints.name] requires [TextInputType.name] and [AutofillHints.email]
  //   works only with [TextInputType.emailAddress]. Make sure the input field has a
  //   compatible [keyboardType]. Empirically, [TextInputType.name] works well
  //   with many autofill hints that are predefined on iOS.
  //
  // ### Troubleshooting Autofill
  //
  // Autofill service providers rely heavily on [autofillHints]. Make sure the
  // entries in [autofillHints] are supported by the autofill service currently
  // in use (the name of the service can typically be found in your mobile
  // device's system settings).
  //
  // #### Autofill UI refuses to show up when I tap on the text field
  //
  // Check the device's system settings and make sure autofill is turned on,
  // and there are available credentials stored in the autofill service.
  //
  // * iOS password autofill: Go to Settings -> Password, turn on "Autofill
  //   Passwords", and add new passwords for testing by pressing the top right
  //   "+" button. Use an arbitrary "website" if you don't have associated
  //   domains set up for your app. As long as there's at least one password
  //   stored, you should be able to see a key-shaped icon in the quick type
  //   bar on the software keyboard, when a password related field is focused.
  //
  // * iOS contact information autofill: iOS seems to pull contact info from
  //   the Apple ID currently associated with the device. Go to Settings ->
  //   Apple ID (usually the first entry, or "Sign in to your iPhone" if you
  //   haven't set up one on the device), and fill out the relevant fields. If
  //   you wish to test more contact info types, try adding them in Contacts ->
  //   My Card.
  //
  // * Android autofill: Go to Settings -> System -> Languages & input ->
  //   Autofill service. Enable the autofill service of your choice, and make
  //   sure there are available credentials associated with your app.
  //
  // #### I called `TextInput.finishAutofillContext` but the autofill save
  // prompt isn't showing
  //
  // * iOS: iOS may not show a prompt or any other visual indication when it
  //   saves user password. Go to Settings -> Password and check if your new
  //   password is saved. Neither saving password nor auto-generating strong
  //   password works without properly setting up associated domains in your
  //   app. To set up associated domains, follow the instructions in
  //   <https://developer.apple.com/documentation/safariservices/supporting_associated_domains_in_your_app>.
  //
  // {@endtemplate}
  // {@macro flutter.services.AutofillConfiguration.autofillHints}
  repeated string autofill_hints = 59;
  // The [AutofillClient] that controls this input field's autofill behavior.
  //
  // When null, this widget's [EditableTextState] will be used as the
  // [AutofillClient]. This property may override [autofillHints].
  FlutterAutofillClientType autofill_client = 60;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 61;
  // Restoration ID to save and restore the scroll offset of the
  // [EditableText].
  //
  // If a restoration id is provided, the [EditableText] will persist its
  // current scroll offset and restore it during state restoration.
  //
  // The scroll offset is persisted in a [RestorationBucket] claimed from
  // the surrounding [RestorationScope] using the provided restoration ID.
  //
  // Persisting and restoring the content of the [EditableText] is the
  // responsibility of the owner of the [controller], who may use a
  // [RestorableTextEditingController] for that purpose.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  string restoration_id = 62;
  // {@template flutter.widgets.shadow.scrollBehavior}
  // A [ScrollBehavior] that will be applied to this widget individually.
  //
  // Defaults to null, wherein the inherited [ScrollBehavior] is copied and
  // modified to alter the viewport decoration, like [Scrollbar]s.
  // {@endtemplate}
  //
  // [ScrollBehavior]s also provide [ScrollPhysics]. If an explicit
  // [ScrollPhysics] is provided in [scrollPhysics], it will take precedence,
  // followed by [scrollBehavior], and then the inherited ancestor
  // [ScrollBehavior].
  //
  // The [ScrollBehavior] of the inherited [ScrollConfiguration] will be
  // modified by default to only apply a [Scrollbar] if [maxLines] is greater
  // than 1.
  FlutterScrollBehaviorType scroll_behavior = 63;
  // {@template flutter.widgets.editableText.scribbleEnabled}
  // Whether iOS 14 Scribble features are enabled for this widget.
  //
  // Only available on iPads.
  //
  // Defaults to true.
  // {@endtemplate}
  bool scribble_enabled = 64;
  // {@macro flutter.services.TextInputConfiguration.enableIMEPersonalizedLearning}
  bool enable_i_m_e_personalized_learning = 65;
  // {@template flutter.widgets.EditableText.spellCheckConfiguration}
  // Configuration that details how spell check should be performed.
  //
  // Specifies the [SpellCheckService] used to spell check text input and the
  // [TextStyle] used to style text with misspelled words.
  //
  // If the [SpellCheckService] is left null, spell check is disabled by
  // default unless the [DefaultSpellCheckService] is supported, in which case
  // it is used. It is currently supported only on Android and iOS.
  //
  // If this configuration is left null, then spell check is disabled by default.
  // {@endtemplate}
  FlutterSpellCheckConfigurationType spell_check_configuration = 68;
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
  //
  // {@macro flutter.widgets.magnifier.intro}
  //
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.details}
  FlutterTextMagnifierConfigurationType magnifier_configuration = 69;
  // Controls the undo state of the current editable text.
  //
  // If null, this widget will create its own [UndoHistoryController].
  FlutterUndoHistoryControllerType undo_controller = 70;
}

// package:flutter/src/widgets/editable_text.dart
message FlutterEditableTextState {
  
}

// package:flutter/src/widgets/text_selection.dart
message FlutterEmptyTextSelectionControls {
  
}

// package:flutter/src/foundation/assertions.dart
//
// A lint enforces that this constructor can only be called with a string
// literal to match the limitations of the Dart Kernel transformer that
// optionally extracts out objects referenced using string interpolation in
// the message passed in.
//
// The message will display with the same text regardless of whether the
// kernel transformer is used. The kernel transformer is required so that
// debugging tools can provide interactive displays of objects described by
// the error.
message FlutterErrorDescription {
  string message = 2;
}

// package:flutter/src/foundation/assertions.dart
//
// A lint enforces that this constructor can only be called with a string
// literal to match the limitations of the Dart Kernel transformer that
// optionally extracts out objects referenced using string interpolation in
// the message passed in.
//
// The message will display with the same text regardless of whether the
// kernel transformer is used. The kernel transformer is required so that
// debugging tools can provide interactive displays of objects described by
// the error.
message FlutterErrorHint {
  string message = 2;
}

// package:flutter/src/foundation/assertions.dart
//
// Creates an empty space to insert into a list of [DiagnosticsNode] objects
// typically within a [FlutterError] object.
message FlutterErrorSpacer {
  
}

// package:flutter/src/foundation/assertions.dart
//
// A lint enforces that this constructor can only be called with a string
// literal to match the limitations of the Dart Kernel transformer that
// optionally extracts out objects referenced using string interpolation in
// the message passed in.
//
// The message will display with the same text regardless of whether the
// kernel transformer is used. The kernel transformer is required so that
// debugging tools can provide interactive displays of objects described by
// the error.
message FlutterErrorSummary {
  string message = 2;
}

// package:flutter/src/widgets/framework.dart
//
// Creates a widget that displays the given error message.
//
// An explicit [FlutterError] can be provided to be reported to inspection
// tools. It need not match the message.
message FlutterErrorWidgetNamedWithDetails {
  // The message to display.
  string message = 2;
  FlutterFlutterErrorType error = 3;
}

// package:flutter/src/widgets/focus_scope.dart
//
// Const constructor for [ExcludeFocus] widget.
message FlutterExcludeFocus {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If true, will make this widget's descendants unfocusable.
  //
  // Defaults to true.
  //
  // If any descendants are focused when this is set to true, they will be
  // unfocused. When [excluding] is set to false again, they will not be
  // refocused, although they will be able to accept focus again.
  //
  // Does not affect the value of [FocusNode.canRequestFocus] on the
  // descendants.
  //
  // See also:
  //
  // * [Focus.descendantsAreFocusable], the attribute of a [Focus] widget that
  //   controls this same property for focus widgets.
  // * [FocusTraversalGroup], a widget used to group together and configure the
  //   focus traversal policy for a widget subtree that has a
  //   `descendantsAreFocusable` parameter to conditionally block focus for a
  //   subtree.
  bool excluding = 3;
  // The child widget of this [ExcludeFocus].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Const constructor for [ExcludeFocusTraversal] widget.
message FlutterExcludeFocusTraversal {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If true, will make this widget's descendants untraversable.
  //
  // Defaults to true.
  //
  // Does not affect the value of [FocusNode.skipTraversal] on the descendants.
  //
  // See also:
  //
  // * [Focus.descendantsAreTraversable], the attribute of a [Focus] widget that
  //   controls this same property for focus widgets.
  // * [FocusTraversalGroup], a widget used to group together and configure the
  //   focus traversal policy for a widget subtree that has a
  //   `descendantsAreFocusable` parameter to conditionally block focus for a
  //   subtree.
  bool excluding = 3;
  // The child widget of this [ExcludeFocusTraversal].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that drops all the semantics of its descendants.
message FlutterExcludeSemantics {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this widget is excluded in the semantics tree.
  bool excluding = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExpandSelectionToDocumentBoundaryIntent].
message FlutterExpandSelectionToDocumentBoundaryIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExpandSelectionToLineBreakIntent].
message FlutterExpandSelectionToLineBreakIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that expands a child of a [Row], [Column], or [Flex]
// so that the child fills the available space along the flex widget's
// main axis.
message FlutterExpanded {
  FlutterKeyType key = 2;
  // The flex factor to use for this child.
  //
  // If null or zero, the child is inflexible and determines its own size. If
  // non-zero, the amount of space the child's can occupy in the main axis is
  // determined by dividing the free space (after placing the inflexible
  // children) according to the flex factors of the flexible children.
  int32 flex = 3;
  WidgetType child = 4;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionByCharacterIntent].
message FlutterExtendSelectionByCharacterIntent {
  bool forward = 2;
  bool collapse_selection = 3;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates a [ExtendSelectionByPageIntent].
message FlutterExtendSelectionByPageIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionToDocumentBoundaryIntent].
message FlutterExtendSelectionToDocumentBoundaryIntent {
  bool forward = 2;
  bool collapse_selection = 3;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionToLineBreakIntent].
message FlutterExtendSelectionToLineBreakIntent {
  bool forward = 2;
  bool collapse_selection = 3;
  bool collapse_at_reversal = 4;
  bool continues_at_wrap = 5;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionToNextParagraphBoundaryIntent].
message FlutterExtendSelectionToNextParagraphBoundaryIntent {
  bool forward = 2;
  bool collapse_selection = 3;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionToNextParagraphBoundaryOrCaretLocationIntent].
message FlutterExtendSelectionToNextParagraphBoundaryOrCaretLocationIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionToNextWordBoundaryIntent].
message FlutterExtendSelectionToNextWordBoundaryIntent {
  bool forward = 2;
  bool collapse_selection = 3;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionToNextWordBoundaryOrCaretLocationIntent].
message FlutterExtendSelectionToNextWordBoundaryOrCaretLocationIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionVerticallyToAdjacentLineIntent].
message FlutterExtendSelectionVerticallyToAdjacentLineIntent {
  bool forward = 2;
  bool collapse_selection = 3;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [ExtendSelectionVerticallyToAdjacentPageIntent].
message FlutterExtendSelectionVerticallyToAdjacentPageIntent {
  bool forward = 2;
  bool collapse_selection = 3;
}

// package:flutter/src/widgets/fade_in_image.dart
//
// Creates a widget that uses a placeholder image stored in an asset bundle
// while loading the final image from the network.
//
// The `placeholder` argument is the key of the image in the asset bundle.
//
// The `image` argument is the URL of the final image.
//
// The `placeholderScale` and `imageScale` arguments are passed to their
// respective [ImageProvider]s (see also [ImageInfo.scale]).
//
// If `placeholderScale` is omitted or is null, pixel-density-aware asset
// resolution will be attempted for the [placeholder] image. Otherwise, the
// exact asset specified will be used.
//
// If [placeholderCacheWidth], [placeholderCacheHeight], [imageCacheWidth],
// or [imageCacheHeight] are provided, it indicates to the
// engine that the respective image should be decoded at the specified size.
// The image will be rendered to the constraints of the layout or [width]
// and [height] regardless of these parameters. These parameters are primarily
// intended to reduce the memory usage of [ImageCache].
//
// See also:
//
//  * [Image.asset], which has more details about loading images from
//    asset bundles.
//  * [Image.network], which has more details about loading images from
//    the network.
message FlutterFadeInImageNamedAssetNetwork {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  string placeholder = 3;
  string image = 5;
  FlutterAssetBundleType bundle = 7;
  double placeholder_scale = 8;
  double image_scale = 9;
  // Whether to exclude this image from semantics.
  //
  // This is useful for images which do not contribute meaningful information
  // to an application.
  bool exclude_from_semantics = 10;
  // A semantic description of the [image].
  //
  // Used to provide a description of the [image] to TalkBack on Android, and
  // VoiceOver on iOS.
  //
  // This description will be used both while the [placeholder] is shown and
  // once the image has loaded.
  string image_semantic_label = 11;
  // The duration of the fade-out animation for the [placeholder].
  DartDurationType fade_out_duration = 12;
  // The curve of the fade-out animation for the [placeholder].
  FlutterSrcAnimationCurveType fade_out_curve = 13;
  // The duration of the fade-in animation for the [image].
  DartDurationType fade_in_duration = 14;
  // The curve of the fade-in animation for the [image].
  FlutterSrcAnimationCurveType fade_in_curve = 15;
  // If non-null, require the image to have this width.
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio. This may result in a sudden change if the size of the
  // placeholder image does not match that of the target image. The size is
  // also affected by the scale factor.
  double width = 16;
  // If non-null, require the image to have this height.
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio. This may result in a sudden change if the size of the
  // placeholder image does not match that of the target image. The size is
  // also affected by the scale factor.
  double height = 17;
  // How to inscribe the image into the space allocated during layout.
  //
  // The default varies based on the other fields. See the discussion at
  // [paintImage].
  FlutterBoxFitType.Enum fit = 18;
  // If non-null, this color is blended with each image pixel using [colorBlendMode].
  //
  // Color applies to the [image].
  //
  // See Also:
  //
  //  * [placeholderColor], the color which applies to the [placeholder].
  DartColorType color = 19;
  // Used to combine [color] with this [image].
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [color] is
  // the source and this image is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  //  * [placeholderColorBlendMode], the color blend mode which applies to the [placeholder].
  DartBlendModeType.Enum color_blend_mode = 20;
  // If non-null, this color is blended with each placeholder image pixel using [placeholderColorBlendMode].
  //
  // Color applies to the [placeholder].
  //
  // See Also:
  //
  //  * [color], the color which applies to the [image].
  DartColorType placeholder_color = 21;
  // Used to combine [placeholderColor] with the [placeholder] image.
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [placeholderColor] is
  // the source and this placeholder is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  //  * [colorBlendMode], the color blend mode which applies to the [image].
  DartBlendModeType.Enum placeholder_color_blend_mode = 22;
  // How to inscribe the placeholder image into the space allocated during layout.
  //
  // If not value set, it will fallback to [fit].
  FlutterBoxFitType.Enum placeholder_fit = 23;
  // The rendering quality of the image.
  //
  // {@macro flutter.widgets.image.filterQuality}
  DartFilterQualityType.Enum filter_quality = 24;
  // The rendering quality of the placeholder image.
  //
  // {@macro flutter.widgets.image.filterQuality}
  DartFilterQualityType.Enum placeholder_filter_quality = 25;
  // How to align the image within its bounds.
  //
  // The alignment aligns the given position in the image to the given position
  // in the layout bounds. For example, an [Alignment] alignment of (-1.0,
  // -1.0) aligns the image to the top-left corner of its layout bounds, while an
  // [Alignment] alignment of (1.0, 1.0) aligns the bottom right of the
  // image with the bottom right corner of its layout bounds. Similarly, an
  // alignment of (0.0, 1.0) aligns the bottom middle of the image with the
  // middle of the bottom edge of its layout bounds.
  //
  // If the [alignment] is [TextDirection]-dependent (i.e. if it is a
  // [AlignmentDirectional]), then an ambient [Directionality] widget
  // must be in scope.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 26;
  // How to paint any portions of the layout bounds not covered by the image.
  FlutterImageRepeatType.Enum repeat = 27;
  // Whether to paint the image in the direction of the [TextDirection].
  //
  // If this is true, then in [TextDirection.ltr] contexts, the image will be
  // drawn with its origin in the top left (the "normal" painting direction for
  // images); and in [TextDirection.rtl] contexts, the image will be drawn with
  // a scaling factor of -1 in the horizontal direction so that the origin is
  // in the top right.
  //
  // This is occasionally used with images in right-to-left environments, for
  // images that were designed for left-to-right locales. Be careful, when
  // using this, to not flip images with integral shadows, text, or other
  // effects that will look incorrect when flipped.
  //
  // If this is true, there must be an ambient [Directionality] widget in
  // scope.
  bool match_text_direction = 28;
  int32 placeholder_cache_width = 29;
  int32 placeholder_cache_height = 30;
  int32 image_cache_width = 31;
  int32 image_cache_height = 32;
}

// package:flutter/src/widgets/fade_in_image.dart
//
// Creates a widget that uses a placeholder image stored in memory while
// loading the final image from the network.
//
// The `placeholder` argument contains the bytes of the in-memory image.
//
// The `image` argument is the URL of the final image.
//
// The `placeholderScale` and `imageScale` arguments are passed to their
// respective [ImageProvider]s (see also [ImageInfo.scale]).
//
// If [placeholderCacheWidth], [placeholderCacheHeight], [imageCacheWidth],
// or [imageCacheHeight] are provided, it indicates to the
// engine that the respective image should be decoded at the specified size.
// The image will be rendered to the constraints of the layout or [width]
// and [height] regardless of these parameters. These parameters are primarily
// intended to reduce the memory usage of [ImageCache].
//
// The [placeholder], [image], [placeholderScale], [imageScale],
// [fadeOutDuration], [fadeOutCurve], [fadeInDuration], [fadeInCurve],
// [alignment], [repeat], and [matchTextDirection] arguments must not be
// null.
//
// See also:
//
//  * [Image.memory], which has more details about loading images from
//    memory.
//  * [Image.network], which has more details about loading images from
//    the network.
message FlutterFadeInImageNamedMemoryNetwork {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  DartUint8ListType placeholder = 3;
  string image = 5;
  double placeholder_scale = 7;
  double image_scale = 8;
  // Whether to exclude this image from semantics.
  //
  // This is useful for images which do not contribute meaningful information
  // to an application.
  bool exclude_from_semantics = 9;
  // A semantic description of the [image].
  //
  // Used to provide a description of the [image] to TalkBack on Android, and
  // VoiceOver on iOS.
  //
  // This description will be used both while the [placeholder] is shown and
  // once the image has loaded.
  string image_semantic_label = 10;
  // The duration of the fade-out animation for the [placeholder].
  DartDurationType fade_out_duration = 11;
  // The curve of the fade-out animation for the [placeholder].
  FlutterSrcAnimationCurveType fade_out_curve = 12;
  // The duration of the fade-in animation for the [image].
  DartDurationType fade_in_duration = 13;
  // The curve of the fade-in animation for the [image].
  FlutterSrcAnimationCurveType fade_in_curve = 14;
  // If non-null, require the image to have this width.
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio. This may result in a sudden change if the size of the
  // placeholder image does not match that of the target image. The size is
  // also affected by the scale factor.
  double width = 15;
  // If non-null, require the image to have this height.
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio. This may result in a sudden change if the size of the
  // placeholder image does not match that of the target image. The size is
  // also affected by the scale factor.
  double height = 16;
  // How to inscribe the image into the space allocated during layout.
  //
  // The default varies based on the other fields. See the discussion at
  // [paintImage].
  FlutterBoxFitType.Enum fit = 17;
  // If non-null, this color is blended with each image pixel using [colorBlendMode].
  //
  // Color applies to the [image].
  //
  // See Also:
  //
  //  * [placeholderColor], the color which applies to the [placeholder].
  DartColorType color = 18;
  // Used to combine [color] with this [image].
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [color] is
  // the source and this image is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  //  * [placeholderColorBlendMode], the color blend mode which applies to the [placeholder].
  DartBlendModeType.Enum color_blend_mode = 19;
  // If non-null, this color is blended with each placeholder image pixel using [placeholderColorBlendMode].
  //
  // Color applies to the [placeholder].
  //
  // See Also:
  //
  //  * [color], the color which applies to the [image].
  DartColorType placeholder_color = 20;
  // Used to combine [placeholderColor] with the [placeholder] image.
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [placeholderColor] is
  // the source and this placeholder is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  //  * [colorBlendMode], the color blend mode which applies to the [image].
  DartBlendModeType.Enum placeholder_color_blend_mode = 21;
  // How to inscribe the placeholder image into the space allocated during layout.
  //
  // If not value set, it will fallback to [fit].
  FlutterBoxFitType.Enum placeholder_fit = 22;
  // The rendering quality of the image.
  //
  // {@macro flutter.widgets.image.filterQuality}
  DartFilterQualityType.Enum filter_quality = 23;
  // The rendering quality of the placeholder image.
  //
  // {@macro flutter.widgets.image.filterQuality}
  DartFilterQualityType.Enum placeholder_filter_quality = 24;
  // How to align the image within its bounds.
  //
  // The alignment aligns the given position in the image to the given position
  // in the layout bounds. For example, an [Alignment] alignment of (-1.0,
  // -1.0) aligns the image to the top-left corner of its layout bounds, while an
  // [Alignment] alignment of (1.0, 1.0) aligns the bottom right of the
  // image with the bottom right corner of its layout bounds. Similarly, an
  // alignment of (0.0, 1.0) aligns the bottom middle of the image with the
  // middle of the bottom edge of its layout bounds.
  //
  // If the [alignment] is [TextDirection]-dependent (i.e. if it is a
  // [AlignmentDirectional]), then an ambient [Directionality] widget
  // must be in scope.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 25;
  // How to paint any portions of the layout bounds not covered by the image.
  FlutterImageRepeatType.Enum repeat = 26;
  // Whether to paint the image in the direction of the [TextDirection].
  //
  // If this is true, then in [TextDirection.ltr] contexts, the image will be
  // drawn with its origin in the top left (the "normal" painting direction for
  // images); and in [TextDirection.rtl] contexts, the image will be drawn with
  // a scaling factor of -1 in the horizontal direction so that the origin is
  // in the top right.
  //
  // This is occasionally used with images in right-to-left environments, for
  // images that were designed for left-to-right locales. Be careful, when
  // using this, to not flip images with integral shadows, text, or other
  // effects that will look incorrect when flipped.
  //
  // If this is true, there must be an ambient [Directionality] widget in
  // scope.
  bool match_text_direction = 27;
  int32 placeholder_cache_width = 28;
  int32 placeholder_cache_height = 29;
  int32 image_cache_width = 30;
  int32 image_cache_height = 31;
}

// package:flutter/src/services/text_formatter.dart
//
// Creates a formatter that replaces banned patterns with the given
// [replacementString].
//
// If [allow] is true, then the filter pattern is an allow list,
// and characters must match the pattern to be accepted. See also
// the [FilteringTextInputFormatter.allow()] constructor.
//
// If [allow] is false, then the filter pattern is a deny list,
// and characters that match the pattern are rejected. See also
// the [FilteringTextInputFormatter.deny] constructor.
message FlutterFilteringTextInputFormatter {
  // Whether the pattern is an allow list or not.
  //
  // When true, [filterPattern] denotes an allow list: characters
  // must match the filter to be allowed.
  //
  // When false, [filterPattern] denotes a deny list: characters
  // that match the filter are disallowed.
  bool allow = 3;
  // String used to replace banned patterns.
  //
  // For deny lists ([allow] is false), each match of the
  // [filterPattern] is replaced with this string. If [filterPattern]
  // can match more than one character at a time, then this can
  // result in multiple characters being replaced by a single
  // instance of this [replacementString].
  //
  // For allow lists ([allow] is true), sequences between matches of
  // [filterPattern] are replaced as one, regardless of the number of
  // characters.
  //
  // For example, consider a [filterPattern] consisting of just the
  // letter "o", applied to text field whose initial value is the
  // string "Into The Woods", with the [replacementString] set to
  // `*`.
  //
  // If [allow] is true, then the result will be "*o*oo*". Each
  // sequence of characters not matching the pattern is replaced by
  // its own single copy of the replacement string, regardless of how
  // many characters are in that sequence.
  //
  // If [allow] is false, then the result will be "Int* the W**ds".
  // Every matching sequence is replaced, and each "o" matches the
  // pattern separately.
  //
  // If the pattern was the [RegExp] `o+`, the result would be the
  // same in the case where [allow] is true, but in the case where
  // [allow] is false, the result would be "Int* the W*ds" (with the
  // two "o"s replaced by a single occurrence of the replacement
  // string) because both of the "o"s would be matched simultaneously
  // by the pattern.
  //
  // The filter may adjust the selection and the composing region of the text
  // after applying the text replacement, such that they still cover the same
  // text. For instance, if the pattern was `o+` and the last character "s" was
  // selected: "Into The Wood|s|", then the result will be "Into The W*d|s|",
  // with the selection still around the same character "s" despite that it is
  // now the 12th character.
  //
  // In the case where one end point of the selection (or the composing region)
  // is strictly inside the banned pattern (for example, "Into The |Wo|ods"),
  // that endpoint will be moved to the end of the replacement string (it will
  // become "Into The |W*|ds" if the pattern was `o+` and the original text and
  // selection were "Into The |Wo|ods").
  string replacement_string = 4;
}

// package:flutter/src/services/text_formatter.dart
//
// Creates a formatter that only allows characters matching a pattern.
message FlutterFilteringTextInputFormatterNamedAllow {
  string replacement_string = 3;
}

// package:flutter/src/services/text_formatter.dart
//
// Creates a formatter that blocks characters matching a pattern.
message FlutterFilteringTextInputFormatterNamedDeny {
  string replacement_string = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that scales and positions its child within itself according to [fit].
message FlutterFittedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How to inscribe the child into the space allocated during layout.
  FlutterBoxFitType.Enum fit = 3;
  // How to align the child within its parent's bounds.
  //
  // An alignment of (-1.0, -1.0) aligns the child to the top-left corner of its
  // parent's bounds. An alignment of (1.0, 0.0) aligns the child to the middle
  // of the right edge of its parent's bounds.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 4;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 5;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 6;
}

// package:flutter/src/rendering/table.dart
//
// Creates a column width based on a fixed number of logical pixels.
message FlutterFixedColumnWidth {
  // The width the column should occupy in logical pixels.
  double value = 2;
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// Creates a scroll controller for scrollables whose items have the same size.
//
// [initialItem] defaults to zero.
message FlutterFixedExtentScrollController {
  // The page to show when first creating the scroll view.
  //
  // Defaults to zero.
  int32 initial_item = 2;
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// Creates a scroll physics that always lands on items.
message FlutterFixedExtentScrollPhysics {
  // If non-null, determines the default behavior for each method.
  //
  // If a subclass of [ScrollPhysics] does not override a method, that subclass
  // will inherit an implementation from this base class that defers to
  // [parent]. This mechanism lets you assemble novel combinations of
  // [ScrollPhysics] subclasses at runtime. For example:
  //
  // ```dart
  // const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
  // ```
  //
  // will result in a [ScrollPhysics] that has the combined behavior
  // of [BouncingScrollPhysics] and [AlwaysScrollableScrollPhysics]:
  // behaviors that are not specified in [BouncingScrollPhysics]
  // (e.g. [shouldAcceptUserOffset]) will defer to [AlwaysScrollableScrollPhysics].
  FlutterScrollPhysicsType parent = 2;
}

// package:flutter/src/foundation/diagnostics.dart
//
// Constructs a FlagProperty with the given descriptions with the specified descriptions.
//
// [showName] defaults to false as typically [ifTrue] and [ifFalse] should
// be descriptions that make the property name redundant.
message FlutterFlagProperty {
  string name = 2;
  bool value = 3;
  // Description to use if the property [value] is true.
  //
  // If not specified and [value] equals true the property's priority [level]
  // will be [DiagnosticLevel.hidden].
  string if_true = 4;
  // Description to use if the property value is false.
  //
  // If not specified and [value] equals false, the property's priority [level]
  // will be [DiagnosticLevel.hidden].
  string if_false = 5;
  bool show_name = 6;
  FlutterDiagnosticLevelType.Enum level = 8;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a flex layout.
//
// The [direction] is required.
//
// If [crossAxisAlignment] is [CrossAxisAlignment.baseline], then
// [textBaseline] must not be null.
//
// The [textDirection] argument defaults to the ambient [Directionality], if
// any. If there is no ambient directionality, and a text direction is going
// to be necessary to decide which direction to lay the children in or to
// disambiguate `start` or `end` values for the main or cross axis
// directions, the [textDirection] must not be null.
message FlutterFlex {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The direction to use as the main axis.
  //
  // If you know the axis in advance, then consider using a [Row] (if it's
  // horizontal) or [Column] (if it's vertical) instead of a [Flex], since that
  // will be less verbose. (For [Row] and [Column] this property is fixed to
  // the appropriate axis.)
  FlutterAxisType.Enum direction = 3;
  // How the children should be placed along the main axis.
  //
  // For example, [MainAxisAlignment.start], the default, places the children
  // at the start (i.e., the left for a [Row] or the top for a [Column]) of the
  // main axis.
  FlutterMainAxisAlignmentType.Enum main_axis_alignment = 4;
  // How much space should be occupied in the main axis.
  //
  // After allocating space to children, there might be some remaining free
  // space. This value controls whether to maximize or minimize the amount of
  // free space, subject to the incoming layout constraints.
  //
  // If some children have a non-zero flex factors (and none have a fit of
  // [FlexFit.loose]), they will expand to consume all the available space and
  // there will be no remaining free space to maximize or minimize, making this
  // value irrelevant to the final layout.
  FlutterMainAxisSizeType.Enum main_axis_size = 5;
  // How the children should be placed along the cross axis.
  //
  // For example, [CrossAxisAlignment.center], the default, centers the
  // children in the cross axis (e.g., horizontally for a [Column]).
  FlutterCrossAxisAlignmentType.Enum cross_axis_alignment = 6;
  // Determines the order to lay children out horizontally and how to interpret
  // `start` and `end` in the horizontal direction.
  //
  // Defaults to the ambient [Directionality].
  //
  // If [textDirection] is [TextDirection.rtl], then the direction in which
  // text flows starts from right to left. Otherwise, if [textDirection] is
  // [TextDirection.ltr], then the direction in which text flows starts from
  // left to right.
  //
  // If the [direction] is [Axis.horizontal], this controls the order in which
  // the children are positioned (left-to-right or right-to-left), and the
  // meaning of the [mainAxisAlignment] property's [MainAxisAlignment.start] and
  // [MainAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.horizontal], and either the
  // [mainAxisAlignment] is either [MainAxisAlignment.start] or
  // [MainAxisAlignment.end], or there's more than one child, then the
  // [textDirection] (or the ambient [Directionality]) must not be null.
  //
  // If the [direction] is [Axis.vertical], this controls the meaning of the
  // [crossAxisAlignment] property's [CrossAxisAlignment.start] and
  // [CrossAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.vertical], and the [crossAxisAlignment] is
  // either [CrossAxisAlignment.start] or [CrossAxisAlignment.end], then the
  // [textDirection] (or the ambient [Directionality]) must not be null.
  DartTextDirectionType.Enum text_direction = 7;
  // Determines the order to lay children out vertically and how to interpret
  // `start` and `end` in the vertical direction.
  //
  // Defaults to [VerticalDirection.down].
  //
  // If the [direction] is [Axis.vertical], this controls which order children
  // are painted in (down or up), the meaning of the [mainAxisAlignment]
  // property's [MainAxisAlignment.start] and [MainAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.vertical], and either the [mainAxisAlignment]
  // is either [MainAxisAlignment.start] or [MainAxisAlignment.end], or there's
  // more than one child, then the [verticalDirection] must not be null.
  //
  // If the [direction] is [Axis.horizontal], this controls the meaning of the
  // [crossAxisAlignment] property's [CrossAxisAlignment.start] and
  // [CrossAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.horizontal], and the [crossAxisAlignment] is
  // either [CrossAxisAlignment.start] or [CrossAxisAlignment.end], then the
  // [verticalDirection] must not be null.
  FlutterVerticalDirectionType.Enum vertical_direction = 8;
  // If aligning items according to their baseline, which baseline to use.
  //
  // This must be set if using baseline alignment. There is no default because there is no
  // way for the framework to know the correct baseline _a priori_.
  DartTextBaselineType.Enum text_baseline = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 11;
}

// package:flutter/src/rendering/table.dart
//
// Creates a column width based on a fraction of the remaining space once all
// the other columns have been laid out.
message FlutterFlexColumnWidth {
  // The fraction of the remaining space once all the other columns have
  // been laid out that this column should occupy.
  double value = 2;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that controls how a child of a [Row], [Column], or [Flex]
// flexes.
message FlutterFlexible {
  FlutterKeyType key = 2;
  // The flex factor to use for this child.
  //
  // If null or zero, the child is inflexible and determines its own size. If
  // non-zero, the amount of space the child's can occupy in the main axis is
  // determined by dividing the free space (after placing the inflexible
  // children) according to the flex factors of the flexible children.
  int32 flex = 3;
  // How a flexible child is inscribed into the available space.
  //
  // If [flex] is non-zero, the [fit] determines whether the child fills the
  // space the parent makes available during layout. If the fit is
  // [FlexFit.tight], the child is required to fill the available space. If the
  // fit is [FlexFit.loose], the child can be at most as large as the available
  // space (but is allowed to be smaller).
  FlutterFlexFitType.Enum fit = 4;
  WidgetType child = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a flow layout.
//
// Wraps each of the given children in a [RepaintBoundary] to avoid
// repainting the children when the flow repaints.
message FlutterFlow {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  repeated WidgetType children = 4;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a flow layout.
//
// Does not wrap the given children in repaint boundaries, unlike the default
// constructor. Useful when the child is trivial to paint or already contains
// a repaint boundary.
message FlutterFlowNamedUnwrapped {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 4;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 5;
}

// package:flutter/src/foundation/assertions.dart
//
// Create an error message from a string.
//
// The message may have newlines in it. The first line should be a terse
// description of the error, e.g. "Incorrect GlobalKey usage" or "setState()
// or markNeedsBuild() called during build". Subsequent lines should contain
// substantial additional information, ideally sufficient to develop a
// correct solution to the problem.
//
// In some cases, when a [FlutterError] is reported to the user, only the first
// line is included. For example, Flutter will typically only fully report
// the first exception at runtime, displaying only the first line of
// subsequent errors.
//
// All sentences in the error should be correctly punctuated (i.e.,
// do end the error message with a period).
//
// This constructor defers to the [FlutterError.fromParts] constructor.
// The first line is wrapped in an implied [ErrorSummary], and subsequent
// lines are wrapped in implied [ErrorDescription]s. Consider using the
// [FlutterError.fromParts] constructor to provide more detail, e.g.
// using [ErrorHint]s or other [DiagnosticsNode]s.
message FlutterFlutterError {
  string message = 2;
}

// package:flutter/src/foundation/assertions.dart
//
// Create an error message from a list of [DiagnosticsNode]s.
//
// By convention, there should be exactly one [ErrorSummary] in the list,
// and it should be the first entry.
//
// Other entries are typically [ErrorDescription]s (for material that is
// always applicable for this error) and [ErrorHint]s (for material that may
// be sometimes useful, but may not always apply). Other [DiagnosticsNode]
// subclasses, such as [DiagnosticsStackTrace], may
// also be used.
//
// When using an [ErrorSummary], [ErrorDescription]s, and [ErrorHint]s, in
// debug builds, values interpolated into the `message` arguments of those
// classes' constructors are expanded and placed into the
// [DiagnosticsProperty.value] property of those objects (which is of type
// [List<Object>]). This allows IDEs to examine values interpolated into
// error messages.
//
// Alternatively, to include a specific [Diagnosticable] object into the
// error message and have the object describe itself in detail (see
// [DiagnosticsNode.toStringDeep]), consider calling
// [Diagnosticable.toDiagnosticsNode] on that object and using that as one of
// the values passed to this constructor.
//
// {@tool snippet}
// In this example, an error is thrown in debug mode if certain conditions
// are not met. The error message includes a description of an object that
// implements the [Diagnosticable] interface, `draconis`.
//
// ```dart
// void controlDraconis() {
//   assert(() {
//     if (!draconisAlive || !draconisAmulet) {
//       throw FlutterError.fromParts(<DiagnosticsNode>[
//         ErrorSummary('Cannot control Draconis in current state.'),
//         ErrorDescription('Draconis can only be controlled while alive and while the amulet is wielded.'),
//         if (!draconisAlive)
//           ErrorHint('Draconis is currently not alive.'),
//         if (!draconisAmulet)
//           ErrorHint('The Amulet of Draconis is currently not wielded.'),
//         draconis.toDiagnosticsNode(name: 'Draconis'),
//       ]);
//     }
//     return true;
//   }());
//   // ...
// }
// ```
// {@end-tool}
message FlutterFlutterErrorNamedFromParts {
  // The information associated with this error, in structured form.
  //
  // The first node is typically an [ErrorSummary] giving a short description
  // of the problem, suitable for an index of errors, a log, etc.
  //
  // Subsequent nodes should give information specific to this error. Typically
  // these will be [ErrorDescription]s or [ErrorHint]s, but they could be other
  // objects also. For instance, an error relating to a timer could include a
  // stack trace of when the timer was scheduled using the
  // [DiagnosticsStackTrace] class.
  repeated FlutterDiagnosticsNodeType diagnostics = 2;
}

// package:flutter/src/painting/flutter_logo.dart
//
// Creates a decoration that knows how to paint Flutter's logo.
//
// The [style] controls whether and where to draw the "Flutter" label. If one
// is shown, the [textColor] controls the color of the label.
message FlutterFlutterLogoDecoration {
  // The color used to paint the "Flutter" text on the logo, if [style] is
  // [FlutterLogoStyle.horizontal] or [FlutterLogoStyle.stacked].
  //
  // If possible, the default (a medium grey) should be used against a white
  // background.
  DartColorType text_color = 2;
  // Whether and where to draw the "Flutter" text. By default, only the logo
  // itself is drawn.
  FlutterFlutterLogoStyleType.Enum style = 3;
  // How far to inset the logo from the edge of the container.
  FlutterEdgeInsetsType margin = 4;
}

// package:flutter/src/widgets/focus_scope.dart
//
// Creates a widget that manages a [FocusNode].
message FlutterFocus {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The child widget of this [Focus].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // {@template flutter.widgets.Focus.focusNode}
  // An optional focus node to use as the focus node for this widget.
  //
  // If one is not supplied, then one will be automatically allocated, owned,
  // and managed by this widget. The widget will be focusable even if a
  // [focusNode] is not supplied. If supplied, the given [focusNode] will be
  // _hosted_ by this widget, but not owned. See [FocusNode] for more
  // information on what being hosted and/or owned implies.
  //
  // Supplying a focus node is sometimes useful if an ancestor to this widget
  // wants to control when this widget has the focus. The owner will be
  // responsible for calling [FocusNode.dispose] on the focus node when it is
  // done with it, but this widget will attach/detach and reparent the node
  // when needed.
  // {@endtemplate}
  //
  // A non-null [focusNode] must be supplied if using the
  // [Focus.withExternalFocusNode] constructor.
  FlutterFocusNodeType focus_node = 4;
  // The optional parent node to use when reparenting the [focusNode] for this
  // [Focus] widget.
  //
  // If [parentNode] is null, then [Focus.maybeOf] is used to find the parent
  // in the widget tree, which is typically what is desired, since it is easier
  // to reason about the focus tree if it mirrors the shape of the widget tree.
  //
  // Set this property if the focus tree needs to have a different shape than
  // the widget tree. This is typically in cases where a dialog is in an
  // [Overlay] (or another part of the widget tree), and focus should
  // behave as if the widgets in the overlay are descendants of the given
  // [parentNode] for purposes of focus.
  //
  // Defaults to null.
  FlutterFocusNodeType parent_node = 5;
  // {@template flutter.widgets.Focus.autofocus}
  // True if this widget will be selected as the initial focus when no other
  // node in its scope is currently focused.
  //
  // Ideally, there is only one widget with autofocus set in each [FocusScope].
  // If there is more than one widget with autofocus set, then the first one
  // added to the tree will get focus.
  //
  // Defaults to false.
  // {@endtemplate}
  bool autofocus = 6;
  bool can_request_focus = 9;
  bool skip_traversal = 10;
  bool descendants_are_focusable = 11;
  bool descendants_are_traversable = 12;
  // {@template flutter.widgets.Focus.includeSemantics}
  // Include semantics information in this widget.
  //
  // If true, this widget will include a [Semantics] node that indicates the
  // [SemanticsProperties.focusable] and [SemanticsProperties.focused]
  // properties.
  //
  // It is not typical to set this to false, as that can affect the semantics
  // information available to accessibility systems.
  //
  // Defaults to true.
  // {@endtemplate}
  bool include_semantics = 13;
  string debug_label = 14;
}

// package:flutter/src/widgets/focus_manager.dart
//
// Creates an object that manages the focus tree.
//
// This constructor is rarely called directly. To access the [FocusManager],
// consider using the [FocusManager.instance] accessor instead (which gets it
// from the [WidgetsBinding] singleton).
//
// This newly constructed focus manager does not have the necessary event
// handlers registered to allow it to manage focus. To register those event
// handlers, callers must call [registerGlobalHandlers]. See the
// documentation in that method for caveats to watch out for.
message FlutterFocusManager {
  
}

// package:flutter/src/widgets/focus_scope.dart
//
// Creates a Focus widget that uses the given [focusNode] as the source of
// truth for attributes on the node, rather than the attributes of this widget.
message FlutterFocusNamedWithExternalFocusNode {
  FlutterKeyType key = 2;
  WidgetType child = 3;
  FlutterFocusNodeType focus_node = 4;
  FlutterFocusNodeType parent_node = 5;
  bool autofocus = 6;
  bool include_semantics = 8;
}

// package:flutter/src/widgets/focus_manager.dart
//
// Creates a focus node.
//
// The [debugLabel] is ignored on release builds.
//
// To receive key events that focuses on this node, pass a listener to
// `onKeyEvent`.
message FlutterFocusNode {
  string debug_label = 2;
  bool skip_traversal = 4;
  bool can_request_focus = 5;
  bool descendants_are_focusable = 6;
  bool descendants_are_traversable = 7;
}

// package:flutter/src/widgets/focus_scope.dart
//
// Creates a widget that manages a [FocusScopeNode].
message FlutterFocusScope {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterFocusScopeNodeType node = 3;
  // The optional parent node to use when reparenting the [focusNode] for this
  // [Focus] widget.
  //
  // If [parentNode] is null, then [Focus.maybeOf] is used to find the parent
  // in the widget tree, which is typically what is desired, since it is easier
  // to reason about the focus tree if it mirrors the shape of the widget tree.
  //
  // Set this property if the focus tree needs to have a different shape than
  // the widget tree. This is typically in cases where a dialog is in an
  // [Overlay] (or another part of the widget tree), and focus should
  // behave as if the widgets in the overlay are descendants of the given
  // [parentNode] for purposes of focus.
  //
  // Defaults to null.
  FlutterFocusNodeType parent_node = 4;
  // The child widget of this [Focus].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
  // {@template flutter.widgets.Focus.autofocus}
  // True if this widget will be selected as the initial focus when no other
  // node in its scope is currently focused.
  //
  // Ideally, there is only one widget with autofocus set in each [FocusScope].
  // If there is more than one widget with autofocus set, then the first one
  // added to the tree will get focus.
  //
  // Defaults to false.
  // {@endtemplate}
  bool autofocus = 6;
  bool can_request_focus = 8;
  bool skip_traversal = 9;
  string debug_label = 12;
}

// package:flutter/src/widgets/focus_scope.dart
//
// Creates a FocusScope widget that uses the given [focusScopeNode] as the
// source of truth for attributes on the node, rather than the attributes of
// this widget.
message FlutterFocusScopeNamedWithExternalFocusNode {
  FlutterKeyType key = 2;
  WidgetType child = 3;
  FlutterFocusScopeNodeType focus_scope_node = 4;
  FlutterFocusNodeType parent_node = 5;
  bool autofocus = 6;
}

// package:flutter/src/widgets/focus_manager.dart
//
// Creates a [FocusScopeNode].
//
// All parameters are optional.
message FlutterFocusScopeNode {
  string debug_label = 2;
  bool skip_traversal = 4;
  bool can_request_focus = 5;
  // Controls the transfer of focus beyond the first and the last items of a
  // [FocusScopeNode].
  //
  // Changing this field value has no immediate effect on the UI. Instead, next time
  // focus traversal takes place [FocusTraversalPolicy] will read this value
  // and apply the new behavior.
  FlutterTraversalEdgeBehaviorType.Enum traversal_edge_behavior = 6;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Creates a [FocusTraversalGroup] object.
message FlutterFocusTraversalGroup {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterFocusTraversalPolicyType policy = 3;
  // {@macro flutter.widgets.Focus.descendantsAreFocusable}
  bool descendants_are_focusable = 4;
  // {@macro flutter.widgets.Focus.descendantsAreTraversable}
  bool descendants_are_traversable = 5;
  // The child widget of this [FocusTraversalGroup].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 6;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Creates an inherited widget used to describe the focus order of
// the [child] subtree.
message FlutterFocusTraversalOrder {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The order for the widget descendants of this [FocusTraversalOrder].
  FlutterFocusOrderType order = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/actions.dart
//
// Create a const [FocusableActionDetector].
message FlutterFocusableActionDetector {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Is this widget enabled or not.
  //
  // If disabled, will not send any notifications needed to update highlight or
  // focus state, and will not define or respond to any actions or shortcuts.
  //
  // When disabled, adds [Focus] to the widget tree, but sets
  // [Focus.canRequestFocus] to false.
  bool enabled = 3;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 4;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 5;
  // {@macro flutter.widgets.Focus.descendantsAreFocusable}
  bool descendants_are_focusable = 6;
  // {@macro flutter.widgets.Focus.descendantsAreTraversable}
  bool descendants_are_traversable = 7;
  // Whether to include semantics from [Focus].
  //
  // Defaults to true.
  bool include_focus_semantics = 14;
  // The child widget for this [FocusableActionDetector] widget.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 15;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a follower layer.
//
// The [unlinkedOffset], [linkedOffset], and [showWhenUnlinked] properties
// must be non-null before the compositing phase of the pipeline.
message FlutterFollowerLayer {
  // The link to the [LeaderLayer].
  //
  // The same object should be provided to a [LeaderLayer] that is earlier in
  // the layer tree. When this layer is composited, it will apply a transform
  // that moves its children to match the position of the [LeaderLayer].
  FlutterLayerLinkType link = 2;
  // Whether to show the layer's contents when the [link] does not point to a
  // [LeaderLayer].
  //
  // When the layer is linked, children layers are positioned such that they
  // have the same global position as the linked [LeaderLayer].
  //
  // When the layer is not linked, then: if [showWhenUnlinked] is true,
  // children are positioned as if the [FollowerLayer] was a [ContainerLayer];
  // if it is false, then children are hidden.
  //
  // The [showWhenUnlinked] property must be non-null before the compositing
  // phase of the pipeline.
  bool show_when_unlinked = 3;
  // Offset from parent in the parent's coordinate system, used when the layer
  // is not linked to a [LeaderLayer].
  //
  // The scene must be explicitly recomposited after this property is changed
  // (as described at [Layer]).
  //
  // The [unlinkedOffset] property must be non-null before the compositing
  // phase of the pipeline.
  //
  // See also:
  //
  //  * [linkedOffset], for when the layers are linked.
  DartOffsetType unlinked_offset = 4;
  // Offset from the origin of the leader layer to the origin of the child
  // layers, used when the layer is linked to a [LeaderLayer].
  //
  // The scene must be explicitly recomposited after this property is changed
  // (as described at [Layer]).
  //
  // The [linkedOffset] property must be non-null before the compositing phase
  // of the pipeline.
  //
  // See also:
  //
  //  * [unlinkedOffset], for when the layer is not linked.
  DartOffsetType linked_offset = 5;
}

// package:flutter/src/gestures/force_press.dart
//
// Creates a force press gesture recognizer.
//
// The [startPressure] defaults to 0.4, and [peakPressure] defaults to 0.85
// where a value of 0.0 is no pressure and a value of 1.0 is maximum pressure.
//
// The [startPressure], [peakPressure] and [interpolation] arguments must not
// be null. The [peakPressure] argument must be greater than [startPressure].
// The [interpolation] callback must always return a value in the range 0.0
// to 1.0 for values of `pressure` that are between `pressureMin` and
// `pressureMax`.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterForcePressGestureRecognizer {
  // The pressure of the press required to initiate a force press.
  //
  // A value of 0.0 is no pressure, and 1.0 is maximum pressure.
  double start_pressure = 2;
  // The pressure of the press required to peak a force press.
  //
  // A value of 0.0 is no pressure, and 1.0 is maximum pressure. This value
  // must be greater than [startPressure].
  double peak_pressure = 3;
}

// package:flutter/src/widgets/form.dart
//
// Creates a container for form fields.
message FlutterForm {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // This is the root of the widget hierarchy that contains this form.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // {@macro flutter.widgets.PopScope.canPop}
  //
  // {@tool dartpad}
  // This sample demonstrates how to use this parameter to show a confirmation
  // dialog when a navigation pop would cause form data to be lost.
  //
  // ** See code in examples/api/lib/widgets/form/form.1.dart **
  // {@end-tool}
  //
  // See also:
  //
  //  * [onPopInvoked], which also comes from [PopScope] and is often used in
  //    conjunction with this parameter.
  //  * [PopScope.canPop], which is what [Form] delegates to internally.
  bool can_pop = 4;
  FlutterAutovalidateModeType.Enum autovalidate_mode = 7;
}

// package:flutter/src/rendering/table.dart
//
// Creates a column width based on a fraction of the table's constraints'
// maxWidth.
message FlutterFractionColumnWidth {
  // The fraction of the table's constraints' maxWidth that this column should
  // occupy.
  double value = 2;
}

// package:flutter/src/painting/fractional_offset.dart
//
// Creates a fractional offset.
message FlutterFractionalOffset {
  double dx = 2;
  double dy = 3;
}

// package:flutter/src/painting/fractional_offset.dart
//
// Creates a fractional offset from a specific offset and rectangle.
//
// The offset is assumed to be relative to the same origin as the rectangle.
//
// If the offset is relative to the top left of the rectangle, use [
// FractionalOffset.fromOffsetAndSize] instead, passing `rect.size`.
//
// The returned [FractionalOffset] describes the position of the
// [Offset] in the [Rect], as a fraction of the [Rect].
message FlutterFractionalOffsetNamedFromOffsetAndRect {
  DartOffsetType offset = 2;
  DartRectType rect = 3;
}

// package:flutter/src/painting/fractional_offset.dart
//
// Creates a fractional offset from a specific offset and size.
//
// The returned [FractionalOffset] describes the position of the
// [Offset] in the [Size], as a fraction of the [Size].
message FlutterFractionalOffsetNamedFromOffsetAndSize {
  DartOffsetType offset = 2;
  DartSizeType size = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that translates its child's painting.
message FlutterFractionalTranslation {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The translation to apply to the child, scaled to the child's size.
  //
  // For example, an [Offset] with a `dx` of 0.25 will result in a horizontal
  // translation of one quarter the width of the child.
  DartOffsetType translation = 3;
  // Whether to apply the translation when performing hit tests.
  bool transform_hit_tests = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that sizes its child to a fraction of the total available space.
//
// If non-null, the [widthFactor] and [heightFactor] arguments must be
// non-negative.
message FlutterFractionallySizedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.basic.fractionallySizedBox.alignment}
  // How to align the child.
  //
  // The x and y values of the alignment control the horizontal and vertical
  // alignment, respectively. An x value of -1.0 means that the left edge of
  // the child is aligned with the left edge of the parent whereas an x value
  // of 1.0 means that the right edge of the child is aligned with the right
  // edge of the parent. Other values interpolate (and extrapolate) linearly.
  // For example, a value of 0.0 means that the center of the child is aligned
  // with the center of the parent.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  // {@endtemplate}
  FlutterAlignmentGeometryType alignment = 3;
  // {@template flutter.widgets.basic.fractionallySizedBox.widthFactor}
  // If non-null, the fraction of the incoming width given to the child.
  //
  // If non-null, the child is given a tight width constraint that is the max
  // incoming width constraint multiplied by this factor.
  //
  // If null, the incoming width constraints are passed to the child
  // unmodified.
  // {@endtemplate}
  double width_factor = 4;
  // {@template flutter.widgets.basic.fractionallySizedBox.heightFactor}
  // If non-null, the fraction of the incoming height given to the child.
  //
  // If non-null, the child is given a tight height constraint that is the max
  // incoming height constraint multiplied by this factor.
  //
  // If null, the incoming height constraints are passed to the child
  // unmodified.
  // {@endtemplate}
  double height_factor = 5;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 6;
}

// package:flutter/src/widgets/gesture_detector.dart
//
// Creates a widget that detects gestures.
//
// Pan and scale callbacks cannot be used simultaneously because scale is a
// superset of pan. Use the scale callbacks instead.
//
// Horizontal and vertical drag callbacks cannot be used simultaneously
// because a combination of a horizontal and vertical drag is a pan.
// Use the pan callbacks instead.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=WhVXkCFPmK4}
//
// By default, gesture detectors contribute semantic information to the tree
// that is used by assistive technology.
message FlutterGestureDetector {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // How this gesture detector should behave during hit testing when deciding
  // how the hit test propagates to children and whether to consider targets
  // behind this one.
  //
  // This defaults to [HitTestBehavior.deferToChild] if [child] is not null and
  // [HitTestBehavior.translucent] if child is null.
  //
  // See [HitTestBehavior] for the allowed values and their meanings.
  FlutterHitTestBehaviorType.Enum behavior = 61;
  // Whether to exclude these gestures from the semantics tree. For
  // example, the long-press gesture for showing a tooltip is
  // excluded because the tooltip itself is included in the semantics
  // tree directly and so having a gesture to show it would result in
  // duplication of information.
  bool exclude_from_semantics = 62;
  // Determines the way that drag start behavior is handled.
  //
  // If set to [DragStartBehavior.start], gesture drag behavior will
  // begin at the position where the drag gesture won the arena. If set to
  // [DragStartBehavior.down] it will begin at the position where a down event
  // is first detected.
  //
  // In general, setting this to [DragStartBehavior.start] will make drag
  // animation smoother and setting it to [DragStartBehavior.down] will make
  // drag behavior feel slightly more reactive.
  //
  // By default, the drag start behavior is [DragStartBehavior.start].
  //
  // Only the [DragGestureRecognizer.onStart] callbacks for the
  // [VerticalDragGestureRecognizer], [HorizontalDragGestureRecognizer] and
  // [PanGestureRecognizer] are affected by this setting.
  //
  // See also:
  //
  //  * [DragGestureRecognizer.dragStartBehavior], which gives an example for the different behaviors.
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 63;
  // {@macro flutter.gestures.scale.trackpadScrollCausesScale}
  bool trackpad_scroll_causes_scale = 64;
  // {@macro flutter.gestures.scale.trackpadScrollToScaleFactor}
  DartOffsetType trackpad_scroll_to_scale_factor = 65;
}

// package:flutter/src/widgets/framework.dart
//
// Creates a [LabeledGlobalKey], which is a [GlobalKey] with a label used for
// debugging.
//
// The label is purely for debugging and not used for comparing the identity
// of the key.
message FlutterGlobalKey {
  string debug_label = 2;
}

// package:flutter/src/widgets/overscroll_indicator.dart
//
// Creates a visual indication that a scroll view has overscrolled.
//
// In order for this widget to display an overscroll indication, the [child]
// widget must contain a widget that generates a [ScrollNotification], such
// as a [ListView] or a [GridView].
message FlutterGlowingOverscrollIndicator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether to show the overscroll glow on the side with negative scroll
  // offsets.
  //
  // For a vertical downwards viewport, this is the top side.
  //
  // Defaults to true.
  //
  // See [showTrailing] for the corresponding control on the other side of the
  // viewport.
  bool show_leading = 3;
  // Whether to show the overscroll glow on the side with positive scroll
  // offsets.
  //
  // For a vertical downwards viewport, this is the bottom side.
  //
  // Defaults to true.
  //
  // See [showLeading] for the corresponding control on the other side of the
  // viewport.
  bool show_trailing = 4;
  // {@template flutter.overscroll.axisDirection}
  // The direction of positive scroll offsets in the [Scrollable] whose
  // overscrolls are to be visualized.
  // {@endtemplate}
  FlutterAxisDirectionType.Enum axis_direction = 5;
  // The color of the glow. The alpha channel is ignored.
  DartColorType color = 6;
  // The widget below this widget in the tree.
  //
  // The overscroll indicator will paint on top of this child. This child (and its
  // subtree) should include a source of [ScrollNotification] notifications.
  //
  // Typically a [GlowingOverscrollIndicator] is created by a
  // [ScrollBehavior.buildOverscrollIndicator] method, in which case
  // the child is usually the one provided as an argument to that method.
  WidgetType child = 8;
}

// package:flutter/src/painting/gradient.dart
//
// Constructs a [GradientRotation] for the specified angle.
//
// The angle is in radians in the clockwise direction.
message FlutterGradientRotation {
  // The angle of rotation in radians in the clockwise direction.
  double radians = 2;
}

// package:flutter/src/widgets/grid_paper.dart
//
// Creates a widget that draws a rectilinear grid of 1-pixel-wide lines.
message FlutterGridPaper {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The color to draw the lines in the grid.
  //
  // Defaults to a light blue commonly seen on traditional grid paper.
  DartColorType color = 3;
  // The distance between the primary lines in the grid, in logical pixels.
  //
  // Each primary line is one logical pixel wide.
  double interval = 4;
  // The number of major divisions within each primary grid cell.
  //
  // This is the number of major divisions per [interval], including the
  // primary grid's line.
  //
  // The lines after the first are half a logical pixel wide.
  //
  // If this is set to 2 (the default), then for each [interval] there will be
  // a 1-pixel line on the left, a half-pixel line in the middle, and a 1-pixel
  // line on the right (the latter being the 1-pixel line on the left of the
  // next [interval]).
  int32 divisions = 5;
  // The number of minor divisions within each major division, including the
  // major division itself.
  //
  // If [subdivisions] is 5 (the default), it means that there will be four
  // lines between each major ([divisions]) line.
  //
  // The subdivision lines after the first are a quarter of a logical pixel wide.
  int32 subdivisions = 6;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 7;
}

// package:flutter/src/widgets/scroll_view.dart
//
// Creates a scrollable, 2D array of widgets with a custom
// [SliverGridDelegate].
//
// The `addAutomaticKeepAlives` argument corresponds to the
// [SliverChildListDelegate.addAutomaticKeepAlives] property. The
// `addRepaintBoundaries` argument corresponds to the
// [SliverChildListDelegate.addRepaintBoundaries] property. Both must not be
// null.
message FlutterGridView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.scroll_view.scrollDirection}
  // The [Axis] along which the scroll view's offset increases.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.vertical].
  // {@endtemplate}
  FlutterAxisType.Enum scroll_direction = 3;
  // {@template flutter.widgets.scroll_view.reverse}
  // Whether the scroll view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  // {@endtemplate}
  bool reverse = 4;
  // {@template flutter.widgets.scroll_view.controller}
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // Must be null if [primary] is true.
  //
  // A [ScrollController] serves several purposes. It can be used to control
  // the initial scroll position (see [ScrollController.initialScrollOffset]).
  // It can be used to control whether the scroll view should automatically
  // save and restore its scroll position in the [PageStorage] (see
  // [ScrollController.keepScrollOffset]). It can be used to read the current
  // scroll position (see [ScrollController.offset]), or change it (see
  // [ScrollController.animateTo]).
  // {@endtemplate}
  FlutterScrollControllerType controller = 5;
  // {@template flutter.widgets.scroll_view.primary}
  // Whether this is the primary scroll view associated with the parent
  // [PrimaryScrollController].
  //
  // When this is true, the scroll view is scrollable even if it does not have
  // sufficient content to actually scroll. Otherwise, by default the user can
  // only scroll the view if it has sufficient content. See [physics].
  //
  // Also when true, the scroll view is used for default [ScrollAction]s. If a
  // ScrollAction is not handled by an otherwise focused part of the application,
  // the ScrollAction will be evaluated using this scroll view, for example,
  // when executing [Shortcuts] key events like page up and down.
  //
  // On iOS, this also identifies the scroll view that will scroll to top in
  // response to a tap in the status bar.
  //
  // Cannot be true while a [ScrollController] is provided to `controller`,
  // only one ScrollController can be associated with a ScrollView.
  //
  // Setting to false will explicitly prevent inheriting any
  // [PrimaryScrollController].
  //
  // Defaults to null. When null, and a controller is not provided,
  // [PrimaryScrollController.shouldInherit] is used to decide automatic
  // inheritance.
  //
  // By default, the [PrimaryScrollController] that is injected by each
  // [ModalRoute] is configured to automatically be inherited on
  // [TargetPlatformVariant.mobile] for ScrollViews in the [Axis.vertical]
  // scroll direction. Adding another to your app will override the
  // PrimaryScrollController above it.
  //
  // The following video contains more information about scroll controllers,
  // the PrimaryScrollController widget, and their impact on your apps:
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=33_0ABjFJUU}
  //
  // {@endtemplate}
  bool primary = 6;
  FlutterScrollPhysicsType physics = 7;
  // {@template flutter.widgets.scroll_view.shrinkWrap}
  // Whether the extent of the scroll view in the [scrollDirection] should be
  // determined by the contents being viewed.
  //
  // If the scroll view does not shrink wrap, then the scroll view will expand
  // to the maximum allowed size in the [scrollDirection]. If the scroll view
  // has unbounded constraints in the [scrollDirection], then [shrinkWrap] must
  // be true.
  //
  // Shrink wrapping the content of the scroll view is significantly more
  // expensive than expanding to the maximum allowed size because the content
  // can expand and contract during scrolling, which means the size of the
  // scroll view needs to be recomputed whenever the scroll position changes.
  //
  // Defaults to false.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=LUqDNnv_dh0}
  // {@endtemplate}
  bool shrink_wrap = 8;
  // The amount of space by which to inset the children.
  FlutterEdgeInsetsGeometryType padding = 9;
  // A delegate that controls the layout of the children within the [GridView].
  //
  // The [GridView], [GridView.builder], and [GridView.custom] constructors let you specify this
  // delegate explicitly. The other constructors create a [gridDelegate]
  // implicitly.
  FlutterSliverGridDelegateType grid_delegate = 10;
  bool add_automatic_keep_alives = 11;
  bool add_repaint_boundaries = 12;
  bool add_semantic_indexes = 13;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtent}
  double cache_extent = 14;
  repeated WidgetType children = 15;
  int32 semantic_child_count = 16;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 17;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 18;
  // {@template flutter.widgets.scroll_view.keyboardDismissBehavior}
  // [ScrollViewKeyboardDismissBehavior] the defines how this [ScrollView] will
  // dismiss the keyboard automatically.
  // {@endtemplate}
  FlutterScrollViewKeyboardDismissBehaviorType.Enum keyboard_dismiss_behavior = 19;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 20;
}

// package:flutter/src/widgets/scroll_view.dart
//
// Creates a scrollable, 2D array of widgets with a fixed number of tiles in
// the cross axis.
//
// Uses a [SliverGridDelegateWithFixedCrossAxisCount] as the [gridDelegate].
//
// The `addAutomaticKeepAlives` argument corresponds to the
// [SliverChildListDelegate.addAutomaticKeepAlives] property. The
// `addRepaintBoundaries` argument corresponds to the
// [SliverChildListDelegate.addRepaintBoundaries] property. Both must not be
// null.
//
// See also:
//
//  * [SliverGrid.count], the equivalent constructor for [SliverGrid].
message FlutterGridViewNamedCount {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.scroll_view.scrollDirection}
  // The [Axis] along which the scroll view's offset increases.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.vertical].
  // {@endtemplate}
  FlutterAxisType.Enum scroll_direction = 3;
  // {@template flutter.widgets.scroll_view.reverse}
  // Whether the scroll view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  // {@endtemplate}
  bool reverse = 4;
  // {@template flutter.widgets.scroll_view.controller}
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // Must be null if [primary] is true.
  //
  // A [ScrollController] serves several purposes. It can be used to control
  // the initial scroll position (see [ScrollController.initialScrollOffset]).
  // It can be used to control whether the scroll view should automatically
  // save and restore its scroll position in the [PageStorage] (see
  // [ScrollController.keepScrollOffset]). It can be used to read the current
  // scroll position (see [ScrollController.offset]), or change it (see
  // [ScrollController.animateTo]).
  // {@endtemplate}
  FlutterScrollControllerType controller = 5;
  // {@template flutter.widgets.scroll_view.primary}
  // Whether this is the primary scroll view associated with the parent
  // [PrimaryScrollController].
  //
  // When this is true, the scroll view is scrollable even if it does not have
  // sufficient content to actually scroll. Otherwise, by default the user can
  // only scroll the view if it has sufficient content. See [physics].
  //
  // Also when true, the scroll view is used for default [ScrollAction]s. If a
  // ScrollAction is not handled by an otherwise focused part of the application,
  // the ScrollAction will be evaluated using this scroll view, for example,
  // when executing [Shortcuts] key events like page up and down.
  //
  // On iOS, this also identifies the scroll view that will scroll to top in
  // response to a tap in the status bar.
  //
  // Cannot be true while a [ScrollController] is provided to `controller`,
  // only one ScrollController can be associated with a ScrollView.
  //
  // Setting to false will explicitly prevent inheriting any
  // [PrimaryScrollController].
  //
  // Defaults to null. When null, and a controller is not provided,
  // [PrimaryScrollController.shouldInherit] is used to decide automatic
  // inheritance.
  //
  // By default, the [PrimaryScrollController] that is injected by each
  // [ModalRoute] is configured to automatically be inherited on
  // [TargetPlatformVariant.mobile] for ScrollViews in the [Axis.vertical]
  // scroll direction. Adding another to your app will override the
  // PrimaryScrollController above it.
  //
  // The following video contains more information about scroll controllers,
  // the PrimaryScrollController widget, and their impact on your apps:
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=33_0ABjFJUU}
  //
  // {@endtemplate}
  bool primary = 6;
  FlutterScrollPhysicsType physics = 7;
  // {@template flutter.widgets.scroll_view.shrinkWrap}
  // Whether the extent of the scroll view in the [scrollDirection] should be
  // determined by the contents being viewed.
  //
  // If the scroll view does not shrink wrap, then the scroll view will expand
  // to the maximum allowed size in the [scrollDirection]. If the scroll view
  // has unbounded constraints in the [scrollDirection], then [shrinkWrap] must
  // be true.
  //
  // Shrink wrapping the content of the scroll view is significantly more
  // expensive than expanding to the maximum allowed size because the content
  // can expand and contract during scrolling, which means the size of the
  // scroll view needs to be recomputed whenever the scroll position changes.
  //
  // Defaults to false.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=LUqDNnv_dh0}
  // {@endtemplate}
  bool shrink_wrap = 8;
  // The amount of space by which to inset the children.
  FlutterEdgeInsetsGeometryType padding = 9;
  int32 cross_axis_count = 10;
  double main_axis_spacing = 11;
  double cross_axis_spacing = 12;
  double child_aspect_ratio = 13;
  bool add_automatic_keep_alives = 14;
  bool add_repaint_boundaries = 15;
  bool add_semantic_indexes = 16;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtent}
  double cache_extent = 17;
  repeated WidgetType children = 18;
  int32 semantic_child_count = 19;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 20;
  // {@template flutter.widgets.scroll_view.keyboardDismissBehavior}
  // [ScrollViewKeyboardDismissBehavior] the defines how this [ScrollView] will
  // dismiss the keyboard automatically.
  // {@endtemplate}
  FlutterScrollViewKeyboardDismissBehaviorType.Enum keyboard_dismiss_behavior = 21;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 22;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 23;
}

// package:flutter/src/widgets/scroll_view.dart
//
// Creates a scrollable, 2D array of widgets with both a custom
// [SliverGridDelegate] and a custom [SliverChildDelegate].
//
// To use an [IndexedWidgetBuilder] callback to build children, either use
// a [SliverChildBuilderDelegate] or use the [GridView.builder] constructor.
message FlutterGridViewNamedCustom {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.scroll_view.scrollDirection}
  // The [Axis] along which the scroll view's offset increases.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.vertical].
  // {@endtemplate}
  FlutterAxisType.Enum scroll_direction = 3;
  // {@template flutter.widgets.scroll_view.reverse}
  // Whether the scroll view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  // {@endtemplate}
  bool reverse = 4;
  // {@template flutter.widgets.scroll_view.controller}
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // Must be null if [primary] is true.
  //
  // A [ScrollController] serves several purposes. It can be used to control
  // the initial scroll position (see [ScrollController.initialScrollOffset]).
  // It can be used to control whether the scroll view should automatically
  // save and restore its scroll position in the [PageStorage] (see
  // [ScrollController.keepScrollOffset]). It can be used to read the current
  // scroll position (see [ScrollController.offset]), or change it (see
  // [ScrollController.animateTo]).
  // {@endtemplate}
  FlutterScrollControllerType controller = 5;
  // {@template flutter.widgets.scroll_view.primary}
  // Whether this is the primary scroll view associated with the parent
  // [PrimaryScrollController].
  //
  // When this is true, the scroll view is scrollable even if it does not have
  // sufficient content to actually scroll. Otherwise, by default the user can
  // only scroll the view if it has sufficient content. See [physics].
  //
  // Also when true, the scroll view is used for default [ScrollAction]s. If a
  // ScrollAction is not handled by an otherwise focused part of the application,
  // the ScrollAction will be evaluated using this scroll view, for example,
  // when executing [Shortcuts] key events like page up and down.
  //
  // On iOS, this also identifies the scroll view that will scroll to top in
  // response to a tap in the status bar.
  //
  // Cannot be true while a [ScrollController] is provided to `controller`,
  // only one ScrollController can be associated with a ScrollView.
  //
  // Setting to false will explicitly prevent inheriting any
  // [PrimaryScrollController].
  //
  // Defaults to null. When null, and a controller is not provided,
  // [PrimaryScrollController.shouldInherit] is used to decide automatic
  // inheritance.
  //
  // By default, the [PrimaryScrollController] that is injected by each
  // [ModalRoute] is configured to automatically be inherited on
  // [TargetPlatformVariant.mobile] for ScrollViews in the [Axis.vertical]
  // scroll direction. Adding another to your app will override the
  // PrimaryScrollController above it.
  //
  // The following video contains more information about scroll controllers,
  // the PrimaryScrollController widget, and their impact on your apps:
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=33_0ABjFJUU}
  //
  // {@endtemplate}
  bool primary = 6;
  FlutterScrollPhysicsType physics = 7;
  // {@template flutter.widgets.scroll_view.shrinkWrap}
  // Whether the extent of the scroll view in the [scrollDirection] should be
  // determined by the contents being viewed.
  //
  // If the scroll view does not shrink wrap, then the scroll view will expand
  // to the maximum allowed size in the [scrollDirection]. If the scroll view
  // has unbounded constraints in the [scrollDirection], then [shrinkWrap] must
  // be true.
  //
  // Shrink wrapping the content of the scroll view is significantly more
  // expensive than expanding to the maximum allowed size because the content
  // can expand and contract during scrolling, which means the size of the
  // scroll view needs to be recomputed whenever the scroll position changes.
  //
  // Defaults to false.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=LUqDNnv_dh0}
  // {@endtemplate}
  bool shrink_wrap = 8;
  // The amount of space by which to inset the children.
  FlutterEdgeInsetsGeometryType padding = 9;
  // A delegate that controls the layout of the children within the [GridView].
  //
  // The [GridView], [GridView.builder], and [GridView.custom] constructors let you specify this
  // delegate explicitly. The other constructors create a [gridDelegate]
  // implicitly.
  FlutterSliverGridDelegateType grid_delegate = 10;
  // A delegate that provides the children for the [GridView].
  //
  // The [GridView.custom] constructor lets you specify this delegate
  // explicitly. The other constructors create a [childrenDelegate] that wraps
  // the given child list.
  FlutterSliverChildDelegateType children_delegate = 11;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtent}
  double cache_extent = 12;
  // The number of children that will contribute semantic information.
  //
  // Some subtypes of [ScrollView] can infer this value automatically. For
  // example [ListView] will use the number of widgets in the child list,
  // while the [ListView.separated] constructor will use half that amount.
  //
  // For [CustomScrollView] and other types which do not receive a builder
  // or list of widgets, the child count must be explicitly provided. If the
  // number is unknown or unbounded this should be left unset or set to null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.scrollChildCount], the corresponding semantics property.
  int32 semantic_child_count = 13;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 14;
  // {@template flutter.widgets.scroll_view.keyboardDismissBehavior}
  // [ScrollViewKeyboardDismissBehavior] the defines how this [ScrollView] will
  // dismiss the keyboard automatically.
  // {@endtemplate}
  FlutterScrollViewKeyboardDismissBehaviorType.Enum keyboard_dismiss_behavior = 15;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 16;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 17;
}

// package:flutter/src/widgets/scroll_view.dart
//
// Creates a scrollable, 2D array of widgets with tiles that each have a
// maximum cross-axis extent.
//
// Uses a [SliverGridDelegateWithMaxCrossAxisExtent] as the [gridDelegate].
//
// The `addAutomaticKeepAlives` argument corresponds to the
// [SliverChildListDelegate.addAutomaticKeepAlives] property. The
// `addRepaintBoundaries` argument corresponds to the
// [SliverChildListDelegate.addRepaintBoundaries] property. Both must not be
// null.
//
// See also:
//
//  * [SliverGrid.extent], the equivalent constructor for [SliverGrid].
message FlutterGridViewNamedExtent {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.scroll_view.scrollDirection}
  // The [Axis] along which the scroll view's offset increases.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.vertical].
  // {@endtemplate}
  FlutterAxisType.Enum scroll_direction = 3;
  // {@template flutter.widgets.scroll_view.reverse}
  // Whether the scroll view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  // {@endtemplate}
  bool reverse = 4;
  // {@template flutter.widgets.scroll_view.controller}
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // Must be null if [primary] is true.
  //
  // A [ScrollController] serves several purposes. It can be used to control
  // the initial scroll position (see [ScrollController.initialScrollOffset]).
  // It can be used to control whether the scroll view should automatically
  // save and restore its scroll position in the [PageStorage] (see
  // [ScrollController.keepScrollOffset]). It can be used to read the current
  // scroll position (see [ScrollController.offset]), or change it (see
  // [ScrollController.animateTo]).
  // {@endtemplate}
  FlutterScrollControllerType controller = 5;
  // {@template flutter.widgets.scroll_view.primary}
  // Whether this is the primary scroll view associated with the parent
  // [PrimaryScrollController].
  //
  // When this is true, the scroll view is scrollable even if it does not have
  // sufficient content to actually scroll. Otherwise, by default the user can
  // only scroll the view if it has sufficient content. See [physics].
  //
  // Also when true, the scroll view is used for default [ScrollAction]s. If a
  // ScrollAction is not handled by an otherwise focused part of the application,
  // the ScrollAction will be evaluated using this scroll view, for example,
  // when executing [Shortcuts] key events like page up and down.
  //
  // On iOS, this also identifies the scroll view that will scroll to top in
  // response to a tap in the status bar.
  //
  // Cannot be true while a [ScrollController] is provided to `controller`,
  // only one ScrollController can be associated with a ScrollView.
  //
  // Setting to false will explicitly prevent inheriting any
  // [PrimaryScrollController].
  //
  // Defaults to null. When null, and a controller is not provided,
  // [PrimaryScrollController.shouldInherit] is used to decide automatic
  // inheritance.
  //
  // By default, the [PrimaryScrollController] that is injected by each
  // [ModalRoute] is configured to automatically be inherited on
  // [TargetPlatformVariant.mobile] for ScrollViews in the [Axis.vertical]
  // scroll direction. Adding another to your app will override the
  // PrimaryScrollController above it.
  //
  // The following video contains more information about scroll controllers,
  // the PrimaryScrollController widget, and their impact on your apps:
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=33_0ABjFJUU}
  //
  // {@endtemplate}
  bool primary = 6;
  FlutterScrollPhysicsType physics = 7;
  // {@template flutter.widgets.scroll_view.shrinkWrap}
  // Whether the extent of the scroll view in the [scrollDirection] should be
  // determined by the contents being viewed.
  //
  // If the scroll view does not shrink wrap, then the scroll view will expand
  // to the maximum allowed size in the [scrollDirection]. If the scroll view
  // has unbounded constraints in the [scrollDirection], then [shrinkWrap] must
  // be true.
  //
  // Shrink wrapping the content of the scroll view is significantly more
  // expensive than expanding to the maximum allowed size because the content
  // can expand and contract during scrolling, which means the size of the
  // scroll view needs to be recomputed whenever the scroll position changes.
  //
  // Defaults to false.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=LUqDNnv_dh0}
  // {@endtemplate}
  bool shrink_wrap = 8;
  // The amount of space by which to inset the children.
  FlutterEdgeInsetsGeometryType padding = 9;
  double max_cross_axis_extent = 10;
  double main_axis_spacing = 11;
  double cross_axis_spacing = 12;
  double child_aspect_ratio = 13;
  bool add_automatic_keep_alives = 14;
  bool add_repaint_boundaries = 15;
  bool add_semantic_indexes = 16;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtent}
  double cache_extent = 17;
  repeated WidgetType children = 18;
  int32 semantic_child_count = 19;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 20;
  // {@template flutter.widgets.scroll_view.keyboardDismissBehavior}
  // [ScrollViewKeyboardDismissBehavior] the defines how this [ScrollView] will
  // dismiss the keyboard automatically.
  // {@endtemplate}
  FlutterScrollViewKeyboardDismissBehaviorType.Enum keyboard_dismiss_behavior = 21;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 22;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 23;
}

// package:flutter/src/widgets/heroes.dart
//
// Creates a hero controller with the given [RectTween] constructor if any.
//
// The [createRectTween] argument is optional. If null, the controller uses a
// linear [Tween<Rect>].
message FlutterHeroController {
  
}

// package:flutter/src/widgets/navigator.dart
//
// Creates a widget to host the input [controller].
message FlutterHeroControllerScope {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The hero controller that is hosted inside this widget.
  FlutterHeroControllerType controller = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/navigator.dart
//
// Creates a widget to prevent the subtree from receiving the hero controller
// above.
message FlutterHeroControllerScopeNamedNone {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 3;
}

// package:flutter/src/widgets/heroes.dart
//
// Creates a widget that enables or disables [Hero]es.
message FlutterHeroMode {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The subtree to place inside the [HeroMode].
  WidgetType child = 3;
  // Whether or not [Hero]es are enabled in this subtree.
  //
  // If this property is false, the [Hero]es in this subtree will not animate
  // on route changes. Otherwise, they will animate as usual.
  //
  // Defaults to true.
  bool enabled = 4;
}

// package:flutter/src/gestures/monodrag.dart
//
// Create a gesture recognizer for interactions in the horizontal axis.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterHorizontalDragGestureRecognizer {
  
}

// package:flutter/src/gestures/multidrag.dart
//
// Create a gesture recognizer for tracking multiple pointers at once
// but only if they first move horizontally.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterHorizontalMultiDragGestureRecognizer {
  
}

// package:flutter/src/widgets/platform_view.dart
//
// Creates a platform view for Flutter Web.
//
// `viewType` identifies the type of platform view to create.
message FlutterHtmlElementView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The unique identifier for the HTML view type to be embedded by this widget.
  //
  // A PlatformViewFactory for this type must have been registered.
  string view_type = 3;
}

// package:flutter/src/widgets/platform_view.dart
//
// Creates a platform view that creates a DOM element specified by [tagName].
//
// [isVisible] indicates whether the view is visible to the user or not.
// Setting this to false allows the rendering pipeline to perform extra
// optimizations knowing that the view will not result in any pixels painted
// on the screen.
//
// [onElementCreated] is called when the DOM element is created. It can be
// used by the app to customize the element by adding attributes and styles.
message FlutterHtmlElementViewNamedFromTagName {
  FlutterKeyType key = 2;
  string tag_name = 3;
  bool is_visible = 4;
}

// package:flutter/src/widgets/icon.dart
//
// Creates an icon.
message FlutterIcon {
  // The icon to display. The available icons are described in [Icons].
  //
  // The icon can be null, in which case the widget will render as an empty
  // space of the specified [size].
  FlutterIconDataType icon = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  // The size of the icon in logical pixels.
  //
  // Icons occupy a square with width and height equal to size.
  //
  // Defaults to the nearest [IconTheme]'s [IconThemeData.size].
  //
  // If this [Icon] is being placed inside an [IconButton], then use
  // [IconButton.iconSize] instead, so that the [IconButton] can make the splash
  // area the appropriate size as well. The [IconButton] uses an [IconTheme] to
  // pass down the size to the [Icon].
  double size = 4;
  // The fill for drawing the icon.
  //
  // Requires the underlying icon font to support the `FILL` [FontVariation]
  // axis, otherwise has no effect. Variable font filenames often indicate
  // the supported axes. Must be between 0.0 (unfilled) and 1.0 (filled),
  // inclusive.
  //
  // Can be used to convey a state transition for animation or interaction.
  //
  // Defaults to nearest [IconTheme]'s [IconThemeData.fill].
  //
  // See also:
  //  * [weight], for controlling stroke weight.
  //  * [grade], for controlling stroke weight in a more granular way.
  //  * [opticalSize], for controlling optical size.
  double fill = 5;
  // The stroke weight for drawing the icon.
  //
  // Requires the underlying icon font to support the `wght` [FontVariation]
  // axis, otherwise has no effect. Variable font filenames often indicate
  // the supported axes. Must be greater than 0.
  //
  // Defaults to nearest [IconTheme]'s [IconThemeData.weight].
  //
  // See also:
  //  * [fill], for controlling fill.
  //  * [grade], for controlling stroke weight in a more granular way.
  //  * [opticalSize], for controlling optical size.
  //  * https://fonts.google.com/knowledge/glossary/weight_axis
  double weight = 6;
  // The grade (granular stroke weight) for drawing the icon.
  //
  // Requires the underlying icon font to support the `GRAD` [FontVariation]
  // axis, otherwise has no effect. Variable font filenames often indicate
  // the supported axes. Can be negative.
  //
  // Grade and [weight] both affect a symbol's stroke weight (thickness), but
  // grade has a smaller impact on the size of the symbol.
  //
  // Grade is also available in some text fonts. One can match grade levels
  // between text and symbols for a harmonious visual effect. For example, if
  // the text font has a -25 grade value, the symbols can match it with a
  // suitable value, say -25.
  //
  // Defaults to nearest [IconTheme]'s [IconThemeData.grade].
  //
  // See also:
  //  * [fill], for controlling fill.
  //  * [weight], for controlling stroke weight in a less granular way.
  //  * [opticalSize], for controlling optical size.
  //  * https://fonts.google.com/knowledge/glossary/grade_axis
  double grade = 7;
  // The optical size for drawing the icon.
  //
  // Requires the underlying icon font to support the `opsz` [FontVariation]
  // axis, otherwise has no effect. Variable font filenames often indicate
  // the supported axes. Must be greater than 0.
  //
  // For an icon to look the same at different sizes, the stroke weight
  // (thickness) must change as the icon size scales. Optical size offers a way
  // to automatically adjust the stroke weight as icon size changes.
  //
  // Defaults to nearest [IconTheme]'s [IconThemeData.opticalSize].
  //
  // See also:
  //  * [fill], for controlling fill.
  //  * [weight], for controlling stroke weight.
  //  * [grade], for controlling stroke weight in a more granular way.
  //  * https://fonts.google.com/knowledge/glossary/optical_size_axis
  double optical_size = 8;
  // The color to use when drawing the icon.
  //
  // Defaults to the nearest [IconTheme]'s [IconThemeData.color].
  //
  // The color (whether specified explicitly here or obtained from the
  // [IconTheme]) will be further adjusted by the nearest [IconTheme]'s
  // [IconThemeData.opacity].
  //
  // {@tool snippet}
  // Typically, a Material Design color will be used, as follows:
  //
  // ```dart
  // Icon(
  //   Icons.widgets,
  //   color: Colors.blue.shade400,
  // )
  // ```
  // {@end-tool}
  DartColorType color = 9;
  // A list of [Shadow]s that will be painted underneath the icon.
  //
  // Multiple shadows are supported to replicate lighting from multiple light
  // sources.
  //
  // Shadows must be in the same order for [Icon] to be considered as
  // equivalent as order produces differing transparency.
  //
  // Defaults to the nearest [IconTheme]'s [IconThemeData.shadows].
  repeated DartShadowType shadows = 10;
  // Semantic label for the icon.
  //
  // Announced in accessibility modes (e.g TalkBack/VoiceOver).
  // This label does not show in the UI.
  //
  //  * [SemanticsProperties.label], which is set to [semanticLabel] in the
  //    underlying	 [Semantics] widget.
  string semantic_label = 11;
  // The text direction to use for rendering the icon.
  //
  // If this is null, the ambient [Directionality] is used instead.
  //
  // Some icons follow the reading direction. For example, "back" buttons point
  // left in left-to-right environments and right in right-to-left
  // environments. Such icons have their [IconData.matchTextDirection] field
  // set to true, and the [Icon] widget uses the [textDirection] to determine
  // the orientation in which to draw the icon.
  //
  // This property has no effect if the [icon]'s [IconData.matchTextDirection]
  // field is false, but for consistency a text direction value must always be
  // specified, either directly using this property or using [Directionality].
  DartTextDirectionType.Enum text_direction = 12;
  // Whether to scale the size of this widget using the ambient [MediaQuery]'s [TextScaler].
  //
  // This is specially useful when you have an icon associated with a text, as
  // scaling the text without scaling the icon would result in a confusing
  // interface.
  //
  // Defaults to the nearest [IconTheme]'s
  // [IconThemeData.applyTextScaling].
  bool apply_text_scaling = 13;
}

// package:flutter/src/widgets/icon_data.dart
//
// Creates icon data.
//
// Rarely used directly. Instead, consider using one of the predefined icons
// like the [Icons] collection.
//
// The [fontPackage] argument must be non-null when using a font family that
// is included in a package. This is used when selecting the font.
//
// Instantiating non-const instances of this class in your app will
// mean the app cannot be built in release mode with icon tree-shaking (it
// need to be explicitly opted out at build time). See [staticIconProvider]
// for more context.
message FlutterIconData {
  // The Unicode code point at which this icon is stored in the icon font.
  int32 code_point = 2;
  // The font family from which the glyph for the [codePoint] will be selected.
  string font_family = 3;
  // The name of the package from which the font family is included.
  //
  // The name is used by the [Icon] widget when configuring the [TextStyle] so
  // that the given [fontFamily] is obtained from the appropriate asset.
  //
  // See also:
  //
  //  * [TextStyle], which describes how to use fonts from other packages.
  string font_package = 4;
  // Whether this icon should be automatically mirrored in right-to-left
  // environments.
  //
  // The [Icon] widget respects this value by mirroring the icon when the
  // [Directionality] is [TextDirection.rtl].
  bool match_text_direction = 5;
  // The ordered list of font families to fall back on when a glyph cannot be found in a higher priority font family.
  //
  // For more details, refer to the documentation of [TextStyle]
  repeated string font_family_fallback = 6;
}

// package:flutter/src/widgets/icon_data.dart
//
// Create a diagnostics property for [IconData].
message FlutterIconDataProperty {
  string name = 2;
  FlutterIconDataType value = 3;
  string if_null = 4;
  bool show_name = 5;
  FlutterDiagnosticsTreeStyleType.Enum style = 6;
  FlutterDiagnosticLevelType.Enum level = 7;
}

// package:flutter/src/widgets/icon_theme.dart
//
// Creates an icon theme that controls properties of descendant widgets.
message FlutterIconTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The set of properties to use for icons in this subtree.
  FlutterIconThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/icon_theme_data.dart
//
// Creates an icon theme data.
//
// The opacity applies to both explicit and default icon colors. The value
// is clamped between 0.0 and 1.0.
message FlutterIconThemeData {
  // The default for [Icon.size].
  //
  // Falls back to 24.0.
  double size = 2;
  // The default for [Icon.fill].
  //
  // Falls back to 0.0.
  double fill = 3;
  // The default for [Icon.weight].
  //
  // Falls back to 400.0.
  double weight = 4;
  // The default for [Icon.grade].
  //
  // Falls back to 0.0.
  double grade = 5;
  // The default for [Icon.opticalSize].
  //
  // Falls back to 48.0.
  double optical_size = 6;
  // The default for [Icon.color].
  //
  // In material apps, if there is a [Theme] without any [IconTheme]s
  // specified, icon colors default to white if [ThemeData.brightness] is dark
  // and black if [ThemeData.brightness] is light.
  //
  // Otherwise, falls back to black.
  DartColorType color = 7;
  double opacity = 8;
  // The default for [Icon.shadows].
  repeated DartShadowType shadows = 9;
  // The default for [Icon.applyTextScaling].
  bool apply_text_scaling = 10;
}

// package:flutter/src/widgets/icon_theme_data.dart
//
// Creates an icon theme with some reasonable default values.
//
// The [size] is 24.0, [fill] is 0.0, [weight] is 400.0, [grade] is 0.0,
// opticalSize is 48.0, [color] is black, and [opacity] is 1.0.
message FlutterIconThemeDataNamedFallback {
  
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that ignores the child for baseline alignment purposes.
message FlutterIgnoreBaseline {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that is invisible to hit testing.
message FlutterIgnorePointer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this widget is ignored during hit testing.
  //
  // Regardless of whether this widget is ignored during hit testing, it will
  // still consume space during layout and be visible during painting.
  //
  // {@macro flutter.widgets.IgnorePointer.semantics}
  //
  // Defaults to true.
  bool ignoring = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/painting/image_provider.dart
//
// Creates an object holding the configuration information for an [ImageProvider].
//
// All the arguments are optional. Configuration information is merely
// advisory and best-effort.
message FlutterImageConfiguration {
  // The preferred [AssetBundle] to use if the [ImageProvider] needs one and
  // does not have one already selected.
  FlutterAssetBundleType bundle = 2;
  // The device pixel ratio where the image will be shown.
  double device_pixel_ratio = 3;
  // The language and region for which to select the image.
  DartLocaleType locale = 4;
  // The reading direction of the language for which to select the image.
  DartTextDirectionType.Enum text_direction = 5;
  // The size at which the image will be rendered.
  DartSizeType size = 6;
  // The [TargetPlatform] for which assets should be used. This allows images
  // to be specified in a platform-neutral fashion yet use different assets on
  // different platforms, to match local conventions e.g. for color matching or
  // shadows.
  FlutterTargetPlatformType.Enum platform = 7;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a layer that applies an [ImageFilter] to its children.
//
// The [imageFilter] property must be non-null before the compositing phase
// of the pipeline.
message FlutterImageFilterLayer {
  DartImageFilterType image_filter = 2;
  DartOffsetType offset = 3;
}

// package:flutter/src/widgets/image_filter.dart
//
// Creates a widget that applies an [ImageFilter] to its child.
message FlutterImageFiltered {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The image filter to apply to the child of this widget.
  DartImageFilterType image_filter = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
  // Whether or not to apply the image filter operation to the child of this
  // widget.
  //
  // Prefer setting enabled to `false` instead of creating a "no-op" filter
  // type for performance reasons.
  bool enabled = 5;
}

// package:flutter/src/widgets/image_icon.dart
//
// Creates an image icon.
//
// The [size] and [color] default to the value given by the current [IconTheme].
message FlutterImageIcon {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  // The size of the icon in logical pixels.
  //
  // Icons occupy a square with width and height equal to size.
  //
  // Defaults to the current [IconTheme] size, if any. If there is no
  // [IconTheme], or it does not specify an explicit size, then it defaults to
  // 24.0.
  double size = 4;
  // The color to use when drawing the icon.
  //
  // Defaults to the current [IconTheme] color, if any. If there is
  // no [IconTheme], then it defaults to not recolorizing the image.
  //
  // The image will be additionally adjusted by the opacity of the current
  // [IconTheme], if any.
  DartColorType color = 5;
  // Semantic label for the icon.
  //
  // Announced in accessibility modes (e.g TalkBack/VoiceOver).
  // This label does not show in the UI.
  //
  //  * [SemanticsProperties.label], which is set to [semanticLabel] in the
  //    underlying	 [Semantics] widget.
  string semantic_label = 6;
}

// package:flutter/src/widgets/image.dart
//
// Creates a widget that displays an [ImageStream] obtained from an asset
// bundle. The key for the image is given by the `name` argument.
//
// The `package` argument must be non-null when displaying an image from a
// package and null otherwise. See the `Assets in packages` section for
// details.
//
// If the `bundle` argument is omitted or null, then the
// [DefaultAssetBundle] will be used.
//
// By default, the pixel-density-aware asset resolution will be attempted. In
// addition:
//
// * If the `scale` argument is provided and is not null, then the exact
// asset specified will be used. To display an image variant with a specific
// density, the exact path must be provided (e.g. `images/2x/cat.png`).
//
// If [excludeFromSemantics] is true, then [semanticLabel] will be ignored.
//
// If `cacheWidth` or `cacheHeight` are provided, they indicate to the
// engine that the image must be decoded at the specified size. The image
// will be rendered to the constraints of the layout or [width] and [height]
// regardless of these parameters. These parameters are primarily intended
// to reduce the memory usage of [ImageCache].
//
// Either the [width] and [height] arguments should be specified, or the
// widget should be placed in a context that sets tight layout constraints.
// Otherwise, the image dimensions will change as the image is loaded, which
// will result in ugly layout changes.
//
// {@macro flutter.widgets.image.filterQualityParameter}
//
// {@tool snippet}
//
// Suppose that the project's `pubspec.yaml` file contains the following:
//
// ```yaml
// flutter:
//   assets:
//     - images/cat.png
//     - images/2x/cat.png
//     - images/3.5x/cat.png
// ```
// {@end-tool}
//
// On a screen with a device pixel ratio of 2.0, the following widget would
// render the `images/2x/cat.png` file:
//
// ```dart
// Image.asset('images/cat.png')
// ```
//
// This corresponds to the file that is in the project's `images/2x/`
// directory with the name `cat.png` (the paths are relative to the
// `pubspec.yaml` file).
//
// On a device with a 4.0 device pixel ratio, the `images/3.5x/cat.png` asset
// would be used. On a device with a 1.0 device pixel ratio, the
// `images/cat.png` resource would be used.
//
// The `images/cat.png` image can be omitted from disk (though it must still
// be present in the manifest). If it is omitted, then on a device with a 1.0
// device pixel ratio, the `images/2x/cat.png` image would be used instead.
//
//
// ## Assets in packages
//
// To create the widget with an asset from a package, the [package] argument
// must be provided. For instance, suppose a package called `my_icons` has
// `icons/heart.png` .
//
// {@tool snippet}
// Then to display the image, use:
//
// ```dart
// Image.asset('icons/heart.png', package: 'my_icons')
// ```
// {@end-tool}
//
// Assets used by the package itself should also be displayed using the
// [package] argument as above.
//
// If the desired asset is specified in the `pubspec.yaml` of the package, it
// is bundled automatically with the app. In particular, assets used by the
// package itself must be specified in its `pubspec.yaml`.
//
// A package can also choose to have assets in its 'lib/' folder that are not
// specified in its `pubspec.yaml`. In this case for those images to be
// bundled, the app has to specify which ones to include. For instance a
// package named `fancy_backgrounds` could have:
//
//     lib/backgrounds/background1.png
//     lib/backgrounds/background2.png
//     lib/backgrounds/background3.png
//
// To include, say the first image, the `pubspec.yaml` of the app should
// specify it in the assets section:
//
// ```yaml
//   assets:
//     - packages/fancy_backgrounds/backgrounds/background1.png
// ```
//
// The `lib/` is implied, so it should not be included in the asset path.
//
//
// See also:
//
//  * [AssetImage], which is used to implement the behavior when the scale is
//    omitted.
//  * [ExactAssetImage], which is used to implement the behavior when the
//    scale is present.
//  * <https://flutter.dev/assets-and-images/>, an introduction to assets in
//    Flutter.
message FlutterImageNamedAsset {
  string name = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  FlutterAssetBundleType bundle = 4;
  // A Semantic description of the image.
  //
  // Used to provide a description of the image to TalkBack on Android, and
  // VoiceOver on iOS.
  string semantic_label = 7;
  // Whether to exclude this image from semantics.
  //
  // Useful for images which do not contribute meaningful information to an
  // application.
  bool exclude_from_semantics = 8;
  double scale = 9;
  // If non-null, require the image to have this width (in logical pixels).
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  //
  // It is strongly recommended that either both the [width] and the [height]
  // be specified, or that the widget be placed in a context that sets tight
  // layout constraints, so that the image does not change size as it loads.
  // Consider using [fit] to adapt the image's rendering to fit the given width
  // and height if the exact image dimensions are not known in advance.
  double width = 10;
  // If non-null, require the image to have this height (in logical pixels).
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  //
  // It is strongly recommended that either both the [width] and the [height]
  // be specified, or that the widget be placed in a context that sets tight
  // layout constraints, so that the image does not change size as it loads.
  // Consider using [fit] to adapt the image's rendering to fit the given width
  // and height if the exact image dimensions are not known in advance.
  double height = 11;
  // If non-null, this color is blended with each image pixel using [colorBlendMode].
  DartColorType color = 12;
  // Used to combine [color] with this image.
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [color] is
  // the source and this image is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  DartBlendModeType.Enum color_blend_mode = 14;
  // How to inscribe the image into the space allocated during layout.
  //
  // The default varies based on the other fields. See the discussion at
  // [paintImage].
  FlutterBoxFitType.Enum fit = 15;
  // How to align the image within its bounds.
  //
  // The alignment aligns the given position in the image to the given position
  // in the layout bounds. For example, an [Alignment] alignment of (-1.0,
  // -1.0) aligns the image to the top-left corner of its layout bounds, while an
  // [Alignment] alignment of (1.0, 1.0) aligns the bottom right of the
  // image with the bottom right corner of its layout bounds. Similarly, an
  // alignment of (0.0, 1.0) aligns the bottom middle of the image with the
  // middle of the bottom edge of its layout bounds.
  //
  // To display a subpart of an image, consider using a [CustomPainter] and
  // [Canvas.drawImageRect].
  //
  // If the [alignment] is [TextDirection]-dependent (i.e. if it is a
  // [AlignmentDirectional]), then an ambient [Directionality] widget
  // must be in scope.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 16;
  // How to paint any portions of the layout bounds not covered by the image.
  FlutterImageRepeatType.Enum repeat = 17;
  // The center slice for a nine-patch image.
  //
  // The region of the image inside the center slice will be stretched both
  // horizontally and vertically to fit the image into its destination. The
  // region of the image above and below the center slice will be stretched
  // only horizontally and the region of the image to the left and right of
  // the center slice will be stretched only vertically.
  DartRectType center_slice = 18;
  // Whether to paint the image in the direction of the [TextDirection].
  //
  // If this is true, then in [TextDirection.ltr] contexts, the image will be
  // drawn with its origin in the top left (the "normal" painting direction for
  // images); and in [TextDirection.rtl] contexts, the image will be drawn with
  // a scaling factor of -1 in the horizontal direction so that the origin is
  // in the top right.
  //
  // This is occasionally used with images in right-to-left environments, for
  // images that were designed for left-to-right locales. Be careful, when
  // using this, to not flip images with integral shadows, text, or other
  // effects that will look incorrect when flipped.
  //
  // If this is true, there must be an ambient [Directionality] widget in
  // scope.
  bool match_text_direction = 19;
  // Whether to continue showing the old image (true), or briefly show nothing
  // (false), when the image provider changes. The default value is false.
  //
  // ## Design discussion
  //
  // ### Why is the default value of [gaplessPlayback] false?
  //
  // Having the default value of [gaplessPlayback] be false helps prevent
  // situations where stale or misleading information might be presented.
  // Consider the following case:
  //
  // We have constructed a 'Person' widget that displays an avatar [Image] of
  // the currently loaded person along with their name. We could request for a
  // new person to be loaded into the widget at any time. Suppose we have a
  // person currently loaded and the widget loads a new person. What happens
  // if the [Image] fails to load?
  //
  // * Option A ([gaplessPlayback] = false): The new person's name is coupled
  // with a blank image.
  //
  // * Option B ([gaplessPlayback] = true): The widget displays the avatar of
  // the previous person and the name of the newly loaded person.
  //
  // This is why the default value is false. Most of the time, when you change
  // the image provider you're not just changing the image, you're removing the
  // old widget and adding a new one and not expecting them to have any
  // relationship. With [gaplessPlayback] on you might accidentally break this
  // expectation and re-use the old widget.
  bool gapless_playback = 20;
  // Whether to paint the image with anti-aliasing.
  //
  // Anti-aliasing alleviates the sawtooth artifact when the image is rotated.
  bool is_anti_alias = 21;
  string package = 22;
  // The rendering quality of the image.
  //
  // {@template flutter.widgets.image.filterQuality}
  // If the image is of a high quality and its pixels are perfectly aligned
  // with the physical screen pixels, extra quality enhancement may not be
  // necessary. If so, then [FilterQuality.none] would be the most efficient.
  //
  // If the pixels are not perfectly aligned with the screen pixels, or if the
  // image itself is of a low quality, [FilterQuality.none] may produce
  // undesirable artifacts. Consider using other [FilterQuality] values to
  // improve the rendered image quality in this case. Pixels may be misaligned
  // with the screen pixels as a result of transforms or scaling.
  //
  // See also:
  //
  //  * [FilterQuality], the enum containing all possible filter quality
  //    options.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 23;
  int32 cache_width = 24;
  int32 cache_height = 25;
}

// package:flutter/src/widgets/image.dart
//
// Creates a widget that displays an [ImageStream] obtained from a [File].
//
// Either the [width] and [height] arguments should be specified, or the
// widget should be placed in a context that sets tight layout constraints.
// Otherwise, the image dimensions will change as the image is loaded, which
// will result in ugly layout changes.
//
// On Android, this may require the
// `android.permission.READ_EXTERNAL_STORAGE` permission.
//
// {@macro flutter.widgets.image.filterQualityParameter}
//
// If [excludeFromSemantics] is true, then [semanticLabel] will be ignored.
//
// If `cacheWidth` or `cacheHeight` are provided, they indicate to the
// engine that the image must be decoded at the specified size. The image
// will be rendered to the constraints of the layout or [width] and [height]
// regardless of these parameters. These parameters are primarily intended
// to reduce the memory usage of [ImageCache].
//
// Loading an image from a file creates an in memory copy of the file,
// which is retained in the [ImageCache]. The underlying file is not
// monitored for changes. If it does change, the application should evict
// the entry from the [ImageCache].
//
// See also:
//
//  * [FileImage] provider for evicting the underlying file easily.
message FlutterImageNamedFile {
  DartFileType file = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  double scale = 4;
  // A Semantic description of the image.
  //
  // Used to provide a description of the image to TalkBack on Android, and
  // VoiceOver on iOS.
  string semantic_label = 7;
  // Whether to exclude this image from semantics.
  //
  // Useful for images which do not contribute meaningful information to an
  // application.
  bool exclude_from_semantics = 8;
  // If non-null, require the image to have this width (in logical pixels).
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  //
  // It is strongly recommended that either both the [width] and the [height]
  // be specified, or that the widget be placed in a context that sets tight
  // layout constraints, so that the image does not change size as it loads.
  // Consider using [fit] to adapt the image's rendering to fit the given width
  // and height if the exact image dimensions are not known in advance.
  double width = 9;
  // If non-null, require the image to have this height (in logical pixels).
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  //
  // It is strongly recommended that either both the [width] and the [height]
  // be specified, or that the widget be placed in a context that sets tight
  // layout constraints, so that the image does not change size as it loads.
  // Consider using [fit] to adapt the image's rendering to fit the given width
  // and height if the exact image dimensions are not known in advance.
  double height = 10;
  // If non-null, this color is blended with each image pixel using [colorBlendMode].
  DartColorType color = 11;
  // Used to combine [color] with this image.
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [color] is
  // the source and this image is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  DartBlendModeType.Enum color_blend_mode = 13;
  // How to inscribe the image into the space allocated during layout.
  //
  // The default varies based on the other fields. See the discussion at
  // [paintImage].
  FlutterBoxFitType.Enum fit = 14;
  // How to align the image within its bounds.
  //
  // The alignment aligns the given position in the image to the given position
  // in the layout bounds. For example, an [Alignment] alignment of (-1.0,
  // -1.0) aligns the image to the top-left corner of its layout bounds, while an
  // [Alignment] alignment of (1.0, 1.0) aligns the bottom right of the
  // image with the bottom right corner of its layout bounds. Similarly, an
  // alignment of (0.0, 1.0) aligns the bottom middle of the image with the
  // middle of the bottom edge of its layout bounds.
  //
  // To display a subpart of an image, consider using a [CustomPainter] and
  // [Canvas.drawImageRect].
  //
  // If the [alignment] is [TextDirection]-dependent (i.e. if it is a
  // [AlignmentDirectional]), then an ambient [Directionality] widget
  // must be in scope.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 15;
  // How to paint any portions of the layout bounds not covered by the image.
  FlutterImageRepeatType.Enum repeat = 16;
  // The center slice for a nine-patch image.
  //
  // The region of the image inside the center slice will be stretched both
  // horizontally and vertically to fit the image into its destination. The
  // region of the image above and below the center slice will be stretched
  // only horizontally and the region of the image to the left and right of
  // the center slice will be stretched only vertically.
  DartRectType center_slice = 17;
  // Whether to paint the image in the direction of the [TextDirection].
  //
  // If this is true, then in [TextDirection.ltr] contexts, the image will be
  // drawn with its origin in the top left (the "normal" painting direction for
  // images); and in [TextDirection.rtl] contexts, the image will be drawn with
  // a scaling factor of -1 in the horizontal direction so that the origin is
  // in the top right.
  //
  // This is occasionally used with images in right-to-left environments, for
  // images that were designed for left-to-right locales. Be careful, when
  // using this, to not flip images with integral shadows, text, or other
  // effects that will look incorrect when flipped.
  //
  // If this is true, there must be an ambient [Directionality] widget in
  // scope.
  bool match_text_direction = 18;
  // Whether to continue showing the old image (true), or briefly show nothing
  // (false), when the image provider changes. The default value is false.
  //
  // ## Design discussion
  //
  // ### Why is the default value of [gaplessPlayback] false?
  //
  // Having the default value of [gaplessPlayback] be false helps prevent
  // situations where stale or misleading information might be presented.
  // Consider the following case:
  //
  // We have constructed a 'Person' widget that displays an avatar [Image] of
  // the currently loaded person along with their name. We could request for a
  // new person to be loaded into the widget at any time. Suppose we have a
  // person currently loaded and the widget loads a new person. What happens
  // if the [Image] fails to load?
  //
  // * Option A ([gaplessPlayback] = false): The new person's name is coupled
  // with a blank image.
  //
  // * Option B ([gaplessPlayback] = true): The widget displays the avatar of
  // the previous person and the name of the newly loaded person.
  //
  // This is why the default value is false. Most of the time, when you change
  // the image provider you're not just changing the image, you're removing the
  // old widget and adding a new one and not expecting them to have any
  // relationship. With [gaplessPlayback] on you might accidentally break this
  // expectation and re-use the old widget.
  bool gapless_playback = 19;
  // Whether to paint the image with anti-aliasing.
  //
  // Anti-aliasing alleviates the sawtooth artifact when the image is rotated.
  bool is_anti_alias = 20;
  // The rendering quality of the image.
  //
  // {@template flutter.widgets.image.filterQuality}
  // If the image is of a high quality and its pixels are perfectly aligned
  // with the physical screen pixels, extra quality enhancement may not be
  // necessary. If so, then [FilterQuality.none] would be the most efficient.
  //
  // If the pixels are not perfectly aligned with the screen pixels, or if the
  // image itself is of a low quality, [FilterQuality.none] may produce
  // undesirable artifacts. Consider using other [FilterQuality] values to
  // improve the rendered image quality in this case. Pixels may be misaligned
  // with the screen pixels as a result of transforms or scaling.
  //
  // See also:
  //
  //  * [FilterQuality], the enum containing all possible filter quality
  //    options.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 21;
  int32 cache_width = 22;
  int32 cache_height = 23;
}

// package:flutter/src/widgets/image.dart
//
// Creates a widget that displays an [ImageStream] obtained from a [Uint8List].
//
// The `bytes` argument specifies encoded image bytes, which can be encoded
// in any of the following supported image formats:
// {@macro dart.ui.imageFormats}
//
// The `scale` argument specifies the linear scale factor for drawing this
// image at its intended size and applies to both the width and the height.
// {@macro flutter.painting.imageInfo.scale}
//
// This only accepts compressed image formats (e.g. PNG). Uncompressed
// formats like rawRgba (the default format of [dart:ui.Image.toByteData])
// will lead to exceptions.
//
// Either the [width] and [height] arguments should be specified, or the
// widget should be placed in a context that sets tight layout constraints.
// Otherwise, the image dimensions will change as the image is loaded, which
// will result in ugly layout changes.
//
// {@macro flutter.widgets.image.filterQualityParameter}
//
// If [excludeFromSemantics] is true, then [semanticLabel] will be ignored.
//
// If `cacheWidth` or `cacheHeight` are provided, they indicate to the
// engine that the image must be decoded at the specified size. The image
// will be rendered to the constraints of the layout or [width] and [height]
// regardless of these parameters. These parameters are primarily intended
// to reduce the memory usage of [ImageCache].
message FlutterImageNamedMemory {
  DartUint8ListType bytes = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  double scale = 4;
  // A Semantic description of the image.
  //
  // Used to provide a description of the image to TalkBack on Android, and
  // VoiceOver on iOS.
  string semantic_label = 7;
  // Whether to exclude this image from semantics.
  //
  // Useful for images which do not contribute meaningful information to an
  // application.
  bool exclude_from_semantics = 8;
  // If non-null, require the image to have this width (in logical pixels).
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  //
  // It is strongly recommended that either both the [width] and the [height]
  // be specified, or that the widget be placed in a context that sets tight
  // layout constraints, so that the image does not change size as it loads.
  // Consider using [fit] to adapt the image's rendering to fit the given width
  // and height if the exact image dimensions are not known in advance.
  double width = 9;
  // If non-null, require the image to have this height (in logical pixels).
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  //
  // It is strongly recommended that either both the [width] and the [height]
  // be specified, or that the widget be placed in a context that sets tight
  // layout constraints, so that the image does not change size as it loads.
  // Consider using [fit] to adapt the image's rendering to fit the given width
  // and height if the exact image dimensions are not known in advance.
  double height = 10;
  // If non-null, this color is blended with each image pixel using [colorBlendMode].
  DartColorType color = 11;
  // Used to combine [color] with this image.
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [color] is
  // the source and this image is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  DartBlendModeType.Enum color_blend_mode = 13;
  // How to inscribe the image into the space allocated during layout.
  //
  // The default varies based on the other fields. See the discussion at
  // [paintImage].
  FlutterBoxFitType.Enum fit = 14;
  // How to align the image within its bounds.
  //
  // The alignment aligns the given position in the image to the given position
  // in the layout bounds. For example, an [Alignment] alignment of (-1.0,
  // -1.0) aligns the image to the top-left corner of its layout bounds, while an
  // [Alignment] alignment of (1.0, 1.0) aligns the bottom right of the
  // image with the bottom right corner of its layout bounds. Similarly, an
  // alignment of (0.0, 1.0) aligns the bottom middle of the image with the
  // middle of the bottom edge of its layout bounds.
  //
  // To display a subpart of an image, consider using a [CustomPainter] and
  // [Canvas.drawImageRect].
  //
  // If the [alignment] is [TextDirection]-dependent (i.e. if it is a
  // [AlignmentDirectional]), then an ambient [Directionality] widget
  // must be in scope.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 15;
  // How to paint any portions of the layout bounds not covered by the image.
  FlutterImageRepeatType.Enum repeat = 16;
  // The center slice for a nine-patch image.
  //
  // The region of the image inside the center slice will be stretched both
  // horizontally and vertically to fit the image into its destination. The
  // region of the image above and below the center slice will be stretched
  // only horizontally and the region of the image to the left and right of
  // the center slice will be stretched only vertically.
  DartRectType center_slice = 17;
  // Whether to paint the image in the direction of the [TextDirection].
  //
  // If this is true, then in [TextDirection.ltr] contexts, the image will be
  // drawn with its origin in the top left (the "normal" painting direction for
  // images); and in [TextDirection.rtl] contexts, the image will be drawn with
  // a scaling factor of -1 in the horizontal direction so that the origin is
  // in the top right.
  //
  // This is occasionally used with images in right-to-left environments, for
  // images that were designed for left-to-right locales. Be careful, when
  // using this, to not flip images with integral shadows, text, or other
  // effects that will look incorrect when flipped.
  //
  // If this is true, there must be an ambient [Directionality] widget in
  // scope.
  bool match_text_direction = 18;
  // Whether to continue showing the old image (true), or briefly show nothing
  // (false), when the image provider changes. The default value is false.
  //
  // ## Design discussion
  //
  // ### Why is the default value of [gaplessPlayback] false?
  //
  // Having the default value of [gaplessPlayback] be false helps prevent
  // situations where stale or misleading information might be presented.
  // Consider the following case:
  //
  // We have constructed a 'Person' widget that displays an avatar [Image] of
  // the currently loaded person along with their name. We could request for a
  // new person to be loaded into the widget at any time. Suppose we have a
  // person currently loaded and the widget loads a new person. What happens
  // if the [Image] fails to load?
  //
  // * Option A ([gaplessPlayback] = false): The new person's name is coupled
  // with a blank image.
  //
  // * Option B ([gaplessPlayback] = true): The widget displays the avatar of
  // the previous person and the name of the newly loaded person.
  //
  // This is why the default value is false. Most of the time, when you change
  // the image provider you're not just changing the image, you're removing the
  // old widget and adding a new one and not expecting them to have any
  // relationship. With [gaplessPlayback] on you might accidentally break this
  // expectation and re-use the old widget.
  bool gapless_playback = 19;
  // Whether to paint the image with anti-aliasing.
  //
  // Anti-aliasing alleviates the sawtooth artifact when the image is rotated.
  bool is_anti_alias = 20;
  // The rendering quality of the image.
  //
  // {@template flutter.widgets.image.filterQuality}
  // If the image is of a high quality and its pixels are perfectly aligned
  // with the physical screen pixels, extra quality enhancement may not be
  // necessary. If so, then [FilterQuality.none] would be the most efficient.
  //
  // If the pixels are not perfectly aligned with the screen pixels, or if the
  // image itself is of a low quality, [FilterQuality.none] may produce
  // undesirable artifacts. Consider using other [FilterQuality] values to
  // improve the rendered image quality in this case. Pixels may be misaligned
  // with the screen pixels as a result of transforms or scaling.
  //
  // See also:
  //
  //  * [FilterQuality], the enum containing all possible filter quality
  //    options.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 21;
  int32 cache_width = 22;
  int32 cache_height = 23;
}

// package:flutter/src/widgets/image.dart
//
// Creates a widget that displays an [ImageStream] obtained from the network.
//
// Either the [width] and [height] arguments should be specified, or the
// widget should be placed in a context that sets tight layout constraints.
// Otherwise, the image dimensions will change as the image is loaded, which
// will result in ugly layout changes.
//
// All network images are cached regardless of HTTP headers.
//
// An optional [headers] argument can be used to send custom HTTP headers
// with the image request.
//
// {@macro flutter.widgets.image.filterQualityParameter}
//
// If [excludeFromSemantics] is true, then [semanticLabel] will be ignored.
//
// If `cacheWidth` or `cacheHeight` are provided, they indicate to the
// engine that the image should be decoded at the specified size. The image
// will be rendered to the constraints of the layout or [width] and [height]
// regardless of these parameters. These parameters are primarily intended
// to reduce the memory usage of [ImageCache].
//
// In the case where the network image is on the Web platform, the [cacheWidth]
// and [cacheHeight] parameters are ignored as the web engine delegates
// image decoding to the web which does not support custom decode sizes.
message FlutterImageNamedNetwork {
  string src = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  double scale = 4;
  // A Semantic description of the image.
  //
  // Used to provide a description of the image to TalkBack on Android, and
  // VoiceOver on iOS.
  string semantic_label = 8;
  // Whether to exclude this image from semantics.
  //
  // Useful for images which do not contribute meaningful information to an
  // application.
  bool exclude_from_semantics = 9;
  // If non-null, require the image to have this width (in logical pixels).
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  //
  // It is strongly recommended that either both the [width] and the [height]
  // be specified, or that the widget be placed in a context that sets tight
  // layout constraints, so that the image does not change size as it loads.
  // Consider using [fit] to adapt the image's rendering to fit the given width
  // and height if the exact image dimensions are not known in advance.
  double width = 10;
  // If non-null, require the image to have this height (in logical pixels).
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  //
  // It is strongly recommended that either both the [width] and the [height]
  // be specified, or that the widget be placed in a context that sets tight
  // layout constraints, so that the image does not change size as it loads.
  // Consider using [fit] to adapt the image's rendering to fit the given width
  // and height if the exact image dimensions are not known in advance.
  double height = 11;
  // If non-null, this color is blended with each image pixel using [colorBlendMode].
  DartColorType color = 12;
  // Used to combine [color] with this image.
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [color] is
  // the source and this image is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  DartBlendModeType.Enum color_blend_mode = 14;
  // How to inscribe the image into the space allocated during layout.
  //
  // The default varies based on the other fields. See the discussion at
  // [paintImage].
  FlutterBoxFitType.Enum fit = 15;
  // How to align the image within its bounds.
  //
  // The alignment aligns the given position in the image to the given position
  // in the layout bounds. For example, an [Alignment] alignment of (-1.0,
  // -1.0) aligns the image to the top-left corner of its layout bounds, while an
  // [Alignment] alignment of (1.0, 1.0) aligns the bottom right of the
  // image with the bottom right corner of its layout bounds. Similarly, an
  // alignment of (0.0, 1.0) aligns the bottom middle of the image with the
  // middle of the bottom edge of its layout bounds.
  //
  // To display a subpart of an image, consider using a [CustomPainter] and
  // [Canvas.drawImageRect].
  //
  // If the [alignment] is [TextDirection]-dependent (i.e. if it is a
  // [AlignmentDirectional]), then an ambient [Directionality] widget
  // must be in scope.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 16;
  // How to paint any portions of the layout bounds not covered by the image.
  FlutterImageRepeatType.Enum repeat = 17;
  // The center slice for a nine-patch image.
  //
  // The region of the image inside the center slice will be stretched both
  // horizontally and vertically to fit the image into its destination. The
  // region of the image above and below the center slice will be stretched
  // only horizontally and the region of the image to the left and right of
  // the center slice will be stretched only vertically.
  DartRectType center_slice = 18;
  // Whether to paint the image in the direction of the [TextDirection].
  //
  // If this is true, then in [TextDirection.ltr] contexts, the image will be
  // drawn with its origin in the top left (the "normal" painting direction for
  // images); and in [TextDirection.rtl] contexts, the image will be drawn with
  // a scaling factor of -1 in the horizontal direction so that the origin is
  // in the top right.
  //
  // This is occasionally used with images in right-to-left environments, for
  // images that were designed for left-to-right locales. Be careful, when
  // using this, to not flip images with integral shadows, text, or other
  // effects that will look incorrect when flipped.
  //
  // If this is true, there must be an ambient [Directionality] widget in
  // scope.
  bool match_text_direction = 19;
  // Whether to continue showing the old image (true), or briefly show nothing
  // (false), when the image provider changes. The default value is false.
  //
  // ## Design discussion
  //
  // ### Why is the default value of [gaplessPlayback] false?
  //
  // Having the default value of [gaplessPlayback] be false helps prevent
  // situations where stale or misleading information might be presented.
  // Consider the following case:
  //
  // We have constructed a 'Person' widget that displays an avatar [Image] of
  // the currently loaded person along with their name. We could request for a
  // new person to be loaded into the widget at any time. Suppose we have a
  // person currently loaded and the widget loads a new person. What happens
  // if the [Image] fails to load?
  //
  // * Option A ([gaplessPlayback] = false): The new person's name is coupled
  // with a blank image.
  //
  // * Option B ([gaplessPlayback] = true): The widget displays the avatar of
  // the previous person and the name of the newly loaded person.
  //
  // This is why the default value is false. Most of the time, when you change
  // the image provider you're not just changing the image, you're removing the
  // old widget and adding a new one and not expecting them to have any
  // relationship. With [gaplessPlayback] on you might accidentally break this
  // expectation and re-use the old widget.
  bool gapless_playback = 20;
  // The rendering quality of the image.
  //
  // {@template flutter.widgets.image.filterQuality}
  // If the image is of a high quality and its pixels are perfectly aligned
  // with the physical screen pixels, extra quality enhancement may not be
  // necessary. If so, then [FilterQuality.none] would be the most efficient.
  //
  // If the pixels are not perfectly aligned with the screen pixels, or if the
  // image itself is of a low quality, [FilterQuality.none] may produce
  // undesirable artifacts. Consider using other [FilterQuality] values to
  // improve the rendered image quality in this case. Pixels may be misaligned
  // with the screen pixels as a result of transforms or scaling.
  //
  // See also:
  //
  //  * [FilterQuality], the enum containing all possible filter quality
  //    options.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 21;
  // Whether to paint the image with anti-aliasing.
  //
  // Anti-aliasing alleviates the sawtooth artifact when the image is rotated.
  bool is_anti_alias = 22;
  int32 cache_width = 24;
  int32 cache_height = 25;
}

// package:flutter/src/gestures/multidrag.dart
//
// Create a gesture recognizer for tracking multiple pointers at once.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterImmediateMultiDragGestureRecognizer {
  
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that annotated the first child semantics node with an index.
message FlutterIndexedSemantics {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The index used to annotate the first child semantics node.
  int32 index = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a [Stack] widget that paints a single child.
message FlutterIndexedStack {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How to align the non-positioned and partially-positioned children in the
  // stack.
  //
  // Defaults to [AlignmentDirectional.topStart].
  //
  // See [Stack.alignment] for more information.
  FlutterAlignmentGeometryType alignment = 3;
  // The text direction with which to resolve [alignment].
  //
  // Defaults to the ambient [Directionality].
  DartTextDirectionType.Enum text_direction = 4;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 5;
  // How to size the non-positioned children in the stack.
  //
  // Defaults to [StackFit.loose].
  //
  // See [Stack.fit] for more information.
  FlutterStackFitType.Enum sizing = 6;
  // The index of the child to show.
  //
  // If this is null, none of the children will be shown.
  int32 index = 7;
  // The child widgets of the stack.
  //
  // Only the child at index [index] will be shown.
  //
  // See [Stack.children] for more information.
  repeated WidgetType children = 8;
}

// package:flutter/src/widgets/framework.dart
//
// Creates an element that uses the given widget as its configuration.
message FlutterInheritedElement {
  FlutterInheritedWidgetType widget = 2;
}

// package:flutter/src/foundation/diagnostics.dart
//
// Create a diagnostics property for integers.
message FlutterIntProperty {
  string name = 2;
  int32 value = 3;
  string if_null = 4;
  bool show_name = 5;
  // Optional unit the [value] is measured in.
  //
  // Unit must be acceptable to display immediately after a number with no
  // spaces. For example: 'physical pixels per logical pixel' should be a
  // [tooltip] not a [unit].
  string unit = 6;
  FlutterDiagnosticsTreeStyleType.Enum style = 8;
  FlutterDiagnosticLevelType.Enum level = 9;
}

// package:flutter/src/widgets/interactive_viewer.dart
//
// Create an InteractiveViewer.
message FlutterInteractiveViewer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If set to [Clip.none], the child may extend beyond the size of the InteractiveViewer,
  // but it will not receive gestures in these areas.
  // Be sure that the InteractiveViewer is the desired size when using [Clip.none].
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 3;
  // When set to [PanAxis.aligned], panning is only allowed in the horizontal
  // axis or the vertical axis, diagonal panning is not allowed.
  //
  // When set to [PanAxis.vertical] or [PanAxis.horizontal] panning is only
  // allowed in the specified axis. For example, if set to [PanAxis.vertical],
  // panning will only be allowed in the vertical axis. And if set to [PanAxis.horizontal],
  // panning will only be allowed in the horizontal axis.
  //
  // When set to [PanAxis.free] panning is allowed in all directions.
  //
  // Defaults to [PanAxis.free].
  FlutterPanAxisType.Enum pan_axis = 4;
  // A margin for the visible boundaries of the child.
  //
  // Any transformation that results in the viewport being able to view outside
  // of the boundaries will be stopped at the boundary. The boundaries do not
  // rotate with the rest of the scene, so they are always aligned with the
  // viewport.
  //
  // To produce no boundaries at all, pass infinite [EdgeInsets], such as
  // `EdgeInsets.all(double.infinity)`.
  //
  // No edge can be NaN.
  //
  // Defaults to [EdgeInsets.zero], which results in boundaries that are the
  // exact same size and position as the [child].
  FlutterEdgeInsetsType boundary_margin = 5;
  // Whether the normal size constraints at this point in the widget tree are
  // applied to the child.
  //
  // If set to false, then the child will be given infinite constraints. This
  // is often useful when a child should be bigger than the InteractiveViewer.
  //
  // For example, for a child which is bigger than the viewport but can be
  // panned to reveal parts that were initially offscreen, [constrained] must
  // be set to false to allow it to size itself properly. If [constrained] is
  // true and the child can only size itself to the viewport, then areas
  // initially outside of the viewport will not be able to receive user
  // interaction events. If experiencing regions of the child that are not
  // receptive to user gestures, make sure [constrained] is false and the child
  // is sized properly.
  //
  // Defaults to true.
  //
  // {@tool dartpad}
  // This example shows how to create a pannable table. Because the table is
  // larger than the entire screen, setting [constrained] to false is necessary
  // to allow it to be drawn to its full size. The parts of the table that
  // exceed the screen size can then be panned into view.
  //
  // ** See code in examples/api/lib/widgets/interactive_viewer/interactive_viewer.constrained.0.dart **
  // {@end-tool}
  bool constrained = 6;
  // The maximum allowed scale.
  //
  // The scale will be clamped between this and [minScale] inclusively.
  //
  // Defaults to 2.5.
  //
  // Must be greater than zero and greater than [minScale].
  double max_scale = 7;
  // The minimum allowed scale.
  //
  // The scale will be clamped between this and [maxScale] inclusively.
  //
  // Scale is also affected by [boundaryMargin]. If the scale would result in
  // viewing beyond the boundary, then it will not be allowed. By default,
  // boundaryMargin is EdgeInsets.zero, so scaling below 1.0 will not be
  // allowed in most cases without first increasing the boundaryMargin.
  //
  // Defaults to 0.8.
  //
  // Must be a finite number greater than zero and less than [maxScale].
  double min_scale = 8;
  // Changes the deceleration behavior after a gesture.
  //
  // Defaults to 0.0000135.
  //
  // Must be a finite number greater than zero.
  double interaction_end_friction_coefficient = 9;
  // If false, the user will be prevented from panning.
  //
  // Defaults to true.
  //
  // See also:
  //
  //   * [scaleEnabled], which is similar but for scale.
  bool pan_enabled = 13;
  // If false, the user will be prevented from scaling.
  //
  // Defaults to true.
  //
  // See also:
  //
  //   * [panEnabled], which is similar but for panning.
  bool scale_enabled = 14;
  // Determines the amount of scale to be performed per pointer scroll.
  //
  // Defaults to [kDefaultMouseScrollToScaleFactor].
  //
  // Increasing this value above the default causes scaling to feel slower,
  // while decreasing it causes scaling to feel faster.
  //
  // The amount of scale is calculated as the exponential function of the
  // [PointerScrollEvent.scrollDelta] to [scaleFactor] ratio. In the Flutter
  // engine, the mousewheel [PointerScrollEvent.scrollDelta] is hardcoded to 20
  // per scroll, while a trackpad scroll can be any amount.
  //
  // Affects only pointer device scrolling, not pinch to zoom.
  double scale_factor = 15;
  // A [TransformationController] for the transformation performed on the
  // child.
  //
  // Whenever the child is transformed, the [Matrix4] value is updated and all
  // listeners are notified. If the value is set, InteractiveViewer will update
  // to respect the new value.
  //
  // {@tool dartpad}
  // This example shows how transformationController can be used to animate the
  // transformation back to its starting position.
  //
  // ** See code in examples/api/lib/widgets/interactive_viewer/interactive_viewer.transformation_controller.0.dart **
  // {@end-tool}
  //
  // See also:
  //
  //  * [ValueNotifier], the parent class of TransformationController.
  //  * [TextEditingController] for an example of another similar pattern.
  FlutterTransformationControllerType transformation_controller = 16;
  // The alignment of the child's origin, relative to the size of the box.
  FlutterAlignmentType alignment = 17;
  // {@macro flutter.gestures.scale.trackpadScrollCausesScale}
  bool trackpad_scroll_causes_scale = 18;
  // The child [Widget] that is transformed by InteractiveViewer.
  //
  // If the [InteractiveViewer.builder] constructor is used, then this will be
  // null, otherwise it is required.
  WidgetType child = 19;
}

// package:flutter/src/rendering/table.dart
//
// Creates a column width based on intrinsic sizing.
//
// This sizing algorithm is very expensive.
//
// The `flex` argument specifies the flex factor to apply to the column if
// there is any room left over when laying out the table. If `flex` is
// null (the default), the table will not distribute any extra space to the
// column.
message FlutterIntrinsicColumnWidth {
  double flex = 2;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that sizes its child to the child's intrinsic height.
//
// This class is relatively expensive. Avoid using it where possible.
message FlutterIntrinsicHeight {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that sizes its child to the child's intrinsic width.
//
// This class is relatively expensive. Avoid using it where possible.
message FlutterIntrinsicWidth {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If non-null, force the child's width to be a multiple of this value.
  //
  // If null or 0.0 the child's width will be the same as its maximum
  // intrinsic width.
  //
  // This value must not be negative.
  //
  // See also:
  //
  //  * [RenderBox.getMaxIntrinsicWidth], which defines a widget's max
  //    intrinsic width in general.
  double step_width = 3;
  // If non-null, force the child's height to be a multiple of this value.
  //
  // If null or 0.0 the child's height will not be constrained.
  //
  // This value must not be negative.
  double step_height = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/foundation/diagnostics.dart
//
// Create a diagnostics property for iterables (e.g. lists).
//
// The [ifEmpty] argument is used to indicate how an iterable [value] with 0
// elements is displayed. If [ifEmpty] equals null that indicates that an
// empty iterable [value] is not interesting to display similar to how
// [defaultValue] is used to indicate that a specific concrete value is not
// interesting to display.
message FlutterIterableProperty {
  string name = 2;
  string if_null = 5;
  // Description if the property description would otherwise be empty.
  string if_empty = 6;
  FlutterDiagnosticsTreeStyleType.Enum style = 7;
  bool show_name = 8;
  bool show_separator = 9;
  FlutterDiagnosticLevelType.Enum level = 10;
}

// package:flutter/src/widgets/sliver.dart
//
// Marks a child as needing to remain alive.
message FlutterKeepAlive {
  FlutterKeyType key = 2;
  // Whether to keep the child alive.
  //
  // If this is false, it is as if this widget was omitted.
  bool keep_alive = 3;
  WidgetType child = 4;
}

// package:flutter/src/foundation/key.dart
//
// Construct a [ValueKey<String>] with the given [String].
//
// This is the simplest way to create keys.
message FlutterKey {
  string value = 2;
}

// package:flutter/src/widgets/keyboard_listener.dart
//
// Creates a widget that receives keyboard events.
//
// For text entry, consider using a [EditableText], which integrates with
// on-screen keyboards and input method editors (IMEs).
//
// The `key` is an identifier for widgets, and is unrelated to keyboards.
// See [Widget.key].
message FlutterKeyboardListener {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Controls whether this widget has keyboard focus.
  FlutterFocusNodeType focus_node = 3;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 4;
  // {@macro flutter.widgets.Focus.includeSemantics}
  bool include_semantics = 5;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 7;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that builds its child.
message FlutterKeyedSubtree {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a KeyedSubtree for child with a key that's based on the child's existing key or childIndex.
message FlutterKeyedSubtreeNamedWrap {
  WidgetType child = 2;
  int32 child_index = 3;
}

// package:flutter/src/widgets/framework.dart
//
// Creates a global key with a debugging label.
//
// The label does not affect the key's identity.
message FlutterLabeledGlobalKey {
  string debug_label = 2;
}

// package:flutter/src/rendering/layer.dart
message FlutterLayerLink {
  
}

// package:flutter/src/rendering/layer.dart
//
// Creates a leader layer.
//
// The [link] property must not have been provided to any other [LeaderLayer]
// layers that are [attached] to the layer tree at the same time.
//
// The [offset] property must be non-null before the compositing phase of the
// pipeline.
message FlutterLeaderLayer {
  FlutterLayerLinkType link = 2;
  DartOffsetType offset = 3;
}

// package:flutter/src/widgets/framework.dart
//
// Creates an element that uses the given widget as its configuration.
message FlutterLeafRenderObjectElement {
  FlutterLeafRenderObjectWidgetType widget = 2;
}

// package:flutter/src/services/text_formatter.dart
//
// Creates a formatter that prevents the insertion of more characters than a
// limit.
//
// The [maxLength] must be null, -1 or greater than zero. If it is null or -1
// then no limit is enforced.
message FlutterLengthLimitingTextInputFormatter {
  // The limit on the number of user-perceived characters that this formatter
  // will allow.
  //
  // The value must be null or greater than zero. If it is null or -1, then no
  // limit is enforced.
  //
  // {@template flutter.services.lengthLimitingTextInputFormatter.maxLength}
  // ## Characters
  //
  // For a specific definition of what is considered a character, see the
  // [characters](https://pub.dev/packages/characters) package on Pub, which is
  // what Flutter uses to delineate characters. In general, even complex
  // characters like surrogate pairs and extended grapheme clusters are
  // correctly interpreted by Flutter as each being a single user-perceived
  // character.
  //
  // For instance, the character "" can be represented as '\u{006F}\u{0308}',
  // which is the letter "o" followed by a composed diaeresis "", or it can
  // be represented as '\u{00F6}', which is the Unicode scalar value "LATIN
  // SMALL LETTER O WITH DIAERESIS". It will be counted as a single character
  // in both cases.
  //
  // Similarly, some emoji are represented by multiple scalar values. The
  // Unicode "THUMBS UP SIGN + MEDIUM SKIN TONE MODIFIER", ""is counted as
  // a single character, even though it is a combination of two Unicode scalar
  // values, '\u{1F44D}\u{1F3FD}'.
  // {@endtemplate}
  //
  // ### Composing text behaviors
  //
  // There is no guarantee for the final value before the composing ends.
  // So while the value is composing, the constraint of [maxLength] will be
  // temporary lifted until the composing ends.
  //
  // In addition, if the current value already reached the [maxLength],
  // composing is not allowed.
  int32 max_length = 2;
  // Determines how the [maxLength] limit should be enforced.
  //
  // Defaults to [MaxLengthEnforcement.enforced].
  //
  // {@macro flutter.services.textFormatter.maxLengthEnforcement}
  FlutterMaxLengthEnforcementType.Enum max_length_enforcement = 3;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Creates an object that describes a focus traversal order lexically.
message FlutterLexicalFocusOrder {
  // The String that defines the lexical order to assign to the widget subtree
  // using [FocusTraversalOrder].
  //
  // Determines the placement of this widget in a sequence of widgets that defines
  // the order in which this node is traversed by the focus policy.
  //
  // Lower lexical values will be traversed first (e.g. 'a' comes before 'z').
  string order = 2;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a box that limits its size only when it's unconstrained.
//
// The [maxWidth] and [maxHeight] arguments must not be negative.
message FlutterLimitedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The maximum width limit to apply in the absence of a
  // [BoxConstraints.maxWidth] constraint.
  double max_width = 3;
  // The maximum height limit to apply in the absence of a
  // [BoxConstraints.maxHeight] constraint.
  double max_height = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/painting/linear_border.dart
//
// Creates a rectangular box border that's rendered as zero to four lines.
message FlutterLinearBorder {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  // Defines the left edge for [TextDirection.ltr] or the right
  // for [TextDirection.rtl].
  FlutterLinearBorderEdgeType start = 3;
  // Defines the right edge for [TextDirection.ltr] or the left
  // for [TextDirection.rtl].
  FlutterLinearBorderEdgeType end = 4;
  // Defines the top edge.
  FlutterLinearBorderEdgeType top = 5;
  // Defines the bottom edge.
  FlutterLinearBorderEdgeType bottom = 6;
}

// package:flutter/src/painting/linear_border.dart
//
// Defines one side of a [LinearBorder].
//
// The values of [size] and [alignment] must be between
// 0.0 and 1.0, and -1.0 and 1.0 respectively.
message FlutterLinearBorderEdge {
  // A value between 0.0 and 1.0 that defines the length of the edge as a
  // percentage of the length of the corresponding box
  // edge. Default is 1.0.
  double size = 2;
  // A value between -1.0 and 1.0 that defines how edges for which [size]
  // is less than 1.0 are aligned relative to the corresponding box edge.
  //
  //  * -1.0, aligned in the "start" direction. That's left
  //    for [TextDirection.ltr] and right for [TextDirection.rtl].
  //  * 0.0, centered.
  //  * 1.0, aligned in the "end" direction. That's right
  //    for [TextDirection.ltr] and left for [TextDirection.rtl].
  double alignment = 3;
}

// package:flutter/src/painting/linear_border.dart
//
// Creates a rectangular box border with an edge on the bottom.
message FlutterLinearBorderNamedBottom {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  double alignment = 3;
  double size = 4;
}

// package:flutter/src/painting/linear_border.dart
//
// Creates a rectangular box border with an edge on the right for [TextDirection.ltr]
// or on the left for [TextDirection.rtl].
message FlutterLinearBorderNamedEnd {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  double alignment = 3;
  double size = 4;
}

// package:flutter/src/painting/linear_border.dart
//
// Creates a rectangular box border with an edge on the left for [TextDirection.ltr]
// or on the right for [TextDirection.rtl].
message FlutterLinearBorderNamedStart {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  double alignment = 3;
  double size = 4;
}

// package:flutter/src/painting/linear_border.dart
//
// Creates a rectangular box border with an edge on the top.
message FlutterLinearBorderNamedTop {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  double alignment = 3;
  double size = 4;
}

// package:flutter/src/painting/gradient.dart
//
// Creates a linear gradient.
//
// If [stops] is non-null, it must have the same length as [colors].
message FlutterLinearGradient {
  // The offset at which stop 0.0 of the gradient is placed.
  //
  // If this is an [Alignment], then it is expressed as a vector from
  // coordinate (0.0, 0.0), in a coordinate space that maps the center of the
  // paint box at (0.0, 0.0) and the bottom right at (1.0, 1.0).
  //
  // For example, a begin offset of (-1.0, 0.0) is half way down the
  // left side of the box.
  //
  // It can also be an [AlignmentDirectional], where the start is the
  // left in left-to-right contexts and the right in right-to-left contexts. If
  // a text-direction-dependent value is provided here, then the [createShader]
  // method will need to be given a [TextDirection].
  FlutterAlignmentGeometryType begin = 2;
  // The offset at which stop 1.0 of the gradient is placed.
  //
  // If this is an [Alignment], then it is expressed as a vector from
  // coordinate (0.0, 0.0), in a coordinate space that maps the center of the
  // paint box at (0.0, 0.0) and the bottom right at (1.0, 1.0).
  //
  // For example, a begin offset of (1.0, 0.0) is half way down the
  // right side of the box.
  //
  // It can also be an [AlignmentDirectional], where the start is the left in
  // left-to-right contexts and the right in right-to-left contexts. If a
  // text-direction-dependent value is provided here, then the [createShader]
  // method will need to be given a [TextDirection].
  FlutterAlignmentGeometryType end = 3;
  // The colors the gradient should obtain at each of the stops.
  //
  // If [stops] is non-null, this list must have the same length as [stops].
  //
  // This list must have at least two colors in it (otherwise, it's not a
  // gradient!).
  repeated DartColorType colors = 4;
  // A list of values from 0.0 to 1.0 that denote fractions along the gradient.
  //
  // If non-null, this list must have the same length as [colors].
  //
  // If the first value is not 0.0, then a stop with position 0.0 and a color
  // equal to the first color in [colors] is implied.
  //
  // If the last value is not 1.0, then a stop with position 1.0 and a color
  // equal to the last color in [colors] is implied.
  //
  // The values in the [stops] list must be in ascending order. If a value in
  // the [stops] list is less than an earlier value in the list, then its value
  // is assumed to equal the previous value.
  //
  // If stops is null, then a set of uniformly distributed stops is implied,
  // with the first stop at 0.0 and the last stop at 1.0.
  repeated double stops = 5;
  // How this gradient should tile the plane beyond in the region before
  // [begin] and after [end].
  //
  // For details, see [TileMode].
  //
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
  DartTileModeType.Enum tile_mode = 6;
  // The transform, if any, to apply to the gradient.
  //
  // This transform is in addition to any other transformations applied to the
  // canvas, but does not add any transformations to the canvas.
  FlutterGradientTransformType transform = 7;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a layout widget that arranges its children sequentially along a
// given axis.
//
// By default, the [mainAxis] is [Axis.vertical].
message FlutterListBody {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The direction to use as the main axis.
  FlutterAxisType.Enum main_axis = 3;
  // Whether the list body positions children in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [mainAxis] is [Axis.horizontal], then the list body positions children
  // from left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [mainAxis] is [Axis.vertical], then the list body positions
  // from top to bottom when [reverse] is false and from bottom to top when
  // [reverse] is true.
  //
  // Defaults to false.
  bool reverse = 4;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 5;
}

// package:flutter/src/widgets/scroll_view.dart
//
// Creates a scrollable, linear array of widgets from an explicit [List].
//
// This constructor is appropriate for list views with a small number of
// children because constructing the [List] requires doing work for every
// child that could possibly be displayed in the list view instead of just
// those children that are actually visible.
//
// Like other widgets in the framework, this widget expects that
// the [children] list will not be mutated after it has been passed in here.
// See the documentation at [SliverChildListDelegate.children] for more details.
//
// It is usually more efficient to create children on demand using
// [ListView.builder] because it will create the widget children lazily as necessary.
//
// The `addAutomaticKeepAlives` argument corresponds to the
// [SliverChildListDelegate.addAutomaticKeepAlives] property. The
// `addRepaintBoundaries` argument corresponds to the
// [SliverChildListDelegate.addRepaintBoundaries] property. The
// `addSemanticIndexes` argument corresponds to the
// [SliverChildListDelegate.addSemanticIndexes] property. None
// may be null.
message FlutterListView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.scroll_view.scrollDirection}
  // The [Axis] along which the scroll view's offset increases.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.vertical].
  // {@endtemplate}
  FlutterAxisType.Enum scroll_direction = 3;
  // {@template flutter.widgets.scroll_view.reverse}
  // Whether the scroll view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  // {@endtemplate}
  bool reverse = 4;
  // {@template flutter.widgets.scroll_view.controller}
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // Must be null if [primary] is true.
  //
  // A [ScrollController] serves several purposes. It can be used to control
  // the initial scroll position (see [ScrollController.initialScrollOffset]).
  // It can be used to control whether the scroll view should automatically
  // save and restore its scroll position in the [PageStorage] (see
  // [ScrollController.keepScrollOffset]). It can be used to read the current
  // scroll position (see [ScrollController.offset]), or change it (see
  // [ScrollController.animateTo]).
  // {@endtemplate}
  FlutterScrollControllerType controller = 5;
  // {@template flutter.widgets.scroll_view.primary}
  // Whether this is the primary scroll view associated with the parent
  // [PrimaryScrollController].
  //
  // When this is true, the scroll view is scrollable even if it does not have
  // sufficient content to actually scroll. Otherwise, by default the user can
  // only scroll the view if it has sufficient content. See [physics].
  //
  // Also when true, the scroll view is used for default [ScrollAction]s. If a
  // ScrollAction is not handled by an otherwise focused part of the application,
  // the ScrollAction will be evaluated using this scroll view, for example,
  // when executing [Shortcuts] key events like page up and down.
  //
  // On iOS, this also identifies the scroll view that will scroll to top in
  // response to a tap in the status bar.
  //
  // Cannot be true while a [ScrollController] is provided to `controller`,
  // only one ScrollController can be associated with a ScrollView.
  //
  // Setting to false will explicitly prevent inheriting any
  // [PrimaryScrollController].
  //
  // Defaults to null. When null, and a controller is not provided,
  // [PrimaryScrollController.shouldInherit] is used to decide automatic
  // inheritance.
  //
  // By default, the [PrimaryScrollController] that is injected by each
  // [ModalRoute] is configured to automatically be inherited on
  // [TargetPlatformVariant.mobile] for ScrollViews in the [Axis.vertical]
  // scroll direction. Adding another to your app will override the
  // PrimaryScrollController above it.
  //
  // The following video contains more information about scroll controllers,
  // the PrimaryScrollController widget, and their impact on your apps:
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=33_0ABjFJUU}
  //
  // {@endtemplate}
  bool primary = 6;
  FlutterScrollPhysicsType physics = 7;
  // {@template flutter.widgets.scroll_view.shrinkWrap}
  // Whether the extent of the scroll view in the [scrollDirection] should be
  // determined by the contents being viewed.
  //
  // If the scroll view does not shrink wrap, then the scroll view will expand
  // to the maximum allowed size in the [scrollDirection]. If the scroll view
  // has unbounded constraints in the [scrollDirection], then [shrinkWrap] must
  // be true.
  //
  // Shrink wrapping the content of the scroll view is significantly more
  // expensive than expanding to the maximum allowed size because the content
  // can expand and contract during scrolling, which means the size of the
  // scroll view needs to be recomputed whenever the scroll position changes.
  //
  // Defaults to false.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=LUqDNnv_dh0}
  // {@endtemplate}
  bool shrink_wrap = 8;
  // The amount of space by which to inset the children.
  FlutterEdgeInsetsGeometryType padding = 9;
  // {@template flutter.widgets.list_view.itemExtent}
  // If non-null, forces the children to have the given extent in the scroll
  // direction.
  //
  // Specifying an [itemExtent] is more efficient than letting the children
  // determine their own extent because the scrolling machinery can make use of
  // the foreknowledge of the children's extent to save work, for example when
  // the scroll position changes drastically.
  //
  // See also:
  //
  //  * [SliverFixedExtentList], the sliver used internally when this property
  //    is provided. It constrains its box children to have a specific given
  //    extent along the main axis.
  //  * The [prototypeItem] property, which allows forcing the children's
  //    extent to be the same as the given widget.
  //  * The [itemExtentBuilder] property, which allows forcing the children's
  //    extent to be the value returned by the callback.
  // {@endtemplate}
  double item_extent = 10;
  // {@template flutter.widgets.list_view.prototypeItem}
  // If non-null, forces the children to have the same extent as the given
  // widget in the scroll direction.
  //
  // Specifying an [prototypeItem] is more efficient than letting the children
  // determine their own extent because the scrolling machinery can make use of
  // the foreknowledge of the children's extent to save work, for example when
  // the scroll position changes drastically.
  //
  // See also:
  //
  //  * [SliverPrototypeExtentList], the sliver used internally when this
  //    property is provided. It constrains its box children to have the same
  //    extent as a prototype item along the main axis.
  //  * The [itemExtent] property, which allows forcing the children's extent
  //    to a given value.
  //  * The [itemExtentBuilder] property, which allows forcing the children's
  //    extent to be the value returned by the callback.
  // {@endtemplate}
  WidgetType prototype_item = 12;
  bool add_automatic_keep_alives = 13;
  bool add_repaint_boundaries = 14;
  bool add_semantic_indexes = 15;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtent}
  double cache_extent = 16;
  repeated WidgetType children = 17;
  int32 semantic_child_count = 18;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 19;
  // {@template flutter.widgets.scroll_view.keyboardDismissBehavior}
  // [ScrollViewKeyboardDismissBehavior] the defines how this [ScrollView] will
  // dismiss the keyboard automatically.
  // {@endtemplate}
  FlutterScrollViewKeyboardDismissBehaviorType.Enum keyboard_dismiss_behavior = 20;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 21;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 22;
}

// package:flutter/src/widgets/scroll_view.dart
//
// Creates a scrollable, linear array of widgets with a custom child model.
//
// For example, a custom child model can control the algorithm used to
// estimate the size of children that are not actually visible.
//
// {@tool dartpad}
// This example shows a [ListView] that uses a custom [SliverChildBuilderDelegate] to support child
// reordering.
//
// ** See code in examples/api/lib/widgets/scroll_view/list_view.1.dart **
// {@end-tool}
message FlutterListViewNamedCustom {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.scroll_view.scrollDirection}
  // The [Axis] along which the scroll view's offset increases.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.vertical].
  // {@endtemplate}
  FlutterAxisType.Enum scroll_direction = 3;
  // {@template flutter.widgets.scroll_view.reverse}
  // Whether the scroll view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  // {@endtemplate}
  bool reverse = 4;
  // {@template flutter.widgets.scroll_view.controller}
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // Must be null if [primary] is true.
  //
  // A [ScrollController] serves several purposes. It can be used to control
  // the initial scroll position (see [ScrollController.initialScrollOffset]).
  // It can be used to control whether the scroll view should automatically
  // save and restore its scroll position in the [PageStorage] (see
  // [ScrollController.keepScrollOffset]). It can be used to read the current
  // scroll position (see [ScrollController.offset]), or change it (see
  // [ScrollController.animateTo]).
  // {@endtemplate}
  FlutterScrollControllerType controller = 5;
  // {@template flutter.widgets.scroll_view.primary}
  // Whether this is the primary scroll view associated with the parent
  // [PrimaryScrollController].
  //
  // When this is true, the scroll view is scrollable even if it does not have
  // sufficient content to actually scroll. Otherwise, by default the user can
  // only scroll the view if it has sufficient content. See [physics].
  //
  // Also when true, the scroll view is used for default [ScrollAction]s. If a
  // ScrollAction is not handled by an otherwise focused part of the application,
  // the ScrollAction will be evaluated using this scroll view, for example,
  // when executing [Shortcuts] key events like page up and down.
  //
  // On iOS, this also identifies the scroll view that will scroll to top in
  // response to a tap in the status bar.
  //
  // Cannot be true while a [ScrollController] is provided to `controller`,
  // only one ScrollController can be associated with a ScrollView.
  //
  // Setting to false will explicitly prevent inheriting any
  // [PrimaryScrollController].
  //
  // Defaults to null. When null, and a controller is not provided,
  // [PrimaryScrollController.shouldInherit] is used to decide automatic
  // inheritance.
  //
  // By default, the [PrimaryScrollController] that is injected by each
  // [ModalRoute] is configured to automatically be inherited on
  // [TargetPlatformVariant.mobile] for ScrollViews in the [Axis.vertical]
  // scroll direction. Adding another to your app will override the
  // PrimaryScrollController above it.
  //
  // The following video contains more information about scroll controllers,
  // the PrimaryScrollController widget, and their impact on your apps:
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=33_0ABjFJUU}
  //
  // {@endtemplate}
  bool primary = 6;
  FlutterScrollPhysicsType physics = 7;
  // {@template flutter.widgets.scroll_view.shrinkWrap}
  // Whether the extent of the scroll view in the [scrollDirection] should be
  // determined by the contents being viewed.
  //
  // If the scroll view does not shrink wrap, then the scroll view will expand
  // to the maximum allowed size in the [scrollDirection]. If the scroll view
  // has unbounded constraints in the [scrollDirection], then [shrinkWrap] must
  // be true.
  //
  // Shrink wrapping the content of the scroll view is significantly more
  // expensive than expanding to the maximum allowed size because the content
  // can expand and contract during scrolling, which means the size of the
  // scroll view needs to be recomputed whenever the scroll position changes.
  //
  // Defaults to false.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=LUqDNnv_dh0}
  // {@endtemplate}
  bool shrink_wrap = 8;
  // The amount of space by which to inset the children.
  FlutterEdgeInsetsGeometryType padding = 9;
  // {@template flutter.widgets.list_view.itemExtent}
  // If non-null, forces the children to have the given extent in the scroll
  // direction.
  //
  // Specifying an [itemExtent] is more efficient than letting the children
  // determine their own extent because the scrolling machinery can make use of
  // the foreknowledge of the children's extent to save work, for example when
  // the scroll position changes drastically.
  //
  // See also:
  //
  //  * [SliverFixedExtentList], the sliver used internally when this property
  //    is provided. It constrains its box children to have a specific given
  //    extent along the main axis.
  //  * The [prototypeItem] property, which allows forcing the children's
  //    extent to be the same as the given widget.
  //  * The [itemExtentBuilder] property, which allows forcing the children's
  //    extent to be the value returned by the callback.
  // {@endtemplate}
  double item_extent = 10;
  // {@template flutter.widgets.list_view.prototypeItem}
  // If non-null, forces the children to have the same extent as the given
  // widget in the scroll direction.
  //
  // Specifying an [prototypeItem] is more efficient than letting the children
  // determine their own extent because the scrolling machinery can make use of
  // the foreknowledge of the children's extent to save work, for example when
  // the scroll position changes drastically.
  //
  // See also:
  //
  //  * [SliverPrototypeExtentList], the sliver used internally when this
  //    property is provided. It constrains its box children to have the same
  //    extent as a prototype item along the main axis.
  //  * The [itemExtent] property, which allows forcing the children's extent
  //    to a given value.
  //  * The [itemExtentBuilder] property, which allows forcing the children's
  //    extent to be the value returned by the callback.
  // {@endtemplate}
  WidgetType prototype_item = 11;
  // A delegate that provides the children for the [ListView].
  //
  // The [ListView.custom] constructor lets you specify this delegate
  // explicitly. The [ListView] and [ListView.builder] constructors create a
  // [childrenDelegate] that wraps the given [List] and [IndexedWidgetBuilder],
  // respectively.
  FlutterSliverChildDelegateType children_delegate = 13;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtent}
  double cache_extent = 14;
  // The number of children that will contribute semantic information.
  //
  // Some subtypes of [ScrollView] can infer this value automatically. For
  // example [ListView] will use the number of widgets in the child list,
  // while the [ListView.separated] constructor will use half that amount.
  //
  // For [CustomScrollView] and other types which do not receive a builder
  // or list of widgets, the child count must be explicitly provided. If the
  // number is unknown or unbounded this should be left unset or set to null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.scrollChildCount], the corresponding semantics property.
  int32 semantic_child_count = 15;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 16;
  // {@template flutter.widgets.scroll_view.keyboardDismissBehavior}
  // [ScrollViewKeyboardDismissBehavior] the defines how this [ScrollView] will
  // dismiss the keyboard automatically.
  // {@endtemplate}
  FlutterScrollViewKeyboardDismissBehaviorType.Enum keyboard_dismiss_behavior = 17;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 18;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 19;
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// Constructs the delegate from a concrete list of children.
message FlutterListWheelChildListDelegate {
  // The list containing all children that can be supplied.
  repeated WidgetType children = 2;
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// Constructs the delegate from a concrete list of children.
message FlutterListWheelChildLoopingListDelegate {
  // The list containing all children that can be supplied.
  repeated WidgetType children = 2;
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// Creates an element that lazily builds children for the given widget.
message FlutterListWheelElement {
  FlutterListWheelViewportType widget = 2;
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// Constructs a list in which children are scrolled a wheel. Its children
// are passed to a delegate and lazily built during layout.
message FlutterListWheelScrollView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Typically a [FixedExtentScrollController] used to control the current item.
  //
  // A [FixedExtentScrollController] can be used to read the currently
  // selected/centered child item and can be used to change the current item.
  //
  // If none is provided, a new [FixedExtentScrollController] is implicitly
  // created.
  //
  // If a [ScrollController] is used instead of [FixedExtentScrollController],
  // [ScrollNotification.metrics] will no longer provide [FixedExtentMetrics]
  // to indicate the current item index and [onSelectedItemChanged] will not
  // work.
  //
  // To read the current selected item only when the value changes, use
  // [onSelectedItemChanged].
  FlutterScrollControllerType controller = 3;
  // How the scroll view should respond to user input.
  //
  // For example, determines how the scroll view continues to animate after the
  // user stops dragging the scroll view.
  //
  // If an explicit [ScrollBehavior] is provided to [scrollBehavior], the
  // [ScrollPhysics] provided by that behavior will take precedence after
  // [physics].
  //
  // Defaults to matching platform conventions.
  FlutterScrollPhysicsType physics = 4;
  // {@macro flutter.rendering.RenderListWheelViewport.diameterRatio}
  double diameter_ratio = 5;
  // {@macro flutter.rendering.RenderListWheelViewport.perspective}
  double perspective = 6;
  // {@macro flutter.rendering.RenderListWheelViewport.offAxisFraction}
  double off_axis_fraction = 7;
  // {@macro flutter.rendering.RenderListWheelViewport.useMagnifier}
  bool use_magnifier = 8;
  // {@macro flutter.rendering.RenderListWheelViewport.magnification}
  double magnification = 9;
  // {@macro flutter.rendering.RenderListWheelViewport.overAndUnderCenterOpacity}
  double over_and_under_center_opacity = 10;
  // Size of each child in the main axis.
  //
  // Must be positive.
  double item_extent = 11;
  // {@macro flutter.rendering.RenderListWheelViewport.squeeze}
  //
  // Defaults to 1.
  double squeeze = 12;
  // {@macro flutter.rendering.RenderListWheelViewport.renderChildrenOutsideViewport}
  bool render_children_outside_viewport = 14;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 15;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 16;
  // {@macro flutter.widgets.shadow.scrollBehavior}
  //
  // [ScrollBehavior]s also provide [ScrollPhysics]. If an explicit
  // [ScrollPhysics] is provided in [physics], it will take precedence,
  // followed by [scrollBehavior], and then the inherited ancestor
  // [ScrollBehavior].
  //
  // The [ScrollBehavior] of the inherited [ScrollConfiguration] will be
  // modified by default to not apply a [Scrollbar].
  FlutterScrollBehaviorType scroll_behavior = 17;
  repeated WidgetType children = 18;
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// Constructs a list in which children are scrolled a wheel. Its children
// are managed by a delegate and are lazily built during layout.
message FlutterListWheelScrollViewNamedUseDelegate {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Typically a [FixedExtentScrollController] used to control the current item.
  //
  // A [FixedExtentScrollController] can be used to read the currently
  // selected/centered child item and can be used to change the current item.
  //
  // If none is provided, a new [FixedExtentScrollController] is implicitly
  // created.
  //
  // If a [ScrollController] is used instead of [FixedExtentScrollController],
  // [ScrollNotification.metrics] will no longer provide [FixedExtentMetrics]
  // to indicate the current item index and [onSelectedItemChanged] will not
  // work.
  //
  // To read the current selected item only when the value changes, use
  // [onSelectedItemChanged].
  FlutterScrollControllerType controller = 3;
  // How the scroll view should respond to user input.
  //
  // For example, determines how the scroll view continues to animate after the
  // user stops dragging the scroll view.
  //
  // If an explicit [ScrollBehavior] is provided to [scrollBehavior], the
  // [ScrollPhysics] provided by that behavior will take precedence after
  // [physics].
  //
  // Defaults to matching platform conventions.
  FlutterScrollPhysicsType physics = 4;
  // {@macro flutter.rendering.RenderListWheelViewport.diameterRatio}
  double diameter_ratio = 5;
  // {@macro flutter.rendering.RenderListWheelViewport.perspective}
  double perspective = 6;
  // {@macro flutter.rendering.RenderListWheelViewport.offAxisFraction}
  double off_axis_fraction = 7;
  // {@macro flutter.rendering.RenderListWheelViewport.useMagnifier}
  bool use_magnifier = 8;
  // {@macro flutter.rendering.RenderListWheelViewport.magnification}
  double magnification = 9;
  // {@macro flutter.rendering.RenderListWheelViewport.overAndUnderCenterOpacity}
  double over_and_under_center_opacity = 10;
  // Size of each child in the main axis.
  //
  // Must be positive.
  double item_extent = 11;
  // {@macro flutter.rendering.RenderListWheelViewport.squeeze}
  //
  // Defaults to 1.
  double squeeze = 12;
  // {@macro flutter.rendering.RenderListWheelViewport.renderChildrenOutsideViewport}
  bool render_children_outside_viewport = 14;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 15;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 16;
  // {@macro flutter.widgets.shadow.scrollBehavior}
  //
  // [ScrollBehavior]s also provide [ScrollPhysics]. If an explicit
  // [ScrollPhysics] is provided in [physics], it will take precedence,
  // followed by [scrollBehavior], and then the inherited ancestor
  // [ScrollBehavior].
  //
  // The [ScrollBehavior] of the inherited [ScrollConfiguration] will be
  // modified by default to not apply a [Scrollbar].
  FlutterScrollBehaviorType scroll_behavior = 17;
  // A delegate that helps lazily instantiating child.
  FlutterListWheelChildDelegateType child_delegate = 18;
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// Creates a viewport where children are rendered onto a wheel.
//
// The [diameterRatio] argument defaults to 2.
//
// The [perspective] argument defaults to 0.003.
//
// The [itemExtent] argument in pixels must be provided and must be positive.
//
// The [clipBehavior] argument defaults to [Clip.hardEdge].
//
// The [renderChildrenOutsideViewport] argument defaults to false and must
// not be null.
//
// The [offset] argument must be provided.
message FlutterListWheelViewport {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.rendering.RenderListWheelViewport.diameterRatio}
  double diameter_ratio = 3;
  // {@macro flutter.rendering.RenderListWheelViewport.perspective}
  double perspective = 4;
  // {@macro flutter.rendering.RenderListWheelViewport.offAxisFraction}
  double off_axis_fraction = 5;
  // {@macro flutter.rendering.RenderListWheelViewport.useMagnifier}
  bool use_magnifier = 6;
  // {@macro flutter.rendering.RenderListWheelViewport.magnification}
  double magnification = 7;
  // {@macro flutter.rendering.RenderListWheelViewport.overAndUnderCenterOpacity}
  double over_and_under_center_opacity = 8;
  // {@macro flutter.rendering.RenderListWheelViewport.itemExtent}
  double item_extent = 9;
  // {@macro flutter.rendering.RenderListWheelViewport.squeeze}
  //
  // Defaults to 1.
  double squeeze = 10;
  // {@macro flutter.rendering.RenderListWheelViewport.renderChildrenOutsideViewport}
  bool render_children_outside_viewport = 11;
  // [ViewportOffset] object describing the content that should be visible
  // in the viewport.
  FlutterViewportOffsetType offset = 12;
  // A delegate that lazily instantiates children.
  FlutterListWheelChildDelegateType child_delegate = 13;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 14;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that forwards point events to callbacks.
//
// The [behavior] argument defaults to [HitTestBehavior.deferToChild].
message FlutterListener {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How to behave during hit testing.
  FlutterHitTestBehaviorType.Enum behavior = 12;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 13;
}

// package:flutter/src/widgets/localizations.dart
//
// Overrides the inherited [Locale] or [LocalizationsDelegate]s for `child`.
//
// This factory constructor is used for the (usually rare) situation where part
// of an app should be localized for a different locale than the one defined
// for the device, or if its localizations should come from a different list
// of [LocalizationsDelegate]s than the list defined by
// [WidgetsApp.localizationsDelegates].
//
// For example you could specify that `myWidget` was only to be localized for
// the US English locale:
//
// ```dart
// Widget build(BuildContext context) {
//   return Localizations.override(
//     context: context,
//     locale: const Locale('en', 'US'),
//     child: myWidget,
//   );
// }
// ```
//
// The `locale` and `delegates` parameters default to the [Localizations.locale]
// and [Localizations.delegates] values from the nearest [Localizations] ancestor.
//
// To override the [Localizations.locale] or [Localizations.delegates] for an
// entire app, specify [WidgetsApp.locale] or [WidgetsApp.localizationsDelegates]
// (or specify the same parameters for [MaterialApp]).
message FlutterLocalizationsNamedOverride {
  FlutterKeyType key = 2;
  FlutterBuildContextType context = 3;
  DartLocaleType locale = 4;
  WidgetType child = 6;
}

// package:flutter/src/widgets/drag_target.dart
//
// Creates a widget that can be dragged starting from long press.
//
// If [maxSimultaneousDrags] is non-null, it must be non-negative.
message FlutterLongPressDraggable {
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // This widget displays [child] when zero drags are under way. If
  // [childWhenDragging] is non-null, this widget instead displays
  // [childWhenDragging] when one or more drags are underway. Otherwise, this
  // widget always displays [child].
  //
  // The [feedback] widget is shown under the pointer when a drag is under way.
  //
  // To limit the number of simultaneous drags on multitouch devices, see
  // [maxSimultaneousDrags].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The widget to show under the pointer when a drag is under way.
  //
  // See [child] and [childWhenDragging] for information about what is shown
  // at the location of the [Draggable] itself when a drag is under way.
  WidgetType feedback = 4;
  // The [Axis] to restrict this draggable's movement, if specified.
  //
  // When axis is set to [Axis.horizontal], this widget can only be dragged
  // horizontally. Behavior is similar for [Axis.vertical].
  //
  // Defaults to allowing drag on both [Axis.horizontal] and [Axis.vertical].
  //
  // When null, allows drag on both [Axis.horizontal] and [Axis.vertical].
  //
  // For the direction of gestures this widget competes with to start a drag
  // event, see [Draggable.affinity].
  FlutterAxisType.Enum axis = 6;
  // The widget to display instead of [child] when one or more drags are under way.
  //
  // If this is null, then this widget will always display [child] (and so the
  // drag source representation will not change while a drag is under
  // way).
  //
  // The [feedback] widget is shown under the pointer when a drag is under way.
  //
  // To limit the number of simultaneous drags on multitouch devices, see
  // [maxSimultaneousDrags].
  WidgetType child_when_dragging = 7;
  // The feedbackOffset can be used to set the hit test target point for the
  // purposes of finding a drag target. It is especially useful if the feedback
  // is transformed compared to the child.
  DartOffsetType feedback_offset = 8;
  // How many simultaneous drags to support.
  //
  // When null, no limit is applied. Set this to 1 if you want to only allow
  // the drag source to have one item dragged at a time. Set this to 0 if you
  // want to prevent the draggable from actually being dragged.
  //
  // If you set this property to 1, consider supplying an "empty" widget for
  // [childWhenDragging] to create the illusion of actually moving [child].
  int32 max_simultaneous_drags = 10;
  // Whether haptic feedback should be triggered on drag start.
  bool haptic_feedback_on_start = 16;
  // Whether the semantics of the [feedback] widget is ignored when building
  // the semantics tree.
  //
  // This value should be set to false when the [feedback] widget is intended
  // to be the same object as the [child]. Placing a [GlobalKey] on this
  // widget will ensure semantic focus is kept on the element as it moves in
  // and out of the feedback position.
  //
  // Defaults to true.
  bool ignoring_feedback_semantics = 17;
  // Whether the [feedback] widget is ignored during hit testing.
  //
  // Regardless of whether this widget is ignored during hit testing, it will
  // still consume space during layout and be visible during painting.
  //
  // Defaults to true.
  bool ignoring_feedback_pointer = 18;
  // The duration that a user has to press down before a long press is registered.
  //
  // Defaults to [kLongPressTimeout].
  DartDurationType delay = 19;
}

// package:flutter/src/gestures/long_press.dart
//
// Creates a long-press gesture recognizer.
//
// Consider assigning the [onLongPressStart] callback after creating this
// object.
//
// The [postAcceptSlopTolerance] argument can be used to specify a maximum
// allowed distance for the gesture to deviate from the starting point once
// the long press has triggered. If the gesture deviates past that point,
// subsequent callbacks ([onLongPressMoveUpdate], [onLongPressUp],
// [onLongPressEnd]) will stop. Defaults to null, which means the gesture
// can be moved without limit once the long press is accepted.
//
// The [duration] argument can be used to overwrite the default duration
// after which the long press will be recognized.
//
// {@macro flutter.gestures.tap.TapGestureRecognizer.allowedButtonsFilter}
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterLongPressGestureRecognizer {
  DartDurationType duration = 2;
  // The maximum distance in logical pixels the gesture is allowed to drift
  // after the gesture has been accepted.
  //
  // Drifting past the allowed slop amount causes the gesture to stop tracking
  // and signaling subsequent callbacks.
  //
  // Can be null to indicate that the gesture can drift for any distance.
  // Defaults to 18 logical pixels.
  double post_accept_slop_tolerance = 3;
}

// package:flutter/src/widgets/lookup_boundary.dart
//
// Creates a [LookupBoundary].
//
// A none-null [child] widget must be provided.
message FlutterLookupBoundary {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 3;
}

// package:flutter/src/widgets/magnifier.dart
//
// Constructs a [MagnifierDecoration].
//
// By default, [MagnifierDecoration] is a rectangular magnifier with no shadows, and
// fully opaque.
message FlutterMagnifierDecoration {
  // The magnifier's opacity.
  double opacity = 2;
  // A list of shadows cast by the [shape].
  //
  // See also:
  //
  //  * [kElevationToShadow], for some predefined shadows used in Material
  //    Design.
  //  * [PhysicalModel], a widget for showing shadows.
  repeated FlutterBoxShadowType shadows = 3;
  // The shape to fill the [color], [gradient], and [image] into and to cast as
  // the [shadows].
  //
  // Shapes can be stacked (using the `+` operator). The color, gradient, and
  // image are drawn into the inner-most shape specified.
  //
  // The [shape] property specifies the outline (border) of the decoration.
  //
  // ## Directionality-dependent shapes
  //
  // Some [ShapeBorder] subclasses are sensitive to the [TextDirection]. The
  // direction that is provided to the border (e.g. for its [ShapeBorder.paint]
  // method) is the one specified in the [ImageConfiguration]
  // ([ImageConfiguration.textDirection]) provided to the [BoxPainter] (via its
  // [BoxPainter.paint method). The [BoxPainter] is obtained when
  // [createBoxPainter] is called.
  //
  // When a [ShapeDecoration] is used with a [Container] widget or a
  // [DecoratedBox] widget (which is what [Container] uses), the
  // [TextDirection] specified in the [ImageConfiguration] is obtained from the
  // ambient [Directionality], using [createLocalImageConfiguration].
  FlutterShapeBorderType shape = 4;
}

// package:flutter/src/rendering/table.dart
//
// Creates a column width that is the maximum of two other column widths.
message FlutterMaxColumnWidth {
  // A lower bound for the width of this column.
  FlutterTableColumnWidthType a = 2;
  // Another lower bound for the width of this column.
  FlutterTableColumnWidthType b = 3;
}

// package:flutter/src/widgets/media_query.dart
//
// Creates a widget that provides [MediaQueryData] to its descendants.
message FlutterMediaQuery {
  FlutterKeyType key = 2;
  // Contains information about the current media.
  //
  // For example, the [MediaQueryData.size] property contains the width and
  // height of the current window.
  FlutterMediaQueryDataType data = 3;
  WidgetType child = 4;
}

// package:flutter/src/widgets/media_query.dart
//
// Creates data for a media query with explicit values.
//
// In a typical application, calling this constructor directly is rarely
// needed. Consider using [MediaQueryData.fromView] to create data based on a
// [dart:ui.FlutterView], or [MediaQueryData.copyWith] to create a new copy
// of [MediaQueryData] with updated properties from a base [MediaQueryData].
message FlutterMediaQueryData {
  // The size of the media in logical pixels (e.g, the size of the screen).
  //
  // Logical pixels are roughly the same visual size across devices. Physical
  // pixels are the size of the actual hardware pixels on the device. The
  // number of physical pixels per logical pixel is described by the
  // [devicePixelRatio].
  //
  // Prefer using [MediaQuery.sizeOf] over [MediaQuery.of]`.size` to get the
  // size, since the former will only notify of changes in [size], while the
  // latter will notify for all [MediaQueryData] changes.
  //
  // For widgets drawn in an [Overlay], do not assume that the size of the
  // [Overlay] is the size of the [MediaQuery]'s size. Nested overlays can have
  // different sizes.
  //
  // ## Troubleshooting
  //
  // It is considered bad practice to cache and later use the size returned by
  // `MediaQuery.sizeOf(context)`. It will make the application non-responsive
  // and might lead to unexpected behaviors.
  //
  // For instance, during startup, especially in release mode, the first
  // returned size might be [Size.zero]. The size will be updated when the
  // native platform reports the actual resolution. Using [MediaQuery.sizeOf]
  // will ensure that when the size changes, any widgets depending on the size
  // are automatically rebuilt.
  //
  // See the article on [Creating responsive and adaptive
  // apps](https://docs.flutter.dev/development/ui/layout/adaptive-responsive)
  // for an introduction.
  //
  // See also:
  //
  // * [FlutterView.physicalSize], which returns the size of the view in physical pixels.
  // * [FlutterView.display], which returns reports display information like size, and refresh rate.
  // * [MediaQuery.sizeOf], a method to find and depend on the size defined for
  //   a [BuildContext].
  DartSizeType size = 2;
  // The number of device pixels for each logical pixel. This number might not
  // be a power of two. Indeed, it might not even be an integer. For example,
  // the Nexus 6 has a device pixel ratio of 3.5.
  double device_pixel_ratio = 3;
  FlutterTextScalerType text_scaler = 4;
  // The current brightness mode of the host platform.
  //
  // For example, starting in Android Pie, battery saver mode asks all apps to
  // render in a "dark mode".
  //
  // Not all platforms necessarily support a concept of brightness mode. Those
  // platforms will report [Brightness.light] in this property.
  //
  // See also:
  //
  //  * [MediaQuery.platformBrightnessOf], a method to find and depend on the
  //    platformBrightness defined for a [BuildContext].
  DartBrightnessType.Enum platform_brightness = 5;
  // The parts of the display that are partially obscured by system UI,
  // typically by the hardware display "notches" or the system status bar.
  //
  // If you consumed this padding (e.g. by building a widget that envelops or
  // accounts for this padding in its layout in such a way that children are
  // no longer exposed to this padding), you should remove this padding
  // for subsequent descendants in the widget tree by inserting a new
  // [MediaQuery] widget using the [MediaQuery.removePadding] factory.
  //
  // Padding is derived from the values of [viewInsets] and [viewPadding].
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=ceCo8U0XHqw}
  //
  // See also:
  //
  //  * [FlutterView], which provides some additional detail about this
  //    property and how it relates to [viewInsets] and [viewPadding].
  //  * [SafeArea], a widget that consumes this padding with a [Padding] widget
  //    and automatically removes it from the [MediaQuery] for its child.
  FlutterEdgeInsetsType padding = 6;
  // The parts of the display that are completely obscured by system UI,
  // typically by the device's keyboard.
  //
  // When a mobile device's keyboard is visible `viewInsets.bottom`
  // corresponds to the top of the keyboard.
  //
  // This value is independent of the [padding] and [viewPadding]. viewPadding
  // is measured from the edges of the [MediaQuery] widget's bounds. Padding is
  // calculated based on the viewPadding and viewInsets. The bounds of the top
  // level MediaQuery created by [WidgetsApp] are the same as the window
  // (often the mobile device screen) that contains the app.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=ceCo8U0XHqw}
  //
  // See also:
  //
  //  * [FlutterView], which provides some additional detail about this property
  //    and how it relates to [padding] and [viewPadding].
  FlutterEdgeInsetsType view_insets = 7;
  // The areas along the edges of the display where the system consumes
  // certain input events and blocks delivery of those events to the app.
  //
  // Starting with Android Q, simple swipe gestures that start within the
  // [systemGestureInsets] areas are used by the system for page navigation
  // and may not be delivered to the app. Taps and swipe gestures that begin
  // with a long-press are delivered to the app, but simple press-drag-release
  // swipe gestures which begin within the area defined by [systemGestureInsets]
  // may not be.
  //
  // Apps should avoid locating gesture detectors within the system gesture
  // insets area. Apps should feel free to put visual elements within
  // this area.
  //
  // This property is currently only expected to be set to a non-default value
  // on Android starting with version Q.
  //
  // {@tool dartpad}
  // For apps that might be deployed on Android Q devices with full gesture
  // navigation enabled, use [systemGestureInsets] with [Padding]
  // to avoid having the left and right edges of the [Slider] from appearing
  // within the area reserved for system gesture navigation.
  //
  // By default, [Slider]s expand to fill the available width. So, we pad the
  // left and right sides.
  //
  // ** See code in examples/api/lib/widgets/media_query/media_query_data.system_gesture_insets.0.dart **
  // {@end-tool}
  FlutterEdgeInsetsType system_gesture_insets = 8;
  // The parts of the display that are partially obscured by system UI,
  // typically by the hardware display "notches" or the system status bar.
  //
  // This value remains the same regardless of whether the system is reporting
  // other obstructions in the same physical area of the screen. For example, a
  // software keyboard on the bottom of the screen that may cover and consume
  // the same area that requires bottom padding will not affect this value.
  //
  // This value is independent of the [padding] and [viewInsets]: their values
  // are measured from the edges of the [MediaQuery] widget's bounds. The
  // bounds of the top level MediaQuery created by [WidgetsApp] are the
  // same as the window that contains the app. On mobile devices, this will
  // typically be the full screen.
  //
  // {@youtube 560 315 https://www.youtube.com/watch?v=ceCo8U0XHqw}
  //
  // See also:
  //
  //  * [FlutterView], which provides some additional detail about this
  //    property and how it relates to [padding] and [viewInsets].
  FlutterEdgeInsetsType view_padding = 9;
  // Whether to use 24-hour format when formatting time.
  //
  // The behavior of this flag is different across platforms:
  //
  // - On Android this flag is reported directly from the user settings called
  //   "Use 24-hour format". It applies to any locale used by the application,
  //   whether it is the system-wide locale, or the custom locale set by the
  //   application.
  // - On iOS this flag is set to true when the user setting called "24-Hour
  //   Time" is set or the system-wide locale's default uses 24-hour
  //   formatting.
  bool always_use24_hour_format = 10;
  // Whether the user is using an accessibility service like TalkBack or
  // VoiceOver to interact with the application.
  //
  // When this setting is true, features such as timeouts should be disabled or
  // have minimum durations increased.
  //
  // See also:
  //
  //  * [dart:ui.PlatformDispatcher.accessibilityFeatures], where the setting originates.
  bool accessible_navigation = 11;
  // Whether the device is inverting the colors of the platform.
  //
  // This flag is currently only updated on iOS devices.
  //
  // See also:
  //
  //  * [dart:ui.PlatformDispatcher.accessibilityFeatures], where the setting
  //    originates.
  bool invert_colors = 12;
  // Whether the user requested a high contrast between foreground and background
  // content on iOS, via Settings -> Accessibility -> Increase Contrast.
  //
  // This flag is currently only updated on iOS devices that are running iOS 13
  // or above.
  bool high_contrast = 13;
  // Whether the user requested to show on/off labels inside switches on iOS,
  // via Settings -> Accessibility -> Display & Text Size -> On/Off Labels.
  //
  // See also:
  //
  //  * [dart:ui.PlatformDispatcher.accessibilityFeatures], where the setting
  //    originates.
  bool on_off_switch_labels = 14;
  // Whether the platform is requesting that animations be disabled or reduced
  // as much as possible.
  //
  // See also:
  //
  //  * [dart:ui.PlatformDispatcher.accessibilityFeatures], where the setting
  //    originates.
  bool disable_animations = 15;
  // Whether the platform is requesting that text be drawn with a bold font
  // weight.
  //
  // See also:
  //
  //  * [dart:ui.PlatformDispatcher.accessibilityFeatures], where the setting
  //    originates.
  bool bold_text = 16;
  // Describes the navigation mode requested by the platform.
  //
  // Some user interfaces are better navigated using a directional pad (DPAD)
  // or arrow keys, and for those interfaces, some widgets need to handle these
  // directional events differently. In order to know when to do that, these
  // widgets will look for the navigation mode in effect for their context.
  //
  // For instance, in a television interface, [NavigationMode.directional]
  // should be set, so that directional navigation is used to navigate away
  // from a text field using the DPAD. In contrast, on a regular desktop
  // application with the [navigationMode] set to [NavigationMode.traditional],
  // the arrow keys are used to move the cursor instead of navigating away.
  //
  // The [NavigationMode] values indicate the type of navigation to be used in
  // a widget subtree for those widgets sensitive to it.
  FlutterNavigationModeType.Enum navigation_mode = 17;
  // The gesture settings for the view this media query is derived from.
  //
  // This contains platform specific configuration for gesture behavior,
  // such as touch slop. These settings should be favored for configuring
  // gesture behavior over the framework constants.
  FlutterDeviceGestureSettingsType gesture_settings = 18;
  // {@macro dart.ui.ViewConfiguration.displayFeatures}
  //
  // See also:
  //
  //  * [dart:ui.DisplayFeatureType], which lists the different types of
  //  display features and explains the differences between them.
  //  * [dart:ui.DisplayFeatureState], which lists the possible states for
  //  folding features ([dart:ui.DisplayFeatureType.fold] and
  //  [dart:ui.DisplayFeatureType.hinge]).
  repeated DartDisplayFeatureType display_features = 19;
}

// package:flutter/src/widgets/media_query.dart
//
// Creates data for a [MediaQuery] based on the given `view`.
//
// If provided, the `platformData` is used to fill in the platform-specific
// aspects of the newly created [MediaQueryData]. If `platformData` is null,
// the `view`'s [PlatformDispatcher] is consulted to construct the
// platform-specific data.
//
// Data which is exposed directly on the [FlutterView] is considered
// view-specific. Data which is only exposed via the
// [FlutterView.platformDispatcher] property is considered platform-specific.
//
// Callers of this method should ensure that they also register for
// notifications so that the [MediaQueryData] can be updated when any data
// used to construct it changes. Notifications to consider are:
//
//  * [WidgetsBindingObserver.didChangeMetrics] or
//    [dart:ui.PlatformDispatcher.onMetricsChanged],
//  * [WidgetsBindingObserver.didChangeAccessibilityFeatures] or
//    [dart:ui.PlatformDispatcher.onAccessibilityFeaturesChanged],
//  * [WidgetsBindingObserver.didChangeTextScaleFactor] or
//    [dart:ui.PlatformDispatcher.onTextScaleFactorChanged],
//  * [WidgetsBindingObserver.didChangePlatformBrightness] or
//    [dart:ui.PlatformDispatcher.onPlatformBrightnessChanged].
//
// The last three notifications are only relevant if no `platformData` is
// provided. If `platformData` is provided, callers should ensure to call
// this method again when it changes to keep the constructed [MediaQueryData]
// updated.
//
// In general, [MediaQuery.of], and its associated "...Of" methods, are the
// appropriate way to obtain [MediaQueryData] from a widget. This `fromView`
// constructor is primarily for use in the implementation of the framework
// itself.
//
// See also:
//
//  * [MediaQuery.fromView], which constructs [MediaQueryData] from a provided
//    [FlutterView], makes it available to descendant widgets, and sets up
//    the appropriate notification listeners to keep the data updated.
message FlutterMediaQueryDataNamedFromView {
  FlutterMediaQueryDataType platform_data = 3;
}

// package:flutter/src/widgets/media_query.dart
//
// Creates a new [MediaQuery] that inherits from the ambient [MediaQuery]
// from the given context, but removes the specified padding.
//
// This should be inserted into the widget tree when the [MediaQuery] padding
// is consumed by a widget in such a way that the padding is no longer
// exposed to the widget's descendants or siblings.
//
// The [context] argument must have a [MediaQuery] in scope.
//
// If all four of the `removeLeft`, `removeTop`, `removeRight`, and
// `removeBottom` arguments are false (the default), then the returned
// [MediaQuery] reuses the ambient [MediaQueryData] unmodified, which is not
// particularly useful.
//
// See also:
//
//  * [SafeArea], which both removes the padding from the [MediaQuery] and
//    adds a [Padding] widget.
//  * [MediaQueryData.padding], the affected property of the
//    [MediaQueryData].
//  * [removeViewInsets], the same thing but for [MediaQueryData.viewInsets].
//  * [removeViewPadding], the same thing but for
//    [MediaQueryData.viewPadding].
message FlutterMediaQueryNamedRemovePadding {
  FlutterKeyType key = 2;
  FlutterBuildContextType context = 3;
  bool remove_left = 4;
  bool remove_top = 5;
  bool remove_right = 6;
  bool remove_bottom = 7;
  WidgetType child = 8;
}

// package:flutter/src/widgets/media_query.dart
//
// Creates a new [MediaQuery] that inherits from the ambient [MediaQuery]
// from the given context, but removes the specified view insets.
//
// This should be inserted into the widget tree when the [MediaQuery] view
// insets are consumed by a widget in such a way that the view insets are no
// longer exposed to the widget's descendants or siblings.
//
// The [context] argument must have a [MediaQuery] in scope.
//
// If all four of the `removeLeft`, `removeTop`, `removeRight`, and
// `removeBottom` arguments are false (the default), then the returned
// [MediaQuery] reuses the ambient [MediaQueryData] unmodified, which is not
// particularly useful.
//
// See also:
//
//  * [MediaQueryData.viewInsets], the affected property of the
//    [MediaQueryData].
//  * [removePadding], the same thing but for [MediaQueryData.padding].
//  * [removeViewPadding], the same thing but for
//    [MediaQueryData.viewPadding].
message FlutterMediaQueryNamedRemoveViewInsets {
  FlutterKeyType key = 2;
  FlutterBuildContextType context = 3;
  bool remove_left = 4;
  bool remove_top = 5;
  bool remove_right = 6;
  bool remove_bottom = 7;
  WidgetType child = 8;
}

// package:flutter/src/widgets/media_query.dart
//
// Creates a new [MediaQuery] that inherits from the ambient [MediaQuery]
// from the given context, but removes the specified view padding.
//
// This should be inserted into the widget tree when the [MediaQuery] view
// padding is consumed by a widget in such a way that the view padding is no
// longer exposed to the widget's descendants or siblings.
//
// The [context] argument must have a [MediaQuery] in scope.
//
// If all four of the `removeLeft`, `removeTop`, `removeRight`, and
// `removeBottom` arguments are false (the default), then the returned
// [MediaQuery] reuses the ambient [MediaQueryData] unmodified, which is not
// particularly useful.
//
// See also:
//
//  * [MediaQueryData.viewPadding], the affected property of the
//    [MediaQueryData].
//  * [removePadding], the same thing but for [MediaQueryData.padding].
//  * [removeViewInsets], the same thing but for [MediaQueryData.viewInsets].
message FlutterMediaQueryNamedRemoveViewPadding {
  FlutterKeyType key = 2;
  FlutterBuildContextType context = 3;
  bool remove_left = 4;
  bool remove_top = 5;
  bool remove_right = 6;
  bool remove_bottom = 7;
  WidgetType child = 8;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that merges the semantics of its descendants.
message FlutterMergeSemantics {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/foundation/diagnostics.dart
//
// Create a diagnostics property that displays a message.
//
// Messages have no concrete [value] (so [value] will return null). The
// message is stored as the description.
message FlutterMessageProperty {
  string name = 2;
  string message = 3;
  FlutterDiagnosticsTreeStyleType.Enum style = 4;
  FlutterDiagnosticLevelType.Enum level = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that hold opaque meta data.
//
// The [behavior] argument defaults to [HitTestBehavior.deferToChild].
message FlutterMetaData {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How to behave during hit testing.
  FlutterHitTestBehaviorType.Enum behavior = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/rendering/table.dart
//
// Creates a column width that is the minimum of two other column widths.
message FlutterMinColumnWidth {
  // An upper bound for the width of this column.
  FlutterTableColumnWidthType a = 2;
  // Another upper bound for the width of this column.
  FlutterTableColumnWidthType b = 3;
}

// package:flutter/src/widgets/modal_barrier.dart
//
// Creates a widget that blocks user interaction.
message FlutterModalBarrier {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If non-null, fill the barrier with this color.
  //
  // See also:
  //
  //  * [ModalRoute.barrierColor], which controls this property for the
  //    [ModalBarrier] built by [ModalRoute] pages.
  DartColorType color = 3;
  // Specifies if the barrier will be dismissed when the user taps on it.
  //
  // If true, and [onDismiss] is non-null, [onDismiss] will be called,
  // otherwise the current route will be popped from the ambient [Navigator].
  //
  // If false, tapping on the barrier will do nothing.
  //
  // See also:
  //
  //  * [ModalRoute.barrierDismissible], which controls this property for the
  //    [ModalBarrier] built by [ModalRoute] pages.
  bool dismissible = 4;
  // Semantics label used for the barrier if it is [dismissible].
  //
  // The semantics label is read out by accessibility tools (e.g. TalkBack
  // on Android and VoiceOver on iOS) when the barrier is focused.
  //
  // See also:
  //
  //  * [ModalRoute.barrierLabel], which controls this property for the
  //    [ModalBarrier] built by [ModalRoute] pages.
  string semantics_label = 6;
  // Whether the modal barrier semantics are included in the semantics tree.
  //
  // See also:
  //
  //  * [ModalRoute.semanticsDismissible], which controls this property for
  //    the [ModalBarrier] built by [ModalRoute] pages.
  bool barrier_semantics_dismissible = 7;
  // {@macro flutter.material.ModalBottomSheetRoute.barrierOnTapHint}
  string semantics_on_tap_hint = 9;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that forwards mouse events to callbacks.
//
// By default, all callbacks are empty, [cursor] is [MouseCursor.defer], and
// [opaque] is true.
message FlutterMouseRegion {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this widget should prevent other [MouseRegion]s visually behind it
  // from detecting the pointer.
  //
  // This changes the list of regions that a pointer hovers, thus affecting how
  // their [onHover], [onEnter], [onExit], and [cursor] behave.
  //
  // If [opaque] is true, this widget will absorb the mouse pointer and
  // prevent this widget's siblings (or any other widgets that are not
  // ancestors or descendants of this widget) from detecting the mouse
  // pointer even when the pointer is within their areas.
  //
  // If [opaque] is false, this object will not affect how [MouseRegion]s
  // behind it behave, which will detect the mouse pointer as long as the
  // pointer is within their areas.
  //
  // This defaults to true.
  bool opaque = 7;
  // How to behave during hit testing.
  //
  // This defaults to [HitTestBehavior.opaque] if null.
  FlutterHitTestBehaviorType.Enum hit_test_behavior = 8;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 9;
}

// package:flutter/src/widgets/framework.dart
//
// Creates an element that uses the given widget as its configuration.
message FlutterMultiChildRenderObjectElement {
  FlutterMultiChildRenderObjectWidgetType widget = 2;
}

// package:flutter/src/gestures/multitap.dart
//
// Creates a multi-tap gesture recognizer.
//
// The [longTapDelay] defaults to [Duration.zero], which means
// [onLongTapDown] is called immediately after [onTapDown].
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterMultiTapGestureRecognizer {
  // The amount of time between [onTapDown] and [onLongTapDown].
  DartDurationType long_tap_delay = 2;
}

// package:flutter/src/widgets/navigation_toolbar.dart
//
// Creates a widget that lays out its children in a manner suitable for a
// toolbar.
message FlutterNavigationToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Widget to place at the start of the horizontal toolbar.
  WidgetType leading = 3;
  // Widget to place in the middle of the horizontal toolbar, occupying
  // as much remaining space as possible.
  WidgetType middle = 4;
  // Widget to place at the end of the horizontal toolbar.
  WidgetType trailing = 5;
  // Whether to align the [middle] widget to the center of this widget or
  // next to the [leading] widget when false.
  bool center_middle = 6;
  // The spacing around the [middle] widget on horizontal axis.
  //
  // Defaults to [kMiddleSpacing].
  double middle_spacing = 7;
}

// package:flutter/src/widgets/navigator.dart
//
// Creates a widget that maintains a stack-based history of child widgets.
//
// If the [pages] is not empty, the [onPopPage] must not be null.
message FlutterNavigator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The name of the first route to show.
  //
  // Defaults to [Navigator.defaultRouteName].
  //
  // The value is interpreted according to [onGenerateInitialRoutes], which
  // defaults to [defaultGenerateInitialRoutes].
  //
  // Changing the [initialRoute] will have no effect, as it only controls the
  // _initial_ route. To change the route while the application is running, use
  // the static functions on this class, such as [push] or [replace].
  string initial_route = 5;
  // Whether this navigator should report route update message back to the
  // engine when the top-most route changes.
  //
  // If the property is set to true, this navigator automatically sends the
  // route update message to the engine when it detects top-most route changes.
  // The messages are used by the web engine to update the browser URL bar.
  //
  // If the property is set to true when the [Navigator] is first created,
  // single-entry history mode is requested using
  // [SystemNavigator.selectSingleEntryHistory]. This means this property
  // should not be used at the same time as [PlatformRouteInformationProvider]
  // is used with a [Router] (including when used with [MaterialApp.router],
  // for example).
  //
  // If there are multiple navigators in the widget tree, at most one of them
  // can set this property to true (typically, the top-most one created from
  // the [WidgetsApp]). Otherwise, the web engine may receive multiple route
  // update messages from different navigators and fail to update the URL
  // bar.
  //
  // Defaults to false.
  bool reports_route_update_to_engine = 10;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // In cases where clipping is not desired, consider setting this property to
  // [Clip.none].
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 11;
  // A list of observers for this navigator.
  repeated FlutterNavigatorObserverType observers = 12;
  // Whether or not the navigator and it's new topmost route should request focus
  // when the new route is pushed onto the navigator.
  //
  // Defaults to true.
  bool request_focus = 13;
  // Restoration ID to save and restore the state of the navigator, including
  // its history.
  //
  // {@template flutter.widgets.navigator.restorationScopeId}
  // If a restoration ID is provided, the navigator will persist its internal
  // state (including the route history as well as the restorable state of the
  // routes) and restore it during state restoration.
  //
  // If no restoration ID is provided, the route history stack will not be
  // restored and state restoration is disabled for the individual routes as
  // well.
  //
  // The state is persisted in a [RestorationBucket] claimed from
  // the surrounding [RestorationScope] using the provided restoration ID.
  // Within that bucket, the [Navigator] also creates a new [RestorationScope]
  // for its children (the [Route]s).
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  //  * [RestorationMixin], which contains a runnable code sample showcasing
  //    state restoration in Flutter.
  //  * [Navigator], which explains under the heading "state restoration"
  //    how and under what conditions the navigator restores its state.
  //  * [Navigator.restorablePush], which includes an example showcasing how
  //    to push a restorable route unto the navigator.
  // {@endtemplate}
  string restoration_scope_id = 14;
  // Controls the transfer of focus beyond the first and the last items of a
  // focus scope that defines focus traversal of widgets within a route.
  //
  // {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}
  // The focus inside routes installed in the top of the app affects how
  // the app behaves with respect to the platform content surrounding it.
  // For example, on the web, an app is at a minimum surrounded by browser UI,
  // such as the address bar, browser tabs, and more. The user should be able
  // to reach browser UI using normal focus shortcuts. Similarly, if the app
  // is embedded within an `<iframe>` or inside a custom element, it should
  // be able to participate in the overall focus traversal, including elements
  // not rendered by Flutter.
  // {@endtemplate}
  FlutterTraversalEdgeBehaviorType.Enum route_traversal_edge_behavior = 15;
}

// package:flutter/src/widgets/navigator.dart
message FlutterNavigatorObserver {
  
}

// package:flutter/src/widgets/navigator_pop_handler.dart
//
// Creates an instance of [NavigatorPopHandler].
message FlutterNavigatorPopHandler {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this widget's ability to handle system back gestures is enabled or
  // disabled.
  //
  // When false, there will be no effect on system back gestures. If provided,
  // [onPop] will still be called.
  //
  // This can be used, for example, when the nested [Navigator] is no longer
  // active but remains in the widget tree, such as in an inactive tab.
  //
  // Defaults to true.
  bool enabled = 4;
  // The widget to place below this in the widget tree.
  //
  // Typically this is a [Navigator] that will handle the pop when [onPop] is
  // called.
  WidgetType child = 5;
}

// package:flutter/src/widgets/navigator.dart
message FlutterNavigatorState {
  
}

// package:flutter/src/widgets/nested_scroll_view.dart
//
// Creates a variant of [Viewport] that has a [SliverOverlapAbsorberHandle].
message FlutterNestedScrollViewViewport {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The direction in which the [offset]'s [ViewportOffset.pixels] increases.
  //
  // For example, if the [axisDirection] is [AxisDirection.down], a scroll
  // offset of zero is at the top of the viewport and increases towards the
  // bottom of the viewport.
  FlutterAxisDirectionType.Enum axis_direction = 3;
  // The direction in which child should be laid out in the cross axis.
  //
  // If the [axisDirection] is [AxisDirection.down] or [AxisDirection.up], this
  // property defaults to [AxisDirection.left] if the ambient [Directionality]
  // is [TextDirection.rtl] and [AxisDirection.right] if the ambient
  // [Directionality] is [TextDirection.ltr].
  //
  // If the [axisDirection] is [AxisDirection.left] or [AxisDirection.right],
  // this property defaults to [AxisDirection.down].
  FlutterAxisDirectionType.Enum cross_axis_direction = 4;
  // The relative position of the zero scroll offset.
  //
  // For example, if [anchor] is 0.5 and the [axisDirection] is
  // [AxisDirection.down] or [AxisDirection.up], then the zero scroll offset is
  // vertically centered within the viewport. If the [anchor] is 1.0, and the
  // [axisDirection] is [AxisDirection.right], then the zero scroll offset is
  // on the left edge of the viewport.
  //
  // {@macro flutter.rendering.GrowthDirection.sample}
  double anchor = 5;
  // Which part of the content inside the viewport should be visible.
  //
  // The [ViewportOffset.pixels] value determines the scroll offset that the
  // viewport uses to select which part of its content to display. As the user
  // scrolls the viewport, this value changes, which changes the content that
  // is displayed.
  //
  // Typically a [ScrollPosition].
  FlutterViewportOffsetType offset = 6;
  // The first child in the [GrowthDirection.forward] growth direction.
  //
  // Children after [center] will be placed in the [axisDirection] relative to
  // the [center]. Children before [center] will be placed in the opposite of
  // the [axisDirection] relative to the [center].
  //
  // The [center] must be the key of a child of the viewport.
  //
  // {@macro flutter.rendering.GrowthDirection.sample}
  FlutterKeyType center = 7;
  repeated WidgetType slivers = 8;
  // The handle to the [SliverOverlapAbsorber] that is feeding this injector.
  FlutterSliverOverlapAbsorberHandleType handle = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 10;
}

// package:flutter/src/services/asset_bundle.dart
//
// Creates a network asset bundle that resolves asset keys as URLs relative
// to the given base URL.
message FlutterNetworkAssetBundle {
  DartUriType base_url = 2;
}

// package:flutter/src/widgets/scroll_physics.dart
//
// Creates scroll physics that does not let the user scroll.
message FlutterNeverScrollableScrollPhysics {
  // If non-null, determines the default behavior for each method.
  //
  // If a subclass of [ScrollPhysics] does not override a method, that subclass
  // will inherit an implementation from this base class that defers to
  // [parent]. This mechanism lets you assemble novel combinations of
  // [ScrollPhysics] subclasses at runtime. For example:
  //
  // ```dart
  // const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
  // ```
  //
  // will result in a [ScrollPhysics] that has the combined behavior
  // of [BouncingScrollPhysics] and [AlwaysScrollableScrollPhysics]:
  // behaviors that are not specified in [BouncingScrollPhysics]
  // (e.g. [shouldAcceptUserOffset]) will defer to [AlwaysScrollableScrollPhysics].
  FlutterScrollPhysicsType parent = 2;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Creates an intent that is used with [NextFocusAction].
message FlutterNextFocusIntent {
  
}

// package:flutter/src/widgets/notification_listener.dart
//
// Creates a widget that listens for notifications.
message FlutterNotificationListener {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 3;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Creates an object that describes a focus traversal order numerically.
message FlutterNumericFocusOrder {
  // The numerical order to assign to the widget subtree using
  // [FocusTraversalOrder].
  //
  // Determines the placement of this widget in a sequence of widgets that defines
  // the order in which this node is traversed by the focus policy.
  //
  // Lower values will be traversed first.
  double order = 2;
}

// package:flutter/src/widgets/framework.dart
//
// Creates a key that uses [identical] on [value] for its [operator==].
message FlutterObjectKey {
  
}

// package:flutter/src/rendering/layer.dart
//
// Creates an offset layer.
//
// By default, [offset] is zero. It must be non-null before the compositing
// phase of the pipeline.
message FlutterOffsetLayer {
  DartOffsetType offset = 2;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that visually hides its child.
message FlutterOffstage {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether the child is hidden from the rest of the tree.
  //
  // If true, the child is laid out as if it was in the tree, but without
  // painting anything, without making the child available for hit testing, and
  // without taking any room in the parent.
  //
  // Offstage children are still active: they can receive focus and have keyboard
  // input directed to them.
  //
  // Animations continue to run in offstage children, and therefore use battery
  // and CPU time, regardless of whether the animations end up being visible.
  //
  // If false, the child is included in the tree as normal.
  bool offstage = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that makes its child partially transparent.
//
// The [opacity] argument must be between zero and one, inclusive.
message FlutterOpacity {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The fraction to scale the child's alpha value.
  //
  // An opacity of one is fully opaque. An opacity of zero is fully transparent
  // (i.e., invisible).
  //
  // Values one and zero are painted with a fast path. Other values require
  // painting the child into an intermediate buffer, which is expensive.
  double opacity = 3;
  // Whether the semantic information of the children is always included.
  //
  // Defaults to false.
  //
  // When true, regardless of the opacity settings the child semantic
  // information is exposed as if the widget were fully visible. This is
  // useful in cases where labels may be hidden during animations that
  // would otherwise contribute relevant semantics.
  bool always_include_semantics = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/rendering/layer.dart
//
// Creates an opacity layer.
//
// The [alpha] property must be non-null before the compositing phase of
// the pipeline.
message FlutterOpacityLayer {
  int32 alpha = 2;
  DartOffsetType offset = 3;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Constructs a traversal policy that orders widgets for keyboard traversal
// based on an explicit order.
//
// If [secondary] is null, it will default to [ReadingOrderTraversalPolicy].
message FlutterOrderedTraversalPolicy {
  // This is the policy that is used when a node doesn't have an order
  // assigned, or when multiple nodes have orders which are identical.
  //
  // If not set, this defaults to [ReadingOrderTraversalPolicy].
  //
  // This policy determines the secondary sorting order of nodes which evaluate
  // as having an identical order (including those with no order specified).
  //
  // Nodes with no order specified will be sorted after nodes with an explicit
  // order.
  FlutterFocusTraversalPolicyType secondary = 2;
}

// package:flutter/src/painting/oval_border.dart
//
// Create an oval border.
message FlutterOvalBorder {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  // Defines the ratio (0.0-1.0) from which the border will deform
  // to fit a rectangle.
  // When 0.0, it draws a circle touching at least two sides of the rectangle.
  // When 1.0, it draws an oval touching all sides of the rectangle.
  double eccentricity = 3;
}

// package:flutter/src/widgets/overflow_bar.dart
//
// Constructs an OverflowBar.
message FlutterOverflowBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The width of the gap between [children] for the default
  // horizontal layout.
  //
  // If the horizontal layout overflows, then [overflowSpacing] is
  // used instead.
  //
  // Defaults to 0.0.
  double spacing = 3;
  // Defines the [children]'s horizontal layout according to the same
  // rules as for [Row.mainAxisAlignment].
  //
  // If this property is non-null, and the [children], separated by
  // [spacing], fit within the available width, then the overflow
  // bar will be as wide as possible. If the children do not fit
  // within the available width, then this property is ignored and
  // [overflowAlignment] applies instead.
  //
  // If this property is null (the default) then the overflow bar
  // will be no wider than needed to layout the [children] separated
  // by [spacing], modulo the incoming constraints.
  //
  // If [alignment] is one of [MainAxisAlignment.spaceAround],
  // [MainAxisAlignment.spaceBetween], or
  // [MainAxisAlignment.spaceEvenly], then the [spacing] parameter is
  // only used to see if the horizontal layout will overflow.
  //
  // Defaults to null.
  //
  // See also:
  //
  //  * [overflowAlignment], the horizontal alignment of the [children] within
  //    the vertical "overflow" layout.
  //
  FlutterMainAxisAlignmentType.Enum alignment = 4;
  // The height of the gap between [children] in the vertical
  // "overflow" layout.
  //
  // This parameter is only used if the horizontal layout overflows, i.e.
  // if there isn't enough horizontal room for the [children] and [spacing].
  //
  // Defaults to 0.0.
  //
  // See also:
  //
  //  * [spacing], The width of the gap between each pair of children
  //    for the default horizontal layout.
  double overflow_spacing = 5;
  // The horizontal alignment of the [children] within the vertical
  // "overflow" layout.
  //
  // This parameter is only used if the horizontal layout overflows, i.e.
  // if there isn't enough horizontal room for the [children] and [spacing].
  // In that case the overflow bar will expand to fill the available
  // width and it will layout its [children] in a column. The
  // horizontal alignment of each child within that column is
  // defined by this parameter and the [textDirection]. If the
  // [textDirection] is [TextDirection.ltr] then each child will be
  // aligned with the left edge of the available space for
  // [OverflowBarAlignment.start], with the right edge of the
  // available space for [OverflowBarAlignment.end]. Similarly, if the
  // [textDirection] is [TextDirection.rtl] then each child will
  // be aligned with the right edge of the available space for
  // [OverflowBarAlignment.start], and with the left edge of the
  // available space for [OverflowBarAlignment.end]. For
  // [OverflowBarAlignment.center] each child is horizontally
  // centered within the available space.
  //
  // Defaults to [OverflowBarAlignment.start].
  //
  // See also:
  //
  //  * [alignment], which defines the [children]'s horizontal layout
  //    (according to the same rules as for [Row.mainAxisAlignment]) when
  //    the children, separated by [spacing], fit within the available space.
  //  * [overflowDirection], which defines the order that the
  //    [OverflowBar]'s children appear in, if the horizontal layout
  //    overflows.
  FlutterOverflowBarAlignmentType.Enum overflow_alignment = 6;
  // Defines the order that the [children] appear in, if
  // the horizontal layout overflows.
  //
  // This parameter is only used if the horizontal layout overflows, i.e.
  // if there isn't enough horizontal room for the [children] and [spacing].
  //
  // If the children do not fit into a single row, then they
  // are arranged in a column. The first child is at the top of the
  // column if this property is set to [VerticalDirection.down], since it
  // "starts" at the top and "ends" at the bottom. On the other hand,
  // the first child will be at the bottom of the column if this
  // property is set to [VerticalDirection.up], since it "starts" at the
  // bottom and "ends" at the top.
  //
  // Defaults to [VerticalDirection.down].
  //
  // See also:
  //
  //  * [overflowAlignment], which defines the horizontal alignment
  //    of the children within the vertical "overflow" layout.
  FlutterVerticalDirectionType.Enum overflow_direction = 7;
  // Determines the order that the [children] appear in for the default
  // horizontal layout, and the interpretation of
  // [OverflowBarAlignment.start] and [OverflowBarAlignment.end] for
  // the vertical overflow layout.
  //
  // For the default horizontal layout, if [textDirection] is
  // [TextDirection.rtl] then the last child is laid out first. If
  // [textDirection] is [TextDirection.ltr] then the first child is
  // laid out first.
  //
  // If this parameter is null, then the value of
  // `Directionality.of(context)` is used.
  //
  // See also:
  //
  //  * [overflowDirection], which defines the order that the
  //    [OverflowBar]'s children appear in, if the horizontal layout
  //    overflows.
  //  * [Directionality], which defines the ambient directionality of
  //    text and text-direction-sensitive render objects.
  DartTextDirectionType.Enum text_direction = 8;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 9;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 10;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that lets its child overflow itself.
message FlutterOverflowBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How to align the child.
  //
  // The x and y values of the alignment control the horizontal and vertical
  // alignment, respectively. An x value of -1.0 means that the left edge of
  // the child is aligned with the left edge of the parent whereas an x value
  // of 1.0 means that the right edge of the child is aligned with the right
  // edge of the parent. Other values interpolate (and extrapolate) linearly.
  // For example, a value of 0.0 means that the center of the child is aligned
  // with the center of the parent.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 3;
  // The minimum width constraint to give the child. Set this to null (the
  // default) to use the constraint from the parent instead.
  double min_width = 4;
  // The maximum width constraint to give the child. Set this to null (the
  // default) to use the constraint from the parent instead.
  double max_width = 5;
  // The minimum height constraint to give the child. Set this to null (the
  // default) to use the constraint from the parent instead.
  double min_height = 6;
  // The maximum height constraint to give the child. Set this to null (the
  // default) to use the constraint from the parent instead.
  double max_height = 7;
  // The way to size the render object.
  //
  // This only affects scenario when the child does not indeed overflow.
  // If set to [OverflowBoxFit.deferToChild], the render object will size itself to
  // match the size of its child within the constraints of its parent or be
  // as small as the parent allows if no child is set. If set to
  // [OverflowBoxFit.max] (the default), the render object will size itself
  // to be as large as the parent allows.
  FlutterOverflowBoxFitType.Enum fit = 8;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 9;
}

// package:flutter/src/widgets/overlay.dart
//
// Creates an overlay.
//
// The initial entries will be inserted into the overlay when its associated
// [OverlayState] is initialized.
//
// Rather than creating an overlay, consider using the overlay that is
// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
// [MaterialApp] for the application.
message FlutterOverlay {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 4;
}

// package:flutter/src/widgets/overlay.dart
message FlutterOverlayState {
  
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that insets its child.
message FlutterPadding {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The amount of space by which to inset the child.
  FlutterEdgeInsetsGeometryType padding = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/page_view.dart
//
// Creates a page controller.
message FlutterPageController {
  // The page to show when first creating the [PageView].
  int32 initial_page = 2;
  // Save the current [page] with [PageStorage] and restore it if
  // this controller's scrollable is recreated.
  //
  // If this property is set to false, the current [page] is never saved
  // and [initialPage] is always used to initialize the scroll offset.
  // If true (the default), the initial page is used the first time the
  // controller's scrollable is created, since there's isn't a page to
  // restore yet. Subsequently the saved page is restored and
  // [initialPage] is ignored.
  //
  // See also:
  //
  //  * [PageStorageKey], which should be used when more than one
  //    scrollable appears in the same route, to distinguish the [PageStorage]
  //    locations used to save scroll offsets.
  bool keep_page = 3;
  // {@template flutter.widgets.pageview.viewportFraction}
  // The fraction of the viewport that each page should occupy.
  //
  // Defaults to 1.0, which means each page fills the viewport in the scrolling
  // direction.
  // {@endtemplate}
  double viewport_fraction = 4;
}

// package:flutter/src/widgets/page_view.dart
//
// Creates physics for a [PageView].
message FlutterPageScrollPhysics {
  // If non-null, determines the default behavior for each method.
  //
  // If a subclass of [ScrollPhysics] does not override a method, that subclass
  // will inherit an implementation from this base class that defers to
  // [parent]. This mechanism lets you assemble novel combinations of
  // [ScrollPhysics] subclasses at runtime. For example:
  //
  // ```dart
  // const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
  // ```
  //
  // will result in a [ScrollPhysics] that has the combined behavior
  // of [BouncingScrollPhysics] and [AlwaysScrollableScrollPhysics]:
  // behaviors that are not specified in [BouncingScrollPhysics]
  // (e.g. [shouldAcceptUserOffset]) will defer to [AlwaysScrollableScrollPhysics].
  FlutterScrollPhysicsType parent = 2;
}

// package:flutter/src/widgets/page_storage.dart
//
// Creates a widget that provides a storage bucket for its descendants.
message FlutterPageStorage {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The page storage bucket to use for this subtree.
  FlutterPageStorageBucketType bucket = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/page_storage.dart
message FlutterPageStorageBucket {
  
}

// package:flutter/src/widgets/page_view.dart
//
// Creates a scrollable list that works page by page from an explicit [List]
// of widgets.
//
// This constructor is appropriate for page views with a small number of
// children because constructing the [List] requires doing work for every
// child that could possibly be displayed in the page view, instead of just
// those children that are actually visible.
//
// Like other widgets in the framework, this widget expects that
// the [children] list will not be mutated after it has been passed in here.
// See the documentation at [SliverChildListDelegate.children] for more details.
//
// {@template flutter.widgets.PageView.allowImplicitScrolling}
// If [allowImplicitScrolling] is true, the [PageView] will participate in
// accessibility scrolling more like a [ListView], where implicit scroll
// actions will move to the next page rather than into the contents of the
// [PageView].
// {@endtemplate}
message FlutterPageView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [Axis] along which the scroll view's offset increases with each page.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.horizontal].
  FlutterAxisType.Enum scroll_direction = 3;
  // Whether the page view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the page view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the page view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  bool reverse = 4;
  FlutterPageControllerType controller = 5;
  // How the page view should respond to user input.
  //
  // For example, determines how the page view continues to animate after the
  // user stops dragging the page view.
  //
  // The physics are modified to snap to page boundaries using
  // [PageScrollPhysics] prior to being used.
  //
  // If an explicit [ScrollBehavior] is provided to [scrollBehavior], the
  // [ScrollPhysics] provided by that behavior will take precedence after
  // [physics].
  //
  // Defaults to matching platform conventions.
  FlutterScrollPhysicsType physics = 6;
  // Set to false to disable page snapping, useful for custom scroll behavior.
  //
  // If the [padEnds] is false and [PageController.viewportFraction] < 1.0,
  // the page will snap to the beginning of the viewport; otherwise, the page
  // will snap to the center of the viewport.
  bool page_snapping = 7;
  repeated WidgetType children = 9;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 10;
  // Controls whether the widget's pages will respond to
  // [RenderObject.showOnScreen], which will allow for implicit accessibility
  // scrolling.
  //
  // With this flag set to false, when accessibility focus reaches the end of
  // the current page and the user attempts to move it to the next element, the
  // focus will traverse to the next widget outside of the page view.
  //
  // With this flag set to true, when accessibility focus reaches the end of
  // the current page and user attempts to move it to the next element, focus
  // will traverse to the next page in the page view.
  bool allow_implicit_scrolling = 11;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 12;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 13;
  // {@macro flutter.widgets.shadow.scrollBehavior}
  //
  // [ScrollBehavior]s also provide [ScrollPhysics]. If an explicit
  // [ScrollPhysics] is provided in [physics], it will take precedence,
  // followed by [scrollBehavior], and then the inherited ancestor
  // [ScrollBehavior].
  //
  // The [ScrollBehavior] of the inherited [ScrollConfiguration] will be
  // modified by default to not apply a [Scrollbar].
  FlutterScrollBehaviorType scroll_behavior = 14;
  // Whether to add padding to both ends of the list.
  //
  // If this is set to true and [PageController.viewportFraction] < 1.0, padding will be added
  // such that the first and last child slivers will be in the center of
  // the viewport when scrolled all the way to the start or end, respectively.
  //
  // If [PageController.viewportFraction] >= 1.0, this property has no effect.
  //
  // This property defaults to true.
  bool pad_ends = 15;
}

// package:flutter/src/widgets/page_view.dart
//
// Creates a scrollable list that works page by page with a custom child
// model.
//
// {@tool dartpad}
// This example shows a [PageView] that uses a custom [SliverChildBuilderDelegate] to support child
// reordering.
//
// ** See code in examples/api/lib/widgets/page_view/page_view.1.dart **
// {@end-tool}
//
// {@macro flutter.widgets.PageView.allowImplicitScrolling}
message FlutterPageViewNamedCustom {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [Axis] along which the scroll view's offset increases with each page.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.horizontal].
  FlutterAxisType.Enum scroll_direction = 3;
  // Whether the page view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the page view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the page view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  bool reverse = 4;
  FlutterPageControllerType controller = 5;
  // How the page view should respond to user input.
  //
  // For example, determines how the page view continues to animate after the
  // user stops dragging the page view.
  //
  // The physics are modified to snap to page boundaries using
  // [PageScrollPhysics] prior to being used.
  //
  // If an explicit [ScrollBehavior] is provided to [scrollBehavior], the
  // [ScrollPhysics] provided by that behavior will take precedence after
  // [physics].
  //
  // Defaults to matching platform conventions.
  FlutterScrollPhysicsType physics = 6;
  // Set to false to disable page snapping, useful for custom scroll behavior.
  //
  // If the [padEnds] is false and [PageController.viewportFraction] < 1.0,
  // the page will snap to the beginning of the viewport; otherwise, the page
  // will snap to the center of the viewport.
  bool page_snapping = 7;
  // A delegate that provides the children for the [PageView].
  //
  // The [PageView.custom] constructor lets you specify this delegate
  // explicitly. The [PageView] and [PageView.builder] constructors create a
  // [childrenDelegate] that wraps the given [List] and [IndexedWidgetBuilder],
  // respectively.
  FlutterSliverChildDelegateType children_delegate = 9;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 10;
  // Controls whether the widget's pages will respond to
  // [RenderObject.showOnScreen], which will allow for implicit accessibility
  // scrolling.
  //
  // With this flag set to false, when accessibility focus reaches the end of
  // the current page and the user attempts to move it to the next element, the
  // focus will traverse to the next widget outside of the page view.
  //
  // With this flag set to true, when accessibility focus reaches the end of
  // the current page and user attempts to move it to the next element, focus
  // will traverse to the next page in the page view.
  bool allow_implicit_scrolling = 11;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 12;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 13;
  // {@macro flutter.widgets.shadow.scrollBehavior}
  //
  // [ScrollBehavior]s also provide [ScrollPhysics]. If an explicit
  // [ScrollPhysics] is provided in [physics], it will take precedence,
  // followed by [scrollBehavior], and then the inherited ancestor
  // [ScrollBehavior].
  //
  // The [ScrollBehavior] of the inherited [ScrollConfiguration] will be
  // modified by default to not apply a [Scrollbar].
  FlutterScrollBehaviorType scroll_behavior = 14;
  // Whether to add padding to both ends of the list.
  //
  // If this is set to true and [PageController.viewportFraction] < 1.0, padding will be added
  // such that the first and last child slivers will be in the center of
  // the viewport when scrolled all the way to the start or end, respectively.
  //
  // If [PageController.viewportFraction] >= 1.0, this property has no effect.
  //
  // This property defaults to true.
  bool pad_ends = 15;
}

// package:flutter/src/gestures/monodrag.dart
//
// Create a gesture recognizer for tracking movement on a plane.
message FlutterPanGestureRecognizer {
  
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an instance of [PasteTextIntent].
message FlutterPasteTextIntent {
  // {@macro flutter.widgets.TextEditingIntents.cause}
  FlutterSelectionChangedCauseType.Enum cause = 2;
}

// package:flutter/src/foundation/diagnostics.dart
//
// Create a diagnostics property for doubles that represent percentages or
// fractions.
//
// Setting [showName] to false is often reasonable for [PercentProperty]
// objects, as the fact that the property is shown as a percentage tends to
// be sufficient to disambiguate its meaning.
message FlutterPercentProperty {
  string name = 2;
  double fraction = 3;
  string if_null = 4;
  bool show_name = 5;
  string tooltip = 6;
  // Optional unit the [value] is measured in.
  //
  // Unit must be acceptable to display immediately after a number with no
  // spaces. For example: 'physical pixels per logical pixel' should be a
  // [tooltip] not a [unit].
  string unit = 7;
  FlutterDiagnosticLevelType.Enum level = 8;
}

// package:flutter/src/widgets/performance_overlay.dart
//
// Create a performance overlay that only displays specific statistics. The
// mask is created by shifting 1 by the index of the specific
// [PerformanceOverlayOption] to enable.
message FlutterPerformanceOverlay {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The mask is created by shifting 1 by the index of the specific
  // [PerformanceOverlayOption] to enable.
  int32 options_mask = 3;
  // The rasterizer threshold is an integer specifying the number of frame
  // intervals that the rasterizer must miss before it decides that the frame
  // is suitable for capturing an SkPicture trace for further analysis.
  //
  // For example, if you want a trace of all pictures that could not be
  // rendered by the rasterizer within the frame boundary (and hence caused
  // jank), specify 1. Specifying 2 will trace all pictures that took more
  // than 2 frame intervals to render. Adjust this value to only capture
  // the particularly expensive pictures while skipping the others. Specifying
  // 0 disables all capture.
  //
  // Captured traces are placed on your device in the application documents
  // directory in this form "trace_<collection_time>.skp". These can
  // be viewed in the Skia debugger.
  //
  // Notes:
  // The rasterizer only takes into account the time it took to render
  // the already constructed picture. This include the Skia calls (which is
  // also why an SkPicture trace is generated) but not any of the time spent in
  // dart to construct that picture. To profile that part of your code, use
  // the instrumentation available in observatory.
  //
  // To decide what threshold interval to use, count the number of horizontal
  // lines displayed in the performance overlay for the rasterizer (not the
  // engine). That should give an idea of how often frames are skipped (and by
  // how many frame intervals).
  int32 rasterizer_threshold = 4;
  // Whether the raster cache should checkerboard cached entries.
  //
  // The compositor can sometimes decide to cache certain portions of the
  // widget hierarchy. Such portions typically don't change often from frame to
  // frame and are expensive to render. This can speed up overall rendering. However,
  // there is certain upfront cost to constructing these cache entries. And, if
  // the cache entries are not used very often, this cost may not be worth the
  // speedup in rendering of subsequent frames. If the developer wants to be certain
  // that populating the raster cache is not causing stutters, this option can be
  // set. Depending on the observations made, hints can be provided to the compositor
  // that aid it in making better decisions about caching.
  bool checkerboard_raster_cache_images = 5;
  // Whether the compositor should checkerboard layers that are rendered to offscreen
  // bitmaps. This can be useful for debugging rendering performance.
  //
  // Render target switches are caused by using opacity layers (via a [FadeTransition] or
  // [Opacity] widget), clips, shader mask layers, etc. Selecting a new render target
  // and merging it with the rest of the scene has a performance cost. This can sometimes
  // be avoided by using equivalent widgets that do not require these layers (for example,
  // replacing an [Opacity] widget with an [widgets.Image] using a [BlendMode]).
  bool checkerboard_offscreen_layers = 6;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a layer that displays a performance overlay.
message FlutterPerformanceOverlayLayer {
  DartRectType overlay_rect = 2;
  // The mask is created by shifting 1 by the index of the specific
  // [PerformanceOverlayOption] to enable.
  int32 options_mask = 3;
  // The rasterizer threshold is an integer specifying the number of frame
  // intervals that the rasterizer must miss before it decides that the frame
  // is suitable for capturing an SkPicture trace for further analysis.
  int32 rasterizer_threshold = 4;
  // Whether the raster cache should checkerboard cached entries.
  //
  // The compositor can sometimes decide to cache certain portions of the
  // widget hierarchy. Such portions typically don't change often from frame to
  // frame and are expensive to render. This can speed up overall rendering. However,
  // there is certain upfront cost to constructing these cache entries. And, if
  // the cache entries are not used very often, this cost may not be worth the
  // speedup in rendering of subsequent frames. If the developer wants to be certain
  // that populating the raster cache is not causing stutters, this option can be
  // set. Depending on the observations made, hints can be provided to the compositor
  // that aid it in making better decisions about caching.
  bool checkerboard_raster_cache_images = 5;
  // Whether the compositor should checkerboard layers that are rendered to offscreen
  // bitmaps. This can be useful for debugging rendering performance.
  //
  // Render target switches are caused by using opacity layers (via a [FadeTransition] or
  // [Opacity] widget), clips, shader mask layers, etc. Selecting a new render target
  // and merging it with the rest of the scene has a performance cost. This can sometimes
  // be avoided by using equivalent widgets that do not require these layers (for example,
  // replacing an [Opacity] widget with an [widgets.Image] using a [BlendMode]).
  bool checkerboard_offscreen_layers = 6;
}

// package:flutter/src/widgets/performance_overlay.dart
//
// Create a performance overlay that displays all available statistics.
message FlutterPerformanceOverlayNamedAllEnabled {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The rasterizer threshold is an integer specifying the number of frame
  // intervals that the rasterizer must miss before it decides that the frame
  // is suitable for capturing an SkPicture trace for further analysis.
  //
  // For example, if you want a trace of all pictures that could not be
  // rendered by the rasterizer within the frame boundary (and hence caused
  // jank), specify 1. Specifying 2 will trace all pictures that took more
  // than 2 frame intervals to render. Adjust this value to only capture
  // the particularly expensive pictures while skipping the others. Specifying
  // 0 disables all capture.
  //
  // Captured traces are placed on your device in the application documents
  // directory in this form "trace_<collection_time>.skp". These can
  // be viewed in the Skia debugger.
  //
  // Notes:
  // The rasterizer only takes into account the time it took to render
  // the already constructed picture. This include the Skia calls (which is
  // also why an SkPicture trace is generated) but not any of the time spent in
  // dart to construct that picture. To profile that part of your code, use
  // the instrumentation available in observatory.
  //
  // To decide what threshold interval to use, count the number of horizontal
  // lines displayed in the performance overlay for the rasterizer (not the
  // engine). That should give an idea of how often frames are skipped (and by
  // how many frame intervals).
  int32 rasterizer_threshold = 3;
  // Whether the raster cache should checkerboard cached entries.
  //
  // The compositor can sometimes decide to cache certain portions of the
  // widget hierarchy. Such portions typically don't change often from frame to
  // frame and are expensive to render. This can speed up overall rendering. However,
  // there is certain upfront cost to constructing these cache entries. And, if
  // the cache entries are not used very often, this cost may not be worth the
  // speedup in rendering of subsequent frames. If the developer wants to be certain
  // that populating the raster cache is not causing stutters, this option can be
  // set. Depending on the observations made, hints can be provided to the compositor
  // that aid it in making better decisions about caching.
  bool checkerboard_raster_cache_images = 4;
  // Whether the compositor should checkerboard layers that are rendered to offscreen
  // bitmaps. This can be useful for debugging rendering performance.
  //
  // Render target switches are caused by using opacity layers (via a [FadeTransition] or
  // [Opacity] widget), clips, shader mask layers, etc. Selecting a new render target
  // and merging it with the rest of the scene has a performance cost. This can sometimes
  // be avoided by using equivalent widgets that do not require these layers (for example,
  // replacing an [Opacity] widget with an [widgets.Image] using a [BlendMode]).
  bool checkerboard_offscreen_layers = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a physical model with a rounded-rectangular clip.
//
// The [color] is required; physical things have a color.
//
// The [shape], [elevation], [color], [clipBehavior], and [shadowColor] must
// not be null. Additionally, the [elevation] must be non-negative.
message FlutterPhysicalModel {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The type of shape.
  FlutterBoxShapeType.Enum shape = 3;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 4;
  // The border radius of the rounded corners.
  //
  // Values are clamped so that horizontal and vertical radii sums do not
  // exceed width/height.
  //
  // This is ignored if the [shape] is not [BoxShape.rectangle].
  FlutterBorderRadiusType border_radius = 5;
  // The z-coordinate relative to the parent at which to place this physical
  // object.
  //
  // The value is non-negative.
  double elevation = 6;
  // The background color.
  DartColorType color = 7;
  // The shadow color.
  DartColorType shadow_color = 8;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 9;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a leaf layer for the layer tree.
message FlutterPictureLayer {
  // The bounds that were used for the canvas that drew this layer's [picture].
  //
  // This is purely advisory. It is included in the information dumped with
  // [debugDumpLayerTree] (which can be triggered by pressing "L" when using
  // "flutter run" at the console), which can help debug why certain drawing
  // commands are being culled.
  DartRectType canvas_bounds = 2;
}

// package:flutter/src/rendering/object.dart
//
// Creates a pipeline owner.
//
// Typically created by the binding (e.g., [RendererBinding]), but can be
// created separately from the binding to drive off-screen render objects
// through the rendering pipeline.
message FlutterPipelineOwner {
  
}

// package:flutter/src/widgets/placeholder.dart
//
// Creates a widget which draws a box.
message FlutterPlaceholder {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The color to draw the placeholder box.
  DartColorType color = 3;
  // The width of the lines in the placeholder box.
  double stroke_width = 4;
  // The width to use when the placeholder is in a situation with an unbounded
  // width.
  //
  // See also:
  //
  //  * [fallbackHeight], the same but vertically.
  double fallback_width = 5;
  // The height to use when the placeholder is in a situation with an unbounded
  // height.
  //
  // See also:
  //
  //  * [fallbackWidth], the same but horizontally.
  double fallback_height = 6;
  // The [child] contained by the placeholder box.
  //
  // Defaults to null.
  WidgetType child = 7;
}

// package:flutter/src/rendering/paragraph.dart
//
// Creates a semantics tag with the input `index`.
//
// Different [PlaceholderSpanIndexSemanticsTag]s with the same `index` are
// consider the same.
message FlutterPlaceholderSpanIndexSemanticsTag {
  // The index of this tag.
  int32 index = 2;
}

// package:flutter/src/services/asset_bundle.dart
message FlutterPlatformAssetBundle {
  
}

// package:flutter/src/widgets/platform_menu_bar.dart
//
// Creates a const [PlatformMenu].
//
// The [label] and [menus] fields are required.
message FlutterPlatformMenu {
  // The required label used for rendering the menu item.
  string label = 2;
  // The menu items in the submenu opened by this menu item.
  //
  // If this is an empty list, this [PlatformMenu] will be disabled.
  repeated FlutterPlatformMenuItemType menus = 5;
}

// package:flutter/src/widgets/platform_menu_bar.dart
//
// Creates a const [PlatformMenuBar].
//
// The [child] and [menus] attributes are required.
message FlutterPlatformMenuBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The list of menu items that are the top level children of the
  // [PlatformMenuBar].
  //
  // The [menus] member contains [PlatformMenuItem]s. They will not be part of
  // the widget tree, since they are not widgets. They are provided to
  // configure the properties of the menus on the platform menu bar.
  //
  // Also, a Widget in Flutter is immutable, so directly modifying the
  // [menus] with `List` APIs such as
  // `somePlatformMenuBarWidget.menus.add(...)` will result in incorrect
  // behaviors. Whenever the menus list is modified, a new list object
  // should be provided.
  repeated FlutterPlatformMenuItemType menus = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/platform_menu_bar.dart
//
// Creates a const [PlatformMenuItem].
//
// The [label] attribute is required.
message FlutterPlatformMenuItem {
  // The required label used for rendering the menu item.
  string label = 2;
  // An optional intent that is invoked when this [PlatformMenuItem] is
  // selected.
  //
  // At most one of [onSelected] and [onSelectedIntent] may be set. If neither
  // field is set, this menu item will be disabled.
  FlutterIntentType on_selected_intent = 5;
}

// package:flutter/src/widgets/platform_menu_bar.dart
//
// Creates a const [PlatformMenuItemGroup].
//
// The [members] field is required.
message FlutterPlatformMenuItemGroup {
  // The [PlatformMenuItem]s that are members of this menu item group.
  //
  // An assertion will be thrown if there isn't at least one member of the group.
  repeated FlutterPlatformMenuItemType members = 2;
}

// package:flutter/src/widgets/platform_menu_bar.dart
//
// Creates a const [PlatformProvidedMenuItem] of the appropriate type. Throws if the
// platform doesn't support the given default menu type.
//
// The [type] argument is required.
message FlutterPlatformProvidedMenuItem {
  // The type of default menu this is.
  //
  // See [PlatformProvidedMenuItemType] for the different types available. Not
  // all of the types will be available on every platform. Use [hasMenu] to
  // determine if the current platform has a given default menu item.
  //
  // If the platform does not support the given [type], then the menu item will
  // throw an [ArgumentError] in debug mode.
  FlutterPlatformProvidedMenuItemTypeType.Enum type = 2;
  // True if this [PlatformProvidedMenuItem] should be enabled or not.
  bool enabled = 3;
}

// package:flutter/src/widgets/router.dart
//
// Create a platform route information provider.
//
// Use the [initialRouteInformation] to set the default route information for this
// provider.
message FlutterPlatformRouteInformationProvider {
  FlutterRouteInformationType initial_route_information = 2;
}

// package:flutter/src/widgets/_platform_selectable_region_context_menu_io.dart
//
// Creates a [PlatformSelectableRegionContextMenu]
message FlutterPlatformSelectableRegionContextMenu {
  WidgetType child = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a platform view layer.
message FlutterPlatformViewLayer {
  // Bounding rectangle of this layer in the global coordinate space.
  DartRectType rect = 2;
  // The unique identifier of the UIView displayed on this layer.
  //
  // A UIView with this identifier must have been created by [PlatformViewsService.initUiKitView].
  int32 view_id = 3;
}

// package:flutter/src/widgets/pop_scope.dart
//
// Creates a widget that registers a callback to veto attempts by the user to
// dismiss the enclosing [ModalRoute].
message FlutterPopScope {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // {@template flutter.widgets.PopScope.canPop}
  // When false, blocks the current route from being popped.
  //
  // This includes the root route, where upon popping, the Flutter app would
  // exit.
  //
  // If multiple [PopScope] widgets appear in a route's widget subtree, then
  // each and every `canPop` must be `true` in order for the route to be
  // able to pop.
  //
  // [Android's predictive back](https://developer.android.com/guide/navigation/predictive-back-gesture)
  // feature will not animate when this boolean is false.
  // {@endtemplate}
  bool can_pop = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that controls where a child of a [Stack] is positioned.
//
// Only two out of the three horizontal values ([left], [right],
// [width]), and only two out of the three vertical values ([top],
// [bottom], [height]), can be set. In each case, at least one of
// the three must be null.
//
// See also:
//
//  * [Positioned.directional], which specifies the widget's horizontal
//    position using `start` and `end` rather than `left` and `right`.
//  * [PositionedDirectional], which is similar to [Positioned.directional]
//    but adapts to the ambient [Directionality].
message FlutterPositioned {
  FlutterKeyType key = 2;
  // The distance that the child's left edge is inset from the left of the stack.
  //
  // Only two out of the three horizontal values ([left], [right], [width]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // horizontally.
  double left = 3;
  // The distance that the child's top edge is inset from the top of the stack.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // vertically.
  double top = 4;
  // The distance that the child's right edge is inset from the right of the stack.
  //
  // Only two out of the three horizontal values ([left], [right], [width]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // horizontally.
  double right = 5;
  // The distance that the child's bottom edge is inset from the bottom of the stack.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // vertically.
  double bottom = 6;
  // The child's width.
  //
  // Only two out of the three horizontal values ([left], [right], [width]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // horizontally.
  double width = 7;
  // The child's height.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // vertically.
  double height = 8;
  WidgetType child = 9;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that controls where a child of a [Stack] is positioned.
//
// Only two out of the three horizontal values (`start`, `end`,
// [width]), and only two out of the three vertical values ([top],
// [bottom], [height]), can be set. In each case, at least one of
// the three must be null.
//
// See also:
//
//  * [Positioned.directional], which also specifies the widget's horizontal
//    position using [start] and [end] but has an explicit [TextDirection].
message FlutterPositionedDirectional {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The distance that the child's leading edge is inset from the leading edge
  // of the stack.
  //
  // Only two out of the three horizontal values ([start], [end], [width]) can be
  // set. The third must be null.
  double start = 3;
  // The distance that the child's top edge is inset from the top of the stack.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can be
  // set. The third must be null.
  double top = 4;
  // The distance that the child's trailing edge is inset from the trailing
  // edge of the stack.
  //
  // Only two out of the three horizontal values ([start], [end], [width]) can be
  // set. The third must be null.
  double end = 5;
  // The distance that the child's bottom edge is inset from the bottom of the stack.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can be
  // set. The third must be null.
  double bottom = 6;
  // The child's width.
  //
  // Only two out of the three horizontal values ([start], [end], [width]) can be
  // set. The third must be null.
  double width = 7;
  // The child's height.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can be
  // set. The third must be null.
  double height = 8;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 9;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that controls where a child of a [Stack] is positioned.
//
// Only two out of the three horizontal values (`start`, `end`,
// [width]), and only two out of the three vertical values ([top],
// [bottom], [height]), can be set. In each case, at least one of
// the three must be null.
//
// If `textDirection` is [TextDirection.rtl], then the `start` argument is
// used for the [right] property and the `end` argument is used for the
// [left] property. Otherwise, if `textDirection` is [TextDirection.ltr],
// then the `start` argument is used for the [left] property and the `end`
// argument is used for the [right] property.
//
// See also:
//
//  * [PositionedDirectional], which adapts to the ambient [Directionality].
message FlutterPositionedNamedDirectional {
  FlutterKeyType key = 2;
  DartTextDirectionType.Enum text_direction = 3;
  double start = 4;
  double top = 5;
  double end = 6;
  double bottom = 7;
  double width = 8;
  double height = 9;
  WidgetType child = 10;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a Positioned object with [left], [top], [right], and [bottom] set
// to 0.0 unless a value for them is passed.
message FlutterPositionedNamedFill {
  FlutterKeyType key = 2;
  // The distance that the child's left edge is inset from the left of the stack.
  //
  // Only two out of the three horizontal values ([left], [right], [width]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // horizontally.
  double left = 3;
  // The distance that the child's top edge is inset from the top of the stack.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // vertically.
  double top = 4;
  // The distance that the child's right edge is inset from the right of the stack.
  //
  // Only two out of the three horizontal values ([left], [right], [width]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // horizontally.
  double right = 5;
  // The distance that the child's bottom edge is inset from the bottom of the stack.
  //
  // Only two out of the three vertical values ([top], [bottom], [height]) can be
  // set. The third must be null.
  //
  // If all three are null, the [Stack.alignment] is used to position the child
  // vertically.
  double bottom = 6;
  WidgetType child = 7;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a Positioned object with the values from the given [Rect].
//
// This sets the [left], [top], [width], and [height] properties
// from the given [Rect]. The [right] and [bottom] properties are
// set to null.
message FlutterPositionedNamedFromRect {
  FlutterKeyType key = 2;
  DartRectType rect = 3;
  WidgetType child = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a Positioned object with the values from the given [RelativeRect].
//
// This sets the [left], [top], [right], and [bottom] properties from the
// given [RelativeRect]. The [height] and [width] properties are set to null.
message FlutterPositionedNamedFromRelativeRect {
  FlutterKeyType key = 2;
  FlutterRelativeRectType rect = 3;
  WidgetType child = 4;
}

// package:flutter/src/widgets/preferred_size.dart
//
// Creates a widget that has a preferred size that the parent can query.
message FlutterPreferredSize {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  DartSizeType preferred_size = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Creates an intent that is used with [PreviousFocusAction].
message FlutterPreviousFocusIntent {
  
}

// package:flutter/src/widgets/primary_scroll_controller.dart
//
// Creates a widget that associates a [ScrollController] with a subtree.
message FlutterPrimaryScrollController {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [ScrollController] associated with the subtree.
  //
  // See also:
  //
  //  * [ScrollView.controller], which discusses the purpose of specifying a
  //    scroll controller.
  FlutterScrollControllerType controller = 3;
  // The [Axis] this controller is configured for [ScrollView]s to
  // automatically inherit.
  //
  // Used in conjunction with [automaticallyInheritForPlatforms]. If the
  // current [TargetPlatform] is not included in
  // [automaticallyInheritForPlatforms], this is ignored.
  //
  // When null, no [ScrollView] in any Axis will automatically inherit this
  // controller. This is dissimilar to [PrimaryScrollController.none]. When a
  // PrimaryScrollController is inherited, ScrollView will insert
  // PrimaryScrollController.none into the tree to prevent further descendant
  // ScrollViews from inheriting the current PrimaryScrollController.
  //
  // For the direction in which active scrolling may be occurring, see
  // [ScrollDirection].
  //
  // Defaults to [Axis.vertical].
  FlutterAxisType.Enum scroll_direction = 5;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 6;
}

// package:flutter/src/widgets/primary_scroll_controller.dart
//
// Creates a subtree without an associated [ScrollController].
message FlutterPrimaryScrollControllerNamedNone {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 3;
}

// package:flutter/src/widgets/actions.dart
//
// Creates an intent that is used with [PrioritizedAction] to specify a list
// of intents, the first available of which will be used.
message FlutterPrioritizedIntents {
  // List of intents to be evaluated in order for execution. When an
  // [Action.isEnabled] returns true, that action will be invoked and
  // progression through the ordered intents stops.
  repeated FlutterIntentType ordered_intents = 2;
}

// package:flutter_project/main.dart
message FlutterProjectMyApp {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
}

// package:flutter_project/main.dart
message FlutterProjectMyHomePage {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  string title = 3;
}

// package:flutter/src/painting/gradient.dart
//
// Creates a radial gradient.
//
// If [stops] is non-null, it must have the same length as [colors].
message FlutterRadialGradient {
  // The center of the gradient, as an offset into the (-1.0, -1.0) x (1.0, 1.0)
  // square describing the gradient which will be mapped onto the paint box.
  //
  // For example, an alignment of (0.0, 0.0) will place the radial
  // gradient in the center of the box.
  //
  // If this is an [Alignment], then it is expressed as a vector from
  // coordinate (0.0, 0.0), in a coordinate space that maps the center of the
  // paint box at (0.0, 0.0) and the bottom right at (1.0, 1.0).
  //
  // It can also be an [AlignmentDirectional], where the start is the left in
  // left-to-right contexts and the right in right-to-left contexts. If a
  // text-direction-dependent value is provided here, then the [createShader]
  // method will need to be given a [TextDirection].
  FlutterAlignmentGeometryType center = 2;
  // The radius of the gradient, as a fraction of the shortest side
  // of the paint box.
  //
  // For example, if a radial gradient is painted on a box that is
  // 100.0 pixels wide and 200.0 pixels tall, then a radius of 1.0
  // will place the 1.0 stop at 100.0 pixels from the [center].
  double radius = 3;
  // The colors the gradient should obtain at each of the stops.
  //
  // If [stops] is non-null, this list must have the same length as [stops].
  //
  // This list must have at least two colors in it (otherwise, it's not a
  // gradient!).
  repeated DartColorType colors = 4;
  // A list of values from 0.0 to 1.0 that denote fractions along the gradient.
  //
  // If non-null, this list must have the same length as [colors].
  //
  // If the first value is not 0.0, then a stop with position 0.0 and a color
  // equal to the first color in [colors] is implied.
  //
  // If the last value is not 1.0, then a stop with position 1.0 and a color
  // equal to the last color in [colors] is implied.
  //
  // The values in the [stops] list must be in ascending order. If a value in
  // the [stops] list is less than an earlier value in the list, then its value
  // is assumed to equal the previous value.
  //
  // If stops is null, then a set of uniformly distributed stops is implied,
  // with the first stop at 0.0 and the last stop at 1.0.
  repeated double stops = 5;
  // How this gradient should tile the plane beyond the outer ring at [radius]
  // pixels from the [center].
  //
  // For details, see [TileMode].
  //
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
  //
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radialWithFocal.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radialWithFocal.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radialWithFocal.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radialWithFocal.png)
  DartTileModeType.Enum tile_mode = 6;
  // The focal point of the gradient. If specified, the gradient will appear
  // to be focused along the vector from [center] to focal.
  //
  // See [center] for a description of how the coordinates are mapped.
  //
  // If this value is specified and [focalRadius] > 0.0, care should be taken
  // to ensure that either this value or [center] will not both resolve to
  // [Offset.zero], which would fail to create a valid gradient.
  FlutterAlignmentGeometryType focal = 7;
  // The radius of the focal point of gradient, as a fraction of the shortest
  // side of the paint box.
  //
  // For example, if a radial gradient is painted on a box that is
  // 100.0 pixels wide and 200.0 pixels tall, then a radius of 1.0
  // will place the 1.0 stop at 100.0 pixels from the [focal] point.
  //
  // If this value is specified and is greater than 0.0, either [focal] or
  // [center] must not resolve to [Offset.zero], which would fail to create
  // a valid gradient.
  double focal_radius = 8;
  // The transform, if any, to apply to the gradient.
  //
  // This transform is in addition to any other transformations applied to the
  // canvas, but does not add any transformations to the canvas.
  FlutterGradientTransformType transform = 9;
}

// package:flutter/src/widgets/scroll_physics.dart
//
// Creates scroll physics that maintain the scroll position in range.
message FlutterRangeMaintainingScrollPhysics {
  // If non-null, determines the default behavior for each method.
  //
  // If a subclass of [ScrollPhysics] does not override a method, that subclass
  // will inherit an implementation from this base class that defers to
  // [parent]. This mechanism lets you assemble novel combinations of
  // [ScrollPhysics] subclasses at runtime. For example:
  //
  // ```dart
  // const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
  // ```
  //
  // will result in a [ScrollPhysics] that has the combined behavior
  // of [BouncingScrollPhysics] and [AlwaysScrollableScrollPhysics]:
  // behaviors that are not specified in [BouncingScrollPhysics]
  // (e.g. [shouldAcceptUserOffset]) will defer to [AlwaysScrollableScrollPhysics].
  FlutterScrollPhysicsType parent = 2;
}

// package:flutter/src/widgets/gesture_detector.dart
//
// Creates a widget that detects gestures.
//
// Gesture detectors can contribute semantic information to the tree that is
// used by assistive technology. The behavior can be configured by
// [semantics], or disabled with [excludeFromSemantics].
message FlutterRawGestureDetector {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // How this gesture detector should behave during hit testing.
  //
  // This defaults to [HitTestBehavior.deferToChild] if [child] is not null and
  // [HitTestBehavior.translucent] if child is null.
  FlutterHitTestBehaviorType.Enum behavior = 5;
  // Whether to exclude these gestures from the semantics tree. For
  // example, the long-press gesture for showing a tooltip is
  // excluded because the tooltip itself is included in the semantics
  // tree directly and so having a gesture to show it would result in
  // duplication of information.
  bool exclude_from_semantics = 6;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that displays an image.
//
// The [scale], [alignment], [repeat], [matchTextDirection] and [filterQuality] arguments must
// not be null.
message FlutterRawImage {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // A string identifying the source of the image.
  string debug_image_label = 4;
  // If non-null, require the image to have this width.
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  double width = 5;
  // If non-null, require the image to have this height.
  //
  // If null, the image will pick a size that best preserves its intrinsic
  // aspect ratio.
  double height = 6;
  // Specifies the image's scale.
  //
  // Used when determining the best display size for the image.
  double scale = 7;
  // If non-null, this color is blended with each image pixel using [colorBlendMode].
  DartColorType color = 8;
  // Used to combine [color] with this image.
  //
  // The default is [BlendMode.srcIn]. In terms of the blend mode, [color] is
  // the source and this image is the destination.
  //
  // See also:
  //
  //  * [BlendMode], which includes an illustration of the effect of each blend mode.
  DartBlendModeType.Enum color_blend_mode = 10;
  // How to inscribe the image into the space allocated during layout.
  //
  // The default varies based on the other fields. See the discussion at
  // [paintImage].
  FlutterBoxFitType.Enum fit = 11;
  // How to align the image within its bounds.
  //
  // The alignment aligns the given position in the image to the given position
  // in the layout bounds. For example, an [Alignment] alignment of (-1.0,
  // -1.0) aligns the image to the top-left corner of its layout bounds, while a
  // [Alignment] alignment of (1.0, 1.0) aligns the bottom right of the
  // image with the bottom right corner of its layout bounds. Similarly, an
  // alignment of (0.0, 1.0) aligns the bottom middle of the image with the
  // middle of the bottom edge of its layout bounds.
  //
  // To display a subpart of an image, consider using a [CustomPainter] and
  // [Canvas.drawImageRect].
  //
  // If the [alignment] is [TextDirection]-dependent (i.e. if it is a
  // [AlignmentDirectional]), then an ambient [Directionality] widget
  // must be in scope.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 12;
  // How to paint any portions of the layout bounds not covered by the image.
  FlutterImageRepeatType.Enum repeat = 13;
  // The center slice for a nine-patch image.
  //
  // The region of the image inside the center slice will be stretched both
  // horizontally and vertically to fit the image into its destination. The
  // region of the image above and below the center slice will be stretched
  // only horizontally and the region of the image to the left and right of
  // the center slice will be stretched only vertically.
  DartRectType center_slice = 14;
  // Whether to paint the image in the direction of the [TextDirection].
  //
  // If this is true, then in [TextDirection.ltr] contexts, the image will be
  // drawn with its origin in the top left (the "normal" painting direction for
  // images); and in [TextDirection.rtl] contexts, the image will be drawn with
  // a scaling factor of -1 in the horizontal direction so that the origin is
  // in the top right.
  //
  // This is occasionally used with images in right-to-left environments, for
  // images that were designed for left-to-right locales. Be careful, when
  // using this, to not flip images with integral shadows, text, or other
  // effects that will look incorrect when flipped.
  //
  // If this is true, there must be an ambient [Directionality] widget in
  // scope.
  bool match_text_direction = 15;
  // Whether the colors of the image are inverted when drawn.
  //
  // Inverting the colors of an image applies a new color filter to the paint.
  // If there is another specified color filter, the invert will be applied
  // after it. This is primarily used for implementing smart invert on iOS.
  //
  // See also:
  //
  //  * [Paint.invertColors], for the dart:ui implementation.
  bool invert_colors = 16;
  // Used to set the filterQuality of the image.
  //
  // Defaults to [FilterQuality.low] to scale the image, which corresponds to
  // bilinear interpolation.
  DartFilterQualityType.Enum filter_quality = 17;
  // Whether to paint the image with anti-aliasing.
  //
  // Anti-aliasing alleviates the sawtooth artifact when the image is rotated.
  bool is_anti_alias = 18;
}

// package:flutter/src/widgets/magnifier.dart
//
// Constructs a [RawMagnifier].
//
// {@template flutter.widgets.magnifier.RawMagnifier.invisibility_warning}
// By default, this magnifier uses the default [MagnifierDecoration],
// the focal point is directly under the magnifier, and there is no magnification:
// This means that a default magnifier will be entirely invisible to the naked eye,
// since it is painting exactly what is under it, exactly where it was painted
// originally.
// {@endtemplate}
message FlutterRawMagnifier {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // An optional widget to position inside the len of the [RawMagnifier].
  //
  // This is positioned over the [RawMagnifier] - it may be useful for tinting the
  // [RawMagnifier], or drawing a crosshair like UI.
  WidgetType child = 3;
  // This magnifier's decoration.
  //
  // {@macro flutter.widgets.magnifier.RawMagnifier.invisibility_warning}
  FlutterMagnifierDecorationType decoration = 4;
  // The offset of the magnifier from [RawMagnifier]'s center.
  //
  // {@template flutter.widgets.magnifier.offset}
  // For example, if [RawMagnifier] is globally positioned at Offset(100, 100),
  // and [focalPointOffset] is Offset(-20, -20), then [RawMagnifier] will see
  // the content at global offset (80, 80).
  //
  // If left as [Offset.zero], the [RawMagnifier] will show the content that
  // is directly below it.
  // {@endtemplate}
  DartOffsetType focal_point_offset = 5;
  // How "zoomed in" the magnification subject is in the lens.
  double magnification_scale = 6;
  // The size of the magnifier.
  //
  // This does not include added border; it only includes
  // the size of the magnifier.
  DartSizeType size = 7;
}

// package:flutter/src/widgets/scrollbar.dart
//
// Creates a basic raw scrollbar that wraps the given [child].
//
// The [child], or a descendant of the [child], should be a source of
// [ScrollNotification] notifications, typically a [Scrollable] widget.
message FlutterRawScrollbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.Scrollbar.child}
  // The widget below this widget in the tree.
  //
  // The scrollbar will be stacked on top of this child. This child (and its
  // subtree) should include a source of [ScrollNotification] notifications.
  // Typically a [Scrollbar] is created on desktop platforms by a
  // [ScrollBehavior.buildScrollbar] method, in which case the child is usually
  // the one provided as an argument to that method.
  //
  // Typically a [ListView] or [CustomScrollView].
  // {@endtemplate}
  WidgetType child = 3;
  // {@template flutter.widgets.Scrollbar.controller}
  // The [ScrollController] used to implement Scrollbar dragging.
  //
  // If nothing is passed to controller, the default behavior is to automatically
  // enable scrollbar dragging on the nearest ScrollController using
  // [PrimaryScrollController.of].
  //
  // If a ScrollController is passed, then dragging on the scrollbar thumb will
  // update the [ScrollPosition] attached to the controller. A stateful ancestor
  // of this widget needs to manage the ScrollController and either pass it to
  // a scrollable descendant or use a PrimaryScrollController to share it.
  //
  // {@tool snippet}
  // Here is an example of using the [controller] attribute to enable
  // scrollbar dragging for multiple independent ListViews:
  //
  // ```dart
  // // (e.g. in a stateful widget)
  //
  // final ScrollController controllerOne = ScrollController();
  // final ScrollController controllerTwo = ScrollController();
  //
  // @override
  // Widget build(BuildContext context) {
  //   return Column(
  //     children: <Widget>[
  //       SizedBox(
  //        height: 200,
  //        child: CupertinoScrollbar(
  //          controller: controllerOne,
  //          child: ListView.builder(
  //            controller: controllerOne,
  //            itemCount: 120,
  //            itemBuilder: (BuildContext context, int index) => Text('item $index'),
  //          ),
  //        ),
  //      ),
  //      SizedBox(
  //        height: 200,
  //        child: CupertinoScrollbar(
  //          controller: controllerTwo,
  //          child: ListView.builder(
  //            controller: controllerTwo,
  //            itemCount: 120,
  //            itemBuilder: (BuildContext context, int index) => Text('list 2 item $index'),
  //          ),
  //        ),
  //      ),
  //    ],
  //   );
  // }
  // ```
  // {@end-tool}
  // {@endtemplate}
  FlutterScrollControllerType controller = 4;
  // {@template flutter.widgets.Scrollbar.thumbVisibility}
  // Indicates that the scrollbar thumb should be visible, even when a scroll
  // is not underway.
  //
  // When false, the scrollbar will be shown during scrolling
  // and will fade out otherwise.
  //
  // When true, the scrollbar will always be visible and never fade out. This
  // requires that the Scrollbar can access the [ScrollController] of the
  // associated Scrollable widget. This can either be the provided [controller],
  // or the [PrimaryScrollController] of the current context.
  //
  //   * When providing a controller, the same ScrollController must also be
  //     provided to the associated Scrollable widget.
  //   * The [PrimaryScrollController] is used by default for a [ScrollView]
  //     that has not been provided a [ScrollController] and that has a
  //     [ScrollView.scrollDirection] of [Axis.vertical]. This automatic
  //     behavior does not apply to those with [Axis.horizontal]. To explicitly
  //     use the PrimaryScrollController, set [ScrollView.primary] to true.
  //
  // Defaults to false when null.
  //
  // {@tool snippet}
  //
  // ```dart
  // // (e.g. in a stateful widget)
  //
  // final ScrollController controllerOne = ScrollController();
  // final ScrollController controllerTwo = ScrollController();
  //
  // @override
  // Widget build(BuildContext context) {
  // return Column(
  //   children: <Widget>[
  //     SizedBox(
  //        height: 200,
  //        child: Scrollbar(
  //          thumbVisibility: true,
  //          controller: controllerOne,
  //          child: ListView.builder(
  //            controller: controllerOne,
  //            itemCount: 120,
  //            itemBuilder: (BuildContext context, int index) {
  //              return Text('item $index');
  //            },
  //          ),
  //        ),
  //      ),
  //      SizedBox(
  //        height: 200,
  //        child: CupertinoScrollbar(
  //          thumbVisibility: true,
  //          controller: controllerTwo,
  //          child: SingleChildScrollView(
  //            controller: controllerTwo,
  //            child: const SizedBox(
  //              height: 2000,
  //              width: 500,
  //              child: Placeholder(),
  //            ),
  //          ),
  //        ),
  //      ),
  //    ],
  //   );
  // }
  // ```
  // {@end-tool}
  //
  // See also:
  //
  //   * [RawScrollbarState.showScrollbar], an overridable getter which uses
  //     this value to override the default behavior.
  //   * [ScrollView.primary], which indicates whether the ScrollView is the primary
  //     scroll view associated with the parent [PrimaryScrollController].
  //   * [PrimaryScrollController], which associates a [ScrollController] with
  //     a subtree.
  // {@endtemplate}
  //
  // Subclass [Scrollbar] can hide and show the scrollbar thumb in response to
  // [MaterialState]s by using [ScrollbarThemeData.thumbVisibility].
  bool thumb_visibility = 5;
  // The [OutlinedBorder] of the scrollbar's thumb.
  //
  // Only one of [radius] and [shape] may be specified. For a rounded rectangle,
  // it's simplest to just specify [radius]. By default, the scrollbar thumb's
  // shape is a simple rectangle.
  //
  // If [shape] is specified, the thumb will take the shape of the passed
  // [OutlinedBorder] and fill itself with [thumbColor] (or grey if it
  // is unspecified).
  //
  // {@tool dartpad}
  // This is an example of using a [StadiumBorder] for drawing the [shape] of the
  // thumb in a [RawScrollbar].
  //
  // ** See code in examples/api/lib/widgets/scrollbar/raw_scrollbar.shape.0.dart **
  // {@end-tool}
  FlutterOutlinedBorderType shape = 6;
  // The [Radius] of the scrollbar thumb's rounded rectangle corners.
  //
  // Scrollbar will be rectangular if [radius] is null, which is the default
  // behavior.
  DartRadiusType radius = 7;
  // The thickness of the scrollbar in the cross axis of the scrollable.
  //
  // If null, will default to 6.0 pixels.
  double thickness = 8;
  // The color of the scrollbar thumb.
  //
  // If null, defaults to Color(0x66BCBCBC).
  DartColorType thumb_color = 9;
  // The preferred smallest size the scrollbar thumb can shrink to when the total
  // scrollable extent is large, the current visible viewport is small, and the
  // viewport is not overscrolled.
  //
  // The size of the scrollbar's thumb may shrink to a smaller size than [minThumbLength]
  // to fit in the available paint area (e.g., when [minThumbLength] is greater
  // than [ScrollMetrics.viewportDimension] and [mainAxisMargin] combined).
  //
  // Mustn't be null and the value has to be greater or equal to
  // [minOverscrollLength], which in turn is >= 0. Defaults to 18.0.
  double min_thumb_length = 10;
  // The preferred smallest size the scrollbar thumb can shrink to when viewport is
  // overscrolled.
  //
  // When overscrolling, the size of the scrollbar's thumb may shrink to a smaller size
  // than [minOverscrollLength] to fit in the available paint area (e.g., when
  // [minOverscrollLength] is greater than [ScrollMetrics.viewportDimension] and
  // [mainAxisMargin] combined).
  //
  // Overscrolling can be made possible by setting the `physics` property
  // of the `child` Widget to a `BouncingScrollPhysics`, which is a special
  // `ScrollPhysics` that allows overscrolling.
  //
  // The value is less than or equal to [minThumbLength] and greater than or equal to 0.
  // When null, it will default to the value of [minThumbLength].
  double min_overscroll_length = 11;
  // {@template flutter.widgets.Scrollbar.trackVisibility}
  // Indicates that the scrollbar track should be visible.
  //
  // When true, the scrollbar track will always be visible so long as the thumb
  // is visible. If the scrollbar thumb is not visible, the track will not be
  // visible either.
  //
  // Defaults to false when null.
  // {@endtemplate}
  //
  // Subclass [Scrollbar] can hide and show the scrollbar thumb in response to
  // [MaterialState]s by using [ScrollbarThemeData.trackVisibility].
  bool track_visibility = 12;
  // The [Radius] of the scrollbar track's rounded rectangle corners.
  //
  // Scrollbar's track will be rectangular if [trackRadius] is null, which is
  // the default behavior.
  DartRadiusType track_radius = 13;
  // The color of the scrollbar track.
  //
  // The scrollbar track will only be visible when [trackVisibility] and
  // [thumbVisibility] are true.
  //
  // If null, defaults to Color(0x08000000).
  DartColorType track_color = 14;
  // The color of the scrollbar track's border.
  //
  // The scrollbar track will only be visible when [trackVisibility] and
  // [thumbVisibility] are true.
  //
  // If null, defaults to Color(0x1a000000).
  DartColorType track_border_color = 15;
  // The [Duration] of the fade animation.
  //
  // Defaults to a [Duration] of 300 milliseconds.
  DartDurationType fade_duration = 16;
  // The [Duration] of time until the fade animation begins.
  //
  // Defaults to a [Duration] of 600 milliseconds.
  DartDurationType time_to_fade = 17;
  // The [Duration] of time that a LongPress will trigger the drag gesture of
  // the scrollbar thumb.
  //
  // Defaults to [Duration.zero].
  DartDurationType press_duration = 18;
  // {@template flutter.widgets.Scrollbar.interactive}
  // Whether the Scrollbar should be interactive and respond to dragging on the
  // thumb, or tapping in the track area.
  //
  // Does not apply to the [CupertinoScrollbar], which is always interactive to
  // match native behavior. On Android, the scrollbar is not interactive by
  // default.
  //
  // When false, the scrollbar will not respond to gesture or hover events,
  // and will allow to click through it.
  //
  // Defaults to true when null, unless on Android, which will default to false
  // when null.
  //
  // See also:
  //
  //   * [RawScrollbarState.enableGestures], an overridable getter which uses
  //     this value to override the default behavior.
  // {@endtemplate}
  bool interactive = 20;
  // {@macro flutter.widgets.Scrollbar.scrollbarOrientation}
  FlutterScrollbarOrientationType.Enum scrollbar_orientation = 21;
  // Distance from the scrollbar thumb's start or end to the nearest edge of
  // the viewport in logical pixels. It affects the amount of available
  // paint area.
  //
  // The scrollbar track consumes this space.
  //
  // Mustn't be null and defaults to 0.
  double main_axis_margin = 22;
  // Distance from the scrollbar thumb's side to the nearest cross axis edge
  // in logical pixels.
  //
  // The scrollbar track consumes this space.
  //
  // Defaults to zero.
  double cross_axis_margin = 23;
  // The insets by which the scrollbar thumb and track should be padded.
  //
  // When null, the inherited [MediaQueryData.padding] is used.
  //
  // Defaults to null.
  FlutterEdgeInsetsType padding = 24;
}

// package:flutter/src/widgets/scrollbar.dart
message FlutterRawScrollbarState {
  
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Constructs a traversal policy that orders the widgets in "reading order".
//
// {@macro flutter.widgets.FocusTraversalPolicy.requestFocusCallback}
message FlutterReadingOrderTraversalPolicy {
  
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates a [RedoTextIntent].
message FlutterRedoTextIntent {
  // {@macro flutter.widgets.TextEditingIntents.cause}
  FlutterSelectionChangedCauseType.Enum cause = 2;
}

// package:flutter/src/rendering/stack.dart
//
// Creates a RelativeRect from horizontal position using `start` and `end`
// rather than `left` and `right`.
//
// If `textDirection` is [TextDirection.rtl], then the `start` argument is
// used for the [right] property and the `end` argument is used for the
// [left] property. Otherwise, if `textDirection` is [TextDirection.ltr],
// then the `start` argument is used for the [left] property and the `end`
// argument is used for the [right] property.
message FlutterRelativeRectNamedFromDirectional {
  DartTextDirectionType.Enum text_direction = 2;
  double start = 3;
  double top = 4;
  double end = 5;
  double bottom = 6;
}

// package:flutter/src/rendering/stack.dart
//
// Creates a RelativeRect with the given values.
message FlutterRelativeRectNamedFromLTRB {
  // Distance from the left side of the container to the left side of this rectangle.
  //
  // May be negative if the left side of the rectangle is outside of the container.
  double left = 2;
  // Distance from the top side of the container to the top side of this rectangle.
  //
  // May be negative if the top side of the rectangle is outside of the container.
  double top = 3;
  // Distance from the right side of the container to the right side of this rectangle.
  //
  // May be positive if the right side of the rectangle is outside of the container.
  double right = 4;
  // Distance from the bottom side of the container to the bottom side of this rectangle.
  //
  // May be positive if the bottom side of the rectangle is outside of the container.
  double bottom = 5;
}

// package:flutter/src/rendering/stack.dart
//
// Creates a RelativeRect from two Rects. The second Rect provides the
// container, the first provides the rectangle, in the same coordinate space,
// that is to be converted to a RelativeRect. The output will be in the
// container's coordinate space.
//
// For example, if the top left of the rect is at 0,0, and the top left of
// the container is at 100,100, then the top left of the output will be at
// -100,-100.
//
// If the first rect is actually in the container's coordinate space, then
// use [RelativeRect.fromSize] and pass the container's size as the second
// argument instead.
message FlutterRelativeRectNamedFromRect {
  DartRectType rect = 2;
  DartRectType container = 3;
}

// package:flutter/src/rendering/stack.dart
//
// Creates a RelativeRect from a Rect and a Size. The Rect (first argument)
// and the RelativeRect (the output) are in the coordinate space of the
// rectangle described by the Size, with 0,0 being at the top left.
message FlutterRelativeRectNamedFromSize {
  DartRectType rect = 2;
  DartSizeType container = 3;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that absorbs pointers during hit testing.
message FlutterRenderAbsorbPointer {
  FlutterRenderBoxType child = 2;
  bool absorbing = 3;
}

// package:flutter/src/rendering/animated_size.dart
//
// Creates a render object that animates its size to match its child.
// The [duration] and [curve] arguments define the animation.
//
// The [alignment] argument is used to align the child when the parent is not
// (yet) the same size as the child.
//
// The [duration] is required.
//
// The [vsync] should specify a [TickerProvider] for the animation
// controller.
//
// The arguments [duration], [curve], [alignment], and [vsync] must
// not be null.
message FlutterRenderAnimatedSize {
  FlutterSrcSchedulerTickerProviderType vsync = 2;
  DartDurationType duration = 3;
  DartDurationType reverse_duration = 4;
  FlutterSrcAnimationCurveType curve = 5;
  FlutterAlignmentGeometryType alignment = 6;
  DartTextDirectionType.Enum text_direction = 7;
  FlutterRenderBoxType child = 8;
  DartClipType.Enum clip_behavior = 9;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates as render object with a specific aspect ratio.
//
// The [aspectRatio] argument must be a finite, positive value.
message FlutterRenderAspectRatio {
  FlutterRenderBoxType child = 2;
  double aspect_ratio = 3;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a backdrop filter.
// The [blendMode] argument defaults to [BlendMode.srcOver].
message FlutterRenderBackdropFilter {
  FlutterRenderBoxType child = 2;
  DartImageFilterType filter = 3;
  DartBlendModeType.Enum blend_mode = 4;
}

// package:flutter/src/rendering/shifted_box.dart
//
// Creates a [RenderBaseline] object.
message FlutterRenderBaseline {
  FlutterRenderBoxType child = 2;
  double baseline = 3;
  DartTextBaselineType.Enum baseline_type = 4;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Create a render object that blocks semantics for nodes below it in paint
// order.
message FlutterRenderBlockSemantics {
  FlutterRenderBoxType child = 2;
  bool blocking = 3;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates an oval-shaped clip.
//
// If [clipper] is null, the oval will be inscribed into the layout size and
// position of the child.
//
// If [clipBehavior] is [Clip.none], no clipping will be applied.
message FlutterRenderClipOval {
  FlutterRenderBoxType child = 2;
  DartClipType.Enum clip_behavior = 4;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a path clip.
//
// If [clipper] is null, the clip will be a rectangle that matches the layout
// size and location of the child. However, rather than use this default,
// consider using a [RenderClipRect], which can achieve the same effect more
// efficiently.
//
// If [clipBehavior] is [Clip.none], no clipping will be applied.
message FlutterRenderClipPath {
  FlutterRenderBoxType child = 2;
  DartClipType.Enum clip_behavior = 4;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a rounded-rectangular clip.
//
// The [borderRadius] defaults to [BorderRadius.zero], i.e. a rectangle with
// right-angled corners.
//
// If [clipper] is non-null, then [borderRadius] is ignored.
//
// If [clipBehavior] is [Clip.none], no clipping will be applied.
message FlutterRenderClipRRect {
  FlutterRenderBoxType child = 2;
  FlutterBorderRadiusGeometryType border_radius = 3;
  DartClipType.Enum clip_behavior = 5;
  DartTextDirectionType.Enum text_direction = 6;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a rectangular clip.
//
// If [clipper] is null, the clip will match the layout size and position of
// the child.
//
// If [clipBehavior] is [Clip.none], no clipping will be applied.
message FlutterRenderClipRect {
  FlutterRenderBoxType child = 2;
  DartClipType.Enum clip_behavior = 4;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render box that constrains its child.
//
// The [additionalConstraints] argument must be valid.
message FlutterRenderConstrainedBox {
  FlutterRenderBoxType child = 2;
  FlutterBoxConstraintsType additional_constraints = 3;
}

// package:flutter/src/rendering/shifted_box.dart
//
// Creates a render object that lets its child overflow itself.
message FlutterRenderConstrainedOverflowBox {
  FlutterRenderBoxType child = 2;
  double min_width = 3;
  double max_width = 4;
  double min_height = 5;
  double max_height = 6;
  FlutterOverflowBoxFitType.Enum fit = 7;
  FlutterAlignmentGeometryType alignment = 8;
  DartTextDirectionType.Enum text_direction = 9;
}

// package:flutter/src/rendering/custom_layout.dart
//
// Creates a render object that customizes the layout of multiple children.
message FlutterRenderCustomMultiChildLayoutBox {
  repeated FlutterRenderBoxType children = 2;
}

// package:flutter/src/rendering/custom_paint.dart
//
// Creates a render object that delegates its painting.
message FlutterRenderCustomPaint {
  FlutterCustomPainterType painter = 2;
  FlutterCustomPainterType foreground_painter = 3;
  DartSizeType preferred_size = 4;
  // Whether to hint that this layer's painting should be cached.
  //
  // The compositor contains a raster cache that holds bitmaps of layers in
  // order to avoid the cost of repeatedly rendering those layers on each
  // frame. If this flag is not set, then the compositor will apply its own
  // heuristics to decide whether the layer containing this render object is
  // complex enough to benefit from caching.
  bool is_complex = 5;
  // Whether the raster cache should be told that this painting is likely
  // to change in the next frame.
  //
  // This hint tells the compositor not to cache the layer containing this
  // render object because the cache will not be used in the future. If this
  // hint is not set, the compositor will apply its own heuristics to decide
  // whether this layer is likely to be reused in the future.
  bool will_change = 6;
  FlutterRenderBoxType child = 7;
}

// package:flutter/src/rendering/shifted_box.dart
//
// Creates a render box that defers its layout to a delegate.
//
// The [delegate] argument must not be null.
message FlutterRenderCustomSingleChildLayoutBox {
  FlutterRenderBoxType child = 2;
  FlutterSingleChildLayoutDelegateType delegate = 3;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a decorated box.
//
// The [decoration], [position], and [configuration] arguments must not be
// null. By default the decoration paints behind the child.
//
// The [ImageConfiguration] will be passed to the decoration (with the size
// filled in) to let it resolve images.
message FlutterRenderDecoratedBox {
  FlutterDecorationType decoration = 2;
  FlutterDecorationPositionType.Enum position = 3;
  FlutterImageConfigurationType configuration = 4;
  FlutterRenderBoxType child = 5;
}

// package:flutter/src/rendering/decorated_sliver.dart
//
// Creates a decorated sliver.
//
// The [decoration], [position], and [configuration] arguments must not be
// null. By default the decoration paints behind the child.
//
// The [ImageConfiguration] will be passed to the decoration (with the size
// filled in) to let it resolve images.
message FlutterRenderDecoratedSliver {
  FlutterDecorationType decoration = 2;
  FlutterDecorationPositionType.Enum position = 3;
  FlutterImageConfigurationType configuration = 4;
}

// package:flutter/src/rendering/error.dart
//
// Creates a RenderErrorBox render object.
//
// A message can optionally be provided. If a message is provided, an attempt
// will be made to render the message when the box paints.
message FlutterRenderErrorBox {
  // The message to attempt to display at paint time.
  string message = 2;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that ignores the semantics of its subtree.
message FlutterRenderExcludeSemantics {
  FlutterRenderBoxType child = 2;
  bool excluding = 3;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Scales and positions its child within itself.
message FlutterRenderFittedBox {
  FlutterBoxFitType.Enum fit = 2;
  FlutterAlignmentGeometryType alignment = 3;
  DartTextDirectionType.Enum text_direction = 4;
  FlutterRenderBoxType child = 5;
  DartClipType.Enum clip_behavior = 6;
}

// package:flutter/src/rendering/flex.dart
//
// Creates a flex render object.
//
// By default, the flex layout is horizontal and children are aligned to the
// start of the main axis and the center of the cross axis.
message FlutterRenderFlex {
  repeated FlutterRenderBoxType children = 2;
  FlutterAxisType.Enum direction = 3;
  FlutterMainAxisSizeType.Enum main_axis_size = 4;
  FlutterMainAxisAlignmentType.Enum main_axis_alignment = 5;
  FlutterCrossAxisAlignmentType.Enum cross_axis_alignment = 6;
  DartTextDirectionType.Enum text_direction = 7;
  FlutterVerticalDirectionType.Enum vertical_direction = 8;
  DartTextBaselineType.Enum text_baseline = 9;
  DartClipType.Enum clip_behavior = 10;
}

// package:flutter/src/rendering/flow.dart
//
// Creates a render object for a flow layout.
//
// For optimal performance, consider using children that return true from
// [isRepaintBoundary].
message FlutterRenderFlow {
  repeated FlutterRenderBoxType children = 2;
  DartClipType.Enum clip_behavior = 4;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that uses a [FollowerLayer].
message FlutterRenderFollowerLayer {
  FlutterLayerLinkType link = 2;
  bool show_when_unlinked = 3;
  DartOffsetType offset = 4;
  FlutterAlignmentType leader_anchor = 5;
  FlutterAlignmentType follower_anchor = 6;
  FlutterRenderBoxType child = 7;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that translates its child's painting.
message FlutterRenderFractionalTranslation {
  DartOffsetType translation = 2;
  // When set to true, hit tests are performed based on the position of the
  // child as it is painted. When set to false, hit tests are performed
  // ignoring the transformation.
  //
  // applyPaintTransform(), and therefore localToGlobal() and globalToLocal(),
  // always honor the transformation, regardless of the value of this property.
  bool transform_hit_tests = 3;
  FlutterRenderBoxType child = 4;
}

// package:flutter/src/rendering/shifted_box.dart
//
// Creates a render box that sizes its child to a fraction of the total available space.
//
// If non-null, the [widthFactor] and [heightFactor] arguments must be
// non-negative.
//
// The [textDirection] must be non-null if the [alignment] is
// direction-sensitive.
message FlutterRenderFractionallySizedOverflowBox {
  FlutterRenderBoxType child = 2;
  double width_factor = 3;
  double height_factor = 4;
  FlutterAlignmentGeometryType alignment = 5;
  DartTextDirectionType.Enum text_direction = 6;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Create a render object that causes the parent to ignore the child for baseline computations.
message FlutterRenderIgnoreBaseline {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that is invisible to hit testing.
message FlutterRenderIgnorePointer {
  FlutterRenderBoxType child = 2;
  bool ignoring = 3;
}

// package:flutter/src/rendering/image.dart
//
// Creates a render box that displays an image.
//
// The [textDirection] argument must not be null if [alignment] will need
// resolving or if [matchTextDirection] is true.
message FlutterRenderImage {
  // A string used to identify the source of the image.
  string debug_image_label = 3;
  double width = 4;
  double height = 5;
  double scale = 6;
  DartColorType color = 7;
  DartBlendModeType.Enum color_blend_mode = 9;
  FlutterBoxFitType.Enum fit = 10;
  FlutterAlignmentGeometryType alignment = 11;
  FlutterImageRepeatType.Enum repeat = 12;
  DartRectType center_slice = 13;
  bool match_text_direction = 14;
  DartTextDirectionType.Enum text_direction = 15;
  bool invert_colors = 16;
  bool is_anti_alias = 17;
  DartFilterQualityType.Enum filter_quality = 18;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that annotates the child semantics with an index.
message FlutterRenderIndexedSemantics {
  FlutterRenderBoxType child = 2;
  int32 index = 3;
}

// package:flutter/src/rendering/stack.dart
//
// Creates a stack render object that paints a single child.
//
// If the [index] parameter is null, nothing is displayed.
message FlutterRenderIndexedStack {
  repeated FlutterRenderBoxType children = 2;
  FlutterAlignmentGeometryType alignment = 3;
  DartTextDirectionType.Enum text_direction = 4;
  FlutterStackFitType.Enum fit = 5;
  DartClipType.Enum clip_behavior = 6;
  int32 index = 7;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that sizes itself to its child's intrinsic height.
message FlutterRenderIntrinsicHeight {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that sizes itself to its child's intrinsic width.
//
// If [stepWidth] is non-null it must be > 0.0. Similarly If [stepHeight] is
// non-null it must be > 0.0.
message FlutterRenderIntrinsicWidth {
  double step_width = 2;
  double step_height = 3;
  FlutterRenderBoxType child = 4;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that uses a [LeaderLayer].
message FlutterRenderLeaderLayer {
  FlutterLayerLinkType link = 2;
  FlutterRenderBoxType child = 3;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render box that imposes a maximum width or maximum height on its
// child if the child is otherwise unconstrained.
//
// The [maxWidth] and [maxHeight] arguments not be null and must be
// non-negative.
message FlutterRenderLimitedBox {
  FlutterRenderBoxType child = 2;
  double max_width = 3;
  double max_height = 4;
}

// package:flutter/src/rendering/list_body.dart
//
// Creates a render object that arranges its children sequentially along a
// given axis.
//
// By default, children are arranged along the vertical axis.
message FlutterRenderListBody {
  repeated FlutterRenderBoxType children = 2;
  FlutterAxisDirectionType.Enum axis_direction = 3;
}

// package:flutter/src/rendering/list_wheel_viewport.dart
//
// Creates a [RenderListWheelViewport] which renders children on a wheel.
//
// Optional arguments have reasonable defaults.
message FlutterRenderListWheelViewport {
  // The delegate that manages the children of this object.
  //
  // This delegate must maintain the [ListWheelParentData.index] value.
  FlutterListWheelChildManagerType child_manager = 2;
  FlutterViewportOffsetType offset = 3;
  double diameter_ratio = 4;
  double perspective = 5;
  double off_axis_fraction = 6;
  bool use_magnifier = 7;
  double magnification = 8;
  double over_and_under_center_opacity = 9;
  double item_extent = 10;
  double squeeze = 11;
  bool render_children_outside_viewport = 12;
  DartClipType.Enum clip_behavior = 13;
  repeated FlutterRenderBoxType children = 14;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that merges the semantics from its descendants.
message FlutterRenderMergeSemantics {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that hold opaque meta data.
//
// The [behavior] argument defaults to [HitTestBehavior.deferToChild].
message FlutterRenderMetaData {
  // How to behave during hit testing when deciding how the hit test propagates
  // to children and whether to consider targets behind this one.
  //
  // Defaults to [HitTestBehavior.deferToChild].
  //
  // See [HitTestBehavior] for the allowed values and their meanings.
  FlutterHitTestBehaviorType.Enum behavior = 3;
  FlutterRenderBoxType child = 4;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that forwards pointer events to callbacks.
//
// All parameters are optional. By default this method creates an opaque
// mouse region with no callbacks and cursor being [MouseCursor.defer].
message FlutterRenderMouseRegion {
  bool valid_for_mouse_tracker = 6;
  bool opaque = 7;
  FlutterRenderBoxType child = 8;
  FlutterHitTestBehaviorType.Enum hit_test_behavior = 9;
}

// package:flutter/src/widgets/nested_scroll_view.dart
//
// Create a variant of [RenderViewport] that has a
// [SliverOverlapAbsorberHandle].
message FlutterRenderNestedScrollViewViewport {
  FlutterAxisDirectionType.Enum axis_direction = 2;
  FlutterAxisDirectionType.Enum cross_axis_direction = 3;
  FlutterViewportOffsetType offset = 4;
  double anchor = 5;
  repeated FlutterRenderSliverType children = 6;
  FlutterRenderSliverType center = 7;
  FlutterSliverOverlapAbsorberHandleType handle = 8;
  DartClipType.Enum clip_behavior = 9;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates an offstage render object.
message FlutterRenderOffstage {
  bool offstage = 2;
  FlutterRenderBoxType child = 3;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a partially transparent render object.
//
// The [opacity] argument must be between 0.0 and 1.0, inclusive.
message FlutterRenderOpacity {
  double opacity = 2;
  bool always_include_semantics = 3;
  FlutterRenderBoxType child = 4;
}

// package:flutter/src/rendering/shifted_box.dart
//
// Creates a render object that insets its child.
//
// The [padding] argument must have non-negative insets.
message FlutterRenderPadding {
  FlutterEdgeInsetsGeometryType padding = 2;
  DartTextDirectionType.Enum text_direction = 3;
  FlutterRenderBoxType child = 4;
}

// package:flutter/src/rendering/paragraph.dart
//
// Creates a paragraph render object.
//
// The [maxLines] property may be null (and indeed defaults to null), but if
// it is not null, it must be greater than zero.
message FlutterRenderParagraph {
  FlutterInlineSpanType text = 2;
  DartTextAlignType.Enum text_align = 3;
  DartTextDirectionType.Enum text_direction = 4;
  bool soft_wrap = 5;
  FlutterTextOverflowType.Enum overflow = 6;
  FlutterTextScalerType text_scaler = 7;
  int32 max_lines = 8;
  DartLocaleType locale = 9;
  FlutterStrutStyleType strut_style = 10;
  FlutterTextWidthBasisType.Enum text_width_basis = 11;
  DartTextHeightBehaviorType text_height_behavior = 12;
  repeated FlutterRenderBoxType children = 13;
  DartColorType selection_color = 14;
  FlutterSelectionRegistrarType registrar = 15;
}

// package:flutter/src/rendering/performance_overlay.dart
//
// Creates a performance overlay render object.
message FlutterRenderPerformanceOverlay {
  int32 options_mask = 2;
  int32 rasterizer_threshold = 3;
  bool checkerboard_raster_cache_images = 4;
  bool checkerboard_offscreen_layers = 5;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a rounded-rectangular clip.
//
// The [color] is required.
//
// The [elevation] parameter must be non-negative.
message FlutterRenderPhysicalModel {
  FlutterRenderBoxType child = 2;
  FlutterBoxShapeType.Enum shape = 3;
  DartClipType.Enum clip_behavior = 4;
  FlutterBorderRadiusType border_radius = 5;
  double elevation = 6;
  DartColorType color = 7;
  DartColorType shadow_color = 8;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that forwards pointer events to callbacks.
//
// The [behavior] argument defaults to [HitTestBehavior.deferToChild].
message FlutterRenderPointerListener {
  // How to behave during hit testing when deciding how the hit test propagates
  // to children and whether to consider targets behind this one.
  //
  // Defaults to [HitTestBehavior.deferToChild].
  //
  // See [HitTestBehavior] for the allowed values and their meanings.
  FlutterHitTestBehaviorType.Enum behavior = 11;
  FlutterRenderBoxType child = 12;
}

// package:flutter/src/rendering/shifted_box.dart
//
// Creates a render object that positions its child.
message FlutterRenderPositionedBox {
  FlutterRenderBoxType child = 2;
  double width_factor = 3;
  double height_factor = 4;
  FlutterAlignmentGeometryType alignment = 5;
  DartTextDirectionType.Enum text_direction = 6;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a proxy render box.
//
// Proxy render boxes are rarely created directly because they proxy
// the render box protocol to [child]. Instead, consider using one of the
// subclasses.
message FlutterRenderProxyBox {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a repaint boundary around [child].
message FlutterRenderRepaintBoundary {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/rotated_box.dart
//
// Creates a rotated render box.
message FlutterRenderRotatedBox {
  int32 quarter_turns = 2;
  FlutterRenderBoxType child = 3;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that attaches a semantic annotation.
//
// If the [SemanticsProperties.attributedLabel] is not null, the [textDirection] must also not be null.
message FlutterRenderSemanticsAnnotations {
  FlutterRenderBoxType child = 2;
  FlutterSrcSemanticsSemanticsPropertiesType properties = 3;
  bool container = 4;
  bool explicit_child_nodes = 5;
  bool exclude_semantics = 6;
  bool block_user_actions = 7;
  DartTextDirectionType.Enum text_direction = 8;
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that listens for specific semantic gestures.
message FlutterRenderSemanticsGestureHandler {
  FlutterRenderBoxType child = 2;
  // The fraction of the dimension of this render box to use when
  // scrolling. For example, if this is 0.8 and the box is 200 pixels
  // wide, then when a left-scroll action is received from the
  // accessibility system, it will translate into a 160 pixel
  // leftwards drag.
  double scroll_factor = 7;
  // How to behave during hit testing when deciding how the hit test propagates
  // to children and whether to consider targets behind this one.
  //
  // Defaults to [HitTestBehavior.deferToChild].
  //
  // See [HitTestBehavior] for the allowed values and their meanings.
  FlutterHitTestBehaviorType.Enum behavior = 8;
}

// package:flutter/src/rendering/viewport.dart
//
// Creates a viewport (for [RenderSliver] objects) that shrink-wraps its
// contents.
//
// The [offset] must be specified. For testing purposes, consider passing a
// [ViewportOffset.zero] or [ViewportOffset.fixed].
message FlutterRenderShrinkWrappingViewport {
  FlutterAxisDirectionType.Enum axis_direction = 2;
  FlutterAxisDirectionType.Enum cross_axis_direction = 3;
  FlutterViewportOffsetType offset = 4;
  DartClipType.Enum clip_behavior = 5;
  repeated FlutterRenderSliverType children = 6;
}

// package:flutter/src/rendering/shifted_box.dart
//
// Creates a render box of a given size that lets its child overflow.
//
// The [textDirection] argument must not be null if the [alignment] is
// direction-sensitive.
message FlutterRenderSizedOverflowBox {
  FlutterRenderBoxType child = 2;
  DartSizeType requested_size = 3;
  FlutterAlignmentGeometryType alignment = 4;
  DartTextDirectionType.Enum text_direction = 5;
}

// package:flutter/src/rendering/proxy_sliver.dart
//
// Creates a render object that constrains the cross axis extent of its sliver child.
//
// The [maxExtent] parameter must be nonnegative.
message FlutterRenderSliverConstrainedCrossAxis {
  double max_extent = 2;
}

// package:flutter/src/rendering/sliver_group.dart
message FlutterRenderSliverCrossAxisGroup {
  
}

// package:flutter/src/rendering/sliver_fill.dart
//
// Creates a [RenderSliver] that wraps a non-scrollable [RenderBox] which is
// sized to fit the remaining space in the viewport.
message FlutterRenderSliverFillRemaining {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/sliver_fill.dart
//
// Creates a [RenderSliver] that wraps a non-scrollable [RenderBox] which is
// sized to fit the remaining space plus any overscroll in the viewport.
message FlutterRenderSliverFillRemainingAndOverscroll {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/sliver_fill.dart
//
// Creates a [RenderSliver] that wraps a scrollable [RenderBox] which is
// sized to fit the remaining space in the viewport.
message FlutterRenderSliverFillRemainingWithScrollable {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/sliver_fill.dart
//
// Creates a sliver that contains multiple box children that each fill the
// viewport.
message FlutterRenderSliverFillViewport {
  FlutterRenderSliverBoxChildManagerType child_manager = 2;
  double viewport_fraction = 3;
}

// package:flutter/src/rendering/sliver_fixed_extent_list.dart
//
// Creates a sliver that contains multiple box children that have a given
// extent in the main axis.
message FlutterRenderSliverFixedExtentList {
  FlutterRenderSliverBoxChildManagerType child_manager = 2;
  double item_extent = 3;
}

// package:flutter/src/rendering/sliver_grid.dart
//
// Creates a sliver that contains multiple box children that whose size and
// position are determined by a delegate.
message FlutterRenderSliverGrid {
  FlutterRenderSliverBoxChildManagerType child_manager = 2;
  FlutterSliverGridDelegateType grid_delegate = 3;
}

// package:flutter/src/rendering/proxy_sliver.dart
//
// Creates a render object that is invisible to hit testing.
message FlutterRenderSliverIgnorePointer {
  FlutterRenderSliverType sliver = 2;
  bool ignoring = 3;
}

// package:flutter/src/rendering/sliver_list.dart
//
// Creates a sliver that places multiple box children in a linear array along
// the main axis.
message FlutterRenderSliverList {
  FlutterRenderSliverBoxChildManagerType child_manager = 2;
}

// package:flutter/src/rendering/sliver_group.dart
message FlutterRenderSliverMainAxisGroup {
  
}

// package:flutter/src/rendering/proxy_sliver.dart
//
// Creates an offstage render object.
message FlutterRenderSliverOffstage {
  bool offstage = 2;
  FlutterRenderSliverType sliver = 3;
}

// package:flutter/src/rendering/proxy_sliver.dart
//
// Creates a partially transparent render object.
//
// The [opacity] argument must be between 0.0 and 1.0, inclusive.
message FlutterRenderSliverOpacity {
  double opacity = 2;
  bool always_include_semantics = 3;
  FlutterRenderSliverType sliver = 4;
}

// package:flutter/src/widgets/nested_scroll_view.dart
//
// Create a sliver that absorbs overlap and reports it to a
// [SliverOverlapAbsorberHandle].
//
// The [sliver] must be a [RenderSliver].
message FlutterRenderSliverOverlapAbsorber {
  FlutterSliverOverlapAbsorberHandleType handle = 2;
  FlutterRenderSliverType sliver = 3;
}

// package:flutter/src/widgets/nested_scroll_view.dart
//
// Creates a sliver that is as tall as the value of the given [handle]'s extent.
message FlutterRenderSliverOverlapInjector {
  FlutterSliverOverlapAbsorberHandleType handle = 2;
}

// package:flutter/src/rendering/sliver_padding.dart
//
// Creates a render object that insets its child in a viewport.
//
// The [padding] argument must have non-negative insets.
message FlutterRenderSliverPadding {
  FlutterEdgeInsetsGeometryType padding = 2;
  DartTextDirectionType.Enum text_direction = 3;
  FlutterRenderSliverType child = 4;
}

// package:flutter/src/rendering/sliver.dart
//
// Creates a [RenderSliver] that wraps a [RenderBox].
message FlutterRenderSliverToBoxAdapter {
  FlutterRenderBoxType child = 2;
}

// package:flutter/src/rendering/stack.dart
//
// Creates a stack render object.
//
// By default, the non-positioned children of the stack are aligned by their
// top left corners.
message FlutterRenderStack {
  repeated FlutterRenderBoxType children = 2;
  FlutterAlignmentGeometryType alignment = 3;
  DartTextDirectionType.Enum text_direction = 4;
  FlutterStackFitType.Enum fit = 5;
  DartClipType.Enum clip_behavior = 6;
}

// package:flutter/src/rendering/table.dart
//
// Creates a table render object.
//
//  * `columns` must either be null or non-negative. If `columns` is null,
//    the number of columns will be inferred from length of the first sublist
//    of `children`.
//  * `rows` must either be null or non-negative. If `rows` is null, the
//    number of rows will be inferred from the `children`. If `rows` is not
//    null, then `children` must be null.
//  * `children` must either be null or contain lists of all the same length.
//    if `children` is not null, then `rows` must be null.
//  * [columnWidths] may be null, in which case it defaults to an empty map.
message FlutterRenderTable {
  int32 columns = 2;
  int32 rows = 3;
  FlutterTableColumnWidthType default_column_width = 5;
  DartTextDirectionType.Enum text_direction = 6;
  FlutterTableBorderType border = 7;
  repeated FlutterDecorationType row_decorations = 8;
  FlutterImageConfigurationType configuration = 9;
  FlutterTableCellVerticalAlignmentType.Enum default_vertical_alignment = 10;
  DartTextBaselineType.Enum text_baseline = 11;
}

// package:flutter/src/widgets/tap_region.dart
//
// Creates a [RenderTapRegion].
message FlutterRenderTapRegion {
  FlutterTapRegionRegistryType registry = 2;
  bool enabled = 3;
  bool consume_outside_taps = 4;
  // How to behave during hit testing when deciding how the hit test propagates
  // to children and whether to consider targets behind this one.
  //
  // Defaults to [HitTestBehavior.deferToChild].
  //
  // See [HitTestBehavior] for the allowed values and their meanings.
  FlutterHitTestBehaviorType.Enum behavior = 7;
  string debug_label = 9;
}

// package:flutter/src/widgets/tap_region.dart
message FlutterRenderTapRegionSurface {
  
}

// package:flutter/src/rendering/proxy_box.dart
//
// Creates a render object that transforms its child.
message FlutterRenderTransform {
  VectorMathMatrix4Type transform = 2;
  DartOffsetType origin = 3;
  FlutterAlignmentGeometryType alignment = 4;
  DartTextDirectionType.Enum text_direction = 5;
  // When set to true, hit tests are performed based on the position of the
  // child as it is painted. When set to false, hit tests are performed
  // ignoring the transformation.
  //
  // [applyPaintTransform], and therefore [localToGlobal] and [globalToLocal],
  // always honor the transformation, regardless of the value of this property.
  bool transform_hit_tests = 6;
  DartFilterQualityType.Enum filter_quality = 7;
  FlutterRenderBoxType child = 8;
}

// package:flutter/src/rendering/view.dart
//
// Creates the root of the render tree.
//
// Typically created by the binding (e.g., [RendererBinding]).
//
// Providing a [configuration] is optional, but a configuration must be set
// before calling [prepareInitialFrame]. This decouples creating the
// [RenderView] object from configuring it. Typically, the object is created
// by the [View] widget and configured by the [RendererBinding] when the
// [RenderView] is registered with it by the [View] widget.
message FlutterRenderView {
  FlutterRenderBoxType child = 2;
  FlutterViewConfigurationType configuration = 3;
}

// package:flutter/src/rendering/viewport.dart
//
// Creates a viewport for [RenderSliver] objects.
//
// If the [center] is not specified, then the first child in the `children`
// list, if any, is used.
//
// The [offset] must be specified. For testing purposes, consider passing a
// [ViewportOffset.zero] or [ViewportOffset.fixed].
message FlutterRenderViewport {
  FlutterAxisDirectionType.Enum axis_direction = 2;
  FlutterAxisDirectionType.Enum cross_axis_direction = 3;
  FlutterViewportOffsetType offset = 4;
  double anchor = 5;
  repeated FlutterRenderSliverType children = 6;
  FlutterRenderSliverType center = 7;
  double cache_extent = 8;
  FlutterCacheExtentStyleType.Enum cache_extent_style = 9;
  DartClipType.Enum clip_behavior = 10;
}

// package:flutter/src/rendering/wrap.dart
//
// Creates a wrap render object.
//
// By default, the wrap layout is horizontal and both the children and the
// runs are aligned to the start.
message FlutterRenderWrap {
  repeated FlutterRenderBoxType children = 2;
  FlutterAxisType.Enum direction = 3;
  FlutterWrapAlignmentType.Enum alignment = 4;
  double spacing = 5;
  FlutterWrapAlignmentType.Enum run_alignment = 6;
  double run_spacing = 7;
  FlutterWrapCrossAlignmentType.Enum cross_axis_alignment = 8;
  DartTextDirectionType.Enum text_direction = 9;
  FlutterVerticalDirectionType.Enum vertical_direction = 10;
  DartClipType.Enum clip_behavior = 11;
}

// package:flutter/src/widgets/reorderable_list.dart
//
// Creates a listener for an drag following a long press event over the
// given child widget.
//
// This is most commonly used to wrap an entire list item in a reorderable
// list.
message FlutterReorderableDelayedDragStartListener {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget for which the application would like to respond to a tap and
  // drag gesture by starting a reordering drag on a reorderable list.
  WidgetType child = 3;
  // The index of the associated item that will be dragged in the list.
  int32 index = 4;
  // Whether the [child] item can be dragged and moved in the list.
  //
  // If true, the item can be moved to another location in the list when the
  // user taps on the child. If false, tapping on the child will be ignored.
  bool enabled = 5;
}

// package:flutter/src/widgets/reorderable_list.dart
//
// Creates a listener for a drag immediately following a pointer down
// event over the given child widget.
//
// This is most commonly used to wrap part of a list item like a drag
// handle.
message FlutterReorderableDragStartListener {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget for which the application would like to respond to a tap and
  // drag gesture by starting a reordering drag on a reorderable list.
  WidgetType child = 3;
  // The index of the associated item that will be dragged in the list.
  int32 index = 4;
  // Whether the [child] item can be dragged and moved in the list.
  //
  // If true, the item can be moved to another location in the list when the
  // user taps on the child. If false, tapping on the child will be ignored.
  bool enabled = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that isolates repaints.
message FlutterRepaintBoundary {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Wraps the given child in a [RepaintBoundary].
//
// The key for the [RepaintBoundary] is derived either from the child's key
// (if the child has a non-null key) or from the given `childIndex`.
message FlutterRepaintBoundaryNamedWrap {
  WidgetType child = 2;
  int32 child_index = 3;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates a [ReplaceTextIntent].
message FlutterReplaceTextIntent {
  // The [TextEditingValue] that this [Intent]'s action should perform on.
  FlutterTextEditingValueType current_text_editing_value = 2;
  // The text to replace the original text within the [replacementRange] with.
  string replacement_text = 3;
  // The range of text in [currentTextEditingValue] that needs to be replaced.
  DartTextRangeType replacement_range = 4;
  // {@macro flutter.widgets.TextEditingIntents.cause}
  FlutterSelectionChangedCauseType.Enum cause = 5;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Creates an intent used with [RequestFocusAction].
//
// {@macro flutter.widgets.FocusTraversalPolicy.requestFocusCallback}
message FlutterRequestFocusIntent {
  // The [FocusNode] that is to be focused.
  FlutterFocusNodeType focus_node = 2;
}

// package:flutter/src/services/restoration.dart
//
// Creates a child bucket initialized with the data that the provided
// `parent` has stored under the provided [restorationId].
//
// This constructor cannot be used if the `parent` does not have any child
// data stored under the given ID. In that case, create an empty bucket (via
// [RestorationBucket.empty] and have the parent adopt it via [adoptChild].
//
// {@macro flutter.services.RestorationBucket.empty.bucketCreation}
message FlutterRestorationBucketNamedChild {
  string restoration_id = 2;
  FlutterRestorationBucketType parent = 3;
}

// package:flutter/src/services/restoration.dart
//
// Creates an empty [RestorationBucket] to be provided to [adoptChild] to add
// it to the bucket hierarchy.
//
// {@template flutter.services.RestorationBucket.empty.bucketCreation}
// Instantiating a bucket directly is rare, most buckets are created by
// claiming a child from a parent via [claimChild]. If no parent bucket is
// available, [RestorationManager.rootBucket] may be used as a parent.
// {@endtemplate}
message FlutterRestorationBucketNamedEmpty {
  string restoration_id = 2;
}

// package:flutter/src/services/restoration.dart
//
// Creates the root [RestorationBucket] for the provided restoration
// `manager`.
//
// The `rawData` must either be null (in which case an empty bucket will be
// instantiated) or it must be a nested map describing the entire bucket
// hierarchy in the following format:
//
// ```javascript
// {
//  'v': {  // key-value pairs
//     // * key is a string representation a restoration ID
//     // * value is any primitive that can be encoded with [StandardMessageCodec]
//    '<restoration-id>: <Object>,
//   },
//  'c': {  // child buckets
//    'restoration-id': <nested map representing a child bucket>
//   }
// }
// ```
//
// {@macro flutter.services.RestorationBucket.empty.bucketCreation}
message FlutterRestorationBucketNamedRoot {
  FlutterRestorationManagerType manager = 2;
}

// package:flutter/src/services/restoration.dart
//
// Construct the restoration manager and set up the communications channels
// with the engine to get restoration messages (by calling [initChannels]).
message FlutterRestorationManager {
  
}

// package:flutter/src/widgets/restoration.dart
//
// Creates a [RestorationScope].
//
// Providing null as the [restorationId] turns off state restoration for
// the [child] and its descendants.
message FlutterRestorationScope {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The restoration ID used by this widget to obtain a child bucket from the
  // surrounding [RestorationScope].
  //
  // The child bucket obtained from the surrounding scope is made available to
  // descendant widgets via [RestorationScope.of].
  //
  // If this is null, [RestorationScope.of] invoked by descendants will return
  // null which effectively turns off state restoration for this subtree.
  string restoration_id = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a paragraph of rich text.
//
// The [maxLines] property may be null (and indeed defaults to null), but if
// it is not null, it must be greater than zero.
//
// The [textDirection], if null, defaults to the ambient [Directionality],
// which in that case must not be null.
message FlutterRichText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The text to display in this widget.
  FlutterInlineSpanType text = 3;
  // How the text should be aligned horizontally.
  DartTextAlignType.Enum text_align = 4;
  // The directionality of the text.
  //
  // This decides how [textAlign] values like [TextAlign.start] and
  // [TextAlign.end] are interpreted.
  //
  // This is also used to disambiguate how to render bidirectional text. For
  // example, if the [text] is an English phrase followed by a Hebrew phrase,
  // in a [TextDirection.ltr] context the English phrase will be on the left
  // and the Hebrew phrase to its right, while in a [TextDirection.rtl]
  // context, the English phrase will be on the right and the Hebrew phrase on
  // its left.
  //
  // Defaults to the ambient [Directionality], if any. If there is no ambient
  // [Directionality], then this must not be null.
  DartTextDirectionType.Enum text_direction = 5;
  // Whether the text should break at soft line breaks.
  //
  // If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.
  bool soft_wrap = 6;
  // How visual overflow should be handled.
  FlutterTextOverflowType.Enum overflow = 7;
  FlutterTextScalerType text_scaler = 8;
  // An optional maximum number of lines for the text to span, wrapping if necessary.
  // If the text exceeds the given number of lines, it will be truncated according
  // to [overflow].
  //
  // If this is 1, text will not wrap. Otherwise, text will be wrapped at the
  // edge of the box.
  int32 max_lines = 9;
  // Used to select a font when the same Unicode character can
  // be rendered differently, depending on the locale.
  //
  // It's rarely necessary to set this property. By default its value
  // is inherited from the enclosing app with `Localizations.localeOf(context)`.
  //
  // See [RenderParagraph.locale] for more information.
  DartLocaleType locale = 10;
  // {@macro flutter.painting.textPainter.strutStyle}
  FlutterStrutStyleType strut_style = 11;
  // {@macro flutter.painting.textPainter.textWidthBasis}
  FlutterTextWidthBasisType.Enum text_width_basis = 12;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 13;
  // The [SelectionRegistrar] this rich text is subscribed to.
  //
  // If this is set, [selectionColor] must be non-null.
  FlutterSelectionRegistrarType selection_registrar = 14;
  // The color to use when painting the selection.
  //
  // This is ignored if [selectionRegistrar] is null.
  //
  // See the section on selections in the [RichText] top-level API
  // documentation for more details on enabling selection in [RichText]
  // widgets.
  DartColorType selection_color = 15;
}

// package:flutter/src/widgets/router.dart
//
// Create a root back button dispatcher.
message FlutterRootBackButtonDispatcher {
  
}

// package:flutter/src/widgets/binding.dart
//
// Creates a [RootElement] for the provided [RootWidget].
message FlutterRootElement {
  FlutterRootWidgetType widget = 2;
}

// package:flutter/src/widgets/restoration.dart
//
// Creates a [RootRestorationScope].
//
// Providing null as the [restorationId] turns off state restoration for
// the [child] and its descendants.
message FlutterRootRestorationScope {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The restoration ID used to identify the child bucket that this widget
  // will insert into the tree.
  //
  // If this is null, no bucket is made available to descendants and state
  // restoration for the subtree is essentially turned off.
  string restoration_id = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/binding.dart
//
// Creates a [RootWidget].
message FlutterRootWidget {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // A short description of this widget used by debugging aids.
  string debug_short_description = 4;
}

// package:flutter/src/widgets/basic.dart
//
// A widget that rotates its child.
message FlutterRotatedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The number of clockwise quarter turns the child should be rotated.
  int32 quarter_turns = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/painting/rounded_rectangle_border.dart
//
// Creates a rounded rectangle border.
message FlutterRoundedRectangleBorder {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  // The radii for each corner.
  FlutterBorderRadiusGeometryType border_radius = 3;
}

// package:flutter/src/widgets/router.dart
//
// Creates a route information object.
//
// Either `location` or `uri` must not be null.
message FlutterRouteInformation {
  DartUriType uri = 2;
}

// package:flutter/src/widgets/routes.dart
message FlutterRouteObserver {
  
}

// package:flutter/src/widgets/basic.dart
//
// Creates a horizontal array of children.
//
// If [crossAxisAlignment] is [CrossAxisAlignment.baseline], then
// [textBaseline] must not be null.
//
// The [textDirection] argument defaults to the ambient [Directionality], if
// any. If there is no ambient directionality, and a text direction is going
// to be necessary to determine the layout order (which is always the case
// unless the row has no children or only one child) or to disambiguate
// `start` or `end` values for the [mainAxisAlignment], the [textDirection]
// must not be null.
message FlutterRow {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How the children should be placed along the main axis.
  //
  // For example, [MainAxisAlignment.start], the default, places the children
  // at the start (i.e., the left for a [Row] or the top for a [Column]) of the
  // main axis.
  FlutterMainAxisAlignmentType.Enum main_axis_alignment = 3;
  // How much space should be occupied in the main axis.
  //
  // After allocating space to children, there might be some remaining free
  // space. This value controls whether to maximize or minimize the amount of
  // free space, subject to the incoming layout constraints.
  //
  // If some children have a non-zero flex factors (and none have a fit of
  // [FlexFit.loose]), they will expand to consume all the available space and
  // there will be no remaining free space to maximize or minimize, making this
  // value irrelevant to the final layout.
  FlutterMainAxisSizeType.Enum main_axis_size = 4;
  // How the children should be placed along the cross axis.
  //
  // For example, [CrossAxisAlignment.center], the default, centers the
  // children in the cross axis (e.g., horizontally for a [Column]).
  FlutterCrossAxisAlignmentType.Enum cross_axis_alignment = 5;
  // Determines the order to lay children out horizontally and how to interpret
  // `start` and `end` in the horizontal direction.
  //
  // Defaults to the ambient [Directionality].
  //
  // If [textDirection] is [TextDirection.rtl], then the direction in which
  // text flows starts from right to left. Otherwise, if [textDirection] is
  // [TextDirection.ltr], then the direction in which text flows starts from
  // left to right.
  //
  // If the [direction] is [Axis.horizontal], this controls the order in which
  // the children are positioned (left-to-right or right-to-left), and the
  // meaning of the [mainAxisAlignment] property's [MainAxisAlignment.start] and
  // [MainAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.horizontal], and either the
  // [mainAxisAlignment] is either [MainAxisAlignment.start] or
  // [MainAxisAlignment.end], or there's more than one child, then the
  // [textDirection] (or the ambient [Directionality]) must not be null.
  //
  // If the [direction] is [Axis.vertical], this controls the meaning of the
  // [crossAxisAlignment] property's [CrossAxisAlignment.start] and
  // [CrossAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.vertical], and the [crossAxisAlignment] is
  // either [CrossAxisAlignment.start] or [CrossAxisAlignment.end], then the
  // [textDirection] (or the ambient [Directionality]) must not be null.
  DartTextDirectionType.Enum text_direction = 6;
  // Determines the order to lay children out vertically and how to interpret
  // `start` and `end` in the vertical direction.
  //
  // Defaults to [VerticalDirection.down].
  //
  // If the [direction] is [Axis.vertical], this controls which order children
  // are painted in (down or up), the meaning of the [mainAxisAlignment]
  // property's [MainAxisAlignment.start] and [MainAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.vertical], and either the [mainAxisAlignment]
  // is either [MainAxisAlignment.start] or [MainAxisAlignment.end], or there's
  // more than one child, then the [verticalDirection] must not be null.
  //
  // If the [direction] is [Axis.horizontal], this controls the meaning of the
  // [crossAxisAlignment] property's [CrossAxisAlignment.start] and
  // [CrossAxisAlignment.end] values.
  //
  // If the [direction] is [Axis.horizontal], and the [crossAxisAlignment] is
  // either [CrossAxisAlignment.start] or [CrossAxisAlignment.end], then the
  // [verticalDirection] must not be null.
  FlutterVerticalDirectionType.Enum vertical_direction = 7;
  // If aligning items according to their baseline, which baseline to use.
  //
  // This must be set if using baseline alignment. There is no default because there is no
  // way for the framework to know the correct baseline _a priori_.
  DartTextBaselineType.Enum text_baseline = 8;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 9;
}

// package:flutter/src/widgets/safe_area.dart
//
// Creates a widget that avoids operating system interfaces.
//
// The [left], [top], [right], [bottom], and [minimum] arguments must not be
// null.
message FlutterSafeArea {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether to avoid system intrusions on the left.
  bool left = 3;
  // Whether to avoid system intrusions at the top of the screen, typically the
  // system status bar.
  bool top = 4;
  // Whether to avoid system intrusions on the right.
  bool right = 5;
  // Whether to avoid system intrusions on the bottom side of the screen.
  bool bottom = 6;
  // This minimum padding to apply.
  //
  // The greater of the minimum insets and the media padding will be applied.
  FlutterEdgeInsetsType minimum = 7;
  // Specifies whether the [SafeArea] should maintain the bottom
  // [MediaQueryData.viewPadding] instead of the bottom [MediaQueryData.padding],
  // defaults to false.
  //
  // For example, if there is an onscreen keyboard displayed above the
  // SafeArea, the padding can be maintained below the obstruction rather than
  // being consumed. This can be helpful in cases where your layout contains
  // flexible widgets, which could visibly move when opening a software
  // keyboard due to the change in the padding value. Setting this to true will
  // avoid the UI shift.
  bool maintain_bottom_view_padding = 8;
  // The widget below this widget in the tree.
  //
  // The padding on the [MediaQuery] for the [child] will be suitably adjusted
  // to zero out any sides that were avoided by this widget.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 9;
}

// package:flutter/src/gestures/scale.dart
//
// Create a gesture recognizer for interactions intended for scaling content.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterScaleGestureRecognizer {
  // Determines what point is used as the starting point in all calculations
  // involving this gesture.
  //
  // When set to [DragStartBehavior.down], the scale is calculated starting
  // from the position where the pointer first contacted the screen.
  //
  // When set to [DragStartBehavior.start], the scale is calculated starting
  // from the position where the scale gesture began. The scale gesture may
  // begin after the time that the pointer first contacted the screen if there
  // are multiple listeners competing for the gesture. In that case, the
  // gesture arena waits to determine whether or not the gesture is a scale
  // gesture before giving the gesture to this GestureRecognizer. This happens
  // in the case of nested GestureDetectors, for example.
  //
  // Defaults to [DragStartBehavior.down].
  //
  // See also:
  //
  // * https://flutter.dev/docs/development/ui/advanced/gestures#gesture-disambiguation,
  //   which provides more information about the gesture arena.
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 5;
  // {@template flutter.gestures.scale.trackpadScrollCausesScale}
  // Whether scrolling up/down on a trackpad should cause scaling instead of
  // panning.
  //
  // Defaults to false.
  // {@endtemplate}
  bool trackpad_scroll_causes_scale = 6;
  // {@template flutter.gestures.scale.trackpadScrollToScaleFactor}
  // A factor to control the direction and magnitude of scale when converting
  // trackpad scrolling.
  //
  // Incoming trackpad pan offsets will be divided by this factor to get scale
  // values. Increasing this offset will reduce the amount of scaling caused by
  // a fixed amount of trackpad scrolling.
  //
  // Defaults to [kDefaultTrackpadScrollToScaleFactor].
  // {@endtemplate}
  DartOffsetType trackpad_scroll_to_scale_factor = 7;
}

// package:flutter/src/widgets/scroll_configuration.dart
//
// Creates a description of how [Scrollable] widgets should behave.
message FlutterScrollBehavior {
  
}

// package:flutter/src/widgets/scroll_configuration.dart
//
// Creates a widget that controls how [Scrollable] widgets behave in a subtree.
message FlutterScrollConfiguration {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How [Scrollable] widgets that are descendants of [child] should behave.
  FlutterScrollBehaviorType behavior = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/scroll_controller.dart
//
// Creates a controller for a scrollable widget.
message FlutterScrollController {
  double initial_scroll_offset = 2;
  // Each time a scroll completes, save the current scroll [offset] with
  // [PageStorage] and restore it if this controller's scrollable is recreated.
  //
  // If this property is set to false, the scroll offset is never saved
  // and [initialScrollOffset] is always used to initialize the scroll
  // offset. If true (the default), the initial scroll offset is used the
  // first time the controller's scrollable is created, since there's no
  // scroll offset to restore yet. Subsequently the saved offset is
  // restored and [initialScrollOffset] is ignored.
  //
  // See also:
  //
  //  * [PageStorageKey], which should be used when more than one
  //    scrollable appears in the same route, to distinguish the [PageStorage]
  //    locations used to save scroll offsets.
  bool keep_scroll_offset = 3;
  // A label that is used in the [toString] output. Intended to aid with
  // identifying scroll controller instances in debug output.
  string debug_label = 4;
}

// package:flutter/src/widgets/scrollable_helpers.dart
//
// Creates a const [ScrollIntent] that requests scrolling in the given
// [direction], with the given [type].
message FlutterScrollIntent {
  // The direction in which to scroll the scrollable containing the focused
  // widget.
  FlutterAxisDirectionType.Enum direction = 2;
  // The type of scrolling that is intended.
  FlutterScrollIncrementTypeType.Enum type = 3;
}

// package:flutter/src/widgets/scroll_notification_observer.dart
//
// Create a [ScrollNotificationObserver].
message FlutterScrollNotificationObserver {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The subtree below this widget.
  WidgetType child = 3;
}

// package:flutter/src/widgets/scroll_physics.dart
//
// Creates an object with the default scroll physics.
message FlutterScrollPhysics {
  // If non-null, determines the default behavior for each method.
  //
  // If a subclass of [ScrollPhysics] does not override a method, that subclass
  // will inherit an implementation from this base class that defers to
  // [parent]. This mechanism lets you assemble novel combinations of
  // [ScrollPhysics] subclasses at runtime. For example:
  //
  // ```dart
  // const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
  // ```
  //
  // will result in a [ScrollPhysics] that has the combined behavior
  // of [BouncingScrollPhysics] and [AlwaysScrollableScrollPhysics]:
  // behaviors that are not specified in [BouncingScrollPhysics]
  // (e.g. [shouldAcceptUserOffset]) will defer to [AlwaysScrollableScrollPhysics].
  FlutterScrollPhysicsType parent = 2;
}

// package:flutter/src/widgets/scroll_position_with_single_context.dart
//
// Create a [ScrollPosition] object that manages its behavior using
// [ScrollActivity] objects.
//
// The `initialPixels` argument can be null, but in that case it is
// imperative that the value be set, using [correctPixels], as soon as
// [applyNewDimensions] is invoked, before calling the inherited
// implementation of that method.
//
// If [keepScrollOffset] is true (the default), the current scroll offset is
// saved with [PageStorage] and restored it if this scroll position's scrollable
// is recreated.
message FlutterScrollPositionWithSingleContext {
  // How the scroll position should respond to user input.
  //
  // For example, determines how the widget continues to animate after the
  // user stops dragging the scroll view.
  FlutterScrollPhysicsType physics = 2;
  // Where the scrolling is taking place.
  //
  // Typically implemented by [ScrollableState].
  FlutterScrollContextType context = 3;
  double initial_pixels = 4;
  // Save the current scroll offset with [PageStorage] and restore it if
  // this scroll position's scrollable is recreated.
  //
  // See also:
  //
  //  * [ScrollController.keepScrollOffset] and [PageController.keepPage], which
  //    create scroll positions and initialize this property.
  bool keep_scroll_offset = 5;
  FlutterScrollPositionType old_position = 6;
  // A label that is used in the [toString] output.
  //
  // Intended to aid with identifying animation controller instances in debug
  // output.
  string debug_label = 7;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates a [ScrollToDocumentBoundaryIntent].
message FlutterScrollToDocumentBoundaryIntent {
  bool forward = 2;
}

// package:flutter/src/widgets/scrollable.dart
message FlutterScrollableState {
  
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an instance of [SelectAllTextIntent].
message FlutterSelectAllTextIntent {
  // {@template flutter.widgets.TextEditingIntents.cause}
  // The [SelectionChangedCause] that triggered the intent.
  // {@endtemplate}
  FlutterSelectionChangedCauseType.Enum cause = 2;
}

// package:flutter/src/widgets/actions.dart
//
// Creates an intent that selects the currently focused control.
message FlutterSelectIntent {
  
}

// package:flutter/src/widgets/selectable_region.dart
//
// Create a new [SelectableRegion] widget.
//
// The [selectionControls] are used for building the selection handles and
// toolbar for mobile devices.
message FlutterSelectableRegion {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 4;
  // The delegate to build the selection handles and toolbar for mobile
  // devices.
  //
  // The [emptyTextSelectionControls] global variable provides a default
  // [TextSelectionControls] implementation with no controls.
  FlutterTextSelectionControlsType selection_controls = 5;
  // The child widget this selection area applies to.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 6;
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
  //
  // {@macro flutter.widgets.magnifier.intro}
  //
  // By default, [SelectableRegion]'s [TextMagnifierConfiguration] is disabled.
  //
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.details}
  FlutterTextMagnifierConfigurationType magnifier_configuration = 7;
}

// package:flutter/src/widgets/selectable_region.dart
message FlutterSelectableRegionState {
  
}

// package:flutter/src/widgets/selection_container.dart
//
// Creates a selection container to collect the [Selectable]s in the subtree.
//
// If [registrar] is not provided, this selection container gets the
// [SelectionRegistrar] from the context instead.
message FlutterSelectionContainer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [SelectionRegistrar] this container is registered to.
  //
  // If null, this widget gets the [SelectionRegistrar] from the current
  // context.
  FlutterSelectionRegistrarType registrar = 3;
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/widgets/selection_container.dart
//
// Creates a selection container that disables selection for the
// subtree.
//
// {@tool dartpad}
// This sample demonstrates how to disable selection for a Text under a
// SelectionArea.
//
// ** See code in examples/api/lib/material/selection_container/selection_container_disabled.0.dart **
// {@end-tool}
message FlutterSelectionContainerNamedDisabled {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/selection_container.dart
//
// Creates a selection registrar scope that host the [registrar].
message FlutterSelectionRegistrarScope {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [SelectionRegistrar] hosted by this widget.
  FlutterSelectionRegistrarType registrar = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a semantic annotation.
//
// To create a `const` instance of [Semantics], use the
// [Semantics.fromProperties] constructor.
//
// See also:
//
//  * [SemanticsProperties], which contains a complete documentation for each
//    of the constructor parameters that belongs to semantics properties.
//  * [SemanticsSortKey] for a class that determines accessibility traversal
//    order.
message FlutterSemantics {
  FlutterKeyType key = 2;
  WidgetType child = 3;
  bool container = 4;
  bool explicit_child_nodes = 5;
  bool exclude_semantics = 6;
  bool block_user_actions = 7;
  bool enabled = 8;
  bool checked = 9;
  bool mixed = 10;
  bool selected = 11;
  bool toggled = 12;
  bool button = 13;
  bool slider = 14;
  bool keyboard_key = 15;
  bool link = 16;
  bool header = 17;
  bool text_field = 18;
  bool read_only = 19;
  bool focusable = 20;
  bool focused = 21;
  bool in_mutually_exclusive_group = 22;
  bool obscured = 23;
  bool multiline = 24;
  bool scopes_route = 25;
  bool names_route = 26;
  bool hidden = 27;
  bool image = 28;
  bool live_region = 29;
  bool expanded = 30;
  int32 max_value_length = 31;
  int32 current_value_length = 32;
  string identifier = 33;
  string label = 34;
  FlutterSrcSemanticsAttributedStringType attributed_label = 35;
  string value = 36;
  FlutterSrcSemanticsAttributedStringType attributed_value = 37;
  string increased_value = 38;
  FlutterSrcSemanticsAttributedStringType attributed_increased_value = 39;
  string decreased_value = 40;
  FlutterSrcSemanticsAttributedStringType attributed_decreased_value = 41;
  string hint = 42;
  FlutterSrcSemanticsAttributedStringType attributed_hint = 43;
  string tooltip = 44;
  string on_tap_hint = 45;
  string on_long_press_hint = 46;
  DartTextDirectionType.Enum text_direction = 47;
  FlutterSrcSemanticsSemanticsSortKeyType sort_key = 48;
  FlutterSrcSemanticsSemanticsTagType tag_for_children = 49;
}

// package:flutter/src/widgets/semantics_debugger.dart
//
// Creates a widget that visualizes the semantics for the child.
//
// [labelStyle] dictates the [TextStyle] used for the semantics labels.
message FlutterSemanticsDebugger {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The [TextStyle] to use when rendering semantics labels.
  FlutterTextStyleType label_style = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a semantic annotation using [SemanticsProperties].
message FlutterSemanticsNamedFromProperties {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // If [container] is true, this widget will introduce a new
  // node in the semantics tree. Otherwise, the semantics will be
  // merged with the semantics of any ancestors (if the ancestor allows that).
  //
  // Whether descendants of this widget can add their semantic information to the
  // [SemanticsNode] introduced by this configuration is controlled by
  // [explicitChildNodes].
  bool container = 4;
  // Whether descendants of this widget are allowed to add semantic information
  // to the [SemanticsNode] annotated by this widget.
  //
  // When set to false descendants are allowed to annotate [SemanticsNode]s of
  // their parent with the semantic information they want to contribute to the
  // semantic tree.
  // When set to true the only way for descendants to contribute semantic
  // information to the semantic tree is to introduce new explicit
  // [SemanticsNode]s to the tree.
  //
  // If the semantics properties of this node include
  // [SemanticsProperties.scopesRoute] set to true, then [explicitChildNodes]
  // must be true also.
  //
  // This setting is often used in combination with [SemanticsConfiguration.isSemanticBoundary]
  // to create semantic boundaries that are either writable or not for children.
  bool explicit_child_nodes = 5;
  // Whether to replace all child semantics with this node.
  //
  // Defaults to false.
  //
  // When this flag is set to true, all child semantics nodes are ignored.
  // This can be used as a convenience for cases where a child is wrapped in
  // an [ExcludeSemantics] widget and then another [Semantics] widget.
  bool exclude_semantics = 6;
  // Whether to block user interactions for the rendering subtree.
  //
  // Setting this to true will prevent users from interacting with The
  // rendering object configured by this widget and its subtree through
  // pointer-related [SemanticsAction]s in assistive technologies.
  //
  // The [SemanticsNode] created from this widget is still focusable by
  // assistive technologies. Only pointer-related [SemanticsAction]s, such as
  // [SemanticsAction.tap] or its friends, are blocked.
  //
  // If this widget is merged into a parent semantics node, only the
  // [SemanticsAction]s of this widget and the widgets in the subtree are
  // blocked.
  //
  // For example:
  // ```dart
  // void _myTap() { }
  // void _myLongPress() { }
  //
  // Widget build(BuildContext context) {
  //   return Semantics(
  //     onTap: _myTap,
  //     child: Semantics(
  //       blockUserActions: true,
  //       onLongPress: _myLongPress,
  //       child: const Text('label'),
  //     ),
  //   );
  // }
  // ```
  //
  // The result semantics node will still have `_myTap`, but the `_myLongPress`
  // will be blocked.
  bool block_user_actions = 7;
  // Contains properties used by assistive technologies to make the application
  // more accessible.
  FlutterSrcSemanticsSemanticsPropertiesType properties = 8;
}

// package:flutter/src/gestures/multitap.dart
//
// Creates a serial tap gesture recognizer.
message FlutterSerialTapGestureRecognizer {
  
}

// package:flutter/src/rendering/layer.dart
//
// Creates a shader mask layer.
//
// The [shader], [maskRect], and [blendMode] properties must be non-null
// before the compositing phase of the pipeline.
message FlutterShaderMaskLayer {
  DartShaderType shader = 2;
  DartRectType mask_rect = 3;
  DartBlendModeType.Enum blend_mode = 4;
}

// package:flutter/src/painting/shape_decoration.dart
//
// Creates a shape decoration.
//
// * If [color] is null, this decoration does not paint a background color.
// * If [gradient] is null, this decoration does not paint gradients.
// * If [image] is null, this decoration does not paint a background image.
// * If [shadows] is null, this decoration does not paint a shadow.
//
// The [color] and [gradient] properties are mutually exclusive, one (or
// both) of them must be null.
message FlutterShapeDecoration {
  // The color to fill in the background of the shape.
  //
  // The color is under the [image].
  //
  // If a [gradient] is specified, [color] must be null.
  DartColorType color = 2;
  // A gradient to use when filling the shape.
  //
  // The gradient is under the [image].
  //
  // If a [color] is specified, [gradient] must be null.
  FlutterGradientType gradient = 4;
  // A list of shadows cast by the [shape].
  //
  // See also:
  //
  //  * [kElevationToShadow], for some predefined shadows used in Material
  //    Design.
  //  * [PhysicalModel], a widget for showing shadows.
  repeated FlutterBoxShadowType shadows = 5;
  // The shape to fill the [color], [gradient], and [image] into and to cast as
  // the [shadows].
  //
  // Shapes can be stacked (using the `+` operator). The color, gradient, and
  // image are drawn into the inner-most shape specified.
  //
  // The [shape] property specifies the outline (border) of the decoration.
  //
  // ## Directionality-dependent shapes
  //
  // Some [ShapeBorder] subclasses are sensitive to the [TextDirection]. The
  // direction that is provided to the border (e.g. for its [ShapeBorder.paint]
  // method) is the one specified in the [ImageConfiguration]
  // ([ImageConfiguration.textDirection]) provided to the [BoxPainter] (via its
  // [BoxPainter.paint method). The [BoxPainter] is obtained when
  // [createBoxPainter] is called.
  //
  // When a [ShapeDecoration] is used with a [Container] widget or a
  // [DecoratedBox] widget (which is what [Container] uses), the
  // [TextDirection] specified in the [ImageConfiguration] is obtained from the
  // ambient [Directionality], using [createLocalImageConfiguration].
  FlutterShapeBorderType shape = 6;
}

// package:flutter/src/painting/shape_decoration.dart
//
// Creates a shape decoration configured to match a [BoxDecoration].
//
// The [BoxDecoration] class is more efficient for shapes that it can
// describe than the [ShapeDecoration] class is for those same shapes,
// because [ShapeDecoration] has to be more general as it can support any
// shape. However, having a [ShapeDecoration] is sometimes necessary, for
// example when calling [ShapeDecoration.lerp] to transition between
// different shapes (e.g. from a [CircleBorder] to a
// [RoundedRectangleBorder]; the [BoxDecoration] class cannot animate the
// transition from a [BoxShape.circle] to [BoxShape.rectangle]).
message FlutterShapeDecorationNamedFromBoxDecoration {
  FlutterBoxDecorationType source = 2;
}

// package:flutter/src/widgets/shared_app_data.dart
//
// Creates a widget based on [InheritedModel] that supports build
// dependencies qualified by keywords. Descendant widgets create
// such dependencies with [SharedAppData.getValue] and they trigger
// rebuilds with [SharedAppData.setValue].
//
// This widget is automatically created by the [WidgetsApp].
message FlutterSharedAppData {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/shortcuts.dart
//
// Constructs a [ShortcutManager].
message FlutterShortcutManager {
  // True if the [ShortcutManager] should not pass on keys that it doesn't
  // handle to any key-handling widgets that are ancestors to this one.
  //
  // Setting [modal] to true will prevent any key event given to this manager
  // from being given to any ancestor managers, even if that key doesn't appear
  // in the [shortcuts] map.
  //
  // The net effect of setting [modal] to true is to return
  // [KeyEventResult.skipRemainingHandlers] from [handleKeypress] if it does
  // not exist in the shortcut map, instead of returning
  // [KeyEventResult.ignored].
  bool modal = 3;
}

// package:flutter/src/widgets/shortcuts.dart
//
// Creates a const [ShortcutRegistrar].
//
// The [child] parameter is required.
message FlutterShortcutRegistrar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/shortcuts.dart
//
// Creates a const [Shortcuts] widget that uses the [manager] to
// manage the map of shortcuts.
//
// If this constructor is used, [shortcuts] will return the contents of
// [ShortcutManager.shortcuts].
//
// The [child] and [manager] arguments are required.
message FlutterShortcutsNamedManager {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [ShortcutManager] that will manage the mapping between key
  // combinations and [Action]s.
  //
  // If this widget was created with [Shortcuts.manager], then
  // [ShortcutManager.shortcuts] will be used as the source for shortcuts. If
  // the unnamed constructor is used, this manager will be null, and a
  // default-constructed [ShortcutManager] will be used.
  FlutterShortcutManagerType manager = 3;
  // The child widget for this [Shortcuts] widget.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
  // The debug label that is printed for this node when logged.
  //
  // If this label is set, then it will be displayed instead of the shortcut
  // map when logged.
  //
  // This allows simplifying the diagnostic output to avoid cluttering it
  // unnecessarily with large default shortcut maps.
  string debug_label = 5;
}

// package:flutter/src/widgets/viewport.dart
//
// Creates a widget that is bigger on the inside and shrink wraps its
// children in the main axis.
//
// The viewport listens to the [offset], which means you do not need to
// rebuild this widget when the [offset] changes.
message FlutterShrinkWrappingViewport {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The direction in which the [offset]'s [ViewportOffset.pixels] increases.
  //
  // For example, if the [axisDirection] is [AxisDirection.down], a scroll
  // offset of zero is at the top of the viewport and increases towards the
  // bottom of the viewport.
  FlutterAxisDirectionType.Enum axis_direction = 3;
  // The direction in which child should be laid out in the cross axis.
  //
  // If the [axisDirection] is [AxisDirection.down] or [AxisDirection.up], this
  // property defaults to [AxisDirection.left] if the ambient [Directionality]
  // is [TextDirection.rtl] and [AxisDirection.right] if the ambient
  // [Directionality] is [TextDirection.ltr].
  //
  // If the [axisDirection] is [AxisDirection.left] or [AxisDirection.right],
  // this property defaults to [AxisDirection.down].
  FlutterAxisDirectionType.Enum cross_axis_direction = 4;
  // Which part of the content inside the viewport should be visible.
  //
  // The [ViewportOffset.pixels] value determines the scroll offset that the
  // viewport uses to select which part of its content to display. As the user
  // scrolls the viewport, this value changes, which changes the content that
  // is displayed.
  //
  // Typically a [ScrollPosition].
  FlutterViewportOffsetType offset = 5;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 6;
  repeated WidgetType slivers = 7;
}

// package:flutter/src/widgets/framework.dart
//
// Creates an element that uses the given widget as its configuration.
message FlutterSingleChildRenderObjectElement {
  FlutterSingleChildRenderObjectWidgetType widget = 2;
}

// package:flutter/src/widgets/single_child_scroll_view.dart
//
// Creates a box in which a single widget can be scrolled.
message FlutterSingleChildScrollView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.scroll_view.scrollDirection}
  FlutterAxisType.Enum scroll_direction = 3;
  // Whether the scroll view scrolls in the reading direction.
  //
  // For example, if the reading direction is left-to-right and
  // [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from
  // left to right when [reverse] is false and from right to left when
  // [reverse] is true.
  //
  // Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view
  // scrolls from top to bottom when [reverse] is false and from bottom to top
  // when [reverse] is true.
  //
  // Defaults to false.
  bool reverse = 4;
  // The amount of space by which to inset the child.
  FlutterEdgeInsetsGeometryType padding = 5;
  // {@macro flutter.widgets.scroll_view.primary}
  bool primary = 6;
  // How the scroll view should respond to user input.
  //
  // For example, determines how the scroll view continues to animate after the
  // user stops dragging the scroll view.
  //
  // Defaults to matching platform conventions.
  FlutterScrollPhysicsType physics = 7;
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // Must be null if [primary] is true.
  //
  // A [ScrollController] serves several purposes. It can be used to control
  // the initial scroll position (see [ScrollController.initialScrollOffset]).
  // It can be used to control whether the scroll view should automatically
  // save and restore its scroll position in the [PageStorage] (see
  // [ScrollController.keepScrollOffset]). It can be used to read the current
  // scroll position (see [ScrollController.offset]), or change it (see
  // [ScrollController.animateTo]).
  FlutterScrollControllerType controller = 8;
  // The widget that scrolls.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 9;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 10;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 11;
  // {@macro flutter.widgets.scrollable.restorationId}
  string restoration_id = 12;
  // {@macro flutter.widgets.scroll_view.keyboardDismissBehavior}
  FlutterScrollViewKeyboardDismissBehaviorType.Enum keyboard_dismiss_behavior = 13;
}

// package:flutter/src/widgets/size_changed_layout_notifier.dart
//
// Creates a [SizeChangedLayoutNotifier] that dispatches layout changed
// notifications when [child] changes layout size.
message FlutterSizeChangedLayoutNotifier {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a fixed size box. The [width] and [height] parameters can be null
// to indicate that the size of the box should not be constrained in
// the corresponding dimension.
message FlutterSizedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If non-null, requires the child to have exactly this width.
  double width = 3;
  // If non-null, requires the child to have exactly this height.
  double height = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a box that will become as large as its parent allows.
message FlutterSizedBoxNamedExpand {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a box with the specified size.
message FlutterSizedBoxNamedFromSize {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  DartSizeType size = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a box that will become as small as its parent allows.
message FlutterSizedBoxNamedShrink {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a box whose [width] and [height] are equal.
message FlutterSizedBoxNamedSquare {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  double dimension = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget of a given size that lets its child overflow.
message FlutterSizedOverflowBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The size this widget should attempt to be.
  DartSizeType size = 3;
  // How to align the child.
  //
  // The x and y values of the alignment control the horizontal and vertical
  // alignment, respectively. An x value of -1.0 means that the left edge of
  // the child is aligned with the left edge of the parent whereas an x value
  // of 1.0 means that the right edge of the child is aligned with the right
  // edge of the parent. Other values interpolate (and extrapolate) linearly.
  // For example, a value of 0.0 means that the center of the child is aligned
  // with the center of the parent.
  //
  // Defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/widgets/animated_scroll_view.dart
message FlutterSliverAnimatedGridState {
  
}

// package:flutter/src/widgets/animated_scroll_view.dart
message FlutterSliverAnimatedListState {
  
}

// package:flutter/src/widgets/implicit_animations.dart
//
// Creates a widget that animates its opacity implicitly.
//
// The [opacity] argument must be between zero and one, inclusive.
message FlutterSliverAnimatedOpacity {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The sliver below this widget in the tree.
  WidgetType sliver = 3;
  // The target opacity.
  //
  // An opacity of 1.0 is fully opaque. An opacity of 0.0 is fully transparent
  // (i.e., invisible).
  double opacity = 4;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 5;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 6;
  // Whether the semantic information of the children is always included.
  //
  // Defaults to false.
  //
  // When true, regardless of the opacity settings the sliver child's semantic
  // information is exposed as if the widget were fully visible. This is
  // useful in cases where labels may be hidden during animations that
  // would otherwise contribute relevant semantics.
  bool always_include_semantics = 8;
}

// package:flutter/src/widgets/scroll_delegate.dart
//
// Creates a delegate that supplies children for slivers using the given
// list.
//
// The [children], [addAutomaticKeepAlives], [addRepaintBoundaries],
// [addSemanticIndexes], and [semanticIndexCallback] arguments must not be
// null.
//
// If the order of children never changes, consider using the constant
// [SliverChildListDelegate.fixed] constructor.
message FlutterSliverChildListDelegate {
  // The widgets to display.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someWidget.children.add(...)` or
  // passing a reference of the original list value to the [children] parameter
  // will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object must be provided.
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return PageView(children: List<Widget>.of(_children));
  //   }
  // }
  // ```
  repeated WidgetType children = 2;
  // {@macro flutter.widgets.SliverChildBuilderDelegate.addAutomaticKeepAlives}
  bool add_automatic_keep_alives = 3;
  // {@macro flutter.widgets.SliverChildBuilderDelegate.addRepaintBoundaries}
  bool add_repaint_boundaries = 4;
  // {@macro flutter.widgets.SliverChildBuilderDelegate.addSemanticIndexes}
  bool add_semantic_indexes = 5;
  // {@macro flutter.widgets.SliverChildBuilderDelegate.semanticIndexOffset}
  int32 semantic_index_offset = 7;
}

// package:flutter/src/widgets/scroll_delegate.dart
//
// Creates a constant version of the delegate that supplies children for
// slivers using the given list.
//
// If the order of the children will change, consider using the regular
// [SliverChildListDelegate] constructor.
//
// The [children], [addAutomaticKeepAlives], [addRepaintBoundaries],
// [addSemanticIndexes], and [semanticIndexCallback] arguments must not be
// null.
message FlutterSliverChildListDelegateNamedFixed {
  // The widgets to display.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someWidget.children.add(...)` or
  // passing a reference of the original list value to the [children] parameter
  // will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object must be provided.
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return PageView(children: List<Widget>.of(_children));
  //   }
  // }
  // ```
  repeated WidgetType children = 2;
  // {@macro flutter.widgets.SliverChildBuilderDelegate.addAutomaticKeepAlives}
  bool add_automatic_keep_alives = 3;
  // {@macro flutter.widgets.SliverChildBuilderDelegate.addRepaintBoundaries}
  bool add_repaint_boundaries = 4;
  // {@macro flutter.widgets.SliverChildBuilderDelegate.addSemanticIndexes}
  bool add_semantic_indexes = 5;
  // {@macro flutter.widgets.SliverChildBuilderDelegate.semanticIndexOffset}
  int32 semantic_index_offset = 7;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that constrains the cross axis extent of its sliver child.
//
// The [maxExtent] parameter is required and must be nonnegative.
message FlutterSliverConstrainedCrossAxis {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The cross axis extent to apply to the sliver child.
  //
  // This value must be nonnegative.
  double max_extent = 3;
  // The widget below this widget in the tree.
  //
  // Must be a sliver.
  WidgetType sliver = 4;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates an object that assigns a [flex] value to the child sliver.
//
// The provided [flex] value must be greater than 0.
message FlutterSliverCrossAxisExpanded {
  FlutterKeyType key = 2;
  // Flex value for allocating cross axis extent left after laying out the children with
  // constrained cross axis. The children with flex values will have the remaining extent
  // allocated proportionally to their flex value. This must an integer between
  // 0 and infinity, exclusive.
  int32 flex = 3;
  WidgetType sliver = 4;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that places sliver children in a linear array along
// the cross axis.
message FlutterSliverCrossAxisGroup {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  repeated WidgetType slivers = 3;
}

// package:flutter/src/widgets/sliver_fill.dart
//
// Creates a sliver that fills the remaining space in the viewport.
message FlutterSliverFillRemaining {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Box child widget that fills the remaining space in the viewport.
  //
  // The main [SliverFillRemaining] documentation contains more details.
  WidgetType child = 3;
  // Indicates whether the child has a scrollable body, this value cannot be
  // null.
  //
  // Defaults to true such that the child will extend beyond the viewport and
  // scroll, as seen in [NestedScrollView].
  //
  // Setting this value to false will allow the child to fill the remainder of
  // the viewport and not extend further. However, if the
  // [SliverConstraints.precedingScrollExtent] and/or the [child]'s
  // extent exceeds the size of the viewport, the sliver will defer to the
  // child's size rather than overriding it.
  bool has_scroll_body = 4;
  // Indicates whether the child should stretch to fill the overscroll area
  // created by certain scroll physics, such as iOS' default scroll physics.
  // This flag is only relevant when [hasScrollBody] is false.
  //
  // Defaults to false, meaning that the default behavior is for the child to
  // maintain its size and not extend into the overscroll area.
  bool fill_overscroll = 5;
}

// package:flutter/src/widgets/sliver_fill.dart
//
// Creates a sliver whose box children that each fill the viewport.
message FlutterSliverFillViewport {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.SliverMultiBoxAdaptorWidget.delegate}
  FlutterSliverChildDelegateType delegate = 3;
  // The fraction of the viewport that each child should fill in the main axis.
  //
  // If this fraction is less than 1.0, more than one child will be visible at
  // once. If this fraction is greater than 1.0, each child will be larger than
  // the viewport in the main axis.
  double viewport_fraction = 4;
  // Whether to add padding to both ends of the list.
  //
  // If this is set to true and [viewportFraction] < 1.0, padding will be added
  // such that the first and last child slivers will be in the center of the
  // viewport when scrolled all the way to the start or end, respectively. You
  // may want to set this to false if this [SliverFillViewport] is not the only
  // widget along this main axis, such as in a [CustomScrollView] with multiple
  // children.
  //
  // If [viewportFraction] is greater than one, this option has no effect.
  // Defaults to true.
  bool pad_ends = 5;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that places box children with the same main axis extent
// in a linear array.
message FlutterSliverFixedExtentList {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.SliverMultiBoxAdaptorWidget.delegate}
  // The delegate that provides the children for this widget.
  //
  // The children are constructed lazily using this delegate to avoid creating
  // more children than are visible through the [Viewport].
  //
  // ## Using more than one delegate in a [Viewport]
  //
  // If multiple delegates are used in a single scroll view, the first child of
  // each delegate will always be laid out, even if it extends beyond the
  // currently viewable area. This is because at least one child is required in
  // order to estimate the max scroll offset for the whole scroll view, as it
  // uses the currently built children to estimate the remaining children's
  // extent.
  //
  // See also:
  //
  //  * [SliverChildBuilderDelegate] and [SliverChildListDelegate], which are
  //    commonly used subclasses of [SliverChildDelegate] that use a builder
  //    callback and an explicit child list, respectively.
  // {@endtemplate}
  FlutterSliverChildDelegateType delegate = 3;
  // The extent the children are forced to have in the main axis.
  double item_extent = 4;
}

// package:flutter/src/widgets/sliver.dart
//
// A sliver that places multiple box children in a linear array along the main
// axis.
//
// [SliverFixedExtentList] places its children in a linear array along the main
// axis starting at offset zero and without gaps. Each child is forced to have
// the [itemExtent] in the main axis and the
// [SliverConstraints.crossAxisExtent] in the cross axis.
//
// This constructor uses a list of [Widget]s to build the sliver.
//
// The `addAutomaticKeepAlives` argument corresponds to the
// [SliverChildBuilderDelegate.addAutomaticKeepAlives] property. The
// `addRepaintBoundaries` argument corresponds to the
// [SliverChildBuilderDelegate.addRepaintBoundaries] property. The
// `addSemanticIndexes` argument corresponds to the
// [SliverChildBuilderDelegate.addSemanticIndexes] property.
//
// {@tool snippet}
// This example, which would be inserted into a [CustomScrollView.slivers]
// list, shows an infinite number of items in varying shades of blue:
//
// ```dart
// SliverFixedExtentList.list(
//   itemExtent: 50.0,
//   children: const <Widget>[
//     Text('Hello'),
//     Text('World!'),
//   ],
// );
// ```
// {@end-tool}
message FlutterSliverFixedExtentListNamedList {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  repeated WidgetType children = 3;
  // The extent the children are forced to have in the main axis.
  double item_extent = 4;
  bool add_automatic_keep_alives = 5;
  bool add_repaint_boundaries = 6;
  bool add_semantic_indexes = 7;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that places multiple box children in a two dimensional
// arrangement.
message FlutterSliverGrid {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.SliverMultiBoxAdaptorWidget.delegate}
  // The delegate that provides the children for this widget.
  //
  // The children are constructed lazily using this delegate to avoid creating
  // more children than are visible through the [Viewport].
  //
  // ## Using more than one delegate in a [Viewport]
  //
  // If multiple delegates are used in a single scroll view, the first child of
  // each delegate will always be laid out, even if it extends beyond the
  // currently viewable area. This is because at least one child is required in
  // order to estimate the max scroll offset for the whole scroll view, as it
  // uses the currently built children to estimate the remaining children's
  // extent.
  //
  // See also:
  //
  //  * [SliverChildBuilderDelegate] and [SliverChildListDelegate], which are
  //    commonly used subclasses of [SliverChildDelegate] that use a builder
  //    callback and an explicit child list, respectively.
  // {@endtemplate}
  FlutterSliverChildDelegateType delegate = 3;
  // The delegate that controls the size and position of the children.
  FlutterSliverGridDelegateType grid_delegate = 4;
}

// package:flutter/src/rendering/sliver_grid.dart
//
// Creates a delegate that makes grid layouts with a fixed number of tiles in
// the cross axis.
//
// The `mainAxisSpacing`, `mainAxisExtent` and `crossAxisSpacing` arguments
// must not be negative. The `crossAxisCount` and `childAspectRatio`
// arguments must be greater than zero.
message FlutterSliverGridDelegateWithFixedCrossAxisCount {
  // The number of children in the cross axis.
  int32 cross_axis_count = 2;
  // The number of logical pixels between each child along the main axis.
  double main_axis_spacing = 3;
  // The number of logical pixels between each child along the cross axis.
  double cross_axis_spacing = 4;
  // The ratio of the cross-axis to the main-axis extent of each child.
  double child_aspect_ratio = 5;
  // The extent of each tile in the main axis. If provided it would define the
  // logical pixels taken by each tile in the main-axis.
  //
  // If null, [childAspectRatio] is used instead.
  double main_axis_extent = 6;
}

// package:flutter/src/rendering/sliver_grid.dart
//
// Creates a delegate that makes grid layouts with tiles that have a maximum
// cross-axis extent.
//
// The [maxCrossAxisExtent], [mainAxisExtent], [mainAxisSpacing],
// and [crossAxisSpacing] arguments must not be negative.
// The [childAspectRatio] argument must be greater than zero.
message FlutterSliverGridDelegateWithMaxCrossAxisExtent {
  // The maximum extent of tiles in the cross axis.
  //
  // This delegate will select a cross-axis extent for the tiles that is as
  // large as possible subject to the following conditions:
  //
  //  - The extent evenly divides the cross-axis extent of the grid.
  //  - The extent is at most [maxCrossAxisExtent].
  //
  // For example, if the grid is vertical, the grid is 500.0 pixels wide, and
  // [maxCrossAxisExtent] is 150.0, this delegate will create a grid with 4
  // columns that are 125.0 pixels wide.
  double max_cross_axis_extent = 2;
  // The number of logical pixels between each child along the main axis.
  double main_axis_spacing = 3;
  // The number of logical pixels between each child along the cross axis.
  double cross_axis_spacing = 4;
  // The ratio of the cross-axis to the main-axis extent of each child.
  double child_aspect_ratio = 5;
  // The extent of each tile in the main axis. If provided it would define the
  // logical pixels taken by each tile in the main-axis.
  //
  // If null, [childAspectRatio] is used instead.
  double main_axis_extent = 6;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that places multiple box children in a two dimensional
// arrangement with a fixed number of tiles in the cross axis.
//
// Uses a [SliverGridDelegateWithFixedCrossAxisCount] as the [gridDelegate],
// and a [SliverChildListDelegate] as the [delegate].
//
// See also:
//
//  * [GridView.count], the equivalent constructor for [GridView] widgets.
message FlutterSliverGridNamedCount {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  int32 cross_axis_count = 3;
  double main_axis_spacing = 4;
  double cross_axis_spacing = 5;
  double child_aspect_ratio = 6;
  repeated WidgetType children = 7;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that places multiple box children in a two dimensional
// arrangement with tiles that each have a maximum cross-axis extent.
//
// Uses a [SliverGridDelegateWithMaxCrossAxisExtent] as the [gridDelegate],
// and a [SliverChildListDelegate] as the [delegate].
//
// See also:
//
//  * [GridView.extent], the equivalent constructor for [GridView] widgets.
message FlutterSliverGridNamedExtent {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  double max_cross_axis_extent = 3;
  double main_axis_spacing = 4;
  double cross_axis_spacing = 5;
  double child_aspect_ratio = 6;
  repeated WidgetType children = 7;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver widget that is invisible to hit testing.
message FlutterSliverIgnorePointer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this sliver is ignored during hit testing.
  //
  // Regardless of whether this sliver is ignored during hit testing, it will
  // still consume space during layout and be visible during painting.
  //
  // {@macro flutter.widgets.IgnorePointer.semantics}
  bool ignoring = 3;
  WidgetType sliver = 4;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that places box children in a linear array.
message FlutterSliverList {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.SliverMultiBoxAdaptorWidget.delegate}
  // The delegate that provides the children for this widget.
  //
  // The children are constructed lazily using this delegate to avoid creating
  // more children than are visible through the [Viewport].
  //
  // ## Using more than one delegate in a [Viewport]
  //
  // If multiple delegates are used in a single scroll view, the first child of
  // each delegate will always be laid out, even if it extends beyond the
  // currently viewable area. This is because at least one child is required in
  // order to estimate the max scroll offset for the whole scroll view, as it
  // uses the currently built children to estimate the remaining children's
  // extent.
  //
  // See also:
  //
  //  * [SliverChildBuilderDelegate] and [SliverChildListDelegate], which are
  //    commonly used subclasses of [SliverChildDelegate] that use a builder
  //    callback and an explicit child list, respectively.
  // {@endtemplate}
  FlutterSliverChildDelegateType delegate = 3;
}

// package:flutter/src/widgets/sliver.dart
//
// A sliver that places multiple box children in a linear array along the main
// axis.
//
// This constructor uses a list of [Widget]s to build the sliver.
//
// The `addAutomaticKeepAlives` argument corresponds to the
// [SliverChildBuilderDelegate.addAutomaticKeepAlives] property. The
// `addRepaintBoundaries` argument corresponds to the
// [SliverChildBuilderDelegate.addRepaintBoundaries] property. The
// `addSemanticIndexes` argument corresponds to the
// [SliverChildBuilderDelegate.addSemanticIndexes] property.
//
// {@tool snippet}
// This example, which would be provided in [CustomScrollView.slivers],
// shows a list containing two [Text] widgets:
//
// ```dart
// SliverList.list(
//   children: const <Widget>[
//     Text('Hello'),
//     Text('World!'),
//   ],
// );
// ```
// {@end-tool}
message FlutterSliverListNamedList {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  repeated WidgetType children = 3;
  bool add_automatic_keep_alives = 4;
  bool add_repaint_boundaries = 5;
  bool add_semantic_indexes = 6;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that places sliver children in a linear array along
// the main axis.
message FlutterSliverMainAxisGroup {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  repeated WidgetType slivers = 3;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates an element that lazily builds children for the given widget.
//
// If `replaceMovedChildren` is set to true, a new child is proactively
// inflate for the index that was previously occupied by a child that moved
// to a new index. The layout offset of the moved child is copied over to the
// new child. RenderObjects, that depend on the layout offset of existing
// children during [RenderObject.performLayout] should set this to true
// (example: [RenderSliverList]). For RenderObjects that figure out the
// layout offset of their children without looking at the layout offset of
// existing children this should be set to false (example:
// [RenderSliverFixedExtentList]) to avoid inflating unnecessary children.
message FlutterSliverMultiBoxAdaptorElement {
  FlutterSliverMultiBoxAdaptorWidgetType widget = 2;
  bool replace_moved_children = 3;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that visually hides its sliver child.
message FlutterSliverOffstage {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether the sliver child is hidden from the rest of the tree.
  //
  // If true, the sliver child is laid out as if it was in the tree, but
  // without painting anything, without making the child available for hit
  // testing, and without taking any room in the parent.
  //
  // If false, the sliver child is included in the tree as normal.
  bool offstage = 3;
  WidgetType sliver = 4;
}

// package:flutter/src/widgets/sliver.dart
//
// Creates a sliver that makes its sliver child partially transparent.
//
// The [opacity] argument must be between zero and one, inclusive.
message FlutterSliverOpacity {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The fraction to scale the sliver child's alpha value.
  //
  // An opacity of 1.0 is fully opaque. An opacity of 0.0 is fully transparent
  // (i.e. invisible).
  //
  // Values 1.0 and 0.0 are painted with a fast path. Other values
  // require painting the sliver child into an intermediate buffer, which is
  // expensive.
  double opacity = 3;
  // Whether the semantic information of the sliver child is always included.
  //
  // Defaults to false.
  //
  // When true, regardless of the opacity settings, the sliver child semantic
  // information is exposed as if the widget were fully visible. This is
  // useful in cases where labels may be hidden during animations that
  // would otherwise contribute relevant semantics.
  bool always_include_semantics = 4;
  WidgetType sliver = 5;
}

// package:flutter/src/widgets/nested_scroll_view.dart
//
// Creates a sliver that absorbs overlap and reports it to a
// [SliverOverlapAbsorberHandle].
message FlutterSliverOverlapAbsorber {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The object in which the absorbed overlap is recorded.
  //
  // A particular [SliverOverlapAbsorberHandle] can only be assigned to a
  // single [SliverOverlapAbsorber] at a time.
  FlutterSliverOverlapAbsorberHandleType handle = 3;
  WidgetType sliver = 4;
}

// package:flutter/src/widgets/nested_scroll_view.dart
//
// Creates a [SliverOverlapAbsorberHandle].
message FlutterSliverOverlapAbsorberHandle {
  
}

// package:flutter/src/widgets/nested_scroll_view.dart
//
// Creates a sliver that is as tall as the value of the given [handle]'s
// layout extent.
message FlutterSliverOverlapInjector {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The handle to the [SliverOverlapAbsorber] that is feeding this injector.
  //
  // This should be a handle owned by a [SliverOverlapAbsorber] and a
  // [NestedScrollViewViewport].
  FlutterSliverOverlapAbsorberHandleType handle = 3;
  WidgetType sliver = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a sliver that applies padding on each side of another sliver.
message FlutterSliverPadding {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The amount of space by which to inset the child sliver.
  FlutterEdgeInsetsGeometryType padding = 3;
  WidgetType sliver = 4;
}

// package:flutter/src/widgets/sliver_persistent_header.dart
//
// Creates a sliver that varies its size when it is scrolled to the start of
// a viewport.
message FlutterSliverPersistentHeader {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether to stick the header to the start of the viewport once it has
  // reached its minimum size.
  //
  // If this is false, the header will continue scrolling off the screen after
  // it has shrunk to its minimum extent.
  bool pinned = 4;
  // Whether the header should immediately grow again if the user reverses
  // scroll direction.
  //
  // If this is false, the header only grows again once the user reaches the
  // part of the viewport that contains the sliver.
  //
  // The [delegate]'s [SliverPersistentHeaderDelegate.snapConfiguration] is
  // ignored unless [floating] is true.
  bool floating = 5;
}

// package:flutter/src/widgets/sliver_prototype_extent_list.dart
//
// Creates a sliver that places its box children in a linear array and
// constrains them to have the same extent as a prototype item along
// the main axis.
message FlutterSliverPrototypeExtentList {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.SliverMultiBoxAdaptorWidget.delegate}
  // The delegate that provides the children for this widget.
  //
  // The children are constructed lazily using this delegate to avoid creating
  // more children than are visible through the [Viewport].
  //
  // ## Using more than one delegate in a [Viewport]
  //
  // If multiple delegates are used in a single scroll view, the first child of
  // each delegate will always be laid out, even if it extends beyond the
  // currently viewable area. This is because at least one child is required in
  // order to estimate the max scroll offset for the whole scroll view, as it
  // uses the currently built children to estimate the remaining children's
  // extent.
  //
  // See also:
  //
  //  * [SliverChildBuilderDelegate] and [SliverChildListDelegate], which are
  //    commonly used subclasses of [SliverChildDelegate] that use a builder
  //    callback and an explicit child list, respectively.
  // {@endtemplate}
  FlutterSliverChildDelegateType delegate = 3;
  // Defines the main axis extent of all of this sliver's children.
  //
  // The [prototypeItem] is laid out before the rest of the sliver's children
  // and its size along the main axis fixes the size of each child. The
  // [prototypeItem] is essentially [Offstage]: it is not painted and it
  // cannot respond to input.
  WidgetType prototype_item = 4;
}

// package:flutter/src/widgets/sliver_prototype_extent_list.dart
//
// A sliver that places multiple box children in a linear array along the main
// axis.
//
// This constructor uses a list of [Widget]s to build the sliver.
//
// The `addAutomaticKeepAlives` argument corresponds to the
// [SliverChildBuilderDelegate.addAutomaticKeepAlives] property. The
// `addRepaintBoundaries` argument corresponds to the
// [SliverChildBuilderDelegate.addRepaintBoundaries] property. The
// `addSemanticIndexes` argument corresponds to the
// [SliverChildBuilderDelegate.addSemanticIndexes] property.
//
// {@tool snippet}
// This example, which would be inserted into a [CustomScrollView.slivers]
// list, shows an infinite number of items in varying shades of blue:
//
// ```dart
// SliverPrototypeExtentList.list(
//   prototypeItem: const Text('Hello'),
//   children: const <Widget>[
//     Text('Hello'),
//     Text('World!'),
//   ],
// );
// ```
// {@end-tool}
message FlutterSliverPrototypeExtentListNamedList {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  repeated WidgetType children = 3;
  // Defines the main axis extent of all of this sliver's children.
  //
  // The [prototypeItem] is laid out before the rest of the sliver's children
  // and its size along the main axis fixes the size of each child. The
  // [prototypeItem] is essentially [Offstage]: it is not painted and it
  // cannot respond to input.
  WidgetType prototype_item = 4;
  bool add_automatic_keep_alives = 5;
  bool add_repaint_boundaries = 6;
  bool add_semantic_indexes = 7;
}

// package:flutter/src/widgets/reorderable_list.dart
message FlutterSliverReorderableListState {
  
}

// package:flutter/src/widgets/safe_area.dart
//
// Creates a sliver that avoids operating system interfaces.
message FlutterSliverSafeArea {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether to avoid system intrusions on the left.
  bool left = 3;
  // Whether to avoid system intrusions at the top of the screen, typically the
  // system status bar.
  bool top = 4;
  // Whether to avoid system intrusions on the right.
  bool right = 5;
  // Whether to avoid system intrusions on the bottom side of the screen.
  bool bottom = 6;
  // This minimum padding to apply.
  //
  // The greater of the minimum padding and the media padding is be applied.
  FlutterEdgeInsetsType minimum = 7;
  // The sliver below this sliver in the tree.
  //
  // The padding on the [MediaQuery] for the [sliver] will be suitably adjusted
  // to zero out any sides that were avoided by this sliver.
  WidgetType sliver = 8;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a sliver that contains a single box widget.
message FlutterSliverToBoxAdapter {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/visibility.dart
//
// Control whether the given [sliver] is [visible].
//
// The [maintainSemantics] and [maintainInteractivity] arguments can only be
// set if [maintainSize] is set.
//
// The [maintainSize] argument can only be set if [maintainAnimation] is set.
//
// The [maintainAnimation] argument can only be set if [maintainState] is
// set.
message FlutterSliverVisibility {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The sliver to show or hide, as controlled by [visible].
  WidgetType sliver = 3;
  // The widget to use when the sliver child is not [visible], assuming that
  // none of the `maintain` flags (in particular, [maintainState]) are set.
  //
  // The normal behavior is to replace the widget with a childless
  // [SliverToBoxAdapter], which by default has a geometry of
  // [SliverGeometry.zero].
  WidgetType replacement_sliver = 4;
  // Switches between showing the [sliver] or hiding it.
  //
  // The `maintain` flags should be set to the same values regardless of the
  // state of the [visible] property, otherwise they will not operate correctly
  // (specifically, the state will be lost regardless of the state of
  // [maintainState] whenever any of the `maintain` flags are changed, since
  // doing so will result in a subtree shape change).
  //
  // Unless [maintainState] is set, the [sliver] subtree will be disposed
  // (removed from the tree) while hidden.
  bool visible = 5;
  // Whether to maintain the [State] objects of the [sliver] subtree when it is
  // not [visible].
  //
  // Keeping the state of the subtree is potentially expensive (because it
  // means all the objects are still in memory; their resources are not
  // released). It should only be maintained if it cannot be recreated on
  // demand. One example of when the state would be maintained is if the sliver
  // subtree contains a [Navigator], since that widget maintains elaborate
  // state that cannot be recreated on the fly.
  //
  // If this property is true, a [SliverOffstage] widget is used to hide the
  // sliver instead of replacing it with [replacementSliver].
  //
  // If this property is false, then [maintainAnimation] must also be false.
  //
  // Dynamically changing this value may cause the current state of the
  // subtree to be lost (and a new instance of the subtree, with new [State]
  // objects, to be immediately created if [visible] is true).
  bool maintain_state = 6;
  // Whether to maintain animations within the [sliver] subtree when it is
  // not [visible].
  //
  // To set this, [maintainState] must also be set.
  //
  // Keeping animations active when the widget is not visible is even more
  // expensive than only maintaining the state.
  //
  // One example when this might be useful is if the subtree is animating its
  // layout in time with an [AnimationController], and the result of that
  // layout is being used to influence some other logic. If this flag is false,
  // then any [AnimationController]s hosted inside the [sliver] subtree will be
  // muted while the [visible] flag is false.
  //
  // If this property is true, no [TickerMode] widget is used.
  //
  // If this property is false, then [maintainSize] must also be false.
  //
  // Dynamically changing this value may cause the current state of the
  // subtree to be lost (and a new instance of the subtree, with new [State]
  // objects, to be immediately created if [visible] is true).
  bool maintain_animation = 7;
  // Whether to maintain space for where the sliver would have been.
  //
  // To set this, [maintainAnimation] must also be set.
  //
  // Maintaining the size when the sliver is not [visible] is not notably more
  // expensive than just keeping animations running without maintaining the
  // size, and may in some circumstances be slightly cheaper if the subtree is
  // simple and the [visible] property is frequently toggled, since it avoids
  // triggering a layout change when the [visible] property is toggled. If the
  // [sliver] subtree is not trivial then it is significantly cheaper to not
  // even keep the state (see [maintainState]).
  //
  // If this property is false, [SliverOffstage] is used.
  //
  // If this property is false, then [maintainSemantics] and
  // [maintainInteractivity] must also be false.
  //
  // Dynamically changing this value may cause the current state of the
  // subtree to be lost (and a new instance of the subtree, with new [State]
  // objects, to be immediately created if [visible] is true).
  bool maintain_size = 8;
  // Whether to maintain the semantics for the sliver when it is hidden (e.g.
  // for accessibility).
  //
  // To set this, [maintainSize] must also be set.
  //
  // By default, with [maintainSemantics] set to false, the [sliver] is not
  // visible to accessibility tools when it is hidden from the user. If this
  // flag is set to true, then accessibility tools will report the widget as if
  // it was present.
  bool maintain_semantics = 9;
  // Whether to allow the sliver to be interactive when hidden.
  //
  // To set this, [maintainSize] must also be set.
  //
  // By default, with [maintainInteractivity] set to false, touch events cannot
  // reach the [sliver] when it is hidden from the user. If this flag is set to
  // true, then touch events will nonetheless be passed through.
  bool maintain_interactivity = 10;
}

// package:flutter/src/widgets/visibility.dart
//
// Control whether the given [sliver] is [visible].
//
// This is equivalent to the default [SliverVisibility] constructor with all
// "maintain" fields set to true. This constructor should be used in place of
// a [SliverOpacity] widget that only takes on values of `0.0` or `1.0`, as it
// avoids extra compositing when fully opaque.
message FlutterSliverVisibilityNamedMaintain {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The sliver to show or hide, as controlled by [visible].
  WidgetType sliver = 3;
  // The widget to use when the sliver child is not [visible], assuming that
  // none of the `maintain` flags (in particular, [maintainState]) are set.
  //
  // The normal behavior is to replace the widget with a childless
  // [SliverToBoxAdapter], which by default has a geometry of
  // [SliverGeometry.zero].
  WidgetType replacement_sliver = 4;
  // Switches between showing the [sliver] or hiding it.
  //
  // The `maintain` flags should be set to the same values regardless of the
  // state of the [visible] property, otherwise they will not operate correctly
  // (specifically, the state will be lost regardless of the state of
  // [maintainState] whenever any of the `maintain` flags are changed, since
  // doing so will result in a subtree shape change).
  //
  // Unless [maintainState] is set, the [sliver] subtree will be disposed
  // (removed from the tree) while hidden.
  bool visible = 5;
}

// package:flutter/src/widgets/snapshot_widget.dart
//
// Create a new [SnapshotController].
//
// By default, [allowSnapshotting] is `false` and cannot be `null`.
message FlutterSnapshotController {
  bool allow_snapshotting = 2;
}

// package:flutter/src/widgets/snapshot_widget.dart
//
// Create a new [SnapshotWidget].
//
// The [controller] and [child] arguments are required.
message FlutterSnapshotWidget {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Configuration that controls how the snapshot widget decides to paint its children.
  //
  // Defaults to [SnapshotMode.normal], which throws an error when a platform view
  // or texture view is encountered.
  //
  // See [SnapshotMode] for more information.
  FlutterSnapshotModeType.Enum mode = 3;
  // Whether or not changes in render object size should automatically re-create
  // the snapshot.
  //
  // Defaults to false.
  bool autoresize = 5;
  // The controller that determines when to display the children as a snapshot.
  FlutterSnapshotControllerType controller = 6;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 7;
}

// package:flutter/src/widgets/spacer.dart
//
// Creates a flexible space to insert into a [Flexible] widget.
//
// The [flex] parameter may not be null or less than one.
message FlutterSpacer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The flex factor to use in determining how much space to take up.
  //
  // The amount of space the [Spacer] can occupy in the main axis is determined
  // by dividing the free space proportionately, after placing the inflexible
  // children, according to the flex factors of the flexible children.
  //
  // Defaults to one.
  int32 flex = 3;
}

// package:flutter/src/widgets/spell_check.dart
//
// Creates a configuration that specifies the service and suggestions handler
// for spell check.
message FlutterSpellCheckConfiguration {
  // The service used to fetch spell check results for text input.
  FlutterSpellCheckServiceType spell_check_service = 2;
  // The color the paint the selection highlight when spell check is showing
  // suggestions for a misspelled word.
  //
  // For example, on iOS, the selection appears red while the spell check menu
  // is showing.
  DartColorType misspelled_selection_color = 3;
  // Style used to indicate misspelled words.
  //
  // This is nullable to allow style-specific wrappers of [EditableText]
  // to infer this, but this must be specified if this configuration is
  // provided directly to [EditableText] or its construction will fail with an
  // assertion error.
  FlutterTextStyleType misspelled_text_style = 4;
}

// package:flutter/src/widgets/spell_check.dart
//
// Creates a configuration that disables spell check.
message FlutterSpellCheckConfigurationNamedDisabled {
  
}

// package:flutter/src/animation/animation_style.dart
//
// Creates an instance of Animation Style class.
message FlutterSrcAnimationAnimationStyle {
  // When specified, the animation will use this curve.
  FlutterSrcAnimationCurveType curve = 2;
  // When specified, the animation will use this duration.
  DartDurationType duration = 3;
  // When specified, the reverse animation will use this curve.
  FlutterSrcAnimationCurveType reverse_curve = 4;
  // When specified, the reverse animation will use this duration.
  DartDurationType reverse_duration = 5;
}

// package:flutter/src/animation/curves.dart
//
// Constructs a centripetal [CatmullRomCurve].
//
// It takes a list of two or more points that describe the points that the
// curve must pass through. See [controlPoints] for a description of the
// restrictions placed on control points. In addition to the given
// [controlPoints], the curve will begin with an implicit control point at
// (0.0, 0.0) and end with an implicit control point at (1.0, 1.0), so that
// the curve begins and ends at those points.
//
// The optional [tension] argument controls how tightly the curve approaches
// the given `controlPoints`. It must be in the range 0.0 to 1.0, inclusive. It
// defaults to 0.0, which provides the smoothest curve. A value of 1.0
// is equivalent to a linear interpolation between points.
//
// The internal curve data structures are lazily computed the first time
// [transform] is called. If you would rather pre-compute the curve, use
// [CatmullRomCurve.precompute] instead.
//
// See also:
//
//  * This [paper on using Catmull-Rom splines](http://faculty.cs.tamu.edu/schaefer/research/cr_cad.pdf).
message FlutterSrcAnimationCatmullRomCurve {
  // The control points used to create this curve.
  //
  // The `dx` value of each [Offset] in [controlPoints] represents the
  // animation value at which the curve should pass through the `dy` value of
  // the same control point.
  //
  // The [controlPoints] list must meet the following criteria:
  //
  //  * The list must contain at least two points.
  //  * The X value of each point must be greater than 0.0 and less then 1.0.
  //  * The X values of each point must be greater than the
  //    previous point's X value (i.e. monotonically increasing). The Y values
  //    are not constrained.
  //  * The resulting spline must be single-valued in X. That is, for each X
  //    value, there must be exactly one Y value. This means that the control
  //    points must not generated a spline that loops or overlaps itself.
  //
  // The static function [validateControlPoints] can be used to check that
  // these conditions are met, and will return true if they are. In debug mode,
  // it will also optionally return a list of reasons in text form. In debug
  // mode, the constructor will assert that these conditions are met and print
  // the reasons if the assert fires.
  //
  // When the curve is evaluated with [transform], the values will interpolate
  // smoothly from one control point to the next, passing through (0.0, 0.0), the
  // given control points, and (1.0, 1.0).
  repeated DartOffsetType control_points = 2;
  // The "tension" of the curve.
  //
  // The [tension] attribute controls how tightly the curve approaches the
  // given [controlPoints]. It must be in the range 0.0 to 1.0, inclusive. It
  // is optional, and defaults to 0.0, which provides the smoothest curve. A
  // value of 1.0 is equivalent to a linear interpolation between control
  // points.
  double tension = 3;
}

// package:flutter/src/animation/curves.dart
//
// Constructs a centripetal [CatmullRomCurve].
//
// Same as [CatmullRomCurve.new], but it precomputes the internal curve data
// structures for a more predictable computation load.
message FlutterSrcAnimationCatmullRomCurveNamedPrecompute {
  // The control points used to create this curve.
  //
  // The `dx` value of each [Offset] in [controlPoints] represents the
  // animation value at which the curve should pass through the `dy` value of
  // the same control point.
  //
  // The [controlPoints] list must meet the following criteria:
  //
  //  * The list must contain at least two points.
  //  * The X value of each point must be greater than 0.0 and less then 1.0.
  //  * The X values of each point must be greater than the
  //    previous point's X value (i.e. monotonically increasing). The Y values
  //    are not constrained.
  //  * The resulting spline must be single-valued in X. That is, for each X
  //    value, there must be exactly one Y value. This means that the control
  //    points must not generated a spline that loops or overlaps itself.
  //
  // The static function [validateControlPoints] can be used to check that
  // these conditions are met, and will return true if they are. In debug mode,
  // it will also optionally return a list of reasons in text form. In debug
  // mode, the constructor will assert that these conditions are met and print
  // the reasons if the assert fires.
  //
  // When the curve is evaluated with [transform], the values will interpolate
  // smoothly from one control point to the next, passing through (0.0, 0.0), the
  // given control points, and (1.0, 1.0).
  repeated DartOffsetType control_points = 2;
  // The "tension" of the curve.
  //
  // The [tension] attribute controls how tightly the curve approaches the
  // given [controlPoints]. It must be in the range 0.0 to 1.0, inclusive. It
  // is optional, and defaults to 0.0, which provides the smoothest curve. A
  // value of 1.0 is equivalent to a linear interpolation between control
  // points.
  double tension = 3;
}

// package:flutter/src/animation/curves.dart
//
// Creates a cubic curve.
//
// Rather than creating a new instance, consider using one of the common
// cubic curves in [Curves].
message FlutterSrcAnimationCubic {
  // The x coordinate of the first control point.
  //
  // The line through the point (0, 0) and the first control point is tangent
  // to the curve at the point (0, 0).
  double a = 2;
  // The y coordinate of the first control point.
  //
  // The line through the point (0, 0) and the first control point is tangent
  // to the curve at the point (0, 0).
  double b = 3;
  // The x coordinate of the second control point.
  //
  // The line through the point (1, 1) and the second control point is tangent
  // to the curve at the point (1, 1).
  double c = 4;
  // The y coordinate of the second control point.
  //
  // The line through the point (1, 1) and the second control point is tangent
  // to the curve at the point (1, 1).
  double d = 5;
}

// package:flutter/src/animation/curves.dart
//
// Creates an elastic-in curve.
//
// Rather than creating a new instance, consider using [Curves.elasticIn].
message FlutterSrcAnimationElasticInCurve {
  // The duration of the oscillation.
  double period = 2;
}

// package:flutter/src/animation/curves.dart
//
// Creates an elastic-in-out curve.
//
// Rather than creating a new instance, consider using [Curves.elasticInOut].
message FlutterSrcAnimationElasticInOutCurve {
  // The duration of the oscillation.
  double period = 2;
}

// package:flutter/src/animation/curves.dart
//
// Creates an elastic-out curve.
//
// Rather than creating a new instance, consider using [Curves.elasticOut].
message FlutterSrcAnimationElasticOutCurve {
  // The duration of the oscillation.
  double period = 2;
}

// package:flutter/src/animation/curves.dart
//
// Creates a flipped curve.
message FlutterSrcAnimationFlippedCurve {
  // The curve that is being flipped.
  FlutterSrcAnimationCurveType curve = 2;
}

// package:flutter/src/animation/curves.dart
//
// Creates an interval curve.
message FlutterSrcAnimationInterval {
  // The largest value for which this interval is 0.0.
  //
  // From t=0.0 to t=[begin], the interval's value is 0.0.
  double begin = 2;
  // The smallest value for which this interval is 1.0.
  //
  // From t=[end] to t=1.0, the interval's value is 1.0.
  double end = 3;
  // The curve to apply between [begin] and [end].
  FlutterSrcAnimationCurveType curve = 4;
}

// package:flutter/src/animation/curves.dart
//
// Creates a sawtooth curve.
message FlutterSrcAnimationSawTooth {
  // The number of repetitions of the sawtooth pattern in the unit interval.
  int32 count = 2;
}

// package:flutter/src/animation/curves.dart
//
// Creates two cubic curves that share a common control point.
//
// Rather than creating a new instance, consider using one of the common
// three-point cubic curves in [Curves].
//
// The arguments correspond to the control points for the two curves,
// including the [midpoint], but do not include the two implied end points at
// (0,0) and (1,1), which are fixed.
message FlutterSrcAnimationThreePointCubic {
  // The coordinates of the first control point of the first curve.
  //
  // The line through the point (0, 0) and this control point is tangent to the
  // curve at the point (0, 0).
  DartOffsetType a1 = 2;
  // The coordinates of the second control point of the first curve.
  //
  // The line through the [midpoint] and this control point is tangent to the
  // curve approaching the [midpoint].
  DartOffsetType b1 = 3;
  // The coordinates of the middle shared point.
  //
  // The curve will go through this point. If the control points surrounding
  // this middle point ([b1], and [a2]) are not colinear with this point, then
  // the curve's derivative will have a discontinuity (a cusp) at this point.
  DartOffsetType midpoint = 4;
  // The coordinates of the first control point of the second curve.
  //
  // The line through the [midpoint] and this control point is tangent to the
  // curve approaching the [midpoint].
  DartOffsetType a2 = 5;
  // The coordinates of the second control point of the second curve.
  //
  // The line through the point (1, 1) and this control point is tangent to the
  // curve at (1, 1).
  DartOffsetType b2 = 6;
}

// package:flutter/src/animation/curves.dart
//
// Creates a threshold curve.
message FlutterSrcAnimationThreshold {
  // The value before which the curve is 0.0 and after which the curve is 1.0.
  //
  // When t is exactly [threshold], the curve has the value 1.0.
  double threshold = 2;
}

// package:flutter/src/semantics/semantics.dart
//
// Creates a attributed string.
//
// The [TextRange] in the [attributes] must be inside the length of the
// [string].
//
// The [attributes] must not be changed after the attributed string is
// created.
message FlutterSrcSemanticsAttributedString {
  // The plain string stored in the attributed string.
  string string = 2;
  // The attributes this string carries.
  //
  // The list must not be modified after this string is created.
  repeated DartStringAttributeType attributes = 3;
}

// package:flutter/src/semantics/semantics.dart
//
// Create a diagnostics property for an [AttributedString] object.
//
// Such properties are used with [SemanticsData] objects.
message FlutterSrcSemanticsAttributedStringProperty {
  string name = 2;
  FlutterSrcSemanticsAttributedStringType value = 3;
  bool show_name = 4;
  // Whether to show the property when the [value] is an [AttributedString]
  // whose [AttributedString.string] is the empty string.
  //
  // This overrides [defaultValue].
  bool show_when_empty = 5;
  FlutterDiagnosticLevelType.Enum level = 7;
  string description = 8;
}

// package:flutter/src/semantics/semantics.dart
//
// Creates a const semantics sort key that uses a [double] as its key value.
//
// The [order] must be a finite number.
message FlutterSrcSemanticsOrdinalSortKey {
  // Determines the placement of this key in a sequence of keys that defines
  // the order in which this node is traversed by the platform's accessibility
  // services.
  //
  // Lower values will be traversed first. Keys with the same [name] will be
  // grouped together and sorted by name first, and then sorted by [order].
  double order = 2;
  // An optional name that will group this sort key with other sort keys of the
  // same [name].
  //
  // Sort keys must have the same `runtimeType` when compared.
  //
  // Keys with no [name] are compared to other keys with no [name], and will
  // be traversed before those with a [name].
  string name = 3;
}

// package:flutter/src/semantics/semantics.dart
//
// Creates a semantics hint overrides.
message FlutterSrcSemanticsSemanticsHintOverrides {
  // The hint text for a tap action.
  //
  // If null, the standard hint is used instead.
  //
  // The hint should describe what happens when a tap occurs, not the
  // manner in which a tap is accomplished.
  //
  // Bad: 'Double tap to show movies'.
  // Good: 'show movies'.
  string on_tap_hint = 2;
  // The hint text for a long press action.
  //
  // If null, the standard hint is used instead.
  //
  // The hint should describe what happens when a long press occurs, not
  // the manner in which the long press is accomplished.
  //
  // Bad: 'Double tap and hold to show tooltip'.
  // Good: 'show tooltip'.
  string on_long_press_hint = 3;
}

// package:flutter/src/semantics/semantics.dart
//
// Creates a semantic node.
//
// Each semantic node has a unique identifier that is assigned when the node
// is created.
message FlutterSrcSemanticsSemanticsNode {
  // Uniquely identifies this node in the list of sibling nodes.
  //
  // Keys are used during the construction of the semantics tree. They are not
  // transferred to the engine.
  FlutterKeyType key = 2;
}

// package:flutter/src/semantics/semantics.dart
//
// Creates a semantic node to represent the root of the semantics tree.
//
// The root node is assigned an identifier of zero.
message FlutterSrcSemanticsSemanticsNodeNamedRoot {
  // Uniquely identifies this node in the list of sibling nodes.
  //
  // Keys are used during the construction of the semantics tree. They are not
  // transferred to the engine.
  FlutterKeyType key = 2;
}

// package:flutter/src/semantics/semantics.dart
//
// Creates a semantic annotation.
message FlutterSrcSemanticsSemanticsProperties {
  // If non-null, indicates that this subtree represents something that can be
  // in an enabled or disabled state.
  //
  // For example, a button that a user can currently interact with would set
  // this field to true. A button that currently does not respond to user
  // interactions would set this field to false.
  bool enabled = 2;
  // If non-null, indicates that this subtree represents a checkbox
  // or similar widget with a "checked" state, and what its current
  // state is.
  //
  // When the [Checkbox.value] of a tristate Checkbox is null,
  // indicating a mixed-state, this value shall be false, in which
  // case, [mixed] will be true.
  //
  // This is mutually exclusive with [toggled] and [mixed].
  bool checked = 3;
  // If non-null, indicates that this subtree represents a checkbox
  // or similar widget with a "half-checked" state or similar, and
  // whether it is currently in this half-checked state.
  //
  // This must be null when [Checkbox.tristate] is false, or
  // when the widget is not a checkbox. When a tristate
  // checkbox is fully unchecked/checked, this value shall
  // be false.
  //
  // This is mutually exclusive with [checked] and [toggled].
  bool mixed = 4;
  // If non-null, indicates that this subtree represents something
  // that can be in an "expanded" or "collapsed" state.
  //
  // For example, if a [SubmenuButton] is opened, this property
  // should be set to true; otherwise, this property should be
  // false.
  bool expanded = 5;
  // If non-null indicates that this subtree represents something that can be
  // in a selected or unselected state, and what its current state is.
  //
  // The active tab in a tab bar for example is considered "selected", whereas
  // all other tabs are unselected.
  bool selected = 6;
  // If non-null, indicates that this subtree represents a toggle switch
  // or similar widget with an "on" state, and what its current
  // state is.
  //
  // This is mutually exclusive with [checked] and [mixed].
  bool toggled = 7;
  // If non-null, indicates that this subtree represents a button.
  //
  // TalkBack/VoiceOver provides users with the hint "button" when a button
  // is focused.
  bool button = 8;
  // If non-null, indicates that this subtree represents a link.
  //
  // iOS's VoiceOver provides users with a unique hint when a link is focused.
  // Android's Talkback will announce a link hint the same way it does a
  // button.
  bool link = 9;
  // If non-null, indicates that this subtree represents a header.
  //
  // A header divides into sections. For example, an address book application
  // might define headers A, B, C, etc. to divide the list of alphabetically
  // sorted contacts into sections.
  bool header = 10;
  // If non-null, indicates that this subtree represents a text field.
  //
  // TalkBack/VoiceOver provide special affordances to enter text into a
  // text field.
  bool text_field = 11;
  // If non-null, indicates that this subtree represents a slider.
  //
  // Talkback/\VoiceOver provides users with the hint "slider" when a
  // slider is focused.
  bool slider = 12;
  // If non-null, indicates that this subtree represents a keyboard key.
  bool keyboard_key = 13;
  // If non-null, indicates that this subtree is read only.
  //
  // Only applicable when [textField] is true.
  //
  // TalkBack/VoiceOver will treat it as non-editable text field.
  bool read_only = 14;
  // If non-null, whether the node is able to hold input focus.
  //
  // If [focusable] is set to false, then [focused] must not be true.
  //
  // Input focus indicates that the node will receive keyboard events. It is not
  // to be confused with accessibility focus. Accessibility focus is the
  // green/black rectangular highlight that TalkBack/VoiceOver draws around the
  // element it is reading, and is separate from input focus.
  bool focusable = 15;
  // If non-null, whether the node currently holds input focus.
  //
  // At most one node in the tree should hold input focus at any point in time,
  // and it should not be set to true if [focusable] is false.
  //
  // Input focus indicates that the node will receive keyboard events. It is not
  // to be confused with accessibility focus. Accessibility focus is the
  // green/black rectangular highlight that TalkBack/VoiceOver draws around the
  // element it is reading, and is separate from input focus.
  bool focused = 16;
  // If non-null, whether a semantic node is in a mutually exclusive group.
  //
  // For example, a radio button is in a mutually exclusive group because only
  // one radio button in that group can be marked as [checked].
  bool in_mutually_exclusive_group = 17;
  // If non-null, whether the node is considered hidden.
  //
  // Hidden elements are currently not visible on screen. They may be covered
  // by other elements or positioned outside of the visible area of a viewport.
  //
  // Hidden elements cannot gain accessibility focus though regular touch. The
  // only way they can be focused is by moving the focus to them via linear
  // navigation.
  //
  // Platforms are free to completely ignore hidden elements and new platforms
  // are encouraged to do so.
  //
  // Instead of marking an element as hidden it should usually be excluded from
  // the semantics tree altogether. Hidden elements are only included in the
  // semantics tree to work around platform limitations and they are mainly
  // used to implement accessibility scrolling on iOS.
  bool hidden = 18;
  // If non-null, whether [value] should be obscured.
  //
  // This option is usually set in combination with [textField] to indicate
  // that the text field contains a password (or other sensitive information).
  // Doing so instructs screen readers to not read out the [value].
  bool obscured = 19;
  // Whether the [value] is coming from a field that supports multiline text
  // editing.
  //
  // This option is only meaningful when [textField] is true to indicate
  // whether it's a single-line or multiline text field.
  //
  // This option is null when [textField] is false.
  bool multiline = 20;
  // If non-null, whether the node corresponds to the root of a subtree for
  // which a route name should be announced.
  //
  // Generally, this is set in combination with
  // [SemanticsConfiguration.explicitChildNodes], since nodes with this flag
  // are not considered focusable by Android or iOS.
  //
  // See also:
  //
  //  * [SemanticsFlag.scopesRoute] for a description of how the announced
  //    value is selected.
  bool scopes_route = 21;
  // If non-null, whether the node contains the semantic label for a route.
  //
  // See also:
  //
  //  * [SemanticsFlag.namesRoute] for a description of how the name is used.
  bool names_route = 22;
  // If non-null, whether the node represents an image.
  //
  // See also:
  //
  //  * [SemanticsFlag.isImage], for the flag this setting controls.
  bool image = 23;
  // If non-null, whether the node should be considered a live region.
  //
  // A live region indicates that updates to semantics node are important.
  // Platforms may use this information to make polite announcements to the
  // user to inform them of updates to this node.
  //
  // An example of a live region is a [SnackBar] widget. On Android and iOS,
  // live region causes a polite announcement to be generated automatically,
  // even if the widget does not have accessibility focus. This announcement
  // may not be spoken if the OS accessibility services are already
  // announcing something else, such as reading the label of a focused widget
  // or providing a system announcement.
  //
  // See also:
  //
  //  * [SemanticsFlag.isLiveRegion], the semantics flag this setting controls.
  //  * [SemanticsConfiguration.liveRegion], for a full description of a live region.
  bool live_region = 24;
  // The maximum number of characters that can be entered into an editable
  // text field.
  //
  // For the purpose of this function a character is defined as one Unicode
  // scalar value.
  //
  // This should only be set when [textField] is true. Defaults to null,
  // which means no limit is imposed on the text field.
  int32 max_value_length = 25;
  // The current number of characters that have been entered into an editable
  // text field.
  //
  // For the purpose of this function a character is defined as one Unicode
  // scalar value.
  //
  // This should only be set when [textField] is true. Must be set when
  // [maxValueLength] is set.
  int32 current_value_length = 26;
  // {@template flutter.semantics.SemanticsProperties.identifier}
  // Provides an identifier for the semantics node in native accessibility hierarchy.
  //
  // This value is not exposed to the users of the app.
  //
  // It's usually used for UI testing with tools that work by querying the
  // native accessibility, like UIAutomator, XCUITest, or Appium.
  //
  // On Android, this is used for `AccessibilityNodeInfo.setViewIdResourceName`.
  // It'll be appear in accessibility hierarchy as `resource-id`.
  //
  // On iOS, this will set `UIAccessibilityElement.accessibilityIdentifier`.
  // {@endtemplate}
  string identifier = 27;
  // Provides a textual description of the widget.
  //
  // If a label is provided, there must either by an ambient [Directionality]
  // or an explicit [textDirection] should be provided.
  //
  // Callers must not provide both [label] and [attributedLabel]. One or both
  // must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.label] for a description of how this is exposed
  //    in TalkBack and VoiceOver.
  //  * [attributedLabel] for an [AttributedString] version of this property.
  string label = 28;
  // Provides an [AttributedString] version of textual description of the widget.
  //
  // If a [attributedLabel] is provided, there must either by an ambient
  // [Directionality] or an explicit [textDirection] should be provided.
  //
  // Callers must not provide both [label] and [attributedLabel]. One or both
  // must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.attributedLabel] for a description of how this
  //    is exposed in TalkBack and VoiceOver.
  //  * [label] for a plain string version of this property.
  FlutterSrcSemanticsAttributedStringType attributed_label = 29;
  // Provides a textual description of the value of the widget.
  //
  // If a value is provided, there must either by an ambient [Directionality]
  // or an explicit [textDirection] should be provided.
  //
  // Callers must not provide both [value] and [attributedValue], One or both
  // must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.value] for a description of how this is exposed
  //    in TalkBack and VoiceOver.
  //  * [attributedLabel] for an [AttributedString] version of this property.
  string value = 30;
  // Provides an [AttributedString] version of textual description of the value
  // of the widget.
  //
  // If a [attributedValue] is provided, there must either by an ambient
  // [Directionality] or an explicit [textDirection] should be provided.
  //
  // Callers must not provide both [value] and [attributedValue], One or both
  // must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.attributedValue] for a description of how this
  //    is exposed in TalkBack and VoiceOver.
  //  * [value] for a plain string version of this property.
  FlutterSrcSemanticsAttributedStringType attributed_value = 31;
  // The value that [value] or [attributedValue] will become after a
  // [SemanticsAction.increase] action has been performed on this widget.
  //
  // If a value is provided, [onIncrease] must also be set and there must
  // either be an ambient [Directionality] or an explicit [textDirection]
  // must be provided.
  //
  // Callers must not provide both [increasedValue] and
  // [attributedIncreasedValue], One or both must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.increasedValue] for a description of how this
  //    is exposed in TalkBack and VoiceOver.
  //  * [attributedIncreasedValue] for an [AttributedString] version of this
  //    property.
  string increased_value = 32;
  // The [AttributedString] that [value] or [attributedValue] will become after
  // a [SemanticsAction.increase] action has been performed on this widget.
  //
  // If a [attributedIncreasedValue] is provided, [onIncrease] must also be set
  // and there must either be an ambient [Directionality] or an explicit
  // [textDirection] must be provided.
  //
  // Callers must not provide both [increasedValue] and
  // [attributedIncreasedValue], One or both must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.attributedIncreasedValue] for a description of
  //    how this is exposed in TalkBack and VoiceOver.
  //  * [increasedValue] for a plain string version of this property.
  FlutterSrcSemanticsAttributedStringType attributed_increased_value = 33;
  // The value that [value] or [attributedValue] will become after a
  // [SemanticsAction.decrease] action has been performed on this widget.
  //
  // If a value is provided, [onDecrease] must also be set and there must
  // either be an ambient [Directionality] or an explicit [textDirection]
  // must be provided.
  //
  // Callers must not provide both [decreasedValue] and
  // [attributedDecreasedValue], One or both must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.decreasedValue] for a description of how this
  //    is exposed in TalkBack and VoiceOver.
  //  * [attributedDecreasedValue] for an [AttributedString] version of this
  //    property.
  string decreased_value = 34;
  // The [AttributedString] that [value] or [attributedValue] will become after
  // a [SemanticsAction.decrease] action has been performed on this widget.
  //
  // If a [attributedDecreasedValue] is provided, [onDecrease] must also be set
  // and there must either be an ambient [Directionality] or an explicit
  // [textDirection] must be provided.
  //
  // Callers must not provide both [decreasedValue] and
  // [attributedDecreasedValue], One or both must be null/// provided.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.attributedDecreasedValue] for a description of
  //    how this is exposed in TalkBack and VoiceOver.
  //  * [decreasedValue] for a plain string version of this property.
  FlutterSrcSemanticsAttributedStringType attributed_decreased_value = 35;
  // Provides a brief textual description of the result of an action performed
  // on the widget.
  //
  // If a hint is provided, there must either be an ambient [Directionality]
  // or an explicit [textDirection] should be provided.
  //
  // Callers must not provide both [hint] and [attributedHint], One or both
  // must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.hint] for a description of how this is exposed
  //    in TalkBack and VoiceOver.
  //  * [attributedHint] for an [AttributedString] version of this property.
  string hint = 36;
  // Provides a textual description of the widget's tooltip.
  //
  // In Android, this property sets the `AccessibilityNodeInfo.setTooltipText`.
  // In iOS, this property is appended to the end of the
  // `UIAccessibilityElement.accessibilityLabel`.
  //
  // If a [tooltip] is provided, there must either by an ambient
  // [Directionality] or an explicit [textDirection] should be provided.
  string tooltip = 37;
  // Provides an [AttributedString] version of brief textual description of the
  // result of an action performed on the widget.
  //
  // If a [attributedHint] is provided, there must either by an ambient
  // [Directionality] or an explicit [textDirection] should be provided.
  //
  // Callers must not provide both [hint] and [attributedHint], One or both
  // must be null.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.attributedHint] for a description of how this
  //    is exposed in TalkBack and VoiceOver.
  //  * [hint] for a plain string version of this property.
  FlutterSrcSemanticsAttributedStringType attributed_hint = 38;
  // Provides hint values which override the default hints on supported
  // platforms.
  //
  // On Android, If no hint overrides are used then default [hint] will be
  // combined with the [label]. Otherwise, the [hint] will be ignored as long
  // as there as at least one non-null hint override.
  //
  // On iOS, these are always ignored and the default [hint] is used instead.
  FlutterSrcSemanticsSemanticsHintOverridesType hint_overrides = 39;
  // The reading direction of the [label], [value], [increasedValue],
  // [decreasedValue], and [hint].
  //
  // Defaults to the ambient [Directionality].
  DartTextDirectionType.Enum text_direction = 40;
  // Determines the position of this node among its siblings in the traversal
  // sort order.
  //
  // This is used to describe the order in which the semantic node should be
  // traversed by the accessibility services on the platform (e.g. VoiceOver
  // on iOS and TalkBack on Android).
  FlutterSrcSemanticsSemanticsSortKeyType sort_key = 41;
  // A tag to be applied to the child [SemanticsNode]s of this widget.
  //
  // The tag is added to all child [SemanticsNode]s that pass through the
  // [RenderObject] corresponding to this widget while looking to be attached
  // to a parent SemanticsNode.
  //
  // Tags are used to communicate to a parent SemanticsNode that a child
  // SemanticsNode was passed through a particular RenderObject. The parent can
  // use this information to determine the shape of the semantics tree.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.addTagForChildren], to which the tags provided
  //    here will be passed.
  FlutterSrcSemanticsSemanticsTagType tag_for_children = 42;
}

// package:flutter/src/semantics/semantics.dart
//
// Creates a [SemanticsTag].
//
// The provided [name] is only used for debugging. Two tags created with the
// same [name] and the `new` operator are not considered identical. However,
// two tags created with the same [name] and the `const` operator are always
// identical.
message FlutterSrcSemanticsSemanticsTag {
  // A human-readable name for this tag used for debugging.
  //
  // This string is not used to determine if two tags are identical.
  string name = 2;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a stack layout widget.
//
// By default, the non-positioned children of the stack are aligned by their
// top left corners.
message FlutterStack {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How to align the non-positioned and partially-positioned children in the
  // stack.
  //
  // The non-positioned children are placed relative to each other such that
  // the points determined by [alignment] are co-located. For example, if the
  // [alignment] is [Alignment.topLeft], then the top left corner of
  // each non-positioned child will be located at the same global coordinate.
  //
  // Partially-positioned children, those that do not specify an alignment in a
  // particular axis (e.g. that have neither `top` nor `bottom` set), use the
  // alignment to determine how they should be positioned in that
  // under-specified axis.
  //
  // Defaults to [AlignmentDirectional.topStart].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 3;
  // The text direction with which to resolve [alignment].
  //
  // Defaults to the ambient [Directionality].
  DartTextDirectionType.Enum text_direction = 4;
  // How to size the non-positioned children in the stack.
  //
  // The constraints passed into the [Stack] from its parent are either
  // loosened ([StackFit.loose]) or tightened to their biggest size
  // ([StackFit.expand]).
  FlutterStackFitType.Enum fit = 5;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Stacks only clip children whose _geometry_ overflows the stack. A child
  // that paints outside its bounds (e.g. a box with a shadow) will not be
  // clipped, regardless of the value of this property. Similarly, a child that
  // itself has a descendant that overflows the stack will not be clipped, as
  // only the geometry of the stack's direct children are considered.
  // [Transform] is an example of a widget that can cause its children to paint
  // outside its geometry.
  //
  // To clip children whose geometry does not overflow the stack, consider
  // using a [ClipRect] widget.
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 6;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 7;
}

// package:flutter/src/painting/stadium_border.dart
//
// Create a stadium border.
message FlutterStadiumBorder {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
}

// package:flutter/src/painting/star_border.dart
//
// Create a const star-shaped border with the given number [points] on the
// star.
message FlutterStarBorder {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  // The number of points in this star, or sides on a polygon.
  //
  // This is a floating point number: if this is not a whole number, then an
  // additional star point or corner shorter than the others will be added to
  // finish the shape. Only whole-numbered values will yield a symmetric shape.
  // (This enables the number of points to be animated smoothly.)
  //
  // For stars created with [StarBorder], this is the number of points on
  // the star. For polygons created with [StarBorder.polygon], this is the
  // number of sides on the polygon.
  //
  // Must be greater than or equal to two.
  double points = 3;
  double inner_radius_ratio = 4;
  // The amount of rounding on the points of stars, or the corners of polygons.
  //
  // This is a value between zero and one which describes how rounded the point
  // or corner should be. A value of zero means no rounding (sharp corners),
  // and a value of one means that the entire point or corner is a portion of a
  // circle.
  //
  // Defaults to zero. The sum of [pointRounding] and [valleyRounding] must be
  // less than or equal to one.
  double point_rounding = 5;
  // The amount of rounding of the interior corners of stars.
  //
  // This is a value between zero and one which describes how rounded the inner
  // corners in a star (the "valley" between points) should be. A value of zero
  // means no rounding (sharp corners), and a value of one means that the
  // entire corner is a portion of a circle.
  //
  // Defaults to zero. The sum of [pointRounding] and [valleyRounding] must be
  // less than or equal to one. For polygons created with [StarBorder.polygon],
  // this will always be zero.
  double valley_rounding = 6;
  double rotation = 7;
  // How much of the aspect ratio of the attached widget to take on.
  //
  // If [squash] is non-zero, the border will match the aspect ratio of the
  // bounding box of the widget that it is attached to, which can give a
  // squashed appearance.
  //
  // The [squash] parameter lets you control how much of that aspect ratio this
  // border takes on.
  //
  // A value of zero means that the border will be drawn with a square aspect
  // ratio at the size of the shortest side of the bounding rectangle, ignoring
  // the aspect ratio of the widget, and a value of one means it will be drawn
  // with the aspect ratio of the widget. The value of [squash] has no effect
  // if the widget is square to begin with.
  //
  // Defaults to zero, and must be between zero and one, inclusive.
  double squash = 8;
}

// package:flutter/src/painting/star_border.dart
//
// Create a const polygon border with the given number of [sides].
message FlutterStarBorderNamedPolygon {
  // The border outline's color and weight.
  //
  // If [side] is [BorderSide.none], which is the default, an outline is not drawn.
  // Otherwise the outline is centered over the shape's boundary.
  FlutterBorderSideType side = 2;
  double sides = 3;
  // The amount of rounding on the points of stars, or the corners of polygons.
  //
  // This is a value between zero and one which describes how rounded the point
  // or corner should be. A value of zero means no rounding (sharp corners),
  // and a value of one means that the entire point or corner is a portion of a
  // circle.
  //
  // Defaults to zero. The sum of [pointRounding] and [valleyRounding] must be
  // less than or equal to one.
  double point_rounding = 4;
  double rotation = 5;
  // How much of the aspect ratio of the attached widget to take on.
  //
  // If [squash] is non-zero, the border will match the aspect ratio of the
  // bounding box of the widget that it is attached to, which can give a
  // squashed appearance.
  //
  // The [squash] parameter lets you control how much of that aspect ratio this
  // border takes on.
  //
  // A value of zero means that the border will be drawn with a square aspect
  // ratio at the size of the shortest side of the bounding rectangle, ignoring
  // the aspect ratio of the widget, and a value of one means it will be drawn
  // with the aspect ratio of the widget. The value of [squash] has no effect
  // if the widget is square to begin with.
  //
  // Defaults to zero, and must be between zero and one, inclusive.
  double squash = 6;
}

// package:flutter/src/widgets/framework.dart
//
// Creates an element that uses the given widget as its configuration.
message FlutterStatefulElement {
  FlutterStatefulWidgetType widget = 2;
}

// package:flutter/src/widgets/framework.dart
//
// Creates an element that uses the given widget as its configuration.
message FlutterStatelessElement {
  FlutterStatelessWidgetType widget = 2;
}

// package:flutter/src/widgets/overscroll_indicator.dart
//
// Creates a visual indication that a scroll view has overscrolled by
// applying a stretch transformation to the content.
//
// In order for this widget to display an overscroll indication, the [child]
// widget must contain a widget that generates a [ScrollNotification], such
// as a [ListView] or a [GridView].
message FlutterStretchingOverscrollIndicator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.overscroll.axisDirection}
  FlutterAxisDirectionType.Enum axis_direction = 3;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 5;
  // The widget below this widget in the tree.
  //
  // The overscroll indicator will apply a stretch effect to this child. This
  // child (and its subtree) should include a source of [ScrollNotification]
  // notifications.
  WidgetType child = 6;
}

// package:flutter/src/foundation/diagnostics.dart
//
// Create a diagnostics property for strings.
message FlutterStringProperty {
  string name = 2;
  string value = 3;
  string description = 4;
  // Optional tooltip typically describing the property.
  //
  // Example tooltip: 'physical pixels per logical pixel'
  //
  // If present, the tooltip is added in parenthesis after the raw value when
  // generating the string description.
  string tooltip = 5;
  bool show_name = 6;
  // Whether the value is enclosed in double quotes.
  bool quoted = 8;
  // Description if the property description would otherwise be empty.
  string if_empty = 9;
  FlutterDiagnosticsTreeStyleType.Enum style = 10;
  FlutterDiagnosticLevelType.Enum level = 11;
}

// package:flutter/src/painting/strut_style.dart
//
// Creates a strut style.
//
// The `package` argument must be non-null if the font family is defined in a
// package. It is combined with the `fontFamily` argument to set the
// [fontFamily] property.
//
// If provided, fontSize must be positive and non-zero, leading must be
// zero or positive.
message FlutterStrutStyle {
  string font_family = 2;
  repeated string font_family_fallback = 3;
  // The size of text (in logical pixels) to use when obtaining metrics from the font.
  //
  // The [fontSize] is used to get the base set of metrics that are then used to calculated
  // the metrics of strut. The height and leading are expressed as a multiple of
  // [fontSize].
  //
  // The default fontSize is 14 logical pixels.
  double font_size = 4;
  // The minimum height of the strut, as a multiple of [fontSize].
  //
  // When [height] is omitted or null, then the strut's height will be the sum
  // of the strut's font-defined ascent, its font-defined descent, and its
  // [leading]. The font's combined ascent and descent may be taller or shorter
  // than the [fontSize].
  //
  // When [height] is provided, the line's EM-square ascent and descent (which
  // sums to [fontSize]) will be scaled by [height] to achieve a final strut
  // height of `fontSize * height + fontSize * leading` logical pixels. The
  // following diagram illustrates the differences between the font metrics
  // defined height and the EM-square height:
  //
  // ![Text height diagram](https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_diagram.png)
  //
  // The ratio of ascent:descent with [height] specified is the same as the
  // font metrics defined ascent:descent ratio when [height] is null or omitted.
  //
  // See [TextStyle.height], which works in a similar manner.
  //
  // The default height is null.
  double height = 5;
  // How the vertical space added by the [height] multiplier should be
  // distributed over and under the strut.
  //
  // When a non-null [height] is specified, after accommodating the imaginary
  // strut glyph, the remaining vertical space from the allotted
  // `fontSize * height` logical pixels will be distributed over and under the
  // strut, according to the [leadingDistribution] property.
  //
  // The additional leading introduced by the [leading] property applies
  // independently of [leadingDistribution]: it will always be distributed
  // evenly over and under the strut, regardless of [leadingDistribution].
  //
  // Defaults to null, which defers to the paragraph's
  // `ParagraphStyle.textHeightBehavior`'s [leadingDistribution].
  DartTextLeadingDistributionType.Enum leading_distribution = 6;
  // The additional leading to apply to the strut as a multiple of [fontSize],
  // independent of [height] and [leadingDistribution].
  //
  // Leading is additional spacing between lines. Half of the leading is added
  // to the top and the other half to the bottom of the line. This differs
  // from [height] since the spacing is always equally distributed above and
  // below the baseline, regardless of [leadingDistribution].
  //
  // The default leading is null, which will use the font-specified leading.
  double leading = 7;
  // The typeface variant to use when calculating the strut (e.g., italics).
  //
  // The default fontStyle is [FontStyle.normal].
  DartFontStyleType.Enum font_style = 9;
  // Whether the strut height should be forced.
  //
  // When true, all lines will be laid out with the height of the
  // strut. All line and run-specific metrics will be ignored/overridden
  // and only strut metrics will be used instead. This property guarantees
  // uniform line spacing, however text in adjacent lines may overlap.
  //
  // This property should be enabled with caution as
  // it bypasses a large portion of the vertical layout system.
  //
  // This is equivalent to setting [TextStyle.height] to zero for all [TextStyle]s
  // in the paragraph. Since the height of each line is calculated as a max of the
  // metrics of each run of text, zero height [TextStyle]s cause the minimums
  // defined by strut to always manifest, resulting in all lines having the height
  // of the strut.
  //
  // The default is false.
  bool force_strut_height = 10;
  // A human-readable description of this strut style.
  //
  // This property is maintained only in debug builds.
  //
  // This property is not considered when comparing strut styles using `==` or
  // [compareTo], and it does not affect [hashCode].
  string debug_label = 11;
  string package = 12;
}

// package:flutter/src/painting/strut_style.dart
//
// Builds a StrutStyle that contains values of the equivalent properties in
// the provided [textStyle].
//
// The named parameters override the [textStyle]'s argument's properties.
// Since TextStyle does not contain [leading] or [forceStrutHeight], these
// values will take on default values (null and false) unless otherwise
// specified.
//
// If provided, fontSize must be positive and non-zero, leading must be
// zero or positive.
//
// When [textStyle] has a package and a new [package] is also specified,
// the entire font family fallback list should be redefined since the
// [textStyle]'s package data is inherited by being prepended onto the
// font family names. If [fontFamilyFallback] is meant to be empty, pass
// an empty list instead of null. This prevents the previous package name
// from being prepended twice.
message FlutterStrutStyleNamedFromTextStyle {
  FlutterTextStyleType text_style = 2;
  string font_family = 3;
  repeated string font_family_fallback = 4;
  double font_size = 5;
  double height = 6;
  DartTextLeadingDistributionType.Enum leading_distribution = 7;
  // The additional leading to apply to the strut as a multiple of [fontSize],
  // independent of [height] and [leadingDistribution].
  //
  // Leading is additional spacing between lines. Half of the leading is added
  // to the top and the other half to the bottom of the line. This differs
  // from [height] since the spacing is always equally distributed above and
  // below the baseline, regardless of [leadingDistribution].
  //
  // The default leading is null, which will use the font-specified leading.
  double leading = 8;
  DartFontStyleType.Enum font_style = 10;
  // Whether the strut height should be forced.
  //
  // When true, all lines will be laid out with the height of the
  // strut. All line and run-specific metrics will be ignored/overridden
  // and only strut metrics will be used instead. This property guarantees
  // uniform line spacing, however text in adjacent lines may overlap.
  //
  // This property should be enabled with caution as
  // it bypasses a large portion of the vertical layout system.
  //
  // This is equivalent to setting [TextStyle.height] to zero for all [TextStyle]s
  // in the paragraph. Since the height of each line is calculated as a max of the
  // metrics of each run of text, zero height [TextStyle]s cause the minimums
  // defined by strut to always manifest, resulting in all lines having the height
  // of the strut.
  //
  // The default is false.
  bool force_strut_height = 11;
  string debug_label = 12;
  string package = 13;
}

// package:flutter/src/painting/gradient.dart
//
// Creates a sweep gradient.
//
// If [stops] is non-null, it must have the same length as [colors].
message FlutterSweepGradient {
  // The center of the gradient, as an offset into the (-1.0, -1.0) x (1.0, 1.0)
  // square describing the gradient which will be mapped onto the paint box.
  //
  // For example, an alignment of (0.0, 0.0) will place the sweep
  // gradient in the center of the box.
  //
  // If this is an [Alignment], then it is expressed as a vector from
  // coordinate (0.0, 0.0), in a coordinate space that maps the center of the
  // paint box at (0.0, 0.0) and the bottom right at (1.0, 1.0).
  //
  // It can also be an [AlignmentDirectional], where the start is the left in
  // left-to-right contexts and the right in right-to-left contexts. If a
  // text-direction-dependent value is provided here, then the [createShader]
  // method will need to be given a [TextDirection].
  FlutterAlignmentGeometryType center = 2;
  // The angle in radians at which stop 0.0 of the gradient is placed.
  //
  // Defaults to 0.0.
  double start_angle = 3;
  // The angle in radians at which stop 1.0 of the gradient is placed.
  //
  // Defaults to math.pi * 2.
  double end_angle = 4;
  // The colors the gradient should obtain at each of the stops.
  //
  // If [stops] is non-null, this list must have the same length as [stops].
  //
  // This list must have at least two colors in it (otherwise, it's not a
  // gradient!).
  repeated DartColorType colors = 5;
  // A list of values from 0.0 to 1.0 that denote fractions along the gradient.
  //
  // If non-null, this list must have the same length as [colors].
  //
  // If the first value is not 0.0, then a stop with position 0.0 and a color
  // equal to the first color in [colors] is implied.
  //
  // If the last value is not 1.0, then a stop with position 1.0 and a color
  // equal to the last color in [colors] is implied.
  //
  // The values in the [stops] list must be in ascending order. If a value in
  // the [stops] list is less than an earlier value in the list, then its value
  // is assumed to equal the previous value.
  //
  // If stops is null, then a set of uniformly distributed stops is implied,
  // with the first stop at 0.0 and the last stop at 1.0.
  repeated double stops = 6;
  // How this gradient should tile the plane beyond in the region before
  // [startAngle] and after [endAngle].
  //
  // For details, see [TileMode].
  //
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png)
  // ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png)
  DartTileModeType.Enum tile_mode = 7;
  // The transform, if any, to apply to the gradient.
  //
  // This transform is in addition to any other transformations applied to the
  // canvas, but does not add any transformations to the canvas.
  FlutterGradientTransformType transform = 8;
}

// package:flutter/src/services/system_chrome.dart
//
// Creates a new [SystemUiOverlayStyle].
message FlutterSystemUiOverlayStyle {
  // The color of the system bottom navigation bar.
  //
  // Only honored in Android versions O and greater.
  DartColorType system_navigation_bar_color = 2;
  // The color of the divider between the system's bottom navigation bar and the app's content.
  //
  // Only honored in Android versions P and greater.
  DartColorType system_navigation_bar_divider_color = 3;
  // The brightness of the system navigation bar icons.
  //
  // Only honored in Android versions O and greater.
  // When set to [Brightness.light], the system navigation bar icons are light.
  // When set to [Brightness.dark], the system navigation bar icons are dark.
  DartBrightnessType.Enum system_navigation_bar_icon_brightness = 4;
  // Overrides the contrast enforcement when setting a transparent navigation
  // bar.
  //
  // When setting a transparent navigation bar in SDK 29+, or Android 10 and up,
  // a translucent body scrim may be applied behind the button navigation bar
  // to ensure contrast with buttons and the background of the application.
  //
  // SDK 28-, or Android P and lower, will not apply this body scrim.
  //
  // Setting this to false overrides the default body scrim.
  //
  // See also:
  //
  //   * [SystemUiOverlayStyle.systemNavigationBarColor], which is overridden
  //   when transparent to enforce this contrast policy.
  bool system_navigation_bar_contrast_enforced = 5;
  // The color of top status bar.
  //
  // Only honored in Android version M and greater.
  DartColorType status_bar_color = 6;
  // The brightness of top status bar.
  //
  // Only honored in iOS.
  DartBrightnessType.Enum status_bar_brightness = 7;
  // The brightness of the top status bar icons.
  //
  // Only honored in Android version M and greater.
  DartBrightnessType.Enum status_bar_icon_brightness = 8;
  // Overrides the contrast enforcement when setting a transparent status
  // bar.
  //
  // When setting a transparent status bar in SDK 29+, or Android 10 and up,
  // a translucent body scrim may be applied to ensure contrast with icons and
  // the background of the application.
  //
  // SDK 28-, or Android P and lower, will not apply this body scrim.
  //
  // Setting this to false overrides the default body scrim.
  //
  // See also:
  //
  //   * [SystemUiOverlayStyle.statusBarColor], which is overridden
  //   when transparent to enforce this contrast policy.
  bool system_status_bar_contrast_enforced = 9;
}

// package:flutter/src/widgets/table.dart
//
// Creates a table.
message FlutterTable {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The rows of the table.
  //
  // Every row in a table must have the same number of children.
  repeated FlutterTableRowType children = 3;
  // How to determine with widths of columns that don't have an explicit sizing
  // algorithm.
  //
  // Specifically, the [defaultColumnWidth] is used for column `i` if
  // `columnWidths[i]` is null. Defaults to [FlexColumnWidth], which will
  // divide the remaining horizontal space up evenly between columns of the
  // same type [TableColumnWidth].
  //
  // A [Table] in a horizontal [ScrollView] must use a [FixedColumnWidth], or
  // an [IntrinsicColumnWidth] as the horizontal space is infinite.
  FlutterTableColumnWidthType default_column_width = 5;
  // The direction in which the columns are ordered.
  //
  // Defaults to the ambient [Directionality].
  DartTextDirectionType.Enum text_direction = 6;
  // The style to use when painting the boundary and interior divisions of the table.
  FlutterTableBorderType border = 7;
  // How cells that do not explicitly specify a vertical alignment are aligned vertically.
  //
  // Cells may specify a vertical alignment by wrapping their contents in a
  // [TableCell] widget.
  FlutterTableCellVerticalAlignmentType.Enum default_vertical_alignment = 8;
  // The text baseline to use when aligning rows using [TableCellVerticalAlignment.baseline].
  //
  // This must be set if using baseline alignment. There is no default because there is no
  // way for the framework to know the correct baseline _a priori_.
  DartTextBaselineType.Enum text_baseline = 9;
}

// package:flutter/src/rendering/table_border.dart
//
// Creates a border for a table.
//
// All the sides of the border default to [BorderSide.none].
message FlutterTableBorder {
  // The top side of this border.
  FlutterBorderSideType top = 2;
  // The right side of this border.
  FlutterBorderSideType right = 3;
  // The bottom side of this border.
  FlutterBorderSideType bottom = 4;
  // The left side of this border.
  FlutterBorderSideType left = 5;
  // The horizontal interior sides of this border.
  FlutterBorderSideType horizontal_inside = 6;
  // The vertical interior sides of this border.
  FlutterBorderSideType vertical_inside = 7;
  // The [BorderRadius] to use when painting the corners of this border.
  //
  // It is also applied to [DataTable]'s [Material].
  FlutterBorderRadiusType border_radius = 8;
}

// package:flutter/src/rendering/table_border.dart
//
// A uniform border with all sides the same color and width.
//
// The sides default to black solid borders, one logical pixel wide.
message FlutterTableBorderNamedAll {
  DartColorType color = 2;
  double width = 3;
  FlutterBorderStyleType.Enum style = 4;
  FlutterBorderRadiusType border_radius = 5;
}

// package:flutter/src/rendering/table_border.dart
//
// Creates a border for a table where all the interior sides use the same
// styling and all the exterior sides use the same styling.
message FlutterTableBorderNamedSymmetric {
  FlutterBorderSideType inside = 2;
  FlutterBorderSideType outside = 3;
}

// package:flutter/src/widgets/table.dart
//
// Creates a widget that controls how a child of a [Table] is aligned.
message FlutterTableCell {
  FlutterKeyType key = 2;
  // How this cell is aligned vertically.
  FlutterTableCellVerticalAlignmentType.Enum vertical_alignment = 3;
  WidgetType child = 4;
}

// package:flutter/src/widgets/table.dart
//
// Creates a row in a [Table].
message FlutterTableRow {
  // An identifier for the row.
  FlutterLocalKeyType key = 2;
  // A decoration to paint behind this row.
  //
  // Row decorations fill the horizontal and vertical extent of each row in
  // the table, unlike decorations for individual cells, which might not fill
  // either.
  FlutterDecorationType decoration = 3;
  // The widgets that comprise the cells in this row.
  //
  // Children may be wrapped in [TableCell] widgets to provide per-cell
  // configuration to the [Table], but children are not required to be wrapped
  // in [TableCell] widgets.
  repeated WidgetType children = 4;
}

// package:flutter/src/gestures/tap_and_drag.dart
//
// Create a gesture recognizer for interactions in the horizontal axis.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterTapAndHorizontalDragGestureRecognizer {
  
}

// package:flutter/src/gestures/tap_and_drag.dart
//
// Create a gesture recognizer for interactions on a plane.
message FlutterTapAndPanGestureRecognizer {
  
}

// package:flutter/src/gestures/tap.dart
//
// Creates a tap gesture recognizer.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterTapGestureRecognizer {
  
}

// package:flutter/src/widgets/tap_region.dart
//
// Creates a const [TapRegion].
//
// The [child] argument is required.
message FlutterTapRegion {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // Whether or not this [TapRegion] is enabled as part of the composite region.
  bool enabled = 4;
  // How to behave during hit testing when deciding how the hit test propagates
  // to children and whether to consider targets behind this [TapRegion].
  //
  // Defaults to [HitTestBehavior.deferToChild].
  //
  // See [HitTestBehavior] for the allowed values and their meanings.
  FlutterHitTestBehaviorType.Enum behavior = 5;
  // If true, then the group that this region belongs to will stop the
  // propagation of the tap down event in the gesture arena.
  //
  // This is useful if you want to block the tap down from being given to a
  // [GestureDetector] when [onTapOutside] is called.
  //
  // If other [TapRegion]s with the same [groupId] have [consumeOutsideTaps]
  // set to false, but this one is true, then this one will take precedence,
  // and the event will be consumed.
  //
  // Defaults to false.
  bool consume_outside_taps = 9;
  string debug_label = 10;
}

// package:flutter/src/widgets/tap_region.dart
//
// Creates a const [RenderTapRegionSurface].
//
// The [child] attribute is required.
message FlutterTapRegionSurface {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/widgets/text.dart
//
// Creates a text widget.
//
// If the [style] argument is null, the text will use the style from the
// closest enclosing [DefaultTextStyle].
//
// The [overflow] property's behavior is affected by the [softWrap] argument.
// If the [softWrap] is true or null, the glyph causing overflow, and those
// that follow, will not be rendered. Otherwise, it will be shown with the
// given overflow option.
message FlutterText {
  // The text to display.
  //
  // This will be null if a [textSpan] is provided instead.
  string data = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  // If non-null, the style to use for this text.
  //
  // If the style's "inherit" property is true, the style will be merged with
  // the closest enclosing [DefaultTextStyle]. Otherwise, the style will
  // replace the closest enclosing [DefaultTextStyle].
  FlutterTextStyleType style = 4;
  // {@macro flutter.painting.textPainter.strutStyle}
  FlutterStrutStyleType strut_style = 5;
  // How the text should be aligned horizontally.
  DartTextAlignType.Enum text_align = 6;
  // The directionality of the text.
  //
  // This decides how [textAlign] values like [TextAlign.start] and
  // [TextAlign.end] are interpreted.
  //
  // This is also used to disambiguate how to render bidirectional text. For
  // example, if the [data] is an English phrase followed by a Hebrew phrase,
  // in a [TextDirection.ltr] context the English phrase will be on the left
  // and the Hebrew phrase to its right, while in a [TextDirection.rtl]
  // context, the English phrase will be on the right and the Hebrew phrase on
  // its left.
  //
  // Defaults to the ambient [Directionality], if any.
  DartTextDirectionType.Enum text_direction = 7;
  // Used to select a font when the same Unicode character can
  // be rendered differently, depending on the locale.
  //
  // It's rarely necessary to set this property. By default its value
  // is inherited from the enclosing app with `Localizations.localeOf(context)`.
  //
  // See [RenderParagraph.locale] for more information.
  DartLocaleType locale = 8;
  // Whether the text should break at soft line breaks.
  //
  // If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.
  bool soft_wrap = 9;
  // How visual overflow should be handled.
  //
  // If this is null [TextStyle.overflow] will be used, otherwise the value
  // from the nearest [DefaultTextStyle] ancestor will be used.
  FlutterTextOverflowType.Enum overflow = 10;
  // {@macro flutter.painting.textPainter.textScaler}
  FlutterTextScalerType text_scaler = 11;
  // An optional maximum number of lines for the text to span, wrapping if necessary.
  // If the text exceeds the given number of lines, it will be truncated according
  // to [overflow].
  //
  // If this is 1, text will not wrap. Otherwise, text will be wrapped at the
  // edge of the box.
  //
  // If this is null, but there is an ambient [DefaultTextStyle] that specifies
  // an explicit number for its [DefaultTextStyle.maxLines], then the
  // [DefaultTextStyle] value will take precedence. You can use a [RichText]
  // widget directly to entirely override the [DefaultTextStyle].
  int32 max_lines = 12;
  // {@template flutter.widgets.Text.semanticsLabel}
  // An alternative semantics label for this text.
  //
  // If present, the semantics of this widget will contain this value instead
  // of the actual text. This will overwrite any of the semantics labels applied
  // directly to the [TextSpan]s.
  //
  // This is useful for replacing abbreviations or shorthands with the full
  // text value:
  //
  // ```dart
  // const Text(r'$$', semanticsLabel: 'Double dollars')
  // ```
  // {@endtemplate}
  string semantics_label = 13;
  // {@macro flutter.painting.textPainter.textWidthBasis}
  FlutterTextWidthBasisType.Enum text_width_basis = 14;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 15;
  // The color to use when painting the selection.
  //
  // This is ignored if [SelectionContainer.maybeOf] returns null
  // in the [BuildContext] of the [Text] widget.
  //
  // If null, the ambient [DefaultSelectionStyle] is used (if any); failing
  // that, the selection color defaults to [DefaultSelectionStyle.defaultColor]
  // (semi-transparent grey).
  DartColorType selection_color = 16;
}

// package:flutter/src/painting/alignment.dart
//
// Creates a TextAlignVertical from any y value between -1.0 and 1.0.
message FlutterTextAlignVertical {
  // A value ranging from -1.0 to 1.0 that defines the topmost and bottommost
  // locations of the top and bottom of the input box.
  double y = 2;
}

// package:flutter/src/widgets/editable_text.dart
//
// Creates a controller for an editable text field.
//
// This constructor treats a null [text] argument as if it were the empty
// string.
message FlutterTextEditingController {
  string text = 2;
}

// package:flutter/src/widgets/editable_text.dart
//
// Creates a controller for an editable text field from an initial [TextEditingValue].
//
// This constructor treats a null [value] argument as if it were
// [TextEditingValue.empty].
message FlutterTextEditingControllerNamedFromValue {
  FlutterTextEditingValueType value = 2;
}

// package:flutter/src/services/text_input.dart
//
// Creates information for editing a run of text.
//
// The selection and composing range must be within the text. This is not
// checked during construction, and must be guaranteed by the caller.
//
// The default value of [selection] is `TextSelection.collapsed(offset: -1)`.
// This indicates that there is no selection at all.
message FlutterTextEditingValue {
  // The current text being edited.
  string text = 2;
  // The range of text that is currently selected.
  //
  // When [selection] is a [TextSelection] that has the same non-negative
  // `baseOffset` and `extentOffset`, the [selection] property represents the
  // caret position.
  //
  // If the current [selection] has a negative `baseOffset` or `extentOffset`,
  // then the text currently does not have a selection or a caret location, and
  // most text editing operations that rely on the current selection (for
  // instance, insert a character at the caret location) will do nothing.
  FlutterTextSelectionType selection = 3;
  // The range of text that is still being composed.
  //
  // Composing regions are created by input methods (IMEs) to indicate the text
  // within a certain range is provisional. For instance, the Android Gboard
  // app's English keyboard puts the current word under the caret into a
  // composing region to indicate the word is subject to autocorrect or
  // prediction changes.
  //
  // Composing regions can also be used for performing multistage input, which
  // is typically used by IMEs designed for phonetic keyboard to enter
  // ideographic symbols. As an example, many CJK keyboards require the user to
  // enter a Latin alphabet sequence and then convert it to CJK characters. On
  // iOS, the default software keyboards do not have a dedicated view to show
  // the unfinished Latin sequence, so it's displayed directly in the text
  // field, inside of a composing region.
  //
  // The composing region should typically only be changed by the IME, or the
  // user via interacting with the IME.
  //
  // If the range represented by this property is [TextRange.empty], then the
  // text is not currently being composed.
  DartTextRangeType composing = 4;
}

// package:flutter/src/widgets/tap_region.dart
//
// Creates a const [TextFieldTapRegion].
//
// The [child] field is required.
message FlutterTextFieldTapRegion {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // Whether or not this [TapRegion] is enabled as part of the composite region.
  bool enabled = 4;
  // If true, then the group that this region belongs to will stop the
  // propagation of the tap down event in the gesture arena.
  //
  // This is useful if you want to block the tap down from being given to a
  // [GestureDetector] when [onTapOutside] is called.
  //
  // If other [TapRegion]s with the same [groupId] have [consumeOutsideTaps]
  // set to false, but this one is true, then this one will take precedence,
  // and the event will be consumed.
  //
  // Defaults to false.
  bool consume_outside_taps = 7;
  string debug_label = 8;
}

// package:flutter/src/services/text_input.dart
//
// Optimize for numerical information.
//
// Requests a numeric keyboard with additional settings.
// The [signed] and [decimal] parameters are optional.
message FlutterTextInputTypeNamedNumberWithOptions {
  // The number is signed, allowing a positive or negative sign at the start.
  //
  // This flag is only used for the [number] input type, otherwise `null`.
  // Use `const TextInputType.numberWithOptions(signed: true)` to set this.
  bool signed = 2;
  // The number is decimal, allowing a decimal point to provide fractional.
  //
  // This flag is only used for the [number] input type, otherwise `null`.
  // Use `const TextInputType.numberWithOptions(decimal: true)` to set this.
  bool decimal = 3;
}

// package:flutter/src/widgets/magnifier.dart
//
// Constructs a [TextMagnifierConfiguration] from parts.
//
// If [magnifierBuilder] is null, a default [MagnifierBuilder] will be used
// that never builds a magnifier.
message FlutterTextMagnifierConfiguration {
  // Determines whether a magnifier should show the text editing handles or not.
  bool should_display_handles_in_magnifier = 3;
}

// package:flutter/src/widgets/text.dart
//
// Creates a text widget with a [InlineSpan].
//
// The following subclasses of [InlineSpan] may be used to build rich text:
//
// * [TextSpan]s define text and children [InlineSpan]s.
// * [WidgetSpan]s define embedded inline widgets.
//
// See [RichText] which provides a lower-level way to draw text.
message FlutterTextNamedRich {
  // The text to display as a [InlineSpan].
  //
  // This will be null if [data] is provided instead.
  FlutterInlineSpanType text_span = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  // If non-null, the style to use for this text.
  //
  // If the style's "inherit" property is true, the style will be merged with
  // the closest enclosing [DefaultTextStyle]. Otherwise, the style will
  // replace the closest enclosing [DefaultTextStyle].
  FlutterTextStyleType style = 4;
  // {@macro flutter.painting.textPainter.strutStyle}
  FlutterStrutStyleType strut_style = 5;
  // How the text should be aligned horizontally.
  DartTextAlignType.Enum text_align = 6;
  // The directionality of the text.
  //
  // This decides how [textAlign] values like [TextAlign.start] and
  // [TextAlign.end] are interpreted.
  //
  // This is also used to disambiguate how to render bidirectional text. For
  // example, if the [data] is an English phrase followed by a Hebrew phrase,
  // in a [TextDirection.ltr] context the English phrase will be on the left
  // and the Hebrew phrase to its right, while in a [TextDirection.rtl]
  // context, the English phrase will be on the right and the Hebrew phrase on
  // its left.
  //
  // Defaults to the ambient [Directionality], if any.
  DartTextDirectionType.Enum text_direction = 7;
  // Used to select a font when the same Unicode character can
  // be rendered differently, depending on the locale.
  //
  // It's rarely necessary to set this property. By default its value
  // is inherited from the enclosing app with `Localizations.localeOf(context)`.
  //
  // See [RenderParagraph.locale] for more information.
  DartLocaleType locale = 8;
  // Whether the text should break at soft line breaks.
  //
  // If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.
  bool soft_wrap = 9;
  // How visual overflow should be handled.
  //
  // If this is null [TextStyle.overflow] will be used, otherwise the value
  // from the nearest [DefaultTextStyle] ancestor will be used.
  FlutterTextOverflowType.Enum overflow = 10;
  // {@macro flutter.painting.textPainter.textScaler}
  FlutterTextScalerType text_scaler = 11;
  // An optional maximum number of lines for the text to span, wrapping if necessary.
  // If the text exceeds the given number of lines, it will be truncated according
  // to [overflow].
  //
  // If this is 1, text will not wrap. Otherwise, text will be wrapped at the
  // edge of the box.
  //
  // If this is null, but there is an ambient [DefaultTextStyle] that specifies
  // an explicit number for its [DefaultTextStyle.maxLines], then the
  // [DefaultTextStyle] value will take precedence. You can use a [RichText]
  // widget directly to entirely override the [DefaultTextStyle].
  int32 max_lines = 12;
  // {@template flutter.widgets.Text.semanticsLabel}
  // An alternative semantics label for this text.
  //
  // If present, the semantics of this widget will contain this value instead
  // of the actual text. This will overwrite any of the semantics labels applied
  // directly to the [TextSpan]s.
  //
  // This is useful for replacing abbreviations or shorthands with the full
  // text value:
  //
  // ```dart
  // const Text(r'$$', semanticsLabel: 'Double dollars')
  // ```
  // {@endtemplate}
  string semantics_label = 13;
  // {@macro flutter.painting.textPainter.textWidthBasis}
  FlutterTextWidthBasisType.Enum text_width_basis = 14;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 15;
  // The color to use when painting the selection.
  //
  // This is ignored if [SelectionContainer.maybeOf] returns null
  // in the [BuildContext] of the [Text] widget.
  //
  // If null, the ambient [DefaultSelectionStyle] is used (if any); failing
  // that, the selection color defaults to [DefaultSelectionStyle.defaultColor]
  // (semi-transparent grey).
  DartColorType selection_color = 16;
}

// package:flutter/src/painting/text_scaler.dart
//
// Creates a proportional [TextScaler] that scales the incoming font size by
// multiplying it with the given `textScaleFactor`.
message FlutterTextScalerNamedLinear {
  double text_scale_factor = 2;
}

// package:flutter/src/services/text_editing.dart
//
// Creates a text selection.
message FlutterTextSelection {
  // The offset at which the selection originates.
  //
  // Might be larger than, smaller than, or equal to extent.
  int32 base_offset = 2;
  // The offset at which the selection terminates.
  //
  // When the user uses the arrow keys to adjust the selection, this is the
  // value that changes. Similarly, if the current theme paints a caret on one
  // side of the selection, this is the location at which to paint the caret.
  //
  // Might be larger than, smaller than, or equal to base.
  int32 extent_offset = 3;
  // If the text range is collapsed and has more than one visual location
  // (e.g., occurs at a line break), which of the two locations to use when
  // painting the caret.
  DartTextAffinityType.Enum affinity = 4;
  // Whether this selection has disambiguated its base and extent.
  //
  // On some platforms, the base and extent are not disambiguated until the
  // first time the user adjusts the selection. At that point, either the start
  // or the end of the selection becomes the base and the other one becomes the
  // extent and is adjusted.
  bool is_directional = 5;
}

// package:flutter/src/widgets/text_selection.dart
//
// Create a [TextSelectionGestureDetector].
//
// Multiple callbacks can be called for one sequence of input gesture.
message FlutterTextSelectionGestureDetector {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether [onUserTap] will be called for all taps including consecutive taps.
  //
  // Defaults to false, so [onUserTap] is only called for each distinct tap.
  bool on_user_tap_always_called = 21;
  // How this gesture detector should behave during hit testing.
  //
  // This defaults to [HitTestBehavior.deferToChild].
  FlutterHitTestBehaviorType.Enum behavior = 22;
  // Child below this widget.
  WidgetType child = 23;
}

// package:flutter/src/services/text_editing.dart
//
// Creates a collapsed selection at the given offset.
//
// A collapsed selection starts and ends at the same offset, which means it
// contains zero characters but instead serves as an insertion point in the
// text.
message FlutterTextSelectionNamedCollapsed {
  int32 offset = 2;
  // If the text range is collapsed and has more than one visual location
  // (e.g., occurs at a line break), which of the two locations to use when
  // painting the caret.
  DartTextAffinityType.Enum affinity = 3;
}

// package:flutter/src/services/text_editing.dart
//
// Creates a collapsed selection at the given text position.
//
// A collapsed selection starts and ends at the same offset, which means it
// contains zero characters but instead serves as an insertion point in the
// text.
message FlutterTextSelectionNamedFromPosition {
  DartTextPositionType position = 2;
}

// package:flutter/src/rendering/editable.dart
//
// Creates a description of a point in a text selection.
message FlutterTextSelectionPoint {
  // Coordinates of the lower left or lower right corner of the selection,
  // relative to the top left of the [RenderEditable] object.
  DartOffsetType point = 2;
  // Direction of the text at this edge of the selection.
  DartTextDirectionType.Enum direction = 3;
}

// package:flutter/src/widgets/text_selection_toolbar_anchors.dart
//
// Creates an instance of [TextSelectionToolbarAnchors] directly from the
// anchor points.
message FlutterTextSelectionToolbarAnchors {
  // The location that the toolbar should attempt to position itself at.
  //
  // If the toolbar doesn't fit at this location, use [secondaryAnchor] if it
  // exists.
  DartOffsetType primary_anchor = 2;
  // The fallback position that should be used if [primaryAnchor] doesn't work.
  DartOffsetType secondary_anchor = 3;
}

// package:flutter/src/widgets/text_selection_toolbar_anchors.dart
//
// Creates an instance of [TextSelectionToolbarAnchors] for some selection.
message FlutterTextSelectionToolbarAnchorsNamedFromSelection {
  FlutterRenderBoxType render_box = 2;
  double start_glyph_height = 3;
  double end_glyph_height = 4;
  repeated FlutterTextSelectionPointType selection_endpoints = 5;
}

// package:flutter/src/widgets/text_selection_toolbar_layout_delegate.dart
//
// Creates an instance of TextSelectionToolbarLayoutDelegate.
message FlutterTextSelectionToolbarLayoutDelegate {
  // {@macro flutter.material.TextSelectionToolbar.anchorAbove}
  //
  // Should be provided in local coordinates.
  DartOffsetType anchor_above = 2;
  // {@macro flutter.material.TextSelectionToolbar.anchorAbove}
  //
  // Should be provided in local coordinates.
  DartOffsetType anchor_below = 3;
  // Whether or not the child should be considered to fit above anchorAbove.
  //
  // Typically used to force the child to be drawn at anchorAbove even when it
  // doesn't fit, such as when the Material [TextSelectionToolbar] draws an
  // open overflow menu.
  //
  // If not provided, it will be calculated.
  bool fits_above = 4;
}

// package:flutter/src/painting/text_span.dart
//
// Creates a [TextSpan] with the given values.
//
// For the object to be useful, at least one of [text] or
// [children] should be set.
message FlutterTextSpan {
  // The text contained in this span.
  //
  // If both [text] and [children] are non-null, the text will precede the
  // children.
  //
  // This getter does not include the contents of its children.
  string text = 2;
  // Additional spans to include as children.
  //
  // If both [text] and [children] are non-null, the text will precede the
  // children.
  //
  // Modifying the list after the [TextSpan] has been created is not supported
  // and may have unexpected results.
  //
  // The list must not contain any nulls.
  repeated FlutterInlineSpanType children = 3;
  // The [TextStyle] to apply to this span.
  //
  // The [style] is also applied to any child spans when this is an instance
  // of [TextSpan].
  FlutterTextStyleType style = 4;
  // A gesture recognizer that will receive events that hit this span.
  //
  // [InlineSpan] itself does not implement hit testing or event dispatch. The
  // object that manages the [InlineSpan] painting is also responsible for
  // dispatching events. In the rendering library, that is the
  // [RenderParagraph] object, which corresponds to the [RichText] widget in
  // the widgets layer; these objects do not bubble events in [InlineSpan]s,
  // so a [recognizer] is only effective for events that directly hit the
  // [text] of that [InlineSpan], not any of its [children].
  //
  // [InlineSpan] also does not manage the lifetime of the gesture recognizer.
  // The code that owns the [GestureRecognizer] object must call
  // [GestureRecognizer.dispose] when the [InlineSpan] object is no longer
  // used.
  //
  // {@tool snippet}
  //
  // This example shows how to manage the lifetime of a gesture recognizer
  // provided to an [InlineSpan] object. It defines a `BuzzingText` widget
  // which uses the [HapticFeedback] class to vibrate the device when the user
  // long-presses the "find the" span, which is underlined in wavy green. The
  // hit-testing is handled by the [RichText] widget. It also changes the
  // hovering mouse cursor to `precise`.
  //
  // ```dart
  // class BuzzingText extends StatefulWidget {
  //   const BuzzingText({super.key});
  //
  //   @override
  //   State<BuzzingText> createState() => _BuzzingTextState();
  // }
  //
  // class _BuzzingTextState extends State<BuzzingText> {
  //   late LongPressGestureRecognizer _longPressRecognizer;
  //
  //   @override
  //   void initState() {
  //     super.initState();
  //     _longPressRecognizer = LongPressGestureRecognizer()
  //       ..onLongPress = _handlePress;
  //   }
  //
  //   @override
  //   void dispose() {
  //     _longPressRecognizer.dispose();
  //     super.dispose();
  //   }
  //
  //   void _handlePress() {
  //     HapticFeedback.vibrate();
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     return Text.rich(
  //       TextSpan(
  //         text: 'Can you ',
  //         style: const TextStyle(color: Colors.black),
  //         children: <InlineSpan>[
  //           TextSpan(
  //             text: 'find the',
  //             style: const TextStyle(
  //               color: Colors.green,
  //               decoration: TextDecoration.underline,
  //               decorationStyle: TextDecorationStyle.wavy,
  //             ),
  //             recognizer: _longPressRecognizer,
  //             mouseCursor: SystemMouseCursors.precise,
  //           ),
  //           const TextSpan(
  //             text: ' secret?',
  //           ),
  //         ],
  //       ),
  //     );
  //   }
  // }
  // ```
  // {@end-tool}
  FlutterGestureRecognizerType recognizer = 5;
  // An alternative semantics label for this [TextSpan].
  //
  // If present, the semantics of this span will contain this value instead
  // of the actual text.
  //
  // This is useful for replacing abbreviations or shorthands with the full
  // text value:
  //
  // ```dart
  // const TextSpan(text: r'$$', semanticsLabel: 'Double dollars')
  // ```
  string semantics_label = 9;
  // The language of the text in this span and its span children.
  //
  // Setting the locale of this text span affects the way that assistive
  // technologies, such as VoiceOver or TalkBack, pronounce the text.
  //
  // If this span contains other text span children, they also inherit the
  // locale from this span unless explicitly set to different locales.
  DartLocaleType locale = 10;
  // Whether the assistive technologies should spell out this text character
  // by character.
  //
  // If the text is 'hello world', setting this to true causes the assistive
  // technologies, such as VoiceOver or TalkBack, to pronounce
  // 'h-e-l-l-o-space-w-o-r-l-d' instead of complete words. This is useful for
  // texts, such as passwords or verification codes.
  //
  // If this span contains other text span children, they also inherit the
  // property from this span unless explicitly set.
  //
  // If the property is not set, this text span inherits the spell out setting
  // from its parent. If this text span does not have a parent or the parent
  // does not have a spell out setting, this text span does not spell out the
  // text by default.
  bool spell_out = 11;
}

// package:flutter/src/painting/text_style.dart
//
// Creates a text style.
//
// The `package` argument must be non-null if the font family is defined in a
// package. It is combined with the `fontFamily` argument to set the
// [fontFamily] property.
//
// On Apple devices the strings 'CupertinoSystemText' and
// 'CupertinoSystemDisplay' are used in [fontFamily] as proxies for the
// Apple system fonts. They currently redirect to the equivilant of SF Pro
// Text and SF Pro Display respectively. 'CupertinoSystemText' is designed
// for fonts below 20 point size, and 'CupertinoSystemDisplay' is recommended
// for sizes 20 and above. When used on non-Apple platforms, these strings
// will return the regular fallback font family instead.
message FlutterTextStyle {
  // Whether null values in this [TextStyle] can be replaced with their value
  // in another [TextStyle] using [merge].
  //
  // The [merge] operation is not commutative: the [inherit] value of the
  // method argument decides whether the two [TextStyle]s can be combined
  // together. If it is false, the method argument [TextStyle] will be returned.
  // Otherwise, the combining is allowed, and the returned [TextStyle] inherits
  // the [inherit] value from the method receiver.
  //
  // This property does not affect the text style inheritance in an [InlineSpan]
  // tree: an [InlineSpan]'s text style is merged with that of an ancestor
  // [InlineSpan] if it has unspecified fields, regardless of its [inherit]
  // value.
  //
  // Properties that don't have explicit values or other default values to fall
  // back to will revert to the defaults: white in color, a font size of 14
  // pixels, in a sans-serif font face.
  //
  // See also:
  //  * [TextStyle.merge], which can be used to combine properties from two
  //    [TextStyle]s.
  bool inherit = 2;
  // The color to use when painting the text.
  //
  // If [foreground] is specified, this value must be null. The [color] property
  // is shorthand for `Paint()..color = color`.
  //
  // In [merge], [apply], and [lerp], conflicts between [color] and [foreground]
  // specification are resolved in [foreground]'s favor - i.e. if [foreground] is
  // specified in one place, it will dominate [color] in another.
  DartColorType color = 3;
  // The color to use as the background for the text.
  //
  // If [background] is specified, this value must be null. The
  // [backgroundColor] property is shorthand for
  // `background: Paint()..color = backgroundColor`.
  //
  // In [merge], [apply], and [lerp], conflicts between [backgroundColor] and [background]
  // specification are resolved in [background]'s favor - i.e. if [background] is
  // specified in one place, it will dominate [color] in another.
  DartColorType background_color = 4;
  // The size of fonts (in logical pixels) to use when painting the text.
  //
  // The value specified matches the dimension of the
  // [em square](https://fonts.google.com/knowledge/glossary/em) of the
  // underlying font, and more often then not isn't exactly the height or the
  // width of glyphs in the font.
  //
  // During painting, the [fontSize] is multiplied by the current
  // `textScaleFactor` to let users make it easier to read text by increasing
  // its size.
  //
  // The [getParagraphStyle] method defaults to 14 logical pixels if [fontSize]
  // is set to null.
  double font_size = 5;
  // The typeface variant to use when drawing the letters (e.g., italics).
  DartFontStyleType.Enum font_style = 7;
  // The amount of space (in logical pixels) to add between each letter.
  // A negative value can be used to bring the letters closer.
  double letter_spacing = 8;
  // The amount of space (in logical pixels) to add at each sequence of
  // white-space (i.e. between each word). A negative value can be used to
  // bring the words closer.
  double word_spacing = 9;
  // The common baseline that should be aligned between this text span and its
  // parent text span, or, for the root text spans, with the line box.
  DartTextBaselineType.Enum text_baseline = 10;
  // The height of this text span, as a multiple of the font size.
  //
  // When [height] is null or omitted, the line height will be determined
  // by the font's metrics directly, which may differ from the fontSize.
  // When [height] is non-null, the line height of the span of text will be a
  // multiple of [fontSize] and be exactly `fontSize * height` logical pixels
  // tall.
  //
  // For most fonts, setting [height] to 1.0 is not the same as omitting or
  // setting height to null because the [fontSize] sets the height of the EM-square,
  // which is different than the font provided metrics for line height. The
  // following diagram illustrates the difference between the font-metrics
  // defined line height and the line height produced with `height: 1.0`
  // (which forms the upper and lower edges of the EM-square):
  //
  // ![With the font-metrics-defined line height, there is space between lines appropriate for the font, whereas the EM-square is only the height required to hold most of the characters.](https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_diagram.png)
  //
  // Examples of the resulting line heights from different values of `TextStyle.height`:
  //
  // ![Since the explicit line height is applied as a scale factor on the font-metrics-defined line height, the gap above the text grows faster, as the height grows, than the gap below the text.](https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_comparison_diagram.png)
  //
  // See [StrutStyle] and [TextHeightBehavior] for further control of line
  // height at the paragraph level.
  double height = 11;
  // How the vertical space added by the [height] multiplier should be
  // distributed over and under the text.
  //
  // When a non-null [height] is specified, after accommodating the glyphs of
  // the text, the remaining vertical space from the allotted line height will
  // be distributed over and under the text, according to the
  // [leadingDistribution] property. See the [TextStyle] class's documentation
  // for an example.
  //
  // When [height] is null, [leadingDistribution] does not affect the text
  // layout.
  //
  // Defaults to null, which defers to the paragraph's
  // `ParagraphStyle.textHeightBehavior`'s [leadingDistribution].
  DartTextLeadingDistributionType.Enum leading_distribution = 12;
  // The locale used to select region-specific glyphs.
  //
  // This property is rarely set. Typically the locale used to select
  // region-specific glyphs is defined by the text widget's [BuildContext]
  // using `Localizations.localeOf(context)`. For example [RichText] defines
  // its locale this way. However, a rich text widget's [TextSpan]s could
  // specify text styles with different explicit locales in order to select
  // different region-specific glyphs for each text span.
  DartLocaleType locale = 13;
  // The paint drawn as a foreground for the text.
  //
  // The value should ideally be cached and reused each time if multiple text
  // styles are created with the same paint settings. Otherwise, each time it
  // will appear like the style changed, which will result in unnecessary
  // updates all the way through the framework.
  //
  // If [color] is specified, this value must be null. The [color] property
  // is shorthand for `Paint()..color = color`.
  //
  // In [merge], [apply], and [lerp], conflicts between [color] and [foreground]
  // specification are resolved in [foreground]'s favor - i.e. if [foreground] is
  // specified in one place, it will dominate [color] in another.
  DartPaintType foreground = 14;
  // The paint drawn as a background for the text.
  //
  // The value should ideally be cached and reused each time if multiple text
  // styles are created with the same paint settings. Otherwise, each time it
  // will appear like the style changed, which will result in unnecessary
  // updates all the way through the framework.
  //
  // If [backgroundColor] is specified, this value must be null. The
  // [backgroundColor] property is shorthand for
  // `background: Paint()..color = backgroundColor`.
  //
  // In [merge], [apply], and [lerp], conflicts between [backgroundColor] and
  // [background] specification are resolved in [background]'s favor - i.e. if
  // [background] is specified in one place, it will dominate [backgroundColor]
  // in another.
  DartPaintType background = 15;
  // A list of [Shadow]s that will be painted underneath the text.
  //
  // Multiple shadows are supported to replicate lighting from multiple light
  // sources.
  //
  // Shadows must be in the same order for [TextStyle] to be considered as
  // equivalent as order produces differing transparency.
  repeated DartShadowType shadows = 16;
  // A list of [FontFeature]s that affect how the font selects glyphs.
  //
  // Some fonts support multiple variants of how a given character can be
  // rendered. For example, a font might provide both proportional and
  // tabular numbers, or it might offer versions of the zero digit with
  // and without slashes. [FontFeature]s can be used to select which of
  // these variants will be used for rendering.
  //
  // Font features are not interpolated by [lerp].
  //
  // See also:
  //
  //  * [fontVariations], for font features that have continuous parameters.
  repeated DartFontFeatureType font_features = 17;
  // A list of [FontVariation]s that affect how a variable font is rendered.
  //
  // Some fonts are variable fonts that can generate multiple font faces based
  // on the values of customizable attributes. For example, a variable font
  // may have a weight axis that can be set to a value between 1 and 1000.
  // [FontVariation]s can be used to select the values of these design axes.
  //
  // For example, to control the weight axis of the Roboto Slab variable font
  // (https://fonts.google.com/specimen/Roboto+Slab):
  // ```dart
  // const TextStyle(
  //   fontFamily: 'RobotoSlab',
  //   fontVariations: <FontVariation>[FontVariation('wght', 900.0)]
  // )
  // ```
  //
  // Font variations can be interpolated via [lerp]. This is fastest when the
  // same font variation axes are specified, in the same order, in both
  // [TextStyle] objects. See [lerpFontVariations].
  //
  // See also:
  //
  //  * [fontFeatures], for font variations that have discrete values.
  repeated DartFontVariationType font_variations = 18;
  // The decorations to paint near the text (e.g., an underline).
  //
  // Multiple decorations can be applied using [TextDecoration.combine].
  DartTextDecorationType decoration = 19;
  // The color in which to paint the text decorations.
  DartColorType decoration_color = 20;
  // The style in which to paint the text decorations (e.g., dashed).
  DartTextDecorationStyleType.Enum decoration_style = 21;
  // The thickness of the decoration stroke as a multiplier of the thickness
  // defined by the font.
  //
  // The font provides a base stroke width for [decoration]s which scales off
  // of the [fontSize]. This property may be used to achieve a thinner or
  // thicker decoration stroke, without changing the [fontSize]. For example,
  // a [decorationThickness] of 2.0 will draw a decoration twice as thick as
  // the font defined decoration thickness.
  //
  // {@tool snippet}
  // To achieve a bolded strike-through, we can apply a thicker stroke for the
  // decoration.
  //
  // ```dart
  // const Text(
  //   'This has a very BOLD strike through!',
  //   style: TextStyle(
  //     decoration: TextDecoration.lineThrough,
  //     decorationThickness: 2.85,
  //   ),
  // )
  // ```
  // {@end-tool}
  //
  // {@tool snippet}
  // We can apply a very thin and subtle wavy underline (perhaps, when words
  // are misspelled) by using a [decorationThickness] < 1.0.
  //
  // ```dart
  // const Text(
  //   'oopsIforgottousespaces!',
  //   style: TextStyle(
  //     decoration: TextDecoration.underline,
  //     decorationStyle: TextDecorationStyle.wavy,
  //     decorationColor: Colors.red,
  //     decorationThickness: 0.5,
  //   ),
  // )
  // ```
  // {@end-tool}
  //
  // The default [decorationThickness] is 1.0, which will use the font's base
  // stroke thickness/width.
  double decoration_thickness = 22;
  // A human-readable description of this text style.
  //
  // This property is maintained only in debug builds.
  //
  // When merging ([merge]), copying ([copyWith]), modifying using [apply], or
  // interpolating ([lerp]), the label of the resulting style is marked with
  // the debug labels of the original styles. This helps figuring out where a
  // particular text style came from.
  //
  // This property is not considered when comparing text styles using `==` or
  // [compareTo], and it does not affect [hashCode].
  string debug_label = 23;
  string font_family = 24;
  repeated string font_family_fallback = 25;
  string package = 26;
  // How visual text overflow should be handled.
  FlutterTextOverflowType.Enum overflow = 27;
}

// package:flutter/src/widgets/texture.dart
//
// Creates a widget backed by the texture identified by [textureId], and use
// [filterQuality] to set texture's [FilterQuality].
message FlutterTexture {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The identity of the backend texture.
  int32 texture_id = 3;
  // When true the texture will not be updated with new frames.
  bool freeze = 4;
  // {@template flutter.widgets.Texture.filterQuality}
  // The quality of sampling the texture and rendering it on screen.
  //
  // When the texture is scaled, a default [FilterQuality.low] is used for a higher quality but slower
  // interpolation (typically bilinear). It can be changed to [FilterQuality.none] for a lower quality but
  // faster interpolation (typically nearest-neighbor). See also [FilterQuality.medium] and
  // [FilterQuality.high] for more options.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 5;
}

// package:flutter/src/rendering/texture.dart
//
// Creates a box backed by the texture identified by [textureId], and use
// [filterQuality] to set texture's [FilterQuality].
message FlutterTextureBox {
  int32 texture_id = 2;
  bool freeze = 3;
  DartFilterQualityType.Enum filter_quality = 4;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a texture layer bounded by [rect] and with backend texture
// identified by [textureId], if [freeze] is true new texture frames will not be
// populated to the texture, and use [filterQuality] to set layer's [FilterQuality].
message FlutterTextureLayer {
  // Bounding rectangle of this layer.
  DartRectType rect = 2;
  // The identity of the backend texture.
  int32 texture_id = 3;
  // When true the texture will not be updated with new frames.
  //
  // This is used for resizing embedded Android views: when resizing there
  // is a short period during which the framework cannot tell if the newest
  // texture frame has the previous or new size; to work around this, the
  // framework "freezes" the texture just before resizing the Android view and
  // un-freezes it when it is certain that a frame with the new size is ready.
  bool freeze = 4;
  // {@macro flutter.widgets.Texture.filterQuality}
  DartFilterQualityType.Enum filter_quality = 5;
}

// package:flutter/src/widgets/ticker_provider.dart
//
// Creates a widget that enables or disables tickers.
message FlutterTickerMode {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The requested ticker mode for this subtree.
  //
  // The effective ticker mode of this subtree may differ from this value
  // if there is an ancestor [TickerMode] with this field set to false.
  //
  // If true and all ancestor [TickerMode]s are also enabled, then tickers in
  // this subtree will tick.
  //
  // If false, then tickers in this subtree will not tick regardless of any
  // ancestor [TickerMode]s. Animations driven by such tickers are not paused,
  // they just don't call their callbacks. Time still elapses.
  bool enabled = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/title.dart
//
// Creates a widget that describes this app to the Android operating system.
//
// [title] will default to the empty string if not supplied.
// [color] must be an opaque color (i.e. color.alpha must be 255 (0xFF)).
// [color] and [child] are required arguments.
message FlutterTitle {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // A one-line description of this app for use in the window manager.
  string title = 3;
  // A color that the window manager should use to identify this app. Must be
  // an opaque color (i.e. color.alpha must be 255 (0xFF)), and must not be
  // null.
  DartColorType color = 4;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/widgets/scroll_controller.dart
//
// Creates a scroll controller that continually updates its
// [initialScrollOffset] to match the last scroll notification it received.
message FlutterTrackingScrollController {
  double initial_scroll_offset = 2;
  // Each time a scroll completes, save the current scroll [offset] with
  // [PageStorage] and restore it if this controller's scrollable is recreated.
  //
  // If this property is set to false, the scroll offset is never saved
  // and [initialScrollOffset] is always used to initialize the scroll
  // offset. If true (the default), the initial scroll offset is used the
  // first time the controller's scrollable is created, since there's no
  // scroll offset to restore yet. Subsequently the saved offset is
  // restored and [initialScrollOffset] is ignored.
  //
  // See also:
  //
  //  * [PageStorageKey], which should be used when more than one
  //    scrollable appears in the same route, to distinguish the [PageStorage]
  //    locations used to save scroll offsets.
  bool keep_scroll_offset = 3;
  // A label that is used in the [toString] output. Intended to aid with
  // identifying scroll controller instances in debug output.
  string debug_label = 4;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that transforms its child.
message FlutterTransform {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The matrix to transform the child by during painting.
  VectorMathMatrix4Type transform = 3;
  // The origin of the coordinate system (relative to the upper left corner of
  // this render object) in which to apply the matrix.
  //
  // Setting an origin is equivalent to conjugating the transform matrix by a
  // translation. This property is provided just for convenience.
  DartOffsetType origin = 4;
  // The alignment of the origin, relative to the size of the box.
  //
  // This is equivalent to setting an origin based on the size of the box.
  // If it is specified at the same time as the [origin], both are applied.
  //
  // An [AlignmentDirectional.centerStart] value is the same as an [Alignment]
  // whose [Alignment.x] value is `-1.0` if [Directionality.of] returns
  // [TextDirection.ltr], and `1.0` if [Directionality.of] returns
  // [TextDirection.rtl].	 Similarly [AlignmentDirectional.centerEnd] is the
  // same as an [Alignment] whose [Alignment.x] value is `1.0` if
  // [Directionality.of] returns	 [TextDirection.ltr], and `-1.0` if
  // [Directionality.of] returns [TextDirection.rtl].
  FlutterAlignmentGeometryType alignment = 5;
  // Whether to apply the transformation when performing hit tests.
  bool transform_hit_tests = 6;
  // The filter quality with which to apply the transform as a bitmap operation.
  //
  // {@template flutter.widgets.Transform.optional.FilterQuality}
  // The transform will be applied by re-rendering the child if [filterQuality] is null,
  // otherwise it controls the quality of an [ImageFilter.matrix] applied to a bitmap
  // rendering of the child.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 7;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 8;
}

// package:flutter/src/rendering/layer.dart
//
// Creates a transform layer.
//
// The [transform] and [offset] properties must be non-null before the
// compositing phase of the pipeline.
message FlutterTransformLayer {
  VectorMathMatrix4Type transform = 2;
  DartOffsetType offset = 3;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that mirrors its child about the widget's center point.
//
// If `flipX` is true, the child widget will be flipped horizontally. Defaults to false.
//
// If `flipY` is true, the child widget will be flipped vertically. Defaults to false.
//
// If both are true, the child widget will be flipped both vertically and horizontally, equivalent to a 180 degree rotation.
//
// {@tool snippet}
//
// This example flips the text horizontally.
//
// ```dart
// Transform.flip(
//   flipX: true,
//   child: const Text('Horizontal Flip'),
// )
// ```
// {@end-tool}
message FlutterTransformNamedFlip {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  bool flip_x = 3;
  bool flip_y = 4;
  // The origin of the coordinate system (relative to the upper left corner of
  // this render object) in which to apply the matrix.
  //
  // Setting an origin is equivalent to conjugating the transform matrix by a
  // translation. This property is provided just for convenience.
  DartOffsetType origin = 5;
  // Whether to apply the transformation when performing hit tests.
  bool transform_hit_tests = 6;
  // The filter quality with which to apply the transform as a bitmap operation.
  //
  // {@template flutter.widgets.Transform.optional.FilterQuality}
  // The transform will be applied by re-rendering the child if [filterQuality] is null,
  // otherwise it controls the quality of an [ImageFilter.matrix] applied to a bitmap
  // rendering of the child.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 7;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 8;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that transforms its child using a rotation around the
// center.
//
// The `angle` argument gives the rotation in clockwise radians.
//
// {@tool snippet}
//
// This example rotates an orange box containing text around its center by
// fifteen degrees.
//
// ```dart
// Transform.rotate(
//   angle: -math.pi / 12.0,
//   child: Container(
//     padding: const EdgeInsets.all(8.0),
//     color: const Color(0xFFE8581C),
//     child: const Text('Apartment for rent!'),
//   ),
// )
// ```
// {@end-tool}
//
// See also:
//
//  * [RotationTransition], which animates changes in rotation smoothly
//    over a given duration.
message FlutterTransformNamedRotate {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  double angle = 3;
  // The origin of the coordinate system (relative to the upper left corner of
  // this render object) in which to apply the matrix.
  //
  // Setting an origin is equivalent to conjugating the transform matrix by a
  // translation. This property is provided just for convenience.
  DartOffsetType origin = 4;
  // The alignment of the origin, relative to the size of the box.
  //
  // This is equivalent to setting an origin based on the size of the box.
  // If it is specified at the same time as the [origin], both are applied.
  //
  // An [AlignmentDirectional.centerStart] value is the same as an [Alignment]
  // whose [Alignment.x] value is `-1.0` if [Directionality.of] returns
  // [TextDirection.ltr], and `1.0` if [Directionality.of] returns
  // [TextDirection.rtl].	 Similarly [AlignmentDirectional.centerEnd] is the
  // same as an [Alignment] whose [Alignment.x] value is `1.0` if
  // [Directionality.of] returns	 [TextDirection.ltr], and `-1.0` if
  // [Directionality.of] returns [TextDirection.rtl].
  FlutterAlignmentGeometryType alignment = 5;
  // Whether to apply the transformation when performing hit tests.
  bool transform_hit_tests = 6;
  // The filter quality with which to apply the transform as a bitmap operation.
  //
  // {@template flutter.widgets.Transform.optional.FilterQuality}
  // The transform will be applied by re-rendering the child if [filterQuality] is null,
  // otherwise it controls the quality of an [ImageFilter.matrix] applied to a bitmap
  // rendering of the child.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 7;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 8;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that scales its child along the 2D plane.
//
// The `scaleX` argument provides the scalar by which to multiply the `x`
// axis, and the `scaleY` argument provides the scalar by which to multiply
// the `y` axis. Either may be omitted, in which case the scaling factor for
// that axis defaults to 1.0.
//
// For convenience, to scale the child uniformly, instead of providing
// `scaleX` and `scaleY`, the `scale` parameter may be used.
//
// At least one of `scale`, `scaleX`, and `scaleY` must be non-null. If
// `scale` is provided, the other two must be null; similarly, if it is not
// provided, one of the other two must be provided.
//
// The [alignment] controls the origin of the scale; by default, this is the
// center of the box.
//
// {@tool snippet}
//
// This example shrinks an orange box containing text such that each
// dimension is half the size it would otherwise be.
//
// ```dart
// Transform.scale(
//   scale: 0.5,
//   child: Container(
//     padding: const EdgeInsets.all(8.0),
//     color: const Color(0xFFE8581C),
//     child: const Text('Bad Idea Bears'),
//   ),
// )
// ```
// {@end-tool}
//
// See also:
//
// * [ScaleTransition], which animates changes in scale smoothly over a given
//   duration.
message FlutterTransformNamedScale {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  double scale = 3;
  double scale_x = 4;
  double scale_y = 5;
  // The origin of the coordinate system (relative to the upper left corner of
  // this render object) in which to apply the matrix.
  //
  // Setting an origin is equivalent to conjugating the transform matrix by a
  // translation. This property is provided just for convenience.
  DartOffsetType origin = 6;
  // The alignment of the origin, relative to the size of the box.
  //
  // This is equivalent to setting an origin based on the size of the box.
  // If it is specified at the same time as the [origin], both are applied.
  //
  // An [AlignmentDirectional.centerStart] value is the same as an [Alignment]
  // whose [Alignment.x] value is `-1.0` if [Directionality.of] returns
  // [TextDirection.ltr], and `1.0` if [Directionality.of] returns
  // [TextDirection.rtl].	 Similarly [AlignmentDirectional.centerEnd] is the
  // same as an [Alignment] whose [Alignment.x] value is `1.0` if
  // [Directionality.of] returns	 [TextDirection.ltr], and `-1.0` if
  // [Directionality.of] returns [TextDirection.rtl].
  FlutterAlignmentGeometryType alignment = 7;
  // Whether to apply the transformation when performing hit tests.
  bool transform_hit_tests = 8;
  // The filter quality with which to apply the transform as a bitmap operation.
  //
  // {@template flutter.widgets.Transform.optional.FilterQuality}
  // The transform will be applied by re-rendering the child if [filterQuality] is null,
  // otherwise it controls the quality of an [ImageFilter.matrix] applied to a bitmap
  // rendering of the child.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 9;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 10;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that transforms its child using a translation.
//
// The `offset` argument specifies the translation.
//
// {@tool snippet}
//
// This example shifts the silver-colored child down by fifteen pixels.
//
// ```dart
// Transform.translate(
//   offset: const Offset(0.0, 15.0),
//   child: Container(
//     padding: const EdgeInsets.all(8.0),
//     color: const Color(0xFF7F7F7F),
//     child: const Text('Quarter'),
//   ),
// )
// ```
// {@end-tool}
message FlutterTransformNamedTranslate {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  DartOffsetType offset = 3;
  // Whether to apply the transformation when performing hit tests.
  bool transform_hit_tests = 4;
  // The filter quality with which to apply the transform as a bitmap operation.
  //
  // {@template flutter.widgets.Transform.optional.FilterQuality}
  // The transform will be applied by re-rendering the child if [filterQuality] is null,
  // otherwise it controls the quality of an [ImageFilter.matrix] applied to a bitmap
  // rendering of the child.
  // {@endtemplate}
  DartFilterQualityType.Enum filter_quality = 5;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 6;
}

// package:flutter/src/painting/matrix_utils.dart
//
// Create a diagnostics property for [Matrix4] objects.
message FlutterTransformProperty {
  string name = 2;
  VectorMathMatrix4Type value = 3;
  bool show_name = 4;
  FlutterDiagnosticLevelType.Enum level = 6;
}

// package:flutter/src/widgets/interactive_viewer.dart
//
// Create an instance of [TransformationController].
//
// The [value] defaults to the identity matrix, which corresponds to no
// transformation.
message FlutterTransformationController {
  VectorMathMatrix4Type value = 2;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates a [TransposeCharactersIntent].
message FlutterTransposeCharactersIntent {
  
}

// package:flutter/src/widgets/platform_view.dart
//
// Creates a widget that embeds an iOS view.
//
// {@macro flutter.widgets.AndroidView.constructorArgs}
message FlutterUiKitView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The unique identifier for iOS view type to be embedded by this widget.
  //
  // A PlatformViewFactory for this type must have been registered.
  string view_type = 3;
  // {@macro flutter.widgets.AndroidView.hitTestBehavior}
  FlutterPlatformViewHitTestBehaviorType.Enum hit_test_behavior = 5;
  // {@macro flutter.widgets.AndroidView.layoutDirection}
  DartTextDirectionType.Enum layout_direction = 6;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a widget that imposes no constraints on its child, allowing it to
// render at its "natural" size. If the child overflows the parents
// constraints, a warning will be given in debug mode.
message FlutterUnconstrainedBox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The text direction to use when interpreting the [alignment] if it is an
  // [AlignmentDirectional].
  DartTextDirectionType.Enum text_direction = 4;
  // The alignment to use when laying out the child.
  //
  // If this is an [AlignmentDirectional], then [textDirection] must not be
  // null.
  //
  // See also:
  //
  //  * [Alignment] for non-[Directionality]-aware alignments.
  //  * [AlignmentDirectional] for [Directionality]-aware alignments.
  FlutterAlignmentGeometryType alignment = 5;
  // The axis to retain constraints on, if any.
  //
  // If not set, or set to null (the default), neither axis will retain its
  // constraints. If set to [Axis.vertical], then vertical constraints will
  // be retained, and if set to [Axis.horizontal], then horizontal constraints
  // will be retained.
  FlutterAxisType.Enum constrained_axis = 6;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 7;
}

// package:flutter/src/widgets/undo_history.dart
//
// Creates a controller for an [UndoHistory] widget.
message FlutterUndoHistoryController {
  FlutterUndoHistoryValueType value = 2;
}

// package:flutter/src/widgets/undo_history.dart
//
// Creates a value for whether the current undo stack can undo or redo.
//
// The [canUndo] and [canRedo] arguments must have a value, but default to
// false.
message FlutterUndoHistoryValue {
  // Whether the current undo stack can perform an undo operation.
  bool can_undo = 2;
  // Whether the current undo stack can perform a redo operation.
  bool can_redo = 3;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [UndoTextIntent].
message FlutterUndoTextIntent {
  // {@macro flutter.widgets.TextEditingIntents.cause}
  FlutterSelectionChangedCauseType.Enum cause = 2;
}

// package:flutter/src/foundation/key.dart
//
// Creates a key that is equal only to itself.
//
// The key cannot be created with a const constructor because that implies
// that all instantiated keys would be the same instance and therefore not
// be unique.
message FlutterUniqueKey {
  
}

// package:flutter/src/widgets/restoration.dart
//
// Creates an [UnmanagedRestorationScope].
//
// When [bucket] is null state restoration is turned off for the [child] and
// its descendants.
message FlutterUnmanagedRestorationScope {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [RestorationBucket] that this widget will insert into the widget tree.
  //
  // Descendant widgets may obtain this bucket via [RestorationScope.of].
  FlutterRestorationBucketType bucket = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/widgets/text_editing_intents.dart
//
// Creates an [UpdateSelectionIntent].
message FlutterUpdateSelectionIntent {
  // The [TextEditingValue] that this [Intent]'s action should perform on.
  FlutterTextEditingValueType current_text_editing_value = 2;
  // The new [TextSelection] the input field should adopt.
  FlutterTextSelectionType new_selection = 3;
  // {@macro flutter.widgets.TextEditingIntents.cause}
  FlutterSelectionChangedCauseType.Enum cause = 4;
}

// package:flutter/src/gestures/monodrag.dart
//
// Create a gesture recognizer for interactions in the vertical axis.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterVerticalDragGestureRecognizer {
  
}

// package:flutter/src/gestures/multidrag.dart
//
// Create a gesture recognizer for tracking multiple pointers at once
// but only if they first move vertically.
//
// {@macro flutter.gestures.GestureRecognizer.supportedDevices}
message FlutterVerticalMultiDragGestureRecognizer {
  
}

// package:flutter/src/widgets/view.dart
//
// Create a [View] widget to bootstrap a render tree that is rendered into
// the provided [FlutterView].
//
// The content rendered into that [view] is determined by the given [child]
// widget.
message FlutterView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree, which will be drawn into the
  // [view].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/widgets/view.dart
//
// Creates a [ViewAnchor] widget.
message FlutterViewAnchor {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget that defines the view anchored to this widget.
  //
  // Typically, a [View] or [ViewCollection] widget is used, which may be
  // wrapped in other non-[RenderObjectWidget]s (e.g. [InheritedWidget]s).
  //
  // {@macro flutter.widgets.ViewAnchor}
  WidgetType view = 3;
  // The widget below this widget in the tree.
  //
  // It is rendered into the surrounding view, not in the view defined by
  // [view].
  //
  // {@macro flutter.widgets.ViewAnchor}
  WidgetType child = 4;
}

// package:flutter/src/widgets/view.dart
//
// Creates a [ViewCollection] widget.
message FlutterViewCollection {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  repeated WidgetType views = 3;
}

// package:flutter/src/rendering/view.dart
//
// Creates a view configuration.
//
// By default, the view has zero [size] and a [devicePixelRatio] of 1.0.
message FlutterViewConfiguration {
  // The size of the output surface.
  DartSizeType size = 2;
  // The pixel density of the output surface.
  double device_pixel_ratio = 3;
}

// package:flutter/src/widgets/viewport.dart
//
// Creates a widget that is bigger on the inside.
//
// The viewport listens to the [offset], which means you do not need to
// rebuild this widget when the [offset] changes.
//
// The [cacheExtent] must be specified if the [cacheExtentStyle] is
// not [CacheExtentStyle.pixel].
message FlutterViewport {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The direction in which the [offset]'s [ViewportOffset.pixels] increases.
  //
  // For example, if the [axisDirection] is [AxisDirection.down], a scroll
  // offset of zero is at the top of the viewport and increases towards the
  // bottom of the viewport.
  FlutterAxisDirectionType.Enum axis_direction = 3;
  // The direction in which child should be laid out in the cross axis.
  //
  // If the [axisDirection] is [AxisDirection.down] or [AxisDirection.up], this
  // property defaults to [AxisDirection.left] if the ambient [Directionality]
  // is [TextDirection.rtl] and [AxisDirection.right] if the ambient
  // [Directionality] is [TextDirection.ltr].
  //
  // If the [axisDirection] is [AxisDirection.left] or [AxisDirection.right],
  // this property defaults to [AxisDirection.down].
  FlutterAxisDirectionType.Enum cross_axis_direction = 4;
  // The relative position of the zero scroll offset.
  //
  // For example, if [anchor] is 0.5 and the [axisDirection] is
  // [AxisDirection.down] or [AxisDirection.up], then the zero scroll offset is
  // vertically centered within the viewport. If the [anchor] is 1.0, and the
  // [axisDirection] is [AxisDirection.right], then the zero scroll offset is
  // on the left edge of the viewport.
  //
  // {@macro flutter.rendering.GrowthDirection.sample}
  double anchor = 5;
  // Which part of the content inside the viewport should be visible.
  //
  // The [ViewportOffset.pixels] value determines the scroll offset that the
  // viewport uses to select which part of its content to display. As the user
  // scrolls the viewport, this value changes, which changes the content that
  // is displayed.
  //
  // Typically a [ScrollPosition].
  FlutterViewportOffsetType offset = 6;
  // The first child in the [GrowthDirection.forward] growth direction.
  //
  // Children after [center] will be placed in the [axisDirection] relative to
  // the [center]. Children before [center] will be placed in the opposite of
  // the [axisDirection] relative to the [center].
  //
  // The [center] must be the key of a child of the viewport.
  //
  // {@macro flutter.rendering.GrowthDirection.sample}
  FlutterKeyType center = 7;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtent}
  //
  // See also:
  //
  //  * [cacheExtentStyle], which controls the units of the [cacheExtent].
  double cache_extent = 8;
  // {@macro flutter.rendering.RenderViewportBase.cacheExtentStyle}
  FlutterCacheExtentStyleType.Enum cache_extent_style = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 10;
  repeated WidgetType slivers = 11;
}

// package:flutter/src/rendering/viewport_offset.dart
//
// Creates a viewport offset with the given [pixels] value.
//
// The [pixels] value does not change unless the viewport issues a
// correction.
message FlutterViewportOffsetNamedFixed {
  double value = 2;
}

// package:flutter/src/rendering/viewport_offset.dart
//
// Creates a viewport offset with a [pixels] value of 0.0.
//
// The [pixels] value does not change unless the viewport issues a
// correction.
message FlutterViewportOffsetNamedZero {
  
}

// package:flutter/src/widgets/visibility.dart
//
// Control whether the given [child] is [visible].
//
// The [maintainSemantics] and [maintainInteractivity] arguments can only be
// set if [maintainSize] is set.
//
// The [maintainSize] argument can only be set if [maintainAnimation] is set.
//
// The [maintainAnimation] argument can only be set if [maintainState] is
// set.
message FlutterVisibility {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget to show or hide, as controlled by [visible].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The widget to use when the child is not [visible], assuming that none of
  // the `maintain` flags (in particular, [maintainState]) are set.
  //
  // The normal behavior is to replace the widget with a zero by zero box
  // ([SizedBox.shrink]).
  //
  // See also:
  //
  //  * [AnimatedCrossFade], which can animate between two children.
  WidgetType replacement = 4;
  // Switches between showing the [child] or hiding it.
  //
  // The `maintain` flags should be set to the same values regardless of the
  // state of the [visible] property, otherwise they will not operate correctly
  // (specifically, the state will be lost regardless of the state of
  // [maintainState] whenever any of the `maintain` flags are changed, since
  // doing so will result in a subtree shape change).
  //
  // Unless [maintainState] is set, the [child] subtree will be disposed
  // (removed from the tree) while hidden.
  bool visible = 5;
  // Whether to maintain the [State] objects of the [child] subtree when it is
  // not [visible].
  //
  // Keeping the state of the subtree is potentially expensive (because it
  // means all the objects are still in memory; their resources are not
  // released). It should only be maintained if it cannot be recreated on
  // demand. One example of when the state would be maintained is if the child
  // subtree contains a [Navigator], since that widget maintains elaborate
  // state that cannot be recreated on the fly.
  //
  // If this property is true, an [Offstage] widget is used to hide the child
  // instead of replacing it with [replacement].
  //
  // If this property is false, then [maintainAnimation] must also be false.
  //
  // Dynamically changing this value may cause the current state of the
  // subtree to be lost (and a new instance of the subtree, with new [State]
  // objects, to be immediately created if [visible] is true).
  bool maintain_state = 6;
  // Whether to maintain animations within the [child] subtree when it is
  // not [visible].
  //
  // To set this, [maintainState] must also be set.
  //
  // Keeping animations active when the widget is not visible is even more
  // expensive than only maintaining the state.
  //
  // One example when this might be useful is if the subtree is animating its
  // layout in time with an [AnimationController], and the result of that
  // layout is being used to influence some other logic. If this flag is false,
  // then any [AnimationController]s hosted inside the [child] subtree will be
  // muted while the [visible] flag is false.
  //
  // If this property is true, no [TickerMode] widget is used.
  //
  // If this property is false, then [maintainSize] must also be false.
  //
  // Dynamically changing this value may cause the current state of the
  // subtree to be lost (and a new instance of the subtree, with new [State]
  // objects, to be immediately created if [visible] is true).
  bool maintain_animation = 7;
  // Whether to maintain space for where the widget would have been.
  //
  // To set this, [maintainAnimation] and [maintainState] must also be set.
  //
  // Maintaining the size when the widget is not [visible] is not notably more
  // expensive than just keeping animations running without maintaining the
  // size, and may in some circumstances be slightly cheaper if the subtree is
  // simple and the [visible] property is frequently toggled, since it avoids
  // triggering a layout change when the [visible] property is toggled. If the
  // [child] subtree is not trivial then it is significantly cheaper to not
  // even keep the state (see [maintainState]).
  //
  // If this property is false, [Offstage] is used.
  //
  // If this property is false, then [maintainSemantics] and
  // [maintainInteractivity] must also be false.
  //
  // Dynamically changing this value may cause the current state of the
  // subtree to be lost (and a new instance of the subtree, with new [State]
  // objects, to be immediately created if [visible] is true).
  //
  // See also:
  //
  //  * [AnimatedOpacity] and [FadeTransition], which apply animations to the
  //    opacity for a more subtle effect.
  bool maintain_size = 8;
  // Whether to maintain the semantics for the widget when it is hidden (e.g.
  // for accessibility).
  //
  // To set this, [maintainSize] must also be set.
  //
  // By default, with [maintainSemantics] set to false, the [child] is not
  // visible to accessibility tools when it is hidden from the user. If this
  // flag is set to true, then accessibility tools will report the widget as if
  // it was present.
  bool maintain_semantics = 9;
  // Whether to allow the widget to be interactive when hidden.
  //
  // To set this, [maintainSize] must also be set.
  //
  // By default, with [maintainInteractivity] set to false, touch events cannot
  // reach the [child] when it is hidden from the user. If this flag is set to
  // true, then touch events will nonetheless be passed through.
  bool maintain_interactivity = 10;
}

// package:flutter/src/widgets/visibility.dart
//
// Control whether the given [child] is [visible].
//
// This is equivalent to the default [Visibility] constructor with all
// "maintain" fields set to true. This constructor should be used in place of
// an [Opacity] widget that only takes on values of `0.0` or `1.0`, as it
// avoids extra compositing when fully opaque.
message FlutterVisibilityNamedMaintain {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget to show or hide, as controlled by [visible].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // Switches between showing the [child] or hiding it.
  //
  // The `maintain` flags should be set to the same values regardless of the
  // state of the [visible] property, otherwise they will not operate correctly
  // (specifically, the state will be lost regardless of the state of
  // [maintainState] whenever any of the `maintain` flags are changed, since
  // doing so will result in a subtree shape change).
  //
  // Unless [maintainState] is set, the [child] subtree will be disposed
  // (removed from the tree) while hidden.
  bool visible = 4;
}

// package:flutter/src/widgets/widget_inspector.dart
//
// Creates a widget that enables inspection for the child.
message FlutterWidgetInspector {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget that is being inspected.
  WidgetType child = 3;
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Constructs a traversal policy that orders widgets for keyboard traversal
// based on the widget hierarchy order.
//
// {@macro flutter.widgets.FocusTraversalPolicy.requestFocusCallback}
message FlutterWidgetOrderTraversalPolicy {
  
}

// package:flutter/src/widgets/widget_span.dart
//
// Creates a [WidgetSpan] with the given values.
//
// [WidgetSpan] is a leaf node in the [InlineSpan] tree. Child widgets are
// constrained by the width of the paragraph they occupy. Child widget
// heights are unconstrained, and may cause the text to overflow and be
// ellipsized/truncated.
//
// A [TextStyle] may be provided with the [style] property, but only the
// decoration, foreground, background, and spacing options will be used.
message FlutterWidgetSpan {
  // The widget to embed inline within text.
  WidgetType child = 2;
  // How the placeholder aligns vertically with the text.
  //
  // See [ui.PlaceholderAlignment] for details on each mode.
  DartPlaceholderAlignmentType.Enum alignment = 3;
  // The [TextBaseline] to align against when using [ui.PlaceholderAlignment.baseline],
  // [ui.PlaceholderAlignment.aboveBaseline], and [ui.PlaceholderAlignment.belowBaseline].
  //
  // This is ignored when using other alignment modes.
  DartTextBaselineType.Enum baseline = 4;
  // The [TextStyle] to apply to this span.
  //
  // The [style] is also applied to any child spans when this is an instance
  // of [TextSpan].
  FlutterTextStyleType style = 5;
}

// package:flutter/src/widgets/basic.dart
//
// Creates an adapter for placing a specific [RenderBox] in the widget tree.
message FlutterWidgetToRenderBoxAdapter {
  // The render box to place in the widget tree.
  //
  // This widget takes ownership of the render object. When it is unmounted,
  // it also calls [RenderObject.dispose].
  FlutterRenderBoxType render_box = 2;
}

// package:flutter/src/widgets/app.dart
//
// Creates a widget that wraps a number of widgets that are commonly
// required for an application.
//
// Most callers will want to use the [home] or [routes] parameters, or both.
// The [home] parameter is a convenience for the following [routes] map:
//
// ```dart
// <String, WidgetBuilder>{ '/': (BuildContext context) => myWidget }
// ```
//
// It is possible to specify both [home] and [routes], but only if [routes] does
//  _not_ contain an entry for `'/'`. Conversely, if [home] is omitted, [routes]
// _must_ contain an entry for `'/'`.
//
// If [home] or [routes] are not null, the routing implementation needs to know how
// appropriately build [PageRoute]s. This can be achieved by supplying the
// [pageRouteBuilder] parameter. The [pageRouteBuilder] is used by [MaterialApp]
// and [CupertinoApp] to create [MaterialPageRoute]s and [CupertinoPageRoute],
// respectively.
//
// The [builder] parameter is designed to provide the ability to wrap the visible
// content of the app in some other widget. It is recommended that you use [home]
// rather than [builder] if you intend to only display a single route in your app.
//
// [WidgetsApp] is also possible to provide a custom implementation of routing via the
// [onGenerateRoute] and [onUnknownRoute] parameters. These parameters correspond
// to [Navigator.onGenerateRoute] and [Navigator.onUnknownRoute]. If [home], [routes],
// and [builder] are null, or if they fail to create a requested route,
// [onGenerateRoute] will be invoked. If that fails, [onUnknownRoute] will be invoked.
//
// The [pageRouteBuilder] is called to create a [PageRoute] that wraps newly built routes.
// If the [builder] is non-null and the [onGenerateRoute] argument is null, then the
// [builder] will be provided only with the context and the child widget, whereas
// the [pageRouteBuilder] will be provided with [RouteSettings]; in that configuration,
// the [navigatorKey], [onUnknownRoute], [navigatorObservers], and
// [initialRoute] properties must have their default values, as they will have no effect.
//
// The `supportedLocales` argument must be a list of one or more elements.
// By default supportedLocales is `[const Locale('en', 'US')]`.
//
// {@tool dartpad}
// This sample shows a basic Flutter application using [WidgetsApp].
//
// ** See code in examples/api/lib/widgets/app/widgets_app.widgets_app.0.dart **
// {@end-tool}
message FlutterWidgetsApp {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.widgetsApp.navigatorObservers}
  // The list of observers for the [Navigator] created for this app.
  //
  // This list must be replaced by a list of newly-created observers if the
  // [navigatorKey] is changed.
  //
  // The [Navigator] is only built if routes are provided (either via [home],
  // [routes], [onGenerateRoute], or [onUnknownRoute]); if they are not,
  // [navigatorObservers] must be the empty list and [builder] must not be null.
  // {@endtemplate}
  repeated FlutterNavigatorObserverType navigator_observers = 8;
  // {@template flutter.widgets.widgetsApp.initialRoute}
  // The name of the first route to show, if a [Navigator] is built.
  //
  // Defaults to [dart:ui.PlatformDispatcher.defaultRouteName], which may be
  // overridden by the code that launched the application.
  //
  // If the route name starts with a slash, then it is treated as a "deep link",
  // and before this route is pushed, the routes leading to this one are pushed
  // also. For example, if the route was `/a/b/c`, then the app would start
  // with the four routes `/`, `/a`, `/a/b`, and `/a/b/c` loaded, in that order.
  // Even if the route was just `/a`, the app would start with `/` and `/a`
  // loaded. You can use the [onGenerateInitialRoutes] property to override
  // this behavior.
  //
  // Intermediate routes aren't required to exist. In the example above, `/a`
  // and `/a/b` could be skipped if they have no matching route. But `/a/b/c` is
  // required to have a route, else [initialRoute] is ignored and
  // [Navigator.defaultRouteName] is used instead (`/`). This can happen if the
  // app is started with an intent that specifies a non-existent route.
  //
  // The [Navigator] is only built if routes are provided (either via [home],
  // [routes], [onGenerateRoute], or [onUnknownRoute]); if they are not,
  // [initialRoute] must be null and [builder] must not be null.
  //
  // Changing the [initialRoute] will have no effect, as it only controls the
  // _initial_ route. To change the route while the application is running, use
  // the [Navigator] or [Router] APIs.
  //
  // See also:
  //
  //  * [Navigator.initialRoute], which is used to implement this property.
  //  * [Navigator.push], for pushing additional routes.
  //  * [Navigator.pop], for removing a route from the stack.
  //
  // {@endtemplate}
  string initial_route = 9;
  // {@template flutter.widgets.widgetsApp.home}
  // The widget for the default route of the app ([Navigator.defaultRouteName],
  // which is `/`).
  //
  // This is the route that is displayed first when the application is started
  // normally, unless [initialRoute] is specified. It's also the route that's
  // displayed if the [initialRoute] can't be displayed.
  //
  // To be able to directly call [Theme.of], [MediaQuery.of], etc, in the code
  // that sets the [home] argument in the constructor, you can use a [Builder]
  // widget to get a [BuildContext].
  //
  // If [home] is specified, then [routes] must not include an entry for `/`,
  // as [home] takes its place.
  //
  // The [Navigator] is only built if routes are provided (either via [home],
  // [routes], [onGenerateRoute], or [onUnknownRoute]); if they are not,
  // [builder] must not be null.
  //
  // The difference between using [home] and using [builder] is that the [home]
  // subtree is inserted into the application below a [Navigator] (and thus
  // below an [Overlay], which [Navigator] uses). With [home], therefore,
  // dialog boxes will work automatically, the [routes] table will be used, and
  // APIs such as [Navigator.push] and [Navigator.pop] will work as expected.
  // In contrast, the widget returned from [builder] is inserted _above_ the
  // app's [Navigator] (if any).
  // {@endtemplate}
  //
  // If this property is set, the [pageRouteBuilder] property must also be set
  // so that the default route handler will know what kind of [PageRoute]s to
  // build.
  WidgetType home = 11;
  // {@template flutter.widgets.widgetsApp.title}
  // A one-line description used by the device to identify the app for the user.
  //
  // On Android the titles appear above the task manager's app snapshots which are
  // displayed when the user presses the "recent apps" button. On iOS this
  // value cannot be used. `CFBundleDisplayName` from the app's `Info.plist` is
  // referred to instead whenever present, `CFBundleName` otherwise.
  // On the web it is used as the page title, which shows up in the browser's list of open tabs.
  //
  // To provide a localized title instead, use [onGenerateTitle].
  // {@endtemplate}
  string title = 14;
  // The default text style for [Text] in the application.
  FlutterTextStyleType text_style = 16;
  // {@template flutter.widgets.widgetsApp.color}
  // The primary color to use for the application in the operating system
  // interface.
  //
  // For example, on Android this is the color used for the application in the
  // application switcher.
  // {@endtemplate}
  DartColorType color = 17;
  // {@template flutter.widgets.widgetsApp.locale}
  // The initial locale for this app's [Localizations] widget is based
  // on this value.
  //
  // If the 'locale' is null then the system's locale value is used.
  //
  // The value of [Localizations.locale] will equal this locale if
  // it matches one of the [supportedLocales]. Otherwise it will be
  // the first element of [supportedLocales].
  // {@endtemplate}
  //
  // See also:
  //
  //  * [localeResolutionCallback], which can override the default
  //    [supportedLocales] matching algorithm.
  //  * [localizationsDelegates], which collectively define all of the localized
  //    resources used by this app.
  DartLocaleType locale = 18;
  // {@template flutter.widgets.widgetsApp.supportedLocales}
  // The list of locales that this app has been localized for.
  //
  // By default only the American English locale is supported. Apps should
  // configure this list to match the locales they support.
  //
  // This list must not null. Its default value is just
  // `[const Locale('en', 'US')]`.
  //
  // The order of the list matters. The default locale resolution algorithm,
  // [basicLocaleListResolution], attempts to match by the following priority:
  //
  //  1. [Locale.languageCode], [Locale.scriptCode], and [Locale.countryCode]
  //  2. [Locale.languageCode] and [Locale.scriptCode] only
  //  3. [Locale.languageCode] and [Locale.countryCode] only
  //  4. [Locale.languageCode] only
  //  5. [Locale.countryCode] only when all preferred locales fail to match
  //  6. Returns the first element of [supportedLocales] as a fallback
  //
  // When more than one supported locale matches one of these criteria, only
  // the first matching locale is returned.
  //
  // The default locale resolution algorithm can be overridden by providing a
  // value for [localeListResolutionCallback]. The provided
  // [basicLocaleListResolution] is optimized for speed and does not implement
  // a full algorithm (such as the one defined in
  // [Unicode TR35](https://unicode.org/reports/tr35/#LanguageMatching)) that
  // takes distances between languages into account.
  //
  // When supporting languages with more than one script, it is recommended
  // to specify the [Locale.scriptCode] explicitly. Locales may also be defined without
  // [Locale.countryCode] to specify a generic fallback for a particular script.
  //
  // A fully supported language with multiple scripts should define a generic language-only
  // locale (e.g. 'zh'), language+script only locales (e.g. 'zh_Hans' and 'zh_Hant'),
  // and any language+script+country locales (e.g. 'zh_Hans_CN'). Fully defining all of
  // these locales as supported is not strictly required but allows for proper locale resolution in
  // the most number of cases. These locales can be specified with the [Locale.fromSubtags]
  // constructor:
  //
  // ```dart
  // // Full Chinese support for CN, TW, and HK
  // supportedLocales: <Locale>[
  //   const Locale.fromSubtags(languageCode: 'zh'), // generic Chinese 'zh'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hans'), // generic simplified Chinese 'zh_Hans'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hant'), // generic traditional Chinese 'zh_Hant'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hans', countryCode: 'CN'), // 'zh_Hans_CN'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hant', countryCode: 'TW'), // 'zh_Hant_TW'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hant', countryCode: 'HK'), // 'zh_Hant_HK'
  // ],
  // ```
  //
  // Omitting some these fallbacks may result in improperly resolved
  // edge-cases, for example, a simplified Chinese user in Taiwan ('zh_Hans_TW')
  // may resolve to traditional Chinese if 'zh_Hans' and 'zh_Hans_CN' are
  // omitted.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [MaterialApp.supportedLocales], which sets the `supportedLocales`
  //    of the [WidgetsApp] it creates.
  //  * [localeResolutionCallback], an app callback that resolves the app's locale
  //    when the device's locale changes.
  //  * [localizationsDelegates], which collectively define all of the localized
  //    resources used by this app.
  //  * [basicLocaleListResolution], the default locale resolution algorithm.
  repeated DartLocaleType supported_locales = 22;
  // Turns on a performance overlay.
  //
  // See also:
  //
  //  * <https://flutter.dev/debugging/#performance-overlay>
  bool show_performance_overlay = 23;
  // Checkerboards raster cache images.
  //
  // See [PerformanceOverlay.checkerboardRasterCacheImages].
  bool checkerboard_raster_cache_images = 24;
  // Checkerboards layers rendered to offscreen bitmaps.
  //
  // See [PerformanceOverlay.checkerboardOffscreenLayers].
  bool checkerboard_offscreen_layers = 25;
  // Turns on an overlay that shows the accessibility information
  // reported by the framework.
  bool show_semantics_debugger = 26;
  // Turns on an overlay that enables inspecting the widget tree.
  //
  // The inspector is only available in debug mode as it depends on
  // [RenderObject.debugDescribeChildren] which should not be called outside of
  // debug mode.
  bool debug_show_widget_inspector = 27;
  // {@template flutter.widgets.widgetsApp.debugShowCheckedModeBanner}
  // Turns on a little "DEBUG" banner in debug mode to indicate
  // that the app is in debug mode. This is on by default (in
  // debug mode), to turn it off, set the constructor argument to
  // false. In release mode this has no effect.
  //
  // To get this banner in your application if you're not using
  // WidgetsApp, include a [CheckedModeBanner] widget in your app.
  //
  // This banner is intended to deter people from complaining that your
  // app is slow when it's in debug mode. In debug mode, Flutter
  // enables a large number of expensive diagnostics to aid in
  // development, and so performance in debug mode is not
  // representative of what will happen in release mode.
  // {@endtemplate}
  bool debug_show_checked_mode_banner = 28;
  // {@template flutter.widgets.widgetsApp.restorationScopeId}
  // The identifier to use for state restoration of this app.
  //
  // Providing a restoration ID inserts a [RootRestorationScope] into the
  // widget hierarchy, which enables state restoration for descendant widgets.
  //
  // Providing a restoration ID also enables the [Navigator] or [Router] built
  // by the [WidgetsApp] to restore its state (i.e. to restore the history
  // stack of active [Route]s). See the documentation on [Navigator] for more
  // details around state restoration of [Route]s.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  // {@endtemplate}
  string restoration_scope_id = 32;
}

// package:flutter/src/widgets/app.dart
//
// Creates a [WidgetsApp] that uses the [Router] instead of a [Navigator].
//
// {@template flutter.widgets.WidgetsApp.router}
// If the [routerConfig] is provided, the other router related delegates,
// [routeInformationParser], [routeInformationProvider], [routerDelegate],
// and [backButtonDispatcher], must all be null.
// {@endtemplate}
message FlutterWidgetsAppNamedRouter {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.widgets.widgetsApp.routeInformationProvider}
  // A object that provides route information through the
  // [RouteInformationProvider.value] and notifies its listener when its value
  // changes.
  //
  // This object will be used by the underlying [Router].
  //
  // If this is not provided, the widgets app will create a
  // [PlatformRouteInformationProvider] with initial route name equal to the
  // [dart:ui.PlatformDispatcher.defaultRouteName] by default.
  //
  // See also:
  //
  //  * [Router.routeInformationProvider], which receives this object when this
  //    widget builds the [Router].
  // {@endtemplate}
  FlutterRouteInformationProviderType route_information_provider = 3;
  // {@template flutter.widgets.widgetsApp.backButtonDispatcher}
  // A delegate that decide whether to handle the Android back button intent.
  //
  // This object will be used by the underlying [Router].
  //
  // If this is not provided, the widgets app will create a
  // [RootBackButtonDispatcher] by default.
  //
  // See also:
  //
  //  * [Router.backButtonDispatcher], which receives this object when this
  //    widget builds the [Router].
  // {@endtemplate}
  FlutterBackButtonDispatcherType back_button_dispatcher = 7;
  // {@template flutter.widgets.widgetsApp.title}
  // A one-line description used by the device to identify the app for the user.
  //
  // On Android the titles appear above the task manager's app snapshots which are
  // displayed when the user presses the "recent apps" button. On iOS this
  // value cannot be used. `CFBundleDisplayName` from the app's `Info.plist` is
  // referred to instead whenever present, `CFBundleName` otherwise.
  // On the web it is used as the page title, which shows up in the browser's list of open tabs.
  //
  // To provide a localized title instead, use [onGenerateTitle].
  // {@endtemplate}
  string title = 9;
  // The default text style for [Text] in the application.
  FlutterTextStyleType text_style = 12;
  // {@template flutter.widgets.widgetsApp.color}
  // The primary color to use for the application in the operating system
  // interface.
  //
  // For example, on Android this is the color used for the application in the
  // application switcher.
  // {@endtemplate}
  DartColorType color = 13;
  // {@template flutter.widgets.widgetsApp.locale}
  // The initial locale for this app's [Localizations] widget is based
  // on this value.
  //
  // If the 'locale' is null then the system's locale value is used.
  //
  // The value of [Localizations.locale] will equal this locale if
  // it matches one of the [supportedLocales]. Otherwise it will be
  // the first element of [supportedLocales].
  // {@endtemplate}
  //
  // See also:
  //
  //  * [localeResolutionCallback], which can override the default
  //    [supportedLocales] matching algorithm.
  //  * [localizationsDelegates], which collectively define all of the localized
  //    resources used by this app.
  DartLocaleType locale = 14;
  // {@template flutter.widgets.widgetsApp.supportedLocales}
  // The list of locales that this app has been localized for.
  //
  // By default only the American English locale is supported. Apps should
  // configure this list to match the locales they support.
  //
  // This list must not null. Its default value is just
  // `[const Locale('en', 'US')]`.
  //
  // The order of the list matters. The default locale resolution algorithm,
  // [basicLocaleListResolution], attempts to match by the following priority:
  //
  //  1. [Locale.languageCode], [Locale.scriptCode], and [Locale.countryCode]
  //  2. [Locale.languageCode] and [Locale.scriptCode] only
  //  3. [Locale.languageCode] and [Locale.countryCode] only
  //  4. [Locale.languageCode] only
  //  5. [Locale.countryCode] only when all preferred locales fail to match
  //  6. Returns the first element of [supportedLocales] as a fallback
  //
  // When more than one supported locale matches one of these criteria, only
  // the first matching locale is returned.
  //
  // The default locale resolution algorithm can be overridden by providing a
  // value for [localeListResolutionCallback]. The provided
  // [basicLocaleListResolution] is optimized for speed and does not implement
  // a full algorithm (such as the one defined in
  // [Unicode TR35](https://unicode.org/reports/tr35/#LanguageMatching)) that
  // takes distances between languages into account.
  //
  // When supporting languages with more than one script, it is recommended
  // to specify the [Locale.scriptCode] explicitly. Locales may also be defined without
  // [Locale.countryCode] to specify a generic fallback for a particular script.
  //
  // A fully supported language with multiple scripts should define a generic language-only
  // locale (e.g. 'zh'), language+script only locales (e.g. 'zh_Hans' and 'zh_Hant'),
  // and any language+script+country locales (e.g. 'zh_Hans_CN'). Fully defining all of
  // these locales as supported is not strictly required but allows for proper locale resolution in
  // the most number of cases. These locales can be specified with the [Locale.fromSubtags]
  // constructor:
  //
  // ```dart
  // // Full Chinese support for CN, TW, and HK
  // supportedLocales: <Locale>[
  //   const Locale.fromSubtags(languageCode: 'zh'), // generic Chinese 'zh'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hans'), // generic simplified Chinese 'zh_Hans'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hant'), // generic traditional Chinese 'zh_Hant'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hans', countryCode: 'CN'), // 'zh_Hans_CN'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hant', countryCode: 'TW'), // 'zh_Hant_TW'
  //   const Locale.fromSubtags(languageCode: 'zh', scriptCode: 'Hant', countryCode: 'HK'), // 'zh_Hant_HK'
  // ],
  // ```
  //
  // Omitting some these fallbacks may result in improperly resolved
  // edge-cases, for example, a simplified Chinese user in Taiwan ('zh_Hans_TW')
  // may resolve to traditional Chinese if 'zh_Hans' and 'zh_Hans_CN' are
  // omitted.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [MaterialApp.supportedLocales], which sets the `supportedLocales`
  //    of the [WidgetsApp] it creates.
  //  * [localeResolutionCallback], an app callback that resolves the app's locale
  //    when the device's locale changes.
  //  * [localizationsDelegates], which collectively define all of the localized
  //    resources used by this app.
  //  * [basicLocaleListResolution], the default locale resolution algorithm.
  repeated DartLocaleType supported_locales = 18;
  // Turns on a performance overlay.
  //
  // See also:
  //
  //  * <https://flutter.dev/debugging/#performance-overlay>
  bool show_performance_overlay = 19;
  // Checkerboards raster cache images.
  //
  // See [PerformanceOverlay.checkerboardRasterCacheImages].
  bool checkerboard_raster_cache_images = 20;
  // Checkerboards layers rendered to offscreen bitmaps.
  //
  // See [PerformanceOverlay.checkerboardOffscreenLayers].
  bool checkerboard_offscreen_layers = 21;
  // Turns on an overlay that shows the accessibility information
  // reported by the framework.
  bool show_semantics_debugger = 22;
  // Turns on an overlay that enables inspecting the widget tree.
  //
  // The inspector is only available in debug mode as it depends on
  // [RenderObject.debugDescribeChildren] which should not be called outside of
  // debug mode.
  bool debug_show_widget_inspector = 23;
  // {@template flutter.widgets.widgetsApp.debugShowCheckedModeBanner}
  // Turns on a little "DEBUG" banner in debug mode to indicate
  // that the app is in debug mode. This is on by default (in
  // debug mode), to turn it off, set the constructor argument to
  // false. In release mode this has no effect.
  //
  // To get this banner in your application if you're not using
  // WidgetsApp, include a [CheckedModeBanner] widget in your app.
  //
  // This banner is intended to deter people from complaining that your
  // app is slow when it's in debug mode. In debug mode, Flutter
  // enables a large number of expensive diagnostics to aid in
  // development, and so performance in debug mode is not
  // representative of what will happen in release mode.
  // {@endtemplate}
  bool debug_show_checked_mode_banner = 24;
  // {@template flutter.widgets.widgetsApp.restorationScopeId}
  // The identifier to use for state restoration of this app.
  //
  // Providing a restoration ID inserts a [RootRestorationScope] into the
  // widget hierarchy, which enables state restoration for descendant widgets.
  //
  // Providing a restoration ID also enables the [Navigator] or [Router] built
  // by the [WidgetsApp] to restore its state (i.e. to restore the history
  // stack of active [Route]s). See the documentation on [Navigator] for more
  // details around state restoration of [Route]s.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  // {@endtemplate}
  string restoration_scope_id = 28;
}

// package:flutter/src/widgets/basic.dart
//
// Creates a wrap layout.
//
// By default, the wrap layout is horizontal and both the children and the
// runs are aligned to the start.
//
// The [textDirection] argument defaults to the ambient [Directionality], if
// any. If there is no ambient directionality, and a text direction is going
// to be necessary to decide which direction to lay the children in or to
// disambiguate `start` or `end` values for the main or cross axis
// directions, the [textDirection] must not be null.
message FlutterWrap {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The direction to use as the main axis.
  //
  // For example, if [direction] is [Axis.horizontal], the default, the
  // children are placed adjacent to one another in a horizontal run until the
  // available horizontal space is consumed, at which point a subsequent
  // children are placed in a new run vertically adjacent to the previous run.
  FlutterAxisType.Enum direction = 3;
  // How the children within a run should be placed in the main axis.
  //
  // For example, if [alignment] is [WrapAlignment.center], the children in
  // each run are grouped together in the center of their run in the main axis.
  //
  // Defaults to [WrapAlignment.start].
  //
  // See also:
  //
  //  * [runAlignment], which controls how the runs are placed relative to each
  //    other in the cross axis.
  //  * [crossAxisAlignment], which controls how the children within each run
  //    are placed relative to each other in the cross axis.
  FlutterWrapAlignmentType.Enum alignment = 4;
  // How much space to place between children in a run in the main axis.
  //
  // For example, if [spacing] is 10.0, the children will be spaced at least
  // 10.0 logical pixels apart in the main axis.
  //
  // If there is additional free space in a run (e.g., because the wrap has a
  // minimum size that is not filled or because some runs are longer than
  // others), the additional free space will be allocated according to the
  // [alignment].
  //
  // Defaults to 0.0.
  double spacing = 5;
  // How the runs themselves should be placed in the cross axis.
  //
  // For example, if [runAlignment] is [WrapAlignment.center], the runs are
  // grouped together in the center of the overall [Wrap] in the cross axis.
  //
  // Defaults to [WrapAlignment.start].
  //
  // See also:
  //
  //  * [alignment], which controls how the children within each run are placed
  //    relative to each other in the main axis.
  //  * [crossAxisAlignment], which controls how the children within each run
  //    are placed relative to each other in the cross axis.
  FlutterWrapAlignmentType.Enum run_alignment = 6;
  // How much space to place between the runs themselves in the cross axis.
  //
  // For example, if [runSpacing] is 10.0, the runs will be spaced at least
  // 10.0 logical pixels apart in the cross axis.
  //
  // If there is additional free space in the overall [Wrap] (e.g., because
  // the wrap has a minimum size that is not filled), the additional free space
  // will be allocated according to the [runAlignment].
  //
  // Defaults to 0.0.
  double run_spacing = 7;
  // How the children within a run should be aligned relative to each other in
  // the cross axis.
  //
  // For example, if this is set to [WrapCrossAlignment.end], and the
  // [direction] is [Axis.horizontal], then the children within each
  // run will have their bottom edges aligned to the bottom edge of the run.
  //
  // Defaults to [WrapCrossAlignment.start].
  //
  // See also:
  //
  //  * [alignment], which controls how the children within each run are placed
  //    relative to each other in the main axis.
  //  * [runAlignment], which controls how the runs are placed relative to each
  //    other in the cross axis.
  FlutterWrapCrossAlignmentType.Enum cross_axis_alignment = 8;
  // Determines the order to lay children out horizontally and how to interpret
  // `start` and `end` in the horizontal direction.
  //
  // Defaults to the ambient [Directionality].
  //
  // If the [direction] is [Axis.horizontal], this controls order in which the
  // children are positioned (left-to-right or right-to-left), and the meaning
  // of the [alignment] property's [WrapAlignment.start] and
  // [WrapAlignment.end] values.
  //
  // If the [direction] is [Axis.horizontal], and either the
  // [alignment] is either [WrapAlignment.start] or [WrapAlignment.end], or
  // there's more than one child, then the [textDirection] (or the ambient
  // [Directionality]) must not be null.
  //
  // If the [direction] is [Axis.vertical], this controls the order in which
  // runs are positioned, the meaning of the [runAlignment] property's
  // [WrapAlignment.start] and [WrapAlignment.end] values, as well as the
  // [crossAxisAlignment] property's [WrapCrossAlignment.start] and
  // [WrapCrossAlignment.end] values.
  //
  // If the [direction] is [Axis.vertical], and either the
  // [runAlignment] is either [WrapAlignment.start] or [WrapAlignment.end], the
  // [crossAxisAlignment] is either [WrapCrossAlignment.start] or
  // [WrapCrossAlignment.end], or there's more than one child, then the
  // [textDirection] (or the ambient [Directionality]) must not be null.
  DartTextDirectionType.Enum text_direction = 9;
  // Determines the order to lay children out vertically and how to interpret
  // `start` and `end` in the vertical direction.
  //
  // If the [direction] is [Axis.vertical], this controls which order children
  // are painted in (down or up), the meaning of the [alignment] property's
  // [WrapAlignment.start] and [WrapAlignment.end] values.
  //
  // If the [direction] is [Axis.vertical], and either the [alignment]
  // is either [WrapAlignment.start] or [WrapAlignment.end], or there's
  // more than one child, then the [verticalDirection] must not be null.
  //
  // If the [direction] is [Axis.horizontal], this controls the order in which
  // runs are positioned, the meaning of the [runAlignment] property's
  // [WrapAlignment.start] and [WrapAlignment.end] values, as well as the
  // [crossAxisAlignment] property's [WrapCrossAlignment.start] and
  // [WrapCrossAlignment.end] values.
  //
  // If the [direction] is [Axis.horizontal], and either the
  // [runAlignment] is either [WrapAlignment.start] or [WrapAlignment.end], the
  // [crossAxisAlignment] is either [WrapCrossAlignment.start] or
  // [WrapCrossAlignment.end], or there's more than one child, then the
  // [verticalDirection] must not be null.
  FlutterVerticalDirectionType.Enum vertical_direction = 10;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 11;
  // The widgets below this widget in the tree.
  //
  // If this list is going to be mutated, it is usually wise to put a [Key] on
  // each of the child widgets, so that the framework can match old
  // configurations to new configurations and maintain the underlying render
  // objects.
  //
  // Also, a [Widget] in Flutter is immutable, so directly modifying the
  // [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
  // as the example code below will result in incorrect behaviors. Whenever the
  // children list is modified, a new list object should be provided.
  //
  // ```dart
  // // This code is incorrect.
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       _children.add(const ChildWidget());
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Reusing `List<Widget> _children` here is problematic.
  //     return Row(children: _children);
  //   }
  // }
  // ```
  //
  // The following code corrects the problem mentioned above.
  //
  // ```dart
  // class SomeWidgetState extends State<SomeWidget> {
  //   final List<Widget> _children = <Widget>[];
  //
  //   void someHandler() {
  //     setState(() {
  //       // The key here allows Flutter to reuse the underlying render
  //       // objects even if the children list is recreated.
  //       _children.add(ChildWidget(key: UniqueKey()));
  //     });
  //   }
  //
  //   @override
  //   Widget build(BuildContext context) {
  //     // Always create a new list of children as a Widget is immutable.
  //     return Row(children: _children.toList());
  //   }
  // }
  // ```
  repeated WidgetType children = 12;
}

// package:flutter/src/material/about.dart
//
// Creates an about box.
//
// The arguments are all optional. The application name, if omitted, will be
// derived from the nearest [Title] widget. The version, icon, and legalese
// values default to the empty string.
message MaterialAboutDialog {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The name of the application.
  //
  // Defaults to the value of [Title.title], if a [Title] widget can be found.
  // Otherwise, defaults to [Platform.resolvedExecutable].
  string application_name = 3;
  // The version of this build of the application.
  //
  // This string is shown under the application name.
  //
  // Defaults to the empty string.
  string application_version = 4;
  // The icon to show next to the application name.
  //
  // By default no icon is shown.
  //
  // Typically this will be an [ImageIcon] widget. It should honor the
  // [IconTheme]'s [IconThemeData.size].
  WidgetType application_icon = 5;
  // A string to show in small print.
  //
  // Typically this is a copyright notice.
  //
  // Defaults to the empty string.
  string application_legalese = 6;
  // Widgets to add to the dialog box after the name, version, and legalese.
  //
  // This could include a link to a Web site, some descriptive text, credits,
  // or other information to show in the about box.
  //
  // Defaults to nothing.
  repeated WidgetType children = 7;
}

// package:flutter/src/material/about.dart
//
// Creates a list tile for showing an about box.
//
// The arguments are all optional. The application name, if omitted, will be
// derived from the nearest [Title] widget. The version, icon, and legalese
// values default to the empty string.
message MaterialAboutListTile {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The icon to show for this drawer item.
  //
  // By default no icon is shown.
  //
  // This is not necessarily the same as the image shown in the dialog box
  // itself; which is controlled by the [applicationIcon] property.
  WidgetType icon = 3;
  // The label to show on this drawer item.
  //
  // Defaults to a text widget that says "About Foo" where "Foo" is the
  // application name specified by [applicationName].
  WidgetType child = 4;
  // The name of the application.
  //
  // This string is used in the default label for this drawer item (see
  // [child]) and as the caption of the [AboutDialog] that is shown.
  //
  // Defaults to the value of [Title.title], if a [Title] widget can be found.
  // Otherwise, defaults to [Platform.resolvedExecutable].
  string application_name = 5;
  // The version of this build of the application.
  //
  // This string is shown under the application name in the [AboutDialog].
  //
  // Defaults to the empty string.
  string application_version = 6;
  // The icon to show next to the application name in the [AboutDialog].
  //
  // By default no icon is shown.
  //
  // Typically this will be an [ImageIcon] widget. It should honor the
  // [IconTheme]'s [IconThemeData.size].
  //
  // This is not necessarily the same as the icon shown on the drawer item
  // itself, which is controlled by the [icon] property.
  WidgetType application_icon = 7;
  // A string to show in small print in the [AboutDialog].
  //
  // Typically this is a copyright notice.
  //
  // Defaults to the empty string.
  string application_legalese = 8;
  // Widgets to add to the [AboutDialog] after the name, version, and legalese.
  //
  // This could include a link to a Web site, some descriptive text, credits,
  // or other information to show in the about box.
  //
  // Defaults to nothing.
  repeated WidgetType about_box_children = 9;
  // Whether this list tile is part of a vertically dense list.
  //
  // If this property is null, then its value is based on [ListTileThemeData.dense].
  //
  // Dense list tiles default to a smaller height.
  bool dense = 10;
}

// package:flutter/src/material/action_chip.dart
//
// Create a chip that acts like a button.
//
// The [label], [onPressed], [autofocus], and [clipBehavior] arguments must
// not be null. The [pressElevation] and [elevation] must be null or
// non-negative. Typically, [pressElevation] is greater than [elevation].
message MaterialActionChip {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  WidgetType avatar = 3;
  WidgetType label = 4;
  FlutterTextStyleType label_style = 5;
  FlutterEdgeInsetsGeometryType label_padding = 6;
  double press_elevation = 8;
  string tooltip = 9;
  FlutterBorderSideType side = 10;
  FlutterOutlinedBorderType shape = 11;
  DartClipType.Enum clip_behavior = 12;
  FlutterFocusNodeType focus_node = 13;
  bool autofocus = 14;
  DartColorType background_color = 16;
  DartColorType disabled_color = 17;
  FlutterEdgeInsetsGeometryType padding = 18;
  MaterialVisualDensityType visual_density = 19;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 20;
  double elevation = 21;
  DartColorType shadow_color = 22;
  DartColorType surface_tint_color = 23;
  FlutterIconThemeDataType icon_theme = 24;
}

// package:flutter/src/material/action_chip.dart
//
// Create an elevated chip that acts like a button.
//
// The [label], [onPressed], [autofocus], and [clipBehavior] arguments must
// not be null. The [pressElevation] and [elevation] must be null or
// non-negative. Typically, [pressElevation] is greater than [elevation].
message MaterialActionChipNamedElevated {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  WidgetType avatar = 3;
  WidgetType label = 4;
  FlutterTextStyleType label_style = 5;
  FlutterEdgeInsetsGeometryType label_padding = 6;
  double press_elevation = 8;
  string tooltip = 9;
  FlutterBorderSideType side = 10;
  FlutterOutlinedBorderType shape = 11;
  DartClipType.Enum clip_behavior = 12;
  FlutterFocusNodeType focus_node = 13;
  bool autofocus = 14;
  DartColorType background_color = 16;
  DartColorType disabled_color = 17;
  FlutterEdgeInsetsGeometryType padding = 18;
  MaterialVisualDensityType visual_density = 19;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 20;
  double elevation = 21;
  DartColorType shadow_color = 22;
  DartColorType surface_tint_color = 23;
  FlutterIconThemeDataType icon_theme = 24;
}

// package:flutter/src/material/action_icons_theme.dart
//
// Creates a theme that overrides the default icon of [BackButtonIcon],
// [CloseButtonIcon], [DrawerButtonIcon], and [EndDrawerButtonIcon] in this
// widget's subtree.
message MaterialActionIconTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the default icon overrides for descendant [BackButtonIcon],
  // [CloseButtonIcon], [DrawerButtonIcon], and [EndDrawerButtonIcon] widgets.
  MaterialActionIconThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/action_icons_theme.dart
//
// Creates an [ActionIconThemeData].
//
// The builders [backButtonIconBuilder], [closeButtonIconBuilder],
// [drawerButtonIconBuilder], [endDrawerButtonIconBuilder] may be null.
message MaterialActionIconThemeData {
  
}

// package:flutter/src/material/adaptive_text_selection_toolbar.dart
//
// Create an instance of [AdaptiveTextSelectionToolbar] with the
// given [children].
//
// See also:
//
// {@template flutter.material.AdaptiveTextSelectionToolbar.buttonItems}
// * [AdaptiveTextSelectionToolbar.buttonItems], which takes a list of
//   [ContextMenuButtonItem]s instead of [children] widgets.
// {@endtemplate}
// {@template flutter.material.AdaptiveTextSelectionToolbar.editable}
// * [AdaptiveTextSelectionToolbar.editable], which builds the default
//   children for an editable field.
// {@endtemplate}
// {@template flutter.material.AdaptiveTextSelectionToolbar.editableText}
// * [AdaptiveTextSelectionToolbar.editableText], which builds the default
//   children for an [EditableText].
// {@endtemplate}
// {@template flutter.material.AdaptiveTextSelectionToolbar.selectable}
// * [AdaptiveTextSelectionToolbar.selectable], which builds the default
//   children for content that is selectable but not editable.
// {@endtemplate}
message MaterialAdaptiveTextSelectionToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The children of the toolbar, typically buttons.
  repeated WidgetType children = 3;
  // {@template flutter.material.AdaptiveTextSelectionToolbar.anchors}
  // The location on which to anchor the menu.
  // {@endtemplate}
  FlutterTextSelectionToolbarAnchorsType anchors = 4;
}

// package:flutter/src/material/adaptive_text_selection_toolbar.dart
//
// Create an instance of [AdaptiveTextSelectionToolbar] whose children will
// be built from the given [buttonItems].
//
// See also:
//
// {@template flutter.material.AdaptiveTextSelectionToolbar.new}
// * [AdaptiveTextSelectionToolbar.new], which takes the children directly as
//   a list of widgets.
// {@endtemplate}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.editable}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.editableText}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.selectable}
message MaterialAdaptiveTextSelectionToolbarNamedButtonItems {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.material.AdaptiveTextSelectionToolbar.buttonItems}
  // The [ContextMenuButtonItem]s that will be turned into the correct button
  // widgets for the current platform.
  // {@endtemplate}
  repeated FlutterContextMenuButtonItemType button_items = 3;
  // {@template flutter.material.AdaptiveTextSelectionToolbar.anchors}
  // The location on which to anchor the menu.
  // {@endtemplate}
  FlutterTextSelectionToolbarAnchorsType anchors = 4;
}

// package:flutter/src/material/adaptive_text_selection_toolbar.dart
//
// Create an instance of [AdaptiveTextSelectionToolbar] with the default
// children for an editable field.
//
// If a callback is null, then its corresponding button will not be built.
//
// See also:
//
// {@macro flutter.material.AdaptiveTextSelectionToolbar.new}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.editableText}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.buttonItems}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.selectable}
message MaterialAdaptiveTextSelectionToolbarNamedEditable {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterClipboardStatusType.Enum clipboard_status = 3;
  // {@template flutter.material.AdaptiveTextSelectionToolbar.anchors}
  // The location on which to anchor the menu.
  // {@endtemplate}
  FlutterTextSelectionToolbarAnchorsType anchors = 12;
}

// package:flutter/src/material/adaptive_text_selection_toolbar.dart
//
// Create an instance of [AdaptiveTextSelectionToolbar] with the default
// children for an [EditableText].
//
// See also:
//
// {@macro flutter.material.AdaptiveTextSelectionToolbar.new}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.editable}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.buttonItems}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.selectable}
message MaterialAdaptiveTextSelectionToolbarNamedEditableText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterEditableTextStateType editable_text_state = 3;
}

// package:flutter/src/material/adaptive_text_selection_toolbar.dart
//
// Create an instance of [AdaptiveTextSelectionToolbar] with the default
// children for a [SelectableRegion].
//
// See also:
//
// {@macro flutter.material.AdaptiveTextSelectionToolbar.new}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.buttonItems}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.editable}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.editableText}
// {@macro flutter.material.AdaptiveTextSelectionToolbar.selectable}
message MaterialAdaptiveTextSelectionToolbarNamedSelectableRegion {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterSelectableRegionStateType selectable_region_state = 3;
}

// package:flutter/src/material/dialog.dart
//
// Creates an alert dialog.
//
// Typically used in conjunction with [showDialog].
//
// The [titlePadding] and [contentPadding] default to null, which implies a
// default that depends on the values of the other properties. See the
// documentation of [titlePadding] and [contentPadding] for details.
message MaterialAlertDialog {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // An optional icon to display at the top of the dialog.
  //
  // Typically, an [Icon] widget. Providing an icon centers the [title]'s text.
  WidgetType icon = 3;
  // Padding around the [icon].
  //
  // If there is no [icon], no padding will be provided. Otherwise, this
  // padding is used.
  //
  // This property defaults to providing 24 pixels on the top, left, and right
  // of the [icon]. If [title] is _not_ null, 16 pixels of bottom padding is
  // added to separate the [icon] from the [title]. If the [title] is null and
  // [content] is _not_ null, then no bottom padding is provided (but see
  // [contentPadding]). In any other case 24 pixels of bottom padding is
  // added.
  FlutterEdgeInsetsGeometryType icon_padding = 4;
  // Color for the [Icon] in the [icon] of this [AlertDialog].
  //
  // If null, [DialogTheme.iconColor] is used. If that is null, defaults to
  // color scheme's [ColorScheme.secondary] if [ThemeData.useMaterial3] is
  // true, black otherwise.
  DartColorType icon_color = 5;
  // The (optional) title of the dialog is displayed in a large font at the top
  // of the dialog, below the (optional) [icon].
  //
  // Typically a [Text] widget.
  WidgetType title = 6;
  // Padding around the title.
  //
  // If there is no title, no padding will be provided. Otherwise, this padding
  // is used.
  //
  // This property defaults to providing 24 pixels on the top, left, and right
  // of the title. If the [content] is not null, then no bottom padding is
  // provided (but see [contentPadding]). If it _is_ null, then an extra 20
  // pixels of bottom padding is added to separate the [title] from the
  // [actions].
  FlutterEdgeInsetsGeometryType title_padding = 7;
  // Style for the text in the [title] of this [AlertDialog].
  //
  // If null, [DialogTheme.titleTextStyle] is used. If that's null, defaults to
  // [TextTheme.titleLarge] of [ThemeData.textTheme].
  FlutterTextStyleType title_text_style = 8;
  // The (optional) content of the dialog is displayed in the center of the
  // dialog in a lighter font.
  //
  // Typically this is a [SingleChildScrollView] that contains the dialog's
  // message. As noted in the [AlertDialog] documentation, it's important
  // to use a [SingleChildScrollView] if there's any risk that the content
  // will not fit, as the contents will otherwise overflow the dialog.
  //
  // The [content] must support reporting its intrinsic dimensions. In
  // particular, [ListView], [GridView], and [CustomScrollView] cannot be used
  // here unless they are first wrapped in a widget that itself can report
  // intrinsic dimensions, such as a [SizedBox].
  WidgetType content = 9;
  // Padding around the content.
  //
  // If there is no [content], no padding will be provided. Otherwise, this
  // padding is used.
  //
  // This property defaults to providing a padding of 20 pixels above the
  // [content] to separate the [content] from the [title], and 24 pixels on the
  // left, right, and bottom to separate the [content] from the other edges of
  // the dialog.
  //
  // If [ThemeData.useMaterial3] is true, the top padding separating the
  // content from the title defaults to 16 pixels instead of 20 pixels.
  FlutterEdgeInsetsGeometryType content_padding = 10;
  // Style for the text in the [content] of this [AlertDialog].
  //
  // If null, [DialogTheme.contentTextStyle] is used. If that's null, defaults
  // to [TextTheme.titleMedium] of [ThemeData.textTheme].
  FlutterTextStyleType content_text_style = 11;
  // The (optional) set of actions that are displayed at the bottom of the
  // dialog with an [OverflowBar].
  //
  // Typically this is a list of [TextButton] widgets. It is recommended to
  // set the [Text.textAlign] to [TextAlign.end] for the [Text] within the
  // [TextButton], so that buttons whose labels wrap to an extra line align
  // with the overall [OverflowBar]'s alignment within the dialog.
  //
  // If the [title] is not null but the [content] _is_ null, then an extra 20
  // pixels of padding is added above the [OverflowBar] to separate the [title]
  // from the [actions].
  repeated WidgetType actions = 12;
  // Padding around the set of [actions] at the bottom of the dialog.
  //
  // Typically used to provide padding to the button bar between the button bar
  // and the edges of the dialog.
  //
  // The [buttonPadding] may contribute to the padding on the edges of
  // [actions] as well.
  //
  // If there are no [actions], then no padding will be included.
  //
  // {@tool snippet}
  // This is an example of a set of actions aligned with the content widget.
  // ```dart
  // AlertDialog(
  //   title: const Text('Title'),
  //   content: Container(width: 200, height: 200, color: Colors.green),
  //   actions: <Widget>[
  //     ElevatedButton(onPressed: () {}, child: const Text('Button 1')),
  //     ElevatedButton(onPressed: () {}, child: const Text('Button 2')),
  //   ],
  //   actionsPadding: const EdgeInsets.symmetric(horizontal: 8.0),
  // )
  // ```
  // {@end-tool}
  //
  // See also:
  //
  // * [OverflowBar], which [actions] configures to lay itself out.
  FlutterEdgeInsetsGeometryType actions_padding = 13;
  // Defines the horizontal layout of the [actions] according to the same
  // rules as for [Row.mainAxisAlignment].
  //
  // This parameter is passed along to the dialog's [OverflowBar].
  //
  // If this parameter is null (the default) then [MainAxisAlignment.end]
  // is used.
  FlutterMainAxisAlignmentType.Enum actions_alignment = 14;
  // The horizontal alignment of [actions] within the vertical
  // "overflow" layout.
  //
  // If the dialog's [actions] do not fit into a single row, then they
  // are arranged in a column. This parameter controls the horizontal
  // alignment of widgets in the case of an overflow.
  //
  // If this parameter is null (the default) then [OverflowBarAlignment.end]
  // is used.
  //
  // See also:
  //
  // * [OverflowBar], which [actions] configures to lay itself out.
  FlutterOverflowBarAlignmentType.Enum actions_overflow_alignment = 15;
  // The vertical direction of [actions] if the children overflow
  // horizontally.
  //
  // If the dialog's [actions] do not fit into a single row, then they
  // are arranged in a column. The first action is at the top of the
  // column if this property is set to [VerticalDirection.down], since it
  // "starts" at the top and "ends" at the bottom. On the other hand,
  // the first action will be at the bottom of the column if this
  // property is set to [VerticalDirection.up], since it "starts" at the
  // bottom and "ends" at the top.
  //
  // See also:
  //
  // * [OverflowBar], which [actions] configures to lay itself out.
  FlutterVerticalDirectionType.Enum actions_overflow_direction = 16;
  // The spacing between [actions] when the [OverflowBar] switches to a column
  // layout because the actions don't fit horizontally.
  //
  // If the widgets in [actions] do not fit into a single row, they are
  // arranged into a column. This parameter provides additional vertical space
  // between buttons when it does overflow.
  //
  // The button spacing may appear to be more than the value provided. This is
  // because most buttons adhere to the [MaterialTapTargetSize] of 48px. So,
  // even though a button might visually be 36px in height, it might still take
  // up to 48px vertically.
  //
  // If null then no spacing will be added in between buttons in an overflow
  // state.
  double actions_overflow_button_spacing = 17;
  // The padding that surrounds each button in [actions].
  //
  // This is different from [actionsPadding], which defines the padding
  // between the entire button bar and the edges of the dialog.
  //
  // If this property is null, then it will default to
  // 8.0 logical pixels on the left and right.
  FlutterEdgeInsetsGeometryType button_padding = 18;
  // {@macro flutter.material.dialog.backgroundColor}
  DartColorType background_color = 19;
  // {@macro flutter.material.dialog.elevation}
  double elevation = 20;
  // {@macro flutter.material.dialog.shadowColor}
  DartColorType shadow_color = 21;
  // {@macro flutter.material.dialog.surfaceTintColor}
  DartColorType surface_tint_color = 22;
  // The semantic label of the dialog used by accessibility frameworks to
  // announce screen transitions when the dialog is opened and closed.
  //
  // In iOS, if this label is not provided, a semantic label will be inferred
  // from the [title] if it is not null.
  //
  // In Android, if this label is not provided, the dialog will use the
  // [MaterialLocalizations.alertDialogLabel] as its label.
  //
  // See also:
  //
  //  * [SemanticsConfiguration.namesRoute], for a description of how this
  //    value is used.
  string semantic_label = 23;
  // {@macro flutter.material.dialog.insetPadding}
  FlutterEdgeInsetsType inset_padding = 24;
  // {@macro flutter.material.dialog.clipBehavior}
  DartClipType.Enum clip_behavior = 25;
  // {@macro flutter.material.dialog.shape}
  FlutterShapeBorderType shape = 26;
  // {@macro flutter.material.dialog.alignment}
  FlutterAlignmentGeometryType alignment = 27;
  // Determines whether the [title] and [content] widgets are wrapped in a
  // scrollable.
  //
  // This configuration is used when the [title] and [content] are expected
  // to overflow. Both [title] and [content] are wrapped in a scroll view,
  // allowing all overflowed content to be visible while still showing the
  // button bar.
  bool scrollable = 28;
}

// package:flutter/src/material/dialog.dart
//
// Creates an adaptive [AlertDialog] based on whether the target platform is
// iOS or macOS, following Material design's
// [Cross-platform guidelines](https://material.io/design/platform-guidance/cross-platform-adaptation.html).
//
// On iOS and macOS, this constructor creates a [CupertinoAlertDialog]. On
// other platforms, this creates a Material design [AlertDialog].
//
// Typically passed as a child of [showAdaptiveDialog], which will display
// the alert differently based on platform.
//
// If a [CupertinoAlertDialog] is created only these parameters are used:
// [title], [content], [actions], [scrollController],
// [actionScrollController], [insetAnimationDuration], and
// [insetAnimationCurve]. If a material [AlertDialog] is created,
// [scrollController], [actionScrollController], [insetAnimationDuration],
// and [insetAnimationCurve] are ignored.
//
// The target platform is based on the current [Theme]: [ThemeData.platform].
//
// {@tool dartpad}
// This demo shows a [TextButton] which when pressed, calls [showAdaptiveDialog].
// When called, this method displays an adaptive dialog above the current
// contents of the app, with different behaviors depending on target platform.
//
// [CupertinoDialogAction] is conditionally used as the child to show more
// platform specific design.
//
// ** See code in examples/api/lib/material/dialog/adaptive_alert_dialog.0.dart **
// {@end-tool}
message MaterialAlertDialogNamedAdaptive {
  FlutterKeyType key = 2;
  WidgetType icon = 3;
  FlutterEdgeInsetsGeometryType icon_padding = 4;
  DartColorType icon_color = 5;
  WidgetType title = 6;
  FlutterEdgeInsetsGeometryType title_padding = 7;
  FlutterTextStyleType title_text_style = 8;
  WidgetType content = 9;
  FlutterEdgeInsetsGeometryType content_padding = 10;
  FlutterTextStyleType content_text_style = 11;
  repeated WidgetType actions = 12;
  FlutterEdgeInsetsGeometryType actions_padding = 13;
  FlutterMainAxisAlignmentType.Enum actions_alignment = 14;
  FlutterOverflowBarAlignmentType.Enum actions_overflow_alignment = 15;
  FlutterVerticalDirectionType.Enum actions_overflow_direction = 16;
  double actions_overflow_button_spacing = 17;
  FlutterEdgeInsetsGeometryType button_padding = 18;
  DartColorType background_color = 19;
  double elevation = 20;
  DartColorType shadow_color = 21;
  DartColorType surface_tint_color = 22;
  string semantic_label = 23;
  FlutterEdgeInsetsType inset_padding = 24;
  DartClipType.Enum clip_behavior = 25;
  FlutterShapeBorderType shape = 26;
  FlutterAlignmentGeometryType alignment = 27;
  bool scrollable = 28;
  FlutterScrollControllerType scroll_controller = 29;
  FlutterScrollControllerType action_scroll_controller = 30;
  DartDurationType inset_animation_duration = 31;
  FlutterSrcAnimationCurveType inset_animation_curve = 32;
}

// package:flutter/src/material/theme.dart
//
// Creates an animated theme.
//
// By default, the theme transition uses a linear curve.
message MaterialAnimatedTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the color and typography values for descendant widgets.
  MaterialThemeDataType data = 3;
  // The curve to apply when animating the parameters of this container.
  FlutterSrcAnimationCurveType curve = 4;
  // The duration over which to animate the parameters of this container.
  DartDurationType duration = 5;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 7;
}

// package:flutter/src/material/app_bar.dart
//
// Creates a Material Design app bar.
//
// If [elevation] is specified, it must be non-negative.
//
// Typically used in the [Scaffold.appBar] property.
message MaterialAppBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.material.appbar.leading}
  // A widget to display before the toolbar's [title].
  //
  // Typically the [leading] widget is an [Icon] or an [IconButton].
  //
  // Becomes the leading component of the [NavigationToolbar] built
  // by this widget. The [leading] widget's width and height are constrained to
  // be no bigger than [leadingWidth] and [toolbarHeight] respectively.
  //
  // If this is null and [automaticallyImplyLeading] is set to true, the
  // [AppBar] will imply an appropriate widget. For example, if the [AppBar] is
  // in a [Scaffold] that also has a [Drawer], the [Scaffold] will fill this
  // widget with an [IconButton] that opens the drawer (using [Icons.menu]). If
  // there's no [Drawer] and the parent [Navigator] can go back, the [AppBar]
  // will use a [BackButton] that calls [Navigator.maybePop].
  // {@endtemplate}
  //
  // {@tool snippet}
  //
  // The following code shows how the drawer button could be manually specified
  // instead of relying on [automaticallyImplyLeading]:
  //
  // ```dart
  // AppBar(
  //   leading: Builder(
  //     builder: (BuildContext context) {
  //       return IconButton(
  //         icon: const Icon(Icons.menu),
  //         onPressed: () { Scaffold.of(context).openDrawer(); },
  //         tooltip: MaterialLocalizations.of(context).openAppDrawerTooltip,
  //       );
  //     },
  //   ),
  // )
  // ```
  // {@end-tool}
  //
  // The [Builder] is used in this example to ensure that the `context` refers
  // to that part of the subtree. That way this code snippet can be used even
  // inside the very code that is creating the [Scaffold] (in which case,
  // without the [Builder], the `context` wouldn't be able to see the
  // [Scaffold], since it would refer to an ancestor of that widget).
  //
  // See also:
  //
  //  * [Scaffold.appBar], in which an [AppBar] is usually placed.
  //  * [Scaffold.drawer], in which the [Drawer] is usually placed.
  WidgetType leading = 3;
  // {@template flutter.material.appbar.automaticallyImplyLeading}
  // Controls whether we should try to imply the leading widget if null.
  //
  // If true and [AppBar.leading] is null, automatically try to deduce what the leading
  // widget should be. If false and [AppBar.leading] is null, leading space is given to [AppBar.title].
  // If leading widget is not null, this parameter has no effect.
  // {@endtemplate}
  bool automatically_imply_leading = 4;
  // {@template flutter.material.appbar.title}
  // The primary widget displayed in the app bar.
  //
  // Becomes the middle component of the [NavigationToolbar] built by this widget.
  //
  // Typically a [Text] widget that contains a description of the current
  // contents of the app.
  // {@endtemplate}
  //
  // The [title]'s width is constrained to fit within the remaining space
  // between the toolbar's [leading] and [actions] widgets. Its height is
  // _not_ constrained. The [title] is vertically centered and clipped to fit
  // within the toolbar, whose height is [toolbarHeight]. Typically this
  // isn't noticeable because a simple [Text] [title] will fit within the
  // toolbar by default. On the other hand, it is noticeable when a
  // widget with an intrinsic height that is greater than [toolbarHeight]
  // is used as the [title]. For example, when the height of an Image used
  // as the [title] exceeds [toolbarHeight], it will be centered and
  // clipped (top and bottom), which may be undesirable. In cases like this
  // the height of the [title] widget can be constrained. For example:
  //
  // ```dart
  // MaterialApp(
  //   home: Scaffold(
  //     appBar: AppBar(
  //       title: SizedBox(
  //         height: _myToolbarHeight,
  //         child: Image.asset(_logoAsset),
  //       ),
  //       toolbarHeight: _myToolbarHeight,
  //     ),
  //   ),
  // )
  // ```
  WidgetType title = 5;
  // {@template flutter.material.appbar.actions}
  // A list of Widgets to display in a row after the [title] widget.
  //
  // Typically these widgets are [IconButton]s representing common operations.
  // For less common operations, consider using a [PopupMenuButton] as the
  // last action.
  //
  // The [actions] become the trailing component of the [NavigationToolbar] built
  // by this widget. The height of each action is constrained to be no bigger
  // than the [toolbarHeight].
  //
  // To avoid having the last action covered by the debug banner, you may want
  // to set the [MaterialApp.debugShowCheckedModeBanner] to false.
  // {@endtemplate}
  //
  // {@tool snippet}
  //
  // ```dart
  // Scaffold(
  //   body: CustomScrollView(
  //     primary: true,
  //     slivers: <Widget>[
  //       SliverAppBar(
  //         title: const Text('Hello World'),
  //         actions: <Widget>[
  //           IconButton(
  //             icon: const Icon(Icons.shopping_cart),
  //             tooltip: 'Open shopping cart',
  //             onPressed: () {
  //               // handle the press
  //             },
  //           ),
  //         ],
  //       ),
  //       // ...rest of body...
  //     ],
  //   ),
  // )
  // ```
  // {@end-tool}
  repeated WidgetType actions = 6;
  // {@template flutter.material.appbar.flexibleSpace}
  // This widget is stacked behind the toolbar and the tab bar. Its height will
  // be the same as the app bar's overall height.
  //
  // A flexible space isn't actually flexible unless the [AppBar]'s container
  // changes the [AppBar]'s size. A [SliverAppBar] in a [CustomScrollView]
  // changes the [AppBar]'s height when scrolled.
  //
  // Typically a [FlexibleSpaceBar]. See [FlexibleSpaceBar] for details.
  // {@endtemplate}
  WidgetType flexible_space = 7;
  // {@template flutter.material.appbar.bottom}
  // This widget appears across the bottom of the app bar.
  //
  // Typically a [TabBar]. Only widgets that implement [PreferredSizeWidget] can
  // be used at the bottom of an app bar.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [PreferredSize], which can be used to give an arbitrary widget a preferred size.
  FlutterPreferredSizeWidgetType bottom = 8;
  // {@template flutter.material.appbar.elevation}
  // The z-coordinate at which to place this app bar relative to its parent.
  //
  // This property controls the size of the shadow below the app bar if
  // [shadowColor] is not null.
  //
  // If [surfaceTintColor] is not null then it will apply a surface tint overlay
  // to the background color (see [Material.surfaceTintColor] for more
  // detail).
  //
  // The value must be non-negative.
  //
  // If this property is null, then [AppBarTheme.elevation] of
  // [ThemeData.appBarTheme] is used. If that is also null, the
  // default value is 4.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [scrolledUnderElevation], which will be used when the app bar has
  //    something scrolled underneath it.
  //  * [shadowColor], which is the color of the shadow below the app bar.
  //  * [surfaceTintColor], which determines the elevation overlay that will
  //    be applied to the background of the app bar.
  //  * [shape], which defines the shape of the app bar's [Material] and its
  //    shadow.
  double elevation = 9;
  // {@template flutter.material.appbar.scrolledUnderElevation}
  // The elevation that will be used if this app bar has something
  // scrolled underneath it.
  //
  // If non-null then it [AppBarTheme.scrolledUnderElevation] of
  // [ThemeData.appBarTheme] will be used. If that is also null then [elevation]
  // will be used.
  //
  // The value must be non-negative.
  //
  // {@endtemplate}
  //
  // See also:
  //  * [elevation], which will be used if there is no content scrolled under
  //    the app bar.
  //  * [shadowColor], which is the color of the shadow below the app bar.
  //  * [surfaceTintColor], which determines the elevation overlay that will
  //    be applied to the background of the app bar.
  //  * [shape], which defines the shape of the app bar's [Material] and its
  //    shadow.
  double scrolled_under_elevation = 10;
  // {@template flutter.material.appbar.shadowColor}
  // The color of the shadow below the app bar.
  //
  // If this property is null, then [AppBarTheme.shadowColor] of
  // [ThemeData.appBarTheme] is used. If that is also null, the default value
  // is fully opaque black.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [elevation], which defines the size of the shadow below the app bar.
  //  * [shape], which defines the shape of the app bar and its shadow.
  DartColorType shadow_color = 12;
  // {@template flutter.material.appbar.surfaceTintColor}
  // The color of the surface tint overlay applied to the app bar's
  // background color to indicate elevation.
  //
  // If null no overlay will be applied.
  // {@endtemplate}
  //
  // See also:
  //   * [Material.surfaceTintColor], which described this feature in more detail.
  DartColorType surface_tint_color = 13;
  // {@template flutter.material.appbar.shape}
  // The shape of the app bar's [Material] as well as its shadow.
  //
  // If this property is null, then [AppBarTheme.shape] of
  // [ThemeData.appBarTheme] is used. Both properties default to null.
  // If both properties are null then the shape of the app bar's [Material]
  // is just a simple rectangle.
  //
  // A shadow is only displayed if the [elevation] is greater than
  // zero.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [elevation], which defines the size of the shadow below the app bar.
  //  * [shadowColor], which is the color of the shadow below the app bar.
  FlutterShapeBorderType shape = 14;
  // {@template flutter.material.appbar.backgroundColor}
  // The fill color to use for an app bar's [Material].
  //
  // If null, then the [AppBarTheme.backgroundColor] is used. If that value is also
  // null, then [AppBar] uses the overall theme's [ColorScheme.primary] if the
  // overall theme's brightness is [Brightness.light], and [ColorScheme.surface]
  // if the overall theme's brightness is [Brightness.dark].
  //
  // If this color is a [MaterialStateColor] it will be resolved against
  // [MaterialState.scrolledUnder] when the content of the app's
  // primary scrollable overlaps the app bar.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [foregroundColor], which specifies the color for icons and text within
  //    the app bar.
  //  * [Theme.of], which returns the current overall Material theme as
  //    a [ThemeData].
  //  * [ThemeData.colorScheme], the thirteen colors that most Material widget
  //    default colors are based on.
  //  * [ColorScheme.brightness], which indicates if the overall [Theme]
  //    is light or dark.
  DartColorType background_color = 15;
  // {@template flutter.material.appbar.foregroundColor}
  // The default color for [Text] and [Icon]s within the app bar.
  //
  // If null, then [AppBarTheme.foregroundColor] is used. If that
  // value is also null, then [AppBar] uses the overall theme's
  // [ColorScheme.onPrimary] if the overall theme's brightness is
  // [Brightness.light], and [ColorScheme.onSurface] if the overall
  // theme's brightness is [Brightness.dark].
  //
  // This color is used to configure [DefaultTextStyle] that contains
  // the toolbar's children, and the default [IconTheme] widgets that
  // are created if [iconTheme] and [actionsIconTheme] are null.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [backgroundColor], which specifies the app bar's background color.
  //  * [Theme.of], which returns the current overall Material theme as
  //    a [ThemeData].
  //  * [ThemeData.colorScheme], the thirteen colors that most Material widget
  //    default colors are based on.
  //  * [ColorScheme.brightness], which indicates if the overall [Theme]
  //    is light or dark.
  DartColorType foreground_color = 16;
  // {@template flutter.material.appbar.iconTheme}
  // The color, opacity, and size to use for toolbar icons.
  //
  // If this property is null, then a copy of [ThemeData.iconTheme]
  // is used, with the [IconThemeData.color] set to the
  // app bar's [foregroundColor].
  // {@endtemplate}
  //
  // See also:
  //
  //  * [actionsIconTheme], which defines the appearance of icons in
  //    the [actions] list.
  FlutterIconThemeDataType icon_theme = 17;
  // {@template flutter.material.appbar.actionsIconTheme}
  // The color, opacity, and size to use for the icons that appear in the app
  // bar's [actions].
  //
  // This property should only be used when the [actions] should be
  // themed differently than the icon that appears in the app bar's [leading]
  // widget.
  //
  // If this property is null, then [AppBarTheme.actionsIconTheme] of
  // [ThemeData.appBarTheme] is used. If that is also null, then the value of
  // [iconTheme] is used.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [iconTheme], which defines the appearance of all of the toolbar icons.
  FlutterIconThemeDataType actions_icon_theme = 18;
  // {@template flutter.material.appbar.primary}
  // Whether this app bar is being displayed at the top of the screen.
  //
  // If true, the app bar's toolbar elements and [bottom] widget will be
  // padded on top by the height of the system status bar. The layout
  // of the [flexibleSpace] is not affected by the [primary] property.
  // {@endtemplate}
  bool primary = 19;
  // {@template flutter.material.appbar.centerTitle}
  // Whether the title should be centered.
  //
  // If this property is null, then [AppBarTheme.centerTitle] of
  // [ThemeData.appBarTheme] is used. If that is also null, then value is
  // adapted to the current [TargetPlatform].
  // {@endtemplate}
  bool center_title = 20;
  // {@template flutter.material.appbar.excludeHeaderSemantics}
  // Whether the title should be wrapped with header [Semantics].
  //
  // Defaults to false.
  // {@endtemplate}
  bool exclude_header_semantics = 21;
  // {@template flutter.material.appbar.titleSpacing}
  // The spacing around [title] content on the horizontal axis. This spacing is
  // applied even if there is no [leading] content or [actions]. If you want
  // [title] to take all the space available, set this value to 0.0.
  //
  // If this property is null, then [AppBarTheme.titleSpacing] of
  // [ThemeData.appBarTheme] is used. If that is also null, then the
  // default value is [NavigationToolbar.kMiddleSpacing].
  // {@endtemplate}
  double title_spacing = 22;
  // {@template flutter.material.appbar.toolbarOpacity}
  // How opaque the toolbar part of the app bar is.
  //
  // A value of 1.0 is fully opaque, and a value of 0.0 is fully transparent.
  //
  // Typically, this value is not changed from its default value (1.0). It is
  // used by [SliverAppBar] to animate the opacity of the toolbar when the app
  // bar is scrolled.
  // {@endtemplate}
  double toolbar_opacity = 23;
  // {@template flutter.material.appbar.bottomOpacity}
  // How opaque the bottom part of the app bar is.
  //
  // A value of 1.0 is fully opaque, and a value of 0.0 is fully transparent.
  //
  // Typically, this value is not changed from its default value (1.0). It is
  // used by [SliverAppBar] to animate the opacity of the toolbar when the app
  // bar is scrolled.
  // {@endtemplate}
  double bottom_opacity = 24;
  // {@template flutter.material.appbar.toolbarHeight}
  // Defines the height of the toolbar component of an [AppBar].
  //
  // By default, the value of [toolbarHeight] is [kToolbarHeight].
  // {@endtemplate}
  double toolbar_height = 25;
  // {@template flutter.material.appbar.leadingWidth}
  // Defines the width of [AppBar.leading] widget.
  //
  // By default, the value of [AppBar.leadingWidth] is 56.0.
  // {@endtemplate}
  double leading_width = 26;
  // {@template flutter.material.appbar.toolbarTextStyle}
  // The default text style for the AppBar's [leading], and
  // [actions] widgets, but not its [title].
  //
  // If this property is null, then [AppBarTheme.toolbarTextStyle] of
  // [ThemeData.appBarTheme] is used. If that is also null, the default
  // value is a copy of the overall theme's [TextTheme.bodyMedium]
  // [TextStyle], with color set to the app bar's [foregroundColor].
  // {@endtemplate}
  //
  // See also:
  //
  //  * [titleTextStyle], which overrides the default text style for the [title].
  //  * [DefaultTextStyle], which overrides the default text style for all of the
  //    widgets in a subtree.
  FlutterTextStyleType toolbar_text_style = 27;
  // {@template flutter.material.appbar.titleTextStyle}
  // The default text style for the AppBar's [title] widget.
  //
  // If this property is null, then [AppBarTheme.titleTextStyle] of
  // [ThemeData.appBarTheme] is used. If that is also null, the default
  // value is a copy of the overall theme's [TextTheme.titleLarge]
  // [TextStyle], with color set to the app bar's [foregroundColor].
  // {@endtemplate}
  //
  // See also:
  //
  //  * [toolbarTextStyle], which is the default text style for the AppBar's
  //    [title], [leading], and [actions] widgets, also known as the
  //    AppBar's "toolbar".
  //  * [DefaultTextStyle], which overrides the default text style for all of the
  //    widgets in a subtree.
  FlutterTextStyleType title_text_style = 28;
  // {@template flutter.material.appbar.systemOverlayStyle}
  // Specifies the style to use for the system overlays (e.g. the status bar on
  // Android or iOS, the system navigation bar on Android).
  //
  // If this property is null, then [AppBarTheme.systemOverlayStyle] of
  // [ThemeData.appBarTheme] is used. If that is also null, an appropriate
  // [SystemUiOverlayStyle] is calculated based on the [backgroundColor].
  //
  // The AppBar's descendants are built within a
  // `AnnotatedRegion<SystemUiOverlayStyle>` widget, which causes
  // [SystemChrome.setSystemUIOverlayStyle] to be called
  // automatically. Apps should not enclose an AppBar with their
  // own [AnnotatedRegion].
  // {@endtemplate}
  // See also:
  //
  //  * [AnnotatedRegion], for placing [SystemUiOverlayStyle] in the layer tree.
  //  * [SystemChrome.setSystemUIOverlayStyle], the imperative API for setting
  //    system overlays style.
  FlutterSystemUiOverlayStyleType system_overlay_style = 29;
  // {@template flutter.material.appbar.forceMaterialTransparency}
  // Forces the AppBar's Material widget type to be [MaterialType.transparency]
  // (instead of Material's default type).
  //
  // This will remove the visual display of [backgroundColor] and [elevation],
  // and affect other characteristics of the AppBar's Material widget.
  //
  // Provided for cases where the app bar is to be transparent, and gestures
  // must pass through the app bar to widgets beneath the app bar (i.e. with
  // [Scaffold.extendBodyBehindAppBar] set to true).
  //
  // Defaults to false.
  // {@endtemplate}
  bool force_material_transparency = 30;
  // {@macro flutter.material.Material.clipBehavior}
  DartClipType.Enum clip_behavior = 31;
}

// package:flutter/src/material/app_bar_theme.dart
//
// Creates a theme that can be used for [ThemeData.appBarTheme].
message MaterialAppBarTheme {
  DartColorType color = 2;
  DartColorType background_color = 3;
  // Overrides the default value of [AppBar.foregroundColor] in all
  // descendant [AppBar] widgets.
  //
  // See also:
  //
  //  * [backgroundColor], which overrides the default value of
  //    [AppBar.backgroundColor] in all descendant [AppBar] widgets.
  DartColorType foreground_color = 4;
  // Overrides the default value of [AppBar.elevation] in all
  // descendant [AppBar] widgets.
  double elevation = 5;
  // Overrides the default value of [AppBar.scrolledUnderElevation] in all
  // descendant [AppBar] widgets.
  double scrolled_under_elevation = 6;
  // Overrides the default value of [AppBar.shadowColor] in all
  // descendant [AppBar] widgets.
  DartColorType shadow_color = 7;
  // Overrides the default value of [AppBar.surfaceTintColor] in all
  // descendant [AppBar] widgets.
  DartColorType surface_tint_color = 8;
  // Overrides the default value of [AppBar.shape] in all
  // descendant [AppBar] widgets.
  FlutterShapeBorderType shape = 9;
  // Overrides the default value of [AppBar.iconTheme] in all
  // descendant [AppBar] widgets.
  //
  // See also:
  //
  //  * [actionsIconTheme], which overrides the default value of
  //    [AppBar.actionsIconTheme] in all descendant [AppBar] widgets.
  //  * [foregroundColor], which overrides the default value
  //    [AppBar.foregroundColor] in all descendant [AppBar] widgets.
  FlutterIconThemeDataType icon_theme = 10;
  // Overrides the default value of [AppBar.actionsIconTheme] in all
  // descendant [AppBar] widgets.
  //
  // See also:
  //
  //  * [iconTheme], which overrides the default value of
  //    [AppBar.iconTheme] in all descendant [AppBar] widgets.
  //  * [foregroundColor], which overrides the default value
  //    [AppBar.foregroundColor] in all descendant [AppBar] widgets.
  FlutterIconThemeDataType actions_icon_theme = 11;
  // Overrides the default value of [AppBar.centerTitle]
  // property in all descendant [AppBar] widgets.
  bool center_title = 12;
  // Overrides the default value of the obsolete [AppBar.titleSpacing]
  // property in all descendant [AppBar] widgets.
  //
  // If null, [AppBar] uses default value of [NavigationToolbar.kMiddleSpacing].
  double title_spacing = 13;
  // Overrides the default value of the [AppBar.toolbarHeight]
  // property in all descendant [AppBar] widgets.
  //
  // See also:
  //
  //  * [AppBar.preferredHeightFor], which computes the overall
  //    height of an AppBar widget, taking this value into account.
  double toolbar_height = 14;
  // Overrides the default value of the obsolete [AppBar.toolbarTextStyle]
  // property in all descendant [AppBar] widgets.
  //
  // See also:
  //
  //  * [titleTextStyle], which overrides the default of [AppBar.titleTextStyle]
  //    in all descendant [AppBar] widgets.
  FlutterTextStyleType toolbar_text_style = 15;
  // Overrides the default value of [AppBar.titleTextStyle]
  // property in all descendant [AppBar] widgets.
  //
  // See also:
  //
  //  * [toolbarTextStyle], which overrides the default of [AppBar.toolbarTextStyle]
  //    in all descendant [AppBar] widgets.
  FlutterTextStyleType title_text_style = 16;
  // Overrides the default value of [AppBar.systemOverlayStyle]
  // property in all descendant [AppBar] widgets.
  FlutterSystemUiOverlayStyleType system_overlay_style = 17;
}

// package:flutter/src/material/action_buttons.dart
//
// Creates an [IconButton] with the appropriate "back" icon for the current
// target platform.
message MaterialBackButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The color to use for the icon.
  //
  // Defaults to the [IconThemeData.color] specified in the ambient [IconTheme],
  // which usually matches the ambient [Theme]'s [ThemeData.iconTheme].
  DartColorType color = 3;
  // Customizes this icon button's appearance.
  //
  // The [style] is only used for Material 3 [IconButton]s. If [ThemeData.useMaterial3]
  // is set to true, [style] is preferred for icon button customization, and any
  // parameters defined in [style] will override the same parameters in [IconButton].
  //
  // Null by default.
  MaterialButtonStyleType style = 4;
}

// package:flutter/src/material/action_buttons.dart
//
// Creates an icon that shows the appropriate "back" image for
// the current platform (as obtained from the [Theme]).
message MaterialBackButtonIcon {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
}

// package:flutter/src/material/badge.dart
//
// Create a Badge that stacks [label] on top of [child].
//
// If [label] is null then just a filled circle is displayed. Otherwise
// the [label] is displayed within a [StadiumBorder] shaped area.
message MaterialBadge {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The badge's fill color.
  //
  // Defaults to the [BadgeTheme]'s background color, or
  // [ColorScheme.errorColor] if the theme value is null.
  DartColorType background_color = 3;
  // The color of the badge's [label] text.
  //
  // This color overrides the color of the label's [textStyle].
  //
  // Defaults to the [BadgeTheme]'s foreground color, or
  // [ColorScheme.onError] if the theme value is null.
  DartColorType text_color = 4;
  // The diameter of the badge if [label] is null.
  //
  // Defaults to the [BadgeTheme]'s small size, or 6 if the theme value
  // is null.
  double small_size = 5;
  // The badge's height if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s large size, or 16 if the theme value
  // is null. If the default value is overridden then it may be useful to
  // also override [padding] and [alignment].
  double large_size = 6;
  // The [DefaultTextStyle] for the badge's label.
  //
  // The text style's color is overwritten by the [textColor].
  //
  // This value is only used if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s text style, or the overall theme's
  // [TextTheme.labelSmall] if the badge theme's value is null. If
  // the default text style is overridden then it may be useful to
  // also override [largeSize], [padding], and [alignment].
  FlutterTextStyleType text_style = 7;
  // The padding added to the badge's label.
  //
  // This value is only used if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s padding, or 4 pixels on the
  // left and right if the theme's value is null.
  FlutterEdgeInsetsGeometryType padding = 8;
  // Combined with [offset] to determine the location of the [label]
  // relative to the [child].
  //
  // The alignment positions the label in the same way a child of an
  // [Align] widget is positioned, except that, the alignment is
  // resolved as if the label was a [largeSize] square and [offset]
  // is added to the result.
  //
  // This value is only used if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s alignment, or
  // [AlignmentDirectional.topEnd] if the theme's value is null.
  FlutterAlignmentGeometryType alignment = 9;
  // Combined with [alignment] to determine the location of the [label]
  // relative to the [child].
  //
  // This value is only used if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s offset, or
  // if the theme's value is null then `Offset(4, -4)` for
  // [TextDirection.ltr] or `Offset(-4, -4)` for [TextDirection.rtl].
  DartOffsetType offset = 10;
  // The badge's content, typically a [Text] widget that contains 1 to 4
  // characters.
  //
  // If the label is null then this is a "small" badge that's
  // displayed as a [smallSize] diameter filled circle. Otherwise
  // this is a [StadiumBorder] shaped "large" badge with height [largeSize].
  WidgetType label = 11;
  // If false, the badge's [label] is not included.
  //
  // This flag is true by default. It's intended to make it convenient
  // to create a badge that's only shown under certain conditions.
  bool is_label_visible = 12;
  // The widget that the badge is stacked on top of.
  //
  // Typically this is an default sized [Icon] that's part of a
  // [BottomNavigationBarItem] or a [NavigationRailDestination].
  WidgetType child = 13;
}

// package:flutter/src/material/badge.dart
//
// Convenience constructor for creating a badge with a numeric
// label with 1-3 digits based on [count].
//
// Initializes [label] with a [Text] widget that contains [count].
// If [count] is greater than 999, then the label is '999+'.
message MaterialBadgeNamedCount {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The badge's fill color.
  //
  // Defaults to the [BadgeTheme]'s background color, or
  // [ColorScheme.errorColor] if the theme value is null.
  DartColorType background_color = 3;
  // The color of the badge's [label] text.
  //
  // This color overrides the color of the label's [textStyle].
  //
  // Defaults to the [BadgeTheme]'s foreground color, or
  // [ColorScheme.onError] if the theme value is null.
  DartColorType text_color = 4;
  // The diameter of the badge if [label] is null.
  //
  // Defaults to the [BadgeTheme]'s small size, or 6 if the theme value
  // is null.
  double small_size = 5;
  // The badge's height if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s large size, or 16 if the theme value
  // is null. If the default value is overridden then it may be useful to
  // also override [padding] and [alignment].
  double large_size = 6;
  // The [DefaultTextStyle] for the badge's label.
  //
  // The text style's color is overwritten by the [textColor].
  //
  // This value is only used if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s text style, or the overall theme's
  // [TextTheme.labelSmall] if the badge theme's value is null. If
  // the default text style is overridden then it may be useful to
  // also override [largeSize], [padding], and [alignment].
  FlutterTextStyleType text_style = 7;
  // The padding added to the badge's label.
  //
  // This value is only used if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s padding, or 4 pixels on the
  // left and right if the theme's value is null.
  FlutterEdgeInsetsGeometryType padding = 8;
  // Combined with [offset] to determine the location of the [label]
  // relative to the [child].
  //
  // The alignment positions the label in the same way a child of an
  // [Align] widget is positioned, except that, the alignment is
  // resolved as if the label was a [largeSize] square and [offset]
  // is added to the result.
  //
  // This value is only used if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s alignment, or
  // [AlignmentDirectional.topEnd] if the theme's value is null.
  FlutterAlignmentGeometryType alignment = 9;
  // Combined with [alignment] to determine the location of the [label]
  // relative to the [child].
  //
  // This value is only used if [label] is non-null.
  //
  // Defaults to the [BadgeTheme]'s offset, or
  // if the theme's value is null then `Offset(4, -4)` for
  // [TextDirection.ltr] or `Offset(-4, -4)` for [TextDirection.rtl].
  DartOffsetType offset = 10;
  int32 count = 11;
  // If false, the badge's [label] is not included.
  //
  // This flag is true by default. It's intended to make it convenient
  // to create a badge that's only shown under certain conditions.
  bool is_label_visible = 12;
  // The widget that the badge is stacked on top of.
  //
  // Typically this is an default sized [Icon] that's part of a
  // [BottomNavigationBarItem] or a [NavigationRailDestination].
  WidgetType child = 13;
}

// package:flutter/src/material/badge_theme.dart
//
// Creates a theme that overrides the default color parameters for [Badge]s
// in this widget's subtree.
message MaterialBadgeTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the default color and size overrides for descendant [Badge] widgets.
  MaterialBadgeThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/badge_theme.dart
//
// Creates the set of color, style, and size properties used to configure [Badge].
message MaterialBadgeThemeData {
  // Overrides the default value for [Badge.backgroundColor].
  DartColorType background_color = 2;
  // Overrides the default value for [Badge.textColor].
  DartColorType text_color = 3;
  // Overrides the default value for [Badge.smallSize].
  double small_size = 4;
  // Overrides the default value for [Badge.largeSize].
  double large_size = 5;
  // Overrides the default value for [Badge.textStyle].
  FlutterTextStyleType text_style = 6;
  // Overrides the default value for [Badge.padding].
  FlutterEdgeInsetsGeometryType padding = 7;
  // Overrides the default value for [Badge.alignment].
  FlutterAlignmentGeometryType alignment = 8;
  // Overrides the default value for [Badge.offset].
  DartOffsetType offset = 9;
}

// package:flutter/src/material/bottom_app_bar.dart
//
// Creates a bottom application bar.
//
// The [clipBehavior] argument defaults to [Clip.none].
// Additionally, [elevation] must be non-negative.
//
// If [color], [elevation], or [shape] are null, their [BottomAppBarTheme] values will be used.
// If the corresponding [BottomAppBarTheme] property is null, then the default
// specified in the property's documentation will be used.
message MaterialBottomAppBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The bottom app bar's background color.
  //
  // If this property is null then [BottomAppBarTheme.color] of
  // [ThemeData.bottomAppBarTheme] is used. If that's null then
  // [ThemeData.bottomAppBarColor] is used.
  DartColorType color = 3;
  // The z-coordinate at which to place this bottom app bar relative to its
  // parent.
  //
  // This controls the size of the shadow below the bottom app bar. The
  // value is non-negative.
  //
  // If this property is null then [BottomAppBarTheme.elevation] of
  // [ThemeData.bottomAppBarTheme] is used. If that's null and
  // [ThemeData.useMaterial3] is true, than the default value is 3 else is 8.
  double elevation = 4;
  // The notch that is made for the floating action button.
  //
  // If this property is null then [BottomAppBarTheme.shape] of
  // [ThemeData.bottomAppBarTheme] is used. If that's null then the shape will
  // be rectangular with no notch.
  FlutterNotchedShapeType shape = 5;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 6;
  // The margin between the [FloatingActionButton] and the [BottomAppBar]'s
  // notch.
  //
  // Not used if [shape] is null.
  double notch_margin = 7;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  //
  // Typically the child will be a [Row] whose first child
  // is an [IconButton] with the [Icons.menu] icon.
  WidgetType child = 8;
  // The amount of space to surround the child inside the bounds of the [BottomAppBar].
  //
  // In Material 3 the padding will default to `EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0)`
  // Otherwise the value will default to EdgeInsets.zero.
  FlutterEdgeInsetsGeometryType padding = 9;
  // A custom color for the Material 3 surface-tint elevation effect.
  //
  // In Material 3, a "surface tint" with an opacity related to [elevation]
  // will be applied to the [BottomAppBar]'s background.
  // Use this property to override the default color of that tint.
  //
  // If this property is null, then [BottomAppBarTheme.surfaceTintColor]
  // of [ThemeData.bottomAppBarTheme] is used.
  // If that is also null, [ColorScheme.surfaceTint] is used.
  //
  // Ignored if [ThemeData.useMaterial3] is false.
  //
  // The default is null.
  //
  // See [Material.surfaceTintColor] for more details on how this overlay is applied.
  DartColorType surface_tint_color = 10;
  // The color of the shadow below the app bar.
  //
  // If this property is null, then [BottomAppBarTheme.shadowColor] of
  // [ThemeData.bottomAppBarTheme] is used. If that is also null, the default value
  // is fully opaque black for Material 2, and transparent for Material 3.
  //
  // See also:
  //
  //  * [elevation], which defines the size of the shadow below the app bar.
  //  * [shape], which defines the shape of the app bar and its shadow.
  DartColorType shadow_color = 11;
  // The double value used to indicate the height of the [BottomAppBar].
  //
  // If this is null, the default value is the minimum in relation to the content,
  // unless [ThemeData.useMaterial3] is true, in which case it defaults to 80.0.
  double height = 12;
}

// package:flutter/src/material/bottom_app_bar_theme.dart
//
// Creates a theme that can be used for [ThemeData.bottomAppBarTheme].
message MaterialBottomAppBarTheme {
  // Overrides the default value for [BottomAppBar.color].
  //
  // If null, [BottomAppBar] uses [ThemeData.bottomAppBarColor].
  DartColorType color = 2;
  // Overrides the default value for [BottomAppBar.elevation].
  double elevation = 3;
  // Overrides the default value for [BottomAppBar.shape].
  FlutterNotchedShapeType shape = 4;
  // Overrides the default value for [BottomAppBar.height].
  double height = 5;
  // Overrides the default value for [BottomAppBar.surfaceTintColor].
  //
  // If null, [BottomAppBar] will not display an overlay color.
  //
  // See [Material.surfaceTintColor] for more details.
  DartColorType surface_tint_color = 6;
  // Overrides the default value for [BottomAppBar.shadowColor].
  DartColorType shadow_color = 7;
  // Overrides the default value for [BottomAppBar.padding].
  FlutterEdgeInsetsGeometryType padding = 8;
}

// package:flutter/src/material/bottom_navigation_bar.dart
//
// Creates a bottom navigation bar which is typically used as a
// [Scaffold]'s [Scaffold.bottomNavigationBar] argument.
//
// The length of [items] must be at least two and each item's icon and label
// must not be null.
//
// If [type] is null then [BottomNavigationBarType.fixed] is used when there
// are two or three [items], [BottomNavigationBarType.shifting] otherwise.
//
// The [iconSize], [selectedFontSize], [unselectedFontSize], and [elevation]
// arguments must be non-negative.
//
// If [selectedLabelStyle].color and [unselectedLabelStyle].color values
// are non-null, they will be used instead of [selectedItemColor] and
// [unselectedItemColor].
//
// If custom [IconThemeData]s are used, you must provide both
// [selectedIconTheme] and [unselectedIconTheme], and both
// [IconThemeData.color] and [IconThemeData.size] must be set.
//
// If [useLegacyColorScheme] is set to `false`
// [selectedIconTheme] values will be used instead of [iconSize] and [selectedItemColor] for selected icons.
// [unselectedIconTheme] values will be used instead of [iconSize] and [unselectedItemColor] for unselected icons.
//
//
// If both [selectedLabelStyle].fontSize and [selectedFontSize] are set,
// [selectedLabelStyle].fontSize will be used.
//
// Only one of [selectedItemColor] and [fixedColor] can be specified. The
// former is preferred, [fixedColor] only exists for the sake of
// backwards compatibility.
//
// If [showSelectedLabels] is `null`, [BottomNavigationBarThemeData.showSelectedLabels]
// is used. If [BottomNavigationBarThemeData.showSelectedLabels]  is null,
// then [showSelectedLabels] defaults to `true`.
//
// If [showUnselectedLabels] is `null`, [BottomNavigationBarThemeData.showUnselectedLabels]
// is used. If [BottomNavigationBarThemeData.showSelectedLabels] is null,
// then [showUnselectedLabels] defaults to `true` when [type] is
// [BottomNavigationBarType.fixed] and `false` when [type] is
// [BottomNavigationBarType.shifting].
message MaterialBottomNavigationBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Defines the appearance of the button items that are arrayed within the
  // bottom navigation bar.
  repeated FlutterBottomNavigationBarItemType items = 3;
  // The index into [items] for the current active [BottomNavigationBarItem].
  int32 current_index = 5;
  // The z-coordinate of this [BottomNavigationBar].
  //
  // If null, defaults to `8.0`.
  //
  // {@macro flutter.material.material.elevation}
  double elevation = 6;
  // Defines the layout and behavior of a [BottomNavigationBar].
  //
  // See documentation for [BottomNavigationBarType] for information on the
  // meaning of different types.
  MaterialBottomNavigationBarTypeType.Enum type = 7;
  DartColorType fixed_color = 8;
  // The color of the [BottomNavigationBar] itself.
  //
  // If [type] is [BottomNavigationBarType.shifting] and the
  // [items] have [BottomNavigationBarItem.backgroundColor] set, the [items]'
  // backgroundColor will splash and overwrite this color.
  DartColorType background_color = 9;
  // The size of all of the [BottomNavigationBarItem] icons.
  //
  // See [BottomNavigationBarItem.icon] for more information.
  double icon_size = 10;
  DartColorType selected_item_color = 11;
  // The color of the unselected [BottomNavigationBarItem.icon] and
  // [BottomNavigationBarItem.label]s.
  //
  // If null then the [ThemeData.unselectedWidgetColor]'s color is used.
  DartColorType unselected_item_color = 12;
  // The size, opacity, and color of the icon in the currently selected
  // [BottomNavigationBarItem.icon].
  //
  // If this is not provided, the size will default to [iconSize], the color
  // will default to [selectedItemColor].
  //
  // It this field is provided, it must contain non-null [IconThemeData.size]
  // and [IconThemeData.color] properties. Also, if this field is supplied,
  // [unselectedIconTheme] must be provided.
  FlutterIconThemeDataType selected_icon_theme = 13;
  // The size, opacity, and color of the icon in the currently unselected
  // [BottomNavigationBarItem.icon]s.
  //
  // If this is not provided, the size will default to [iconSize], the color
  // will default to [unselectedItemColor].
  //
  // It this field is provided, it must contain non-null [IconThemeData.size]
  // and [IconThemeData.color] properties. Also, if this field is supplied,
  // [selectedIconTheme] must be provided.
  FlutterIconThemeDataType unselected_icon_theme = 14;
  // The font size of the [BottomNavigationBarItem] labels when they are selected.
  //
  // If [TextStyle.fontSize] of [selectedLabelStyle] is non-null, it will be
  // used instead of this.
  //
  // Defaults to `14.0`.
  double selected_font_size = 15;
  // The font size of the [BottomNavigationBarItem] labels when they are not
  // selected.
  //
  // If [TextStyle.fontSize] of [unselectedLabelStyle] is non-null, it will be
  // used instead of this.
  //
  // Defaults to `12.0`.
  double unselected_font_size = 16;
  // The [TextStyle] of the [BottomNavigationBarItem] labels when they are
  // selected.
  FlutterTextStyleType selected_label_style = 17;
  // The [TextStyle] of the [BottomNavigationBarItem] labels when they are not
  // selected.
  FlutterTextStyleType unselected_label_style = 18;
  // Whether the labels are shown for the selected [BottomNavigationBarItem].
  bool show_selected_labels = 19;
  // Whether the labels are shown for the unselected [BottomNavigationBarItem]s.
  bool show_unselected_labels = 20;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 22;
  // The arrangement of the bar's [items] when the enclosing
  // [MediaQueryData.orientation] is [Orientation.landscape].
  //
  // The following alternatives are supported:
  //
  // * [BottomNavigationBarLandscapeLayout.spread] - the items are
  //   evenly spaced and spread out across the available width. Each
  //   item's label and icon are arranged in a column.
  // * [BottomNavigationBarLandscapeLayout.centered] - the items are
  //   evenly spaced in a row but only consume as much width as they
  //   would in portrait orientation. The row of items is centered within
  //   the available width. Each item's label and icon are arranged
  //   in a column.
  // * [BottomNavigationBarLandscapeLayout.linear] - the items are
  //   evenly spaced and each item's icon and label are lined up in a
  //   row instead of a column.
  //
  // If this property is null, then the value of the enclosing
  // [BottomNavigationBarThemeData.landscapeLayout is used. If that
  // property is also null, then
  // [BottomNavigationBarLandscapeLayout.spread] is used.
  //
  // This property is null by default.
  //
  // See also:
  //
  //  * [ThemeData.bottomNavigationBarTheme] - which can be used to specify
  //    bottom navigation bar defaults for an entire application.
  //  * [BottomNavigationBarTheme] - which can be used to specify
  //    bottom navigation bar defaults for a widget subtree.
  //  * [MediaQuery.orientationOf] - which can be used to determine the current
  //    orientation.
  MaterialBottomNavigationBarLandscapeLayoutType.Enum landscape_layout = 23;
  // This flag is controlling how [BottomNavigationBar] is going to use
  // the colors provided by the [selectedIconTheme], [unselectedIconTheme],
  // [selectedItemColor], [unselectedItemColor].
  // The default value is `true` as the new theming logic is a breaking change.
  // To opt-in the new theming logic set the flag to `false`
  bool use_legacy_color_scheme = 24;
}

// package:flutter/src/material/bottom_navigation_bar_theme.dart
//
// Constructs a bottom navigation bar theme that configures all descendant
// [BottomNavigationBar] widgets.
message MaterialBottomNavigationBarTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [BottomNavigationBar] widgets.
  MaterialBottomNavigationBarThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/bottom_navigation_bar_theme.dart
//
// Creates a theme that can be used for [ThemeData.bottomNavigationBarTheme].
message MaterialBottomNavigationBarThemeData {
  // The color of the [BottomNavigationBar] itself.
  //
  // See [BottomNavigationBar.backgroundColor].
  DartColorType background_color = 2;
  // The z-coordinate of the [BottomNavigationBar].
  //
  // See [BottomNavigationBar.elevation].
  double elevation = 3;
  // The size, opacity, and color of the icon in the currently selected
  // [BottomNavigationBarItem.icon].
  //
  // If [BottomNavigationBar.selectedIconTheme] is non-null on the widget,
  // the whole [IconThemeData] from the widget will be used over this
  // [selectedIconTheme].
  //
  // See [BottomNavigationBar.selectedIconTheme].
  FlutterIconThemeDataType selected_icon_theme = 4;
  // The size, opacity, and color of the icon in the currently unselected
  // [BottomNavigationBarItem.icon]s.
  //
  // If [BottomNavigationBar.unselectedIconTheme] is non-null on the widget,
  // the whole [IconThemeData] from the widget will be used over this
  // [unselectedIconTheme].
  //
  // See [BottomNavigationBar.unselectedIconTheme].
  FlutterIconThemeDataType unselected_icon_theme = 5;
  // The color of the selected [BottomNavigationBarItem.icon] and
  // [BottomNavigationBarItem.label].
  //
  // See [BottomNavigationBar.selectedItemColor].
  DartColorType selected_item_color = 6;
  // The color of the unselected [BottomNavigationBarItem.icon] and
  // [BottomNavigationBarItem.label]s.
  //
  // See [BottomNavigationBar.unselectedItemColor].
  DartColorType unselected_item_color = 7;
  // The [TextStyle] of the [BottomNavigationBarItem] labels when they are
  // selected.
  //
  // See [BottomNavigationBar.selectedLabelStyle].
  FlutterTextStyleType selected_label_style = 8;
  // The [TextStyle] of the [BottomNavigationBarItem] labels when they are not
  // selected.
  //
  // See [BottomNavigationBar.unselectedLabelStyle].
  FlutterTextStyleType unselected_label_style = 9;
  // Whether the labels are shown for the selected [BottomNavigationBarItem].
  //
  // See [BottomNavigationBar.showSelectedLabels].
  bool show_selected_labels = 10;
  // Whether the labels are shown for the unselected [BottomNavigationBarItem]s.
  //
  // See [BottomNavigationBar.showUnselectedLabels].
  bool show_unselected_labels = 11;
  // Defines the layout and behavior of a [BottomNavigationBar].
  //
  // See [BottomNavigationBar.type].
  MaterialBottomNavigationBarTypeType.Enum type = 12;
  // If specified, defines the feedback property for [BottomNavigationBar].
  //
  // If [BottomNavigationBar.enableFeedback] is provided, [enableFeedback] is ignored.
  bool enable_feedback = 13;
  // If non-null, overrides the [BottomNavigationBar.landscapeLayout] property.
  MaterialBottomNavigationBarLandscapeLayoutType.Enum landscape_layout = 14;
}

// package:flutter/src/material/bottom_sheet_theme.dart
//
// Creates a theme that can be used for [ThemeData.bottomSheetTheme].
message MaterialBottomSheetThemeData {
  // Overrides the default value for [BottomSheet.backgroundColor].
  //
  // If null, [BottomSheet] defaults to [Material]'s default.
  DartColorType background_color = 2;
  // Overrides the default value for surfaceTintColor.
  //
  // If null, [BottomSheet] will not display an overlay color.
  //
  // See [Material.surfaceTintColor] for more details.
  DartColorType surface_tint_color = 3;
  // Overrides the default value for [BottomSheet.elevation].
  //
  // {@macro flutter.material.material.elevation}
  //
  // If null, [BottomSheet] defaults to 0.0.
  double elevation = 4;
  // Value for [BottomSheet.backgroundColor] when the Bottom sheet is presented
  // as a modal bottom sheet.
  DartColorType modal_background_color = 5;
  // Overrides the default value for barrier color when the Bottom sheet is presented as
  // a modal bottom sheet.
  DartColorType modal_barrier_color = 6;
  // Overrides the default value for [BottomSheet.shadowColor].
  DartColorType shadow_color = 7;
  // Value for [BottomSheet.elevation] when the Bottom sheet is presented as a
  // modal bottom sheet.
  double modal_elevation = 8;
  // Overrides the default value for [BottomSheet.shape].
  //
  // If null, no overriding shape is specified for [BottomSheet], so the
  // [BottomSheet] is rectangular.
  FlutterShapeBorderType shape = 9;
  // Overrides the default value for [BottomSheet.showDragHandle].
  bool show_drag_handle = 10;
  // Overrides the default value for [BottomSheet.dragHandleColor].
  DartColorType drag_handle_color = 11;
  // Overrides the default value for [BottomSheet.dragHandleSize].
  DartSizeType drag_handle_size = 12;
  // Overrides the default value for [BottomSheet.clipBehavior].
  //
  // If null, [BottomSheet] uses [Clip.none].
  DartClipType.Enum clip_behavior = 13;
  // Constrains the size of the [BottomSheet].
  //
  // If null, the bottom sheet's size will be unconstrained.
  FlutterBoxConstraintsType constraints = 14;
}

// package:flutter/src/material/button_bar.dart
//
// Creates a button bar.
//
// Both [buttonMinWidth] and [buttonHeight] must be non-negative if they
// are not null.
message MaterialButtonBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // How the children should be placed along the horizontal axis.
  //
  // If null then it will use [ButtonBarThemeData.alignment]. If that is null,
  // it will default to [MainAxisAlignment.end].
  FlutterMainAxisAlignmentType.Enum alignment = 3;
  // How much horizontal space is available. See [Row.mainAxisSize].
  //
  // If null then it will use the surrounding [ButtonBarThemeData.mainAxisSize].
  // If that is null, it will default to [MainAxisSize.max].
  FlutterMainAxisSizeType.Enum main_axis_size = 4;
  // Overrides the surrounding [ButtonBarThemeData.buttonTextTheme] to define a
  // button's base colors, size, internal padding and shape.
  //
  // If null then it will use the surrounding
  // [ButtonBarThemeData.buttonTextTheme]. If that is null, it will default to
  // [ButtonTextTheme.primary].
  MaterialButtonTextThemeType.Enum button_text_theme = 5;
  // Overrides the surrounding [ButtonThemeData.minWidth] to define a button's
  // minimum width.
  //
  // If null then it will use the surrounding [ButtonBarThemeData.buttonMinWidth].
  // If that is null, it will default to 64.0 logical pixels.
  double button_min_width = 6;
  // Overrides the surrounding [ButtonThemeData.height] to define a button's
  // minimum height.
  //
  // If null then it will use the surrounding [ButtonBarThemeData.buttonHeight].
  // If that is null, it will default to 36.0 logical pixels.
  double button_height = 7;
  // Overrides the surrounding [ButtonThemeData.padding] to define the padding
  // for a button's child (typically the button's label).
  //
  // If null then it will use the surrounding [ButtonBarThemeData.buttonPadding].
  // If that is null, it will default to 8.0 logical pixels on the left
  // and right.
  FlutterEdgeInsetsGeometryType button_padding = 8;
  // Overrides the surrounding [ButtonThemeData.alignedDropdown] to define whether
  // a [DropdownButton] menu's width will match the button's width.
  //
  // If null then it will use the surrounding [ButtonBarThemeData.buttonAlignedDropdown].
  // If that is null, it will default to false.
  bool button_aligned_dropdown = 9;
  // Defines whether a [ButtonBar] should size itself with a minimum size
  // constraint or with padding.
  //
  // Overrides the surrounding [ButtonThemeData.layoutBehavior].
  //
  // If null then it will use the surrounding [ButtonBarThemeData.layoutBehavior].
  // If that is null, it will default [ButtonBarLayoutBehavior.padded].
  MaterialButtonBarLayoutBehaviorType.Enum layout_behavior = 10;
  // Defines the vertical direction of a [ButtonBar]'s children if it
  // overflows.
  //
  // If [children] do not fit into a single row, then they
  // are arranged in a column. The first action is at the top of the
  // column if this property is set to [VerticalDirection.down], since it
  // "starts" at the top and "ends" at the bottom. On the other hand,
  // the first action will be at the bottom of the column if this
  // property is set to [VerticalDirection.up], since it "starts" at the
  // bottom and "ends" at the top.
  //
  // If null then it will use the surrounding
  // [ButtonBarThemeData.overflowDirection]. If that is null, it will
  // default to [VerticalDirection.down].
  FlutterVerticalDirectionType.Enum overflow_direction = 11;
  // The spacing between buttons when the button bar overflows.
  //
  // If the [children] do not fit into a single row, they are arranged into a
  // column. This parameter provides additional vertical space in between
  // buttons when it does overflow.
  //
  // The button spacing may appear to be more than the value provided. This is
  // because most buttons adhere to the [MaterialTapTargetSize] of 48px. So,
  // even though a button might visually be 36px in height, it might still take
  // up to 48px vertically.
  //
  // If null then no spacing will be added in between buttons in
  // an overflow state.
  double overflow_button_spacing = 12;
  // The buttons to arrange horizontally.
  //
  // Typically [ElevatedButton] or [TextButton] widgets.
  repeated WidgetType children = 13;
}

// package:flutter/src/material/button_bar_theme.dart
//
// Constructs a button bar theme that configures all descendant [ButtonBar]
// widgets.
message MaterialButtonBarTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [ButtonBar] widgets.
  MaterialButtonBarThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/button_bar_theme.dart
//
// Constructs the set of properties used to configure [ButtonBar] widgets.
//
// Both [buttonMinWidth] and [buttonHeight] must be non-negative if they
// are not null.
message MaterialButtonBarThemeData {
  // How the children should be placed along the horizontal axis.
  FlutterMainAxisAlignmentType.Enum alignment = 2;
  // How much horizontal space is available. See [Row.mainAxisSize].
  FlutterMainAxisSizeType.Enum main_axis_size = 3;
  // Defines a [ButtonBar] button's base colors, and the defaults for
  // the button's minimum size, internal padding, and shape.
  //
  // This will override the surrounding [ButtonThemeData.textTheme] setting
  // for buttons contained in the [ButtonBar].
  //
  // Despite the name, this property is not a [TextTheme], its value is not a
  // collection of [TextStyle]s.
  MaterialButtonTextThemeType.Enum button_text_theme = 4;
  // The minimum width for [ButtonBar] buttons.
  //
  // This will override the surrounding [ButtonThemeData.minWidth] setting
  // for buttons contained in the [ButtonBar].
  //
  // The actual horizontal space allocated for a button's child is
  // at least this value less the theme's horizontal [ButtonThemeData.padding].
  double button_min_width = 5;
  // The minimum height for [ButtonBar] buttons.
  //
  // This will override the surrounding [ButtonThemeData.height] setting
  // for buttons contained in the [ButtonBar].
  double button_height = 6;
  // Padding for a [ButtonBar] button's child (typically the button's label).
  //
  // This will override the surrounding [ButtonThemeData.padding] setting
  // for buttons contained in the [ButtonBar].
  FlutterEdgeInsetsGeometryType button_padding = 7;
  // If true, then a [DropdownButton] menu's width will match the [ButtonBar]
  // button's width.
  //
  // If false, then the dropdown's menu will be wider than
  // its button. In either case the dropdown button will line up the leading
  // edge of the menu's value with the leading edge of the values
  // displayed by the menu items.
  //
  // This will override the surrounding [ButtonThemeData.alignedDropdown] setting
  // for buttons contained in the [ButtonBar].
  //
  // This property only affects [DropdownButton] contained in a [ButtonBar]
  // and its menu.
  bool button_aligned_dropdown = 8;
  // Defines whether a [ButtonBar] should size itself with a minimum size
  // constraint or with padding.
  MaterialButtonBarLayoutBehaviorType.Enum layout_behavior = 9;
  // Defines the vertical direction of a [ButtonBar]'s children if it
  // overflows.
  //
  // If the [ButtonBar]'s children do not fit into a single row, then they
  // are arranged in a column. The first action is at the top of the
  // column if this property is set to [VerticalDirection.down], since it
  // "starts" at the top and "ends" at the bottom. On the other hand,
  // the first action will be at the bottom of the column if this
  // property is set to [VerticalDirection.up], since it "starts" at the
  // bottom and "ends" at the top.
  FlutterVerticalDirectionType.Enum overflow_direction = 10;
}

// package:flutter/src/material/button_style.dart
//
// Create a [ButtonStyle].
message MaterialButtonStyle {
  // Defines how compact the button's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all widgets
  //    within a [Theme].
  MaterialVisualDensityType visual_density = 18;
  // Configures the minimum size of the area within which the button may be pressed.
  //
  // If the [tapTargetSize] is larger than [minimumSize], the button will include
  // a transparent margin that responds to taps.
  //
  // Always defaults to [ThemeData.materialTapTargetSize].
  MaterialMaterialTapTargetSizeType.Enum tap_target_size = 19;
  // Defines the duration of animated changes for [shape] and [elevation].
  //
  // Typically the component default value is [kThemeChangeDuration].
  DartDurationType animation_duration = 20;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // Typically the component default value is true.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 21;
  // The alignment of the button's child.
  //
  // Typically buttons are sized to be just big enough to contain the child and its
  // padding. If the button's size is constrained to a fixed size, for example by
  // enclosing it with a [SizedBox], this property defines how the child is aligned
  // within the available space.
  //
  // Always defaults to [Alignment.center].
  FlutterAlignmentGeometryType alignment = 22;
}

// package:flutter/src/material/button_theme.dart
//
// Creates a button theme.
message MaterialButtonTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  MaterialButtonTextThemeType.Enum text_theme = 3;
  MaterialButtonBarLayoutBehaviorType.Enum layout_behavior = 4;
  double min_width = 5;
  double height = 6;
  FlutterEdgeInsetsGeometryType padding = 7;
  FlutterShapeBorderType shape = 8;
  bool aligned_dropdown = 9;
  DartColorType button_color = 10;
  DartColorType disabled_color = 11;
  DartColorType focus_color = 12;
  DartColorType hover_color = 13;
  DartColorType highlight_color = 14;
  DartColorType splash_color = 15;
  MaterialColorSchemeType color_scheme = 16;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 17;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 18;
}

// package:flutter/src/material/button_theme.dart
//
// Create a button theme object that can be used with [ButtonTheme]
// or [ThemeData].
//
// The [minWidth] and [height] parameters must greater than or equal to zero.
//
// The ButtonTheme's methods that have a [MaterialButton] parameter and
// have a name with a `get` prefix are used to configure a
// [RawMaterialButton].
message MaterialButtonThemeData {
  // Defines a button's base colors, and the defaults for the button's minimum
  // size, internal padding, and shape.
  //
  // Despite the name, this property is not a [TextTheme], its value is not a
  // collection of [TextStyle]s.
  MaterialButtonTextThemeType.Enum text_theme = 2;
  // The minimum width for buttons.
  //
  // The actual horizontal space allocated for a button's child is
  // at least this value less the theme's horizontal [padding].
  //
  // Defaults to 88.0 logical pixels.
  double min_width = 3;
  // The minimum height for buttons.
  //
  // Defaults to 36.0 logical pixels.
  double height = 4;
  FlutterEdgeInsetsGeometryType padding = 5;
  FlutterShapeBorderType shape = 6;
  // Defines whether a [ButtonBar] should size itself with a minimum size
  // constraint or with padding.
  //
  // Defaults to [ButtonBarLayoutBehavior.padded].
  MaterialButtonBarLayoutBehaviorType.Enum layout_behavior = 7;
  // If true, then a [DropdownButton] menu's width will match the button's
  // width.
  //
  // If false (the default), then the dropdown's menu will be wider than
  // its button. In either case the dropdown button will line up the leading
  // edge of the menu's value with the leading edge of the values
  // displayed by the menu items.
  //
  // This property only affects [DropdownButton] and its menu.
  bool aligned_dropdown = 8;
  DartColorType button_color = 9;
  DartColorType disabled_color = 10;
  DartColorType focus_color = 11;
  DartColorType hover_color = 12;
  DartColorType highlight_color = 13;
  DartColorType splash_color = 14;
  // A set of thirteen colors that can be used to derive the button theme's
  // colors.
  //
  // This property was added much later than the theme's set of highly specific
  // colors, like [ThemeData.highlightColor] and [ThemeData.splashColor] etc.
  //
  // The colors for new button classes can be defined exclusively in terms of
  // [colorScheme]. When it's possible, the existing buttons will (continue to)
  // gradually migrate to it.
  MaterialColorSchemeType color_scheme = 15;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 16;
}

// package:flutter/src/material/button_theme.dart
//
// Creates a button theme from [data].
message MaterialButtonThemeNamedFromButtonThemeData {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the color and geometry of buttons.
  MaterialButtonThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/card.dart
//
// Creates a Material Design card.
//
// The [elevation] must be null or non-negative.
message MaterialCard {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The card's background color.
  //
  // Defines the card's [Material.color].
  //
  // In Material 3, [surfaceTintColor] is drawn on top of this color
  // when the card is elevated. This might make the appearance of
  // the card slightly different than in Material 2. To disable this
  // feature, set [surfaceTintColor] to [Colors.transparent].
  // See [Material.surfaceTintColor] for more details.
  //
  // If this property is null then the ambient [CardTheme.color] is used. If that is null,
  // and [ThemeData.useMaterial3] is true, then [ColorScheme.surface] of
  // [ThemeData.colorScheme] is used. Otherwise, [ThemeData.cardColor] is used.
  DartColorType color = 3;
  // The color to paint the shadow below the card.
  //
  // If null then the ambient [CardTheme]'s shadowColor is used.
  // If that's null too, then the overall theme's [ThemeData.shadowColor]
  // (default black) is used.
  DartColorType shadow_color = 4;
  // The color used as an overlay on [color] to indicate elevation.
  //
  // If this is null, no overlay will be applied. Otherwise this color
  // will be composited on top of [color] with an opacity related
  // to [elevation] and used to paint the background of the card.
  //
  // The default is null.
  //
  // See [Material.surfaceTintColor] for more details on how this
  // overlay is applied.
  DartColorType surface_tint_color = 5;
  // The z-coordinate at which to place this card. This controls the size of
  // the shadow below the card.
  //
  // Defines the card's [Material.elevation].
  //
  // If this property is null then [CardTheme.elevation] of
  // [ThemeData.cardTheme] is used. If that's null, the default value is 1.0.
  double elevation = 6;
  // The shape of the card's [Material].
  //
  // Defines the card's [Material.shape].
  //
  // If this property is null then [CardTheme.shape] of [ThemeData.cardTheme]
  // is used. If that's null then the shape will be a [RoundedRectangleBorder]
  // with a circular corner radius of 12.0 and if [ThemeData.useMaterial3] is
  // false, then the circular corner radius will be 4.0.
  FlutterShapeBorderType shape = 7;
  // Whether to paint the [shape] border in front of the [child].
  //
  // The default value is true.
  // If false, the border will be painted behind the [child].
  bool border_on_foreground = 8;
  // The empty space that surrounds the card.
  //
  // Defines the card's outer [Container.margin].
  //
  // If this property is null then [CardTheme.margin] of
  // [ThemeData.cardTheme] is used. If that's null, the default margin is 4.0
  // logical pixels on all sides: `EdgeInsets.all(4.0)`.
  FlutterEdgeInsetsGeometryType margin = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // If this property is null then [CardTheme.clipBehavior] of
  // [ThemeData.cardTheme] is used. If that's null then the behavior will be [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 11;
  // Whether this widget represents a single semantic container, or if false
  // a collection of individual semantic nodes.
  //
  // Defaults to true.
  //
  // Setting this flag to true will attempt to merge all child semantics into
  // this node. Setting this flag to false will force all child semantic nodes
  // to be explicit.
  //
  // This flag should be false if the card contains multiple different types
  // of content.
  bool semantic_container = 12;
}

// package:flutter/src/material/card.dart
//
// Create a filled variant of Card.
//
// Filled cards provide subtle separation from the background. This has less
// emphasis than elevated(default) or outlined cards.
message MaterialCardNamedFilled {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The card's background color.
  //
  // Defines the card's [Material.color].
  //
  // In Material 3, [surfaceTintColor] is drawn on top of this color
  // when the card is elevated. This might make the appearance of
  // the card slightly different than in Material 2. To disable this
  // feature, set [surfaceTintColor] to [Colors.transparent].
  // See [Material.surfaceTintColor] for more details.
  //
  // If this property is null then the ambient [CardTheme.color] is used. If that is null,
  // and [ThemeData.useMaterial3] is true, then [ColorScheme.surface] of
  // [ThemeData.colorScheme] is used. Otherwise, [ThemeData.cardColor] is used.
  DartColorType color = 3;
  // The color to paint the shadow below the card.
  //
  // If null then the ambient [CardTheme]'s shadowColor is used.
  // If that's null too, then the overall theme's [ThemeData.shadowColor]
  // (default black) is used.
  DartColorType shadow_color = 4;
  // The color used as an overlay on [color] to indicate elevation.
  //
  // If this is null, no overlay will be applied. Otherwise this color
  // will be composited on top of [color] with an opacity related
  // to [elevation] and used to paint the background of the card.
  //
  // The default is null.
  //
  // See [Material.surfaceTintColor] for more details on how this
  // overlay is applied.
  DartColorType surface_tint_color = 5;
  // The z-coordinate at which to place this card. This controls the size of
  // the shadow below the card.
  //
  // Defines the card's [Material.elevation].
  //
  // If this property is null then [CardTheme.elevation] of
  // [ThemeData.cardTheme] is used. If that's null, the default value is 1.0.
  double elevation = 6;
  // The shape of the card's [Material].
  //
  // Defines the card's [Material.shape].
  //
  // If this property is null then [CardTheme.shape] of [ThemeData.cardTheme]
  // is used. If that's null then the shape will be a [RoundedRectangleBorder]
  // with a circular corner radius of 12.0 and if [ThemeData.useMaterial3] is
  // false, then the circular corner radius will be 4.0.
  FlutterShapeBorderType shape = 7;
  // Whether to paint the [shape] border in front of the [child].
  //
  // The default value is true.
  // If false, the border will be painted behind the [child].
  bool border_on_foreground = 8;
  // The empty space that surrounds the card.
  //
  // Defines the card's outer [Container.margin].
  //
  // If this property is null then [CardTheme.margin] of
  // [ThemeData.cardTheme] is used. If that's null, the default margin is 4.0
  // logical pixels on all sides: `EdgeInsets.all(4.0)`.
  FlutterEdgeInsetsGeometryType margin = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // If this property is null then [CardTheme.clipBehavior] of
  // [ThemeData.cardTheme] is used. If that's null then the behavior will be [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 11;
  // Whether this widget represents a single semantic container, or if false
  // a collection of individual semantic nodes.
  //
  // Defaults to true.
  //
  // Setting this flag to true will attempt to merge all child semantics into
  // this node. Setting this flag to false will force all child semantic nodes
  // to be explicit.
  //
  // This flag should be false if the card contains multiple different types
  // of content.
  bool semantic_container = 12;
}

// package:flutter/src/material/card.dart
//
// Create an outlined variant of Card.
//
// Outlined cards have a visual boundary around the container. This can
// provide greater emphasis than the other types.
message MaterialCardNamedOutlined {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The card's background color.
  //
  // Defines the card's [Material.color].
  //
  // In Material 3, [surfaceTintColor] is drawn on top of this color
  // when the card is elevated. This might make the appearance of
  // the card slightly different than in Material 2. To disable this
  // feature, set [surfaceTintColor] to [Colors.transparent].
  // See [Material.surfaceTintColor] for more details.
  //
  // If this property is null then the ambient [CardTheme.color] is used. If that is null,
  // and [ThemeData.useMaterial3] is true, then [ColorScheme.surface] of
  // [ThemeData.colorScheme] is used. Otherwise, [ThemeData.cardColor] is used.
  DartColorType color = 3;
  // The color to paint the shadow below the card.
  //
  // If null then the ambient [CardTheme]'s shadowColor is used.
  // If that's null too, then the overall theme's [ThemeData.shadowColor]
  // (default black) is used.
  DartColorType shadow_color = 4;
  // The color used as an overlay on [color] to indicate elevation.
  //
  // If this is null, no overlay will be applied. Otherwise this color
  // will be composited on top of [color] with an opacity related
  // to [elevation] and used to paint the background of the card.
  //
  // The default is null.
  //
  // See [Material.surfaceTintColor] for more details on how this
  // overlay is applied.
  DartColorType surface_tint_color = 5;
  // The z-coordinate at which to place this card. This controls the size of
  // the shadow below the card.
  //
  // Defines the card's [Material.elevation].
  //
  // If this property is null then [CardTheme.elevation] of
  // [ThemeData.cardTheme] is used. If that's null, the default value is 1.0.
  double elevation = 6;
  // The shape of the card's [Material].
  //
  // Defines the card's [Material.shape].
  //
  // If this property is null then [CardTheme.shape] of [ThemeData.cardTheme]
  // is used. If that's null then the shape will be a [RoundedRectangleBorder]
  // with a circular corner radius of 12.0 and if [ThemeData.useMaterial3] is
  // false, then the circular corner radius will be 4.0.
  FlutterShapeBorderType shape = 7;
  // Whether to paint the [shape] border in front of the [child].
  //
  // The default value is true.
  // If false, the border will be painted behind the [child].
  bool border_on_foreground = 8;
  // The empty space that surrounds the card.
  //
  // Defines the card's outer [Container.margin].
  //
  // If this property is null then [CardTheme.margin] of
  // [ThemeData.cardTheme] is used. If that's null, the default margin is 4.0
  // logical pixels on all sides: `EdgeInsets.all(4.0)`.
  FlutterEdgeInsetsGeometryType margin = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // If this property is null then [CardTheme.clipBehavior] of
  // [ThemeData.cardTheme] is used. If that's null then the behavior will be [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 11;
  // Whether this widget represents a single semantic container, or if false
  // a collection of individual semantic nodes.
  //
  // Defaults to true.
  //
  // Setting this flag to true will attempt to merge all child semantics into
  // this node. Setting this flag to false will force all child semantic nodes
  // to be explicit.
  //
  // This flag should be false if the card contains multiple different types
  // of content.
  bool semantic_container = 12;
}

// package:flutter/src/material/card_theme.dart
//
// Creates a theme that can be used for [ThemeData.cardTheme].
//
// The [elevation] must be null or non-negative.
message MaterialCardTheme {
  // Overrides the default value for [Card.clipBehavior].
  //
  // If null, [Card] uses [Clip.none].
  DartClipType.Enum clip_behavior = 2;
  // Overrides the default value for [Card.color].
  //
  // If null, [Card] uses [ThemeData.cardColor].
  DartColorType color = 3;
  // Overrides the default value for [Card.shadowColor].
  //
  // If null, [Card] defaults to fully opaque black.
  DartColorType shadow_color = 4;
  // Overrides the default value for [Card.surfaceTintColor].
  //
  // If null, [Card] will not display an overlay color.
  //
  // See [Material.surfaceTintColor] for more details.
  DartColorType surface_tint_color = 5;
  // Overrides the default value for [Card.elevation].
  //
  // If null, [Card] uses a default of 1.0.
  double elevation = 6;
  // Overrides the default value for [Card.margin].
  //
  // If null, [Card] uses a default margin of 4.0 logical pixels on all sides:
  // `EdgeInsets.all(4.0)`.
  FlutterEdgeInsetsGeometryType margin = 7;
  // Overrides the default value for [Card.shape].
  //
  // If null, [Card] then uses a [RoundedRectangleBorder] with a circular
  // corner radius of 12.0 and if [ThemeData.useMaterial3] is false,
  // then the circular corner radius will be 4.0.
  FlutterShapeBorderType shape = 8;
}

// package:flutter/src/material/checkbox.dart
//
// Creates a Material Design checkbox.
//
// The checkbox itself does not maintain any state. Instead, when the state of
// the checkbox changes, the widget calls the [onChanged] callback. Most
// widgets that use a checkbox will listen for the [onChanged] callback and
// rebuild the checkbox with a new [value] to update the visual appearance of
// the checkbox.
//
// The following arguments are required:
//
// * [value], which determines whether the checkbox is checked. The [value]
//   can only be null if [tristate] is true.
// * [onChanged], which is called when the value of the checkbox should
//   change. It can be set to null to disable the checkbox.
message MaterialCheckbox {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this checkbox is checked.
  //
  // When [tristate] is true, a value of null corresponds to the mixed state.
  // When [tristate] is false, this value must not be null.
  bool value = 3;
  // If true the checkbox's [value] can be true, false, or null.
  //
  // [Checkbox] displays a dash when its value is null.
  //
  // When a tri-state checkbox ([tristate] is true) is tapped, its [onChanged]
  // callback will be applied to true if the current value is false, to null if
  // value is true, and to false if value is null (i.e. it cycles through false
  // => true => null => false when tapped).
  //
  // If tristate is false (the default), [value] must not be null.
  bool tristate = 4;
  // The color to use when this checkbox is checked.
  //
  // Defaults to [ColorScheme.secondary].
  //
  // If [fillColor] returns a non-null color in the [MaterialState.selected]
  // state, it will be used instead of this color.
  DartColorType active_color = 7;
  // {@template flutter.material.checkbox.checkColor}
  // The color to use for the check icon when this checkbox is checked.
  // {@endtemplate}
  //
  // If null, then the value of [CheckboxThemeData.checkColor] is used. If
  // that is also null, then Color(0xFFFFFFFF) is used.
  DartColorType check_color = 9;
  // The color for the checkbox's [Material] when it has the input focus.
  //
  // If [overlayColor] returns a non-null color in the [MaterialState.focused]
  // state, it will be used instead.
  //
  // If null, then the value of [CheckboxThemeData.overlayColor] is used in the
  // focused state. If that is also null, then the value of
  // [ThemeData.focusColor] is used.
  DartColorType focus_color = 10;
  // {@template flutter.material.checkbox.hoverColor}
  // The color for the checkbox's [Material] when a pointer is hovering over it.
  //
  // If [overlayColor] returns a non-null color in the [MaterialState.hovered]
  // state, it will be used instead.
  // {@endtemplate}
  //
  // If null, then the value of [CheckboxThemeData.overlayColor] is used in the
  // hovered state. If that is also null, then the value of
  // [ThemeData.hoverColor] is used.
  DartColorType hover_color = 11;
  // {@template flutter.material.checkbox.splashRadius}
  // The splash radius of the circular [Material] ink response.
  // {@endtemplate}
  //
  // If null, then the value of [CheckboxThemeData.splashRadius] is used. If
  // that is also null, then [kRadialReactionRadius] is used.
  double splash_radius = 13;
  // {@template flutter.material.checkbox.materialTapTargetSize}
  // Configures the minimum size of the tap target.
  // {@endtemplate}
  //
  // If null, then the value of [CheckboxThemeData.materialTapTargetSize] is
  // used. If that is also null, then the value of
  // [ThemeData.materialTapTargetSize] is used.
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 14;
  // {@template flutter.material.checkbox.visualDensity}
  // Defines how compact the checkbox's layout will be.
  // {@endtemplate}
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // If null, then the value of [CheckboxThemeData.visualDensity] is used. If
  // that is also null, then the value of [ThemeData.visualDensity] is used.
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 15;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 16;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 17;
  // {@template flutter.material.checkbox.shape}
  // The shape of the checkbox's [Material].
  // {@endtemplate}
  //
  // If this property is null then [CheckboxThemeData.shape] of [ThemeData.checkboxTheme]
  // is used. If that's null then the shape will be a [RoundedRectangleBorder]
  // with a circular corner radius of 1.0 in Material 2, and 2.0 in Material 3.
  FlutterOutlinedBorderType shape = 18;
  // {@template flutter.material.checkbox.side}
  // The color and width of the checkbox's border.
  //
  // This property can be a [MaterialStateBorderSide] that can
  // specify different border color and widths depending on the
  // checkbox's state.
  //
  // Resolves in the following states:
  //  * [MaterialState.pressed].
  //  * [MaterialState.selected].
  //  * [MaterialState.hovered].
  //  * [MaterialState.focused].
  //  * [MaterialState.disabled].
  //  * [MaterialState.error].
  //
  // If this property is not a [MaterialStateBorderSide] and it is
  // non-null, then it is only rendered when the checkbox's value is
  // false. The difference in interpretation is for backwards
  // compatibility.
  // {@endtemplate}
  //
  // If this property is null, then [CheckboxThemeData.side] of
  // [ThemeData.checkboxTheme] is used. If that is also null, then the side
  // will be width 2.
  FlutterBorderSideType side = 19;
  // {@template flutter.material.checkbox.isError}
  // True if this checkbox wants to show an error state.
  //
  // The checkbox will have different default container color and check color when
  // this is true. This is only used when [ThemeData.useMaterial3] is set to true.
  // {@endtemplate}
  //
  // Defaults to false.
  bool is_error = 20;
  // {@template flutter.material.checkbox.semanticLabel}
  // The semantic label for the checkobox that will be announced by screen readers.
  //
  // This is announced in accessibility modes (e.g TalkBack/VoiceOver).
  //
  // This label does not show in the UI.
  // {@endtemplate}
  string semantic_label = 21;
}

// package:flutter/src/material/checkbox_list_tile.dart
//
// Creates a combination of a list tile and a checkbox.
//
// The checkbox tile itself does not maintain any state. Instead, when the
// state of the checkbox changes, the widget calls the [onChanged] callback.
// Most widgets that use a checkbox will listen for the [onChanged] callback
// and rebuild the checkbox tile with a new [value] to update the visual
// appearance of the checkbox.
//
// The following arguments are required:
//
// * [value], which determines whether the checkbox is checked. The [value]
//   can only be null if [tristate] is true.
// * [onChanged], which is called when the value of the checkbox should
//   change. It can be set to null to disable the checkbox.
message MaterialCheckboxListTile {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this checkbox is checked.
  bool value = 3;
  // The color to use when this checkbox is checked.
  //
  // Defaults to [ColorScheme.secondary] of the current [Theme].
  DartColorType active_color = 6;
  // The color to use for the check icon when this checkbox is checked.
  //
  // Defaults to Color(0xFFFFFFFF).
  DartColorType check_color = 8;
  // {@macro flutter.material.checkbox.hoverColor}
  DartColorType hover_color = 9;
  // {@macro flutter.material.checkbox.splashRadius}
  //
  // If null, then the value of [CheckboxThemeData.splashRadius] is used. If
  // that is also null, then [kRadialReactionRadius] is used.
  double splash_radius = 11;
  // {@macro flutter.material.checkbox.materialTapTargetSize}
  //
  // Defaults to [MaterialTapTargetSize.shrinkWrap].
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 12;
  // Defines how compact the list tile's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  MaterialVisualDensityType visual_density = 13;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 14;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 15;
  // {@macro flutter.material.ListTile.shape}
  FlutterShapeBorderType shape = 16;
  // {@macro flutter.material.checkbox.side}
  //
  // The given value is passed directly to [Checkbox.side].
  //
  // If this property is null, then [CheckboxThemeData.side] of
  // [ThemeData.checkboxTheme] is used. If that is also null, then the side
  // will be width 2.
  FlutterBorderSideType side = 17;
  // {@macro flutter.material.checkbox.isError}
  //
  // Defaults to false.
  bool is_error = 18;
  // Whether the CheckboxListTile is interactive.
  //
  // If false, this list tile is styled with the disabled color from the
  // current [Theme] and the [ListTile.onTap] callback is
  // inoperative.
  bool enabled = 19;
  // {@macro flutter.material.ListTile.tileColor}
  DartColorType tile_color = 20;
  // The primary content of the list tile.
  //
  // Typically a [Text] widget.
  WidgetType title = 21;
  // Additional content displayed below the title.
  //
  // Typically a [Text] widget.
  WidgetType subtitle = 22;
  // Whether this list tile is intended to display three lines of text.
  //
  // If false, the list tile is treated as having one line if the subtitle is
  // null and treated as having two lines if the subtitle is non-null.
  bool is_three_line = 23;
  // Whether this list tile is part of a vertically dense list.
  //
  // If this property is null then its value is based on [ListTileThemeData.dense].
  bool dense = 24;
  // A widget to display on the opposite side of the tile from the checkbox.
  //
  // Typically an [Icon] widget.
  WidgetType secondary = 25;
  // Whether to render icons and text in the [activeColor].
  //
  // No effort is made to automatically coordinate the [selected] state and the
  // [value] state. To have the list tile appear selected when the checkbox is
  // checked, pass the same value to both.
  //
  // Normally, this property is left to its default value, false.
  bool selected = 26;
  // Where to place the control relative to the text.
  MaterialListTileControlAffinityType.Enum control_affinity = 27;
  // Defines insets surrounding the tile's contents.
  //
  // This value will surround the [Checkbox], [title], [subtitle], and [secondary]
  // widgets in [CheckboxListTile].
  //
  // When the value is null, the [contentPadding] is `EdgeInsets.symmetric(horizontal: 16.0)`.
  FlutterEdgeInsetsGeometryType content_padding = 28;
  // If true the checkbox's [value] can be true, false, or null.
  //
  // Checkbox displays a dash when its value is null.
  //
  // When a tri-state checkbox ([tristate] is true) is tapped, its [onChanged]
  // callback will be applied to true if the current value is false, to null if
  // value is true, and to false if value is null (i.e. it cycles through false
  // => true => null => false when tapped).
  //
  // If tristate is false (the default), [value] must not be null.
  bool tristate = 29;
  // {@macro flutter.material.checkbox.shape}
  //
  // If this property is null then [CheckboxThemeData.shape] of [ThemeData.checkboxTheme]
  // is used. If that's null then the shape will be a [RoundedRectangleBorder]
  // with a circular corner radius of 1.0.
  FlutterOutlinedBorderType checkbox_shape = 30;
  // If non-null, defines the background color when [CheckboxListTile.selected] is true.
  DartColorType selected_tile_color = 31;
  // {@macro flutter.material.ListTile.enableFeedback}
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 33;
  // {@macro flutter.material.checkbox.semanticLabel}
  string checkbox_semantic_label = 34;
}

// package:flutter/src/material/checkbox_list_tile.dart
//
// Creates a combination of a list tile and a platform adaptive checkbox.
//
// The checkbox uses [Checkbox.adaptive] to show a [CupertinoCheckbox] for
// iOS platforms, or [Checkbox] for all others.
//
// All other properties are the same as [CheckboxListTile].
message MaterialCheckboxListTileNamedAdaptive {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this checkbox is checked.
  bool value = 3;
  // The color to use when this checkbox is checked.
  //
  // Defaults to [ColorScheme.secondary] of the current [Theme].
  DartColorType active_color = 6;
  // The color to use for the check icon when this checkbox is checked.
  //
  // Defaults to Color(0xFFFFFFFF).
  DartColorType check_color = 8;
  // {@macro flutter.material.checkbox.hoverColor}
  DartColorType hover_color = 9;
  // {@macro flutter.material.checkbox.splashRadius}
  //
  // If null, then the value of [CheckboxThemeData.splashRadius] is used. If
  // that is also null, then [kRadialReactionRadius] is used.
  double splash_radius = 11;
  // {@macro flutter.material.checkbox.materialTapTargetSize}
  //
  // Defaults to [MaterialTapTargetSize.shrinkWrap].
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 12;
  // Defines how compact the list tile's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  MaterialVisualDensityType visual_density = 13;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 14;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 15;
  // {@macro flutter.material.ListTile.shape}
  FlutterShapeBorderType shape = 16;
  // {@macro flutter.material.checkbox.side}
  //
  // The given value is passed directly to [Checkbox.side].
  //
  // If this property is null, then [CheckboxThemeData.side] of
  // [ThemeData.checkboxTheme] is used. If that is also null, then the side
  // will be width 2.
  FlutterBorderSideType side = 17;
  // {@macro flutter.material.checkbox.isError}
  //
  // Defaults to false.
  bool is_error = 18;
  // Whether the CheckboxListTile is interactive.
  //
  // If false, this list tile is styled with the disabled color from the
  // current [Theme] and the [ListTile.onTap] callback is
  // inoperative.
  bool enabled = 19;
  // {@macro flutter.material.ListTile.tileColor}
  DartColorType tile_color = 20;
  // The primary content of the list tile.
  //
  // Typically a [Text] widget.
  WidgetType title = 21;
  // Additional content displayed below the title.
  //
  // Typically a [Text] widget.
  WidgetType subtitle = 22;
  // Whether this list tile is intended to display three lines of text.
  //
  // If false, the list tile is treated as having one line if the subtitle is
  // null and treated as having two lines if the subtitle is non-null.
  bool is_three_line = 23;
  // Whether this list tile is part of a vertically dense list.
  //
  // If this property is null then its value is based on [ListTileThemeData.dense].
  bool dense = 24;
  // A widget to display on the opposite side of the tile from the checkbox.
  //
  // Typically an [Icon] widget.
  WidgetType secondary = 25;
  // Whether to render icons and text in the [activeColor].
  //
  // No effort is made to automatically coordinate the [selected] state and the
  // [value] state. To have the list tile appear selected when the checkbox is
  // checked, pass the same value to both.
  //
  // Normally, this property is left to its default value, false.
  bool selected = 26;
  // Where to place the control relative to the text.
  MaterialListTileControlAffinityType.Enum control_affinity = 27;
  // Defines insets surrounding the tile's contents.
  //
  // This value will surround the [Checkbox], [title], [subtitle], and [secondary]
  // widgets in [CheckboxListTile].
  //
  // When the value is null, the [contentPadding] is `EdgeInsets.symmetric(horizontal: 16.0)`.
  FlutterEdgeInsetsGeometryType content_padding = 28;
  // If true the checkbox's [value] can be true, false, or null.
  //
  // Checkbox displays a dash when its value is null.
  //
  // When a tri-state checkbox ([tristate] is true) is tapped, its [onChanged]
  // callback will be applied to true if the current value is false, to null if
  // value is true, and to false if value is null (i.e. it cycles through false
  // => true => null => false when tapped).
  //
  // If tristate is false (the default), [value] must not be null.
  bool tristate = 29;
  // {@macro flutter.material.checkbox.shape}
  //
  // If this property is null then [CheckboxThemeData.shape] of [ThemeData.checkboxTheme]
  // is used. If that's null then the shape will be a [RoundedRectangleBorder]
  // with a circular corner radius of 1.0.
  FlutterOutlinedBorderType checkbox_shape = 30;
  // If non-null, defines the background color when [CheckboxListTile.selected] is true.
  DartColorType selected_tile_color = 31;
  // {@macro flutter.material.ListTile.enableFeedback}
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 33;
  // {@macro flutter.material.checkbox.semanticLabel}
  string checkbox_semantic_label = 34;
}

// package:flutter/src/material/menu_anchor.dart
//
// Creates a const [CheckboxMenuButton].
//
// The [child], [value], and [onChanged] attributes are required.
message MaterialCheckboxMenuButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this checkbox is checked.
  //
  // When [tristate] is true, a value of null corresponds to the mixed state.
  // When [tristate] is false, this value must not be null.
  bool value = 3;
  // If true, then the checkbox's [value] can be true, false, or null.
  //
  // [CheckboxMenuButton] displays a dash when its value is null.
  //
  // When a tri-state checkbox ([tristate] is true) is tapped, its [onChanged]
  // callback will be applied to true if the current value is false, to null if
  // value is true, and to false if value is null (i.e. it cycles through false
  // => true => null => false when tapped).
  //
  // If tristate is false (the default), [value] must not be null.
  bool tristate = 4;
  // True if this checkbox wants to show an error state.
  //
  // The checkbox will have different default container color and check color when
  // this is true. This is only used when [ThemeData.useMaterial3] is set to true.
  //
  // Defaults to false.
  bool is_error = 5;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 9;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding properties in
  // [MenuItemButton.themeStyleOf] and [MenuItemButton.defaultStyleOf].
  // [MaterialStateProperty]s that resolve to non-null values will similarly
  // override the corresponding [MaterialStateProperty]s in
  // [MenuItemButton.themeStyleOf] and [MenuItemButton.defaultStyleOf].
  //
  // Null by default.
  MaterialButtonStyleType style = 11;
  // {@macro flutter.material.inkwell.statesController}
  MaterialMaterialStatesControllerType states_controller = 12;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 13;
  // An optional icon to display after the [child] label.
  WidgetType trailing_icon = 14;
  // {@macro flutter.material.menu_anchor.closeOnActivate}
  bool close_on_activate = 15;
  // The widget displayed in the center of this button.
  //
  // Typically this is the button's label, using a [Text] widget.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 16;
}

// package:flutter/src/material/checkbox.dart
//
// Creates an adaptive [Checkbox] based on whether the target platform is iOS
// or macOS, following Material design's
// [Cross-platform guidelines](https://material.io/design/platform-guidance/cross-platform-adaptation.html).
//
// On iOS and macOS, this constructor creates a [CupertinoCheckbox], which has
// matching functionality and presentation as Material checkboxes, and are the
// graphics expected on iOS. On other platforms, this creates a Material
// design [Checkbox].
//
// If a [CupertinoCheckbox] is created, the following parameters are ignored:
// [mouseCursor], [fillColor], [hoverColor], [overlayColor], [splashRadius],
// [materialTapTargetSize], [visualDensity], [isError]. However, [shape] and
// [side] will still affect the [CupertinoCheckbox] and should be handled if
// native fidelity is important.
//
// The target platform is based on the current [Theme]: [ThemeData.platform].
message MaterialCheckboxNamedAdaptive {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this checkbox is checked.
  //
  // When [tristate] is true, a value of null corresponds to the mixed state.
  // When [tristate] is false, this value must not be null.
  bool value = 3;
  // If true the checkbox's [value] can be true, false, or null.
  //
  // [Checkbox] displays a dash when its value is null.
  //
  // When a tri-state checkbox ([tristate] is true) is tapped, its [onChanged]
  // callback will be applied to true if the current value is false, to null if
  // value is true, and to false if value is null (i.e. it cycles through false
  // => true => null => false when tapped).
  //
  // If tristate is false (the default), [value] must not be null.
  bool tristate = 4;
  // The color to use when this checkbox is checked.
  //
  // Defaults to [ColorScheme.secondary].
  //
  // If [fillColor] returns a non-null color in the [MaterialState.selected]
  // state, it will be used instead of this color.
  DartColorType active_color = 7;
  // {@template flutter.material.checkbox.checkColor}
  // The color to use for the check icon when this checkbox is checked.
  // {@endtemplate}
  //
  // If null, then the value of [CheckboxThemeData.checkColor] is used. If
  // that is also null, then Color(0xFFFFFFFF) is used.
  DartColorType check_color = 9;
  // The color for the checkbox's [Material] when it has the input focus.
  //
  // If [overlayColor] returns a non-null color in the [MaterialState.focused]
  // state, it will be used instead.
  //
  // If null, then the value of [CheckboxThemeData.overlayColor] is used in the
  // focused state. If that is also null, then the value of
  // [ThemeData.focusColor] is used.
  DartColorType focus_color = 10;
  // {@template flutter.material.checkbox.hoverColor}
  // The color for the checkbox's [Material] when a pointer is hovering over it.
  //
  // If [overlayColor] returns a non-null color in the [MaterialState.hovered]
  // state, it will be used instead.
  // {@endtemplate}
  //
  // If null, then the value of [CheckboxThemeData.overlayColor] is used in the
  // hovered state. If that is also null, then the value of
  // [ThemeData.hoverColor] is used.
  DartColorType hover_color = 11;
  // {@template flutter.material.checkbox.splashRadius}
  // The splash radius of the circular [Material] ink response.
  // {@endtemplate}
  //
  // If null, then the value of [CheckboxThemeData.splashRadius] is used. If
  // that is also null, then [kRadialReactionRadius] is used.
  double splash_radius = 13;
  // {@template flutter.material.checkbox.materialTapTargetSize}
  // Configures the minimum size of the tap target.
  // {@endtemplate}
  //
  // If null, then the value of [CheckboxThemeData.materialTapTargetSize] is
  // used. If that is also null, then the value of
  // [ThemeData.materialTapTargetSize] is used.
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 14;
  // {@template flutter.material.checkbox.visualDensity}
  // Defines how compact the checkbox's layout will be.
  // {@endtemplate}
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // If null, then the value of [CheckboxThemeData.visualDensity] is used. If
  // that is also null, then the value of [ThemeData.visualDensity] is used.
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 15;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 16;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 17;
  // {@template flutter.material.checkbox.shape}
  // The shape of the checkbox's [Material].
  // {@endtemplate}
  //
  // If this property is null then [CheckboxThemeData.shape] of [ThemeData.checkboxTheme]
  // is used. If that's null then the shape will be a [RoundedRectangleBorder]
  // with a circular corner radius of 1.0 in Material 2, and 2.0 in Material 3.
  FlutterOutlinedBorderType shape = 18;
  // {@template flutter.material.checkbox.side}
  // The color and width of the checkbox's border.
  //
  // This property can be a [MaterialStateBorderSide] that can
  // specify different border color and widths depending on the
  // checkbox's state.
  //
  // Resolves in the following states:
  //  * [MaterialState.pressed].
  //  * [MaterialState.selected].
  //  * [MaterialState.hovered].
  //  * [MaterialState.focused].
  //  * [MaterialState.disabled].
  //  * [MaterialState.error].
  //
  // If this property is not a [MaterialStateBorderSide] and it is
  // non-null, then it is only rendered when the checkbox's value is
  // false. The difference in interpretation is for backwards
  // compatibility.
  // {@endtemplate}
  //
  // If this property is null, then [CheckboxThemeData.side] of
  // [ThemeData.checkboxTheme] is used. If that is also null, then the side
  // will be width 2.
  FlutterBorderSideType side = 19;
  // {@template flutter.material.checkbox.isError}
  // True if this checkbox wants to show an error state.
  //
  // The checkbox will have different default container color and check color when
  // this is true. This is only used when [ThemeData.useMaterial3] is set to true.
  // {@endtemplate}
  //
  // Defaults to false.
  bool is_error = 20;
  // {@template flutter.material.checkbox.semanticLabel}
  // The semantic label for the checkobox that will be announced by screen readers.
  //
  // This is announced in accessibility modes (e.g TalkBack/VoiceOver).
  //
  // This label does not show in the UI.
  // {@endtemplate}
  string semantic_label = 21;
}

// package:flutter/src/material/checkbox_theme.dart
//
// Constructs a checkbox theme that configures all descendant [Checkbox]
// widgets.
message MaterialCheckboxTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [Checkbox] widgets.
  MaterialCheckboxThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/checkbox_theme.dart
//
// Creates a theme that can be used for [ThemeData.checkboxTheme].
message MaterialCheckboxThemeData {
  // {@macro flutter.material.checkbox.splashRadius}
  //
  // If specified, overrides the default value of [Checkbox.splashRadius].
  double splash_radius = 6;
  // {@macro flutter.material.checkbox.materialTapTargetSize}
  //
  // If specified, overrides the default value of
  // [Checkbox.materialTapTargetSize].
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 7;
  // {@macro flutter.material.checkbox.visualDensity}
  //
  // If specified, overrides the default value of [Checkbox.visualDensity].
  MaterialVisualDensityType visual_density = 8;
  // {@macro flutter.material.checkbox.shape}
  //
  // If specified, overrides the default value of [Checkbox.shape].
  FlutterOutlinedBorderType shape = 9;
  // {@macro flutter.material.checkbox.side}
  //
  // If specified, overrides the default value of [Checkbox.side].
  FlutterBorderSideType side = 10;
}

// package:flutter/src/material/popup_menu.dart
//
// Creates a popup menu item with a checkmark.
//
// By default, the menu item is [enabled] but unchecked. To mark the item as
// checked, set [checked] to true.
message MaterialCheckedPopupMenuItem {
  FlutterKeyType key = 2;
  // Whether to display a checkmark next to the menu item.
  //
  // Defaults to false.
  //
  // When true, an [Icons.done] checkmark is displayed.
  //
  // When this popup menu item is selected, the checkmark will fade in or out
  // as appropriate to represent the implied new state.
  bool checked = 4;
  // Whether the user is permitted to select this item.
  //
  // Defaults to true. If this is false, then the item will not react to
  // touches.
  bool enabled = 5;
  // The padding of the menu item.
  //
  // The [height] property may interact with the applied padding. For example,
  // If a [height] greater than the height of the sum of the padding and [child]
  // is provided, then the padding's effect will not be visible.
  //
  // If this is null and [ThemeData.useMaterial3] is true, the horizontal padding
  // defaults to 12.0 on both sides.
  //
  // If this is null and [ThemeData.useMaterial3] is false, the horizontal padding
  // defaults to 16.0 on both sides.
  FlutterEdgeInsetsType padding = 6;
  // The minimum height of the menu item.
  //
  // Defaults to [kMinInteractiveDimension] pixels.
  double height = 7;
  // The widget below this widget in the tree.
  //
  // Typically a single-line [ListTile] (for menus with icons) or a [Text]. An
  // appropriate [DefaultTextStyle] is put in scope for the child. In either
  // case, the text should be short enough that it won't wrap.
  WidgetType child = 10;
}

// package:flutter/src/material/chip.dart
//
// Creates a Material Design chip.
//
// The [elevation] must be null or non-negative.
message MaterialChip {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  WidgetType avatar = 3;
  WidgetType label = 4;
  FlutterTextStyleType label_style = 5;
  FlutterEdgeInsetsGeometryType label_padding = 6;
  WidgetType delete_icon = 7;
  DartColorType delete_icon_color = 9;
  string delete_button_tooltip_message = 10;
  FlutterBorderSideType side = 11;
  FlutterOutlinedBorderType shape = 12;
  DartClipType.Enum clip_behavior = 13;
  FlutterFocusNodeType focus_node = 14;
  bool autofocus = 15;
  DartColorType background_color = 17;
  FlutterEdgeInsetsGeometryType padding = 18;
  MaterialVisualDensityType visual_density = 19;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 20;
  double elevation = 21;
  DartColorType shadow_color = 22;
  DartColorType surface_tint_color = 23;
  FlutterIconThemeDataType icon_theme = 24;
}

// package:flutter/src/material/chip_theme.dart
//
// Applies the given theme [data] to [child].
message MaterialChipTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the color, shape, and text style values for descendant chip
  // widgets.
  MaterialChipThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/chip_theme.dart
//
// Create a [ChipThemeData] given a set of exact values. All the values
// must be specified except for [shadowColor], [selectedShadowColor],
// [elevation], and [pressElevation], which may be null.
//
// This will rarely be used directly. It is used by [lerp] to
// create intermediate themes based on two themes.
message MaterialChipThemeData {
  // Overrides the default for [ChipAttributes.backgroundColor]
  // which is used for unselected, enabled chip backgrounds.
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  DartColorType background_color = 3;
  // Overrides the default for [DeletableChipAttributes.deleteIconColor].
  //
  // This property applies to [Chip], [InputChip], [RawChip].
  DartColorType delete_icon_color = 4;
  // Overrides the default for
  // [DisabledChipAttributes.disabledColor], the background color
  // which indicates that the chip is not enabled.
  //
  // This property applies to [ActionChip], [ChoiceChip],
  // [FilterChip], [InputChip], and [RawChip].
  DartColorType disabled_color = 5;
  // Overrides the default for
  // [SelectableChipAttributes.selectedColor], the background color
  // that indicates that the chip is selected.
  //
  // This property applies to [ChoiceChip], [FilterChip],
  // [InputChip], [RawChip].
  DartColorType selected_color = 6;
  // Overrides the default for [ChoiceChip.selectedColor], the
  // background color that indicates that the chip is selected.
  DartColorType secondary_selected_color = 7;
  // Overrides the default for [ChipAttributes.shadowColor], the
  // Color of the chip's shadow when its elevation is greater than 0.
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  DartColorType shadow_color = 8;
  // Overrides the default for [ChipAttributes.surfaceTintColor], the
  // Color of the chip's surface tint overlay when its elevation is
  // greater than 0.
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  DartColorType surface_tint_color = 9;
  // Overrides the default for
  // [SelectableChipAttributes.selectedShadowColor], the Color of the
  // chip's shadow when its elevation is greater than 0 and the chip
  // is selected.
  //
  // This property applies to [ChoiceChip], [FilterChip],
  // [InputChip], [RawChip].
  DartColorType selected_shadow_color = 10;
  // Overrides the default for
  // [CheckmarkableChipAttributes.showCheckmark], which indicates if
  // a check mark should be shown.
  //
  // This property applies to [FilterChip], [InputChip], [RawChip].
  bool show_checkmark = 11;
  // Overrides the default for
  // [CheckmarkableChipAttributes.checkmarkColor].
  //
  // This property applies to [FilterChip], [InputChip], [RawChip].
  DartColorType checkmark_color = 12;
  // Overrides the default for [ChipAttributes.labelPadding],
  // the padding around the chip's label widget.
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  FlutterEdgeInsetsGeometryType label_padding = 13;
  // Overrides the default for [ChipAttributes.padding],
  // the padding between the contents of the chip and the outside [shape].
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  FlutterEdgeInsetsGeometryType padding = 14;
  // Overrides the default for [ChipAttributes.side],
  // the color and weight of the chip's outline.
  //
  // This value is combined with [shape] to create a shape decorated with an
  // outline. If it is a [MaterialStateBorderSide],
  // [MaterialStateProperty.resolve] is used for the following
  // [MaterialState]s:
  //
  //  * [MaterialState.disabled].
  //  * [MaterialState.selected].
  //  * [MaterialState.hovered].
  //  * [MaterialState.focused].
  //  * [MaterialState.pressed].
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  FlutterBorderSideType side = 15;
  // Overrides the default for [ChipAttributes.shape],
  // the shape of border to draw around the chip.
  //
  // This shape is combined with [side] to create a shape decorated with an
  // outline. If it is a [MaterialStateOutlinedBorder],
  // [MaterialStateProperty.resolve] is used for the following
  // [MaterialState]s:
  //
  //  * [MaterialState.disabled].
  //  * [MaterialState.selected].
  //  * [MaterialState.hovered].
  //  * [MaterialState.focused].
  //  * [MaterialState.pressed].
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  FlutterOutlinedBorderType shape = 16;
  // Overrides the default for [ChipAttributes.labelStyle],
  // the style of the [DefaultTextStyle] that contains the
  // chip's label.
  //
  // This only has an effect on label widgets that respect the
  // [DefaultTextStyle], such as [Text].
  //
  // This property applies to [ActionChip], [Chip],
  // [FilterChip], [InputChip], [RawChip].
  FlutterTextStyleType label_style = 17;
  // Overrides the default for [ChoiceChip.labelStyle],
  // the style of the [DefaultTextStyle] that contains the
  // chip's label.
  //
  // This only has an effect on label widgets that respect the
  // [DefaultTextStyle], such as [Text].
  FlutterTextStyleType secondary_label_style = 18;
  // Overrides the default value for all chips which affects various base
  // material color choices in the chip rendering.
  DartBrightnessType.Enum brightness = 19;
  // Overrides the default for [ChipAttributes.elevation],
  // the elevation of the chip's [Material].
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  double elevation = 20;
  // Overrides the default for [TappableChipAttributes.pressElevation],
  // the elevation of the chip's [Material] during a "press" or tap down.
  //
  // This property applies to [ActionChip], [InputChip], [RawChip].
  double press_elevation = 21;
  // Overrides the default for [ChipAttributes.iconTheme],
  // the theme used for all icons in the chip.
  //
  // This property applies to [ActionChip], [Chip], [ChoiceChip],
  // [FilterChip], [InputChip], [RawChip].
  FlutterIconThemeDataType icon_theme = 22;
}

// package:flutter/src/material/chip_theme.dart
//
// Generates a ChipThemeData from a brightness, a primary color, and a text
// style.
//
// The [brightness] is used to select a primary color from the default
// values.
//
// The optional [primaryColor] is used as the base color for the other
// colors. The opacity of the [primaryColor] is ignored. If a [primaryColor]
// is specified, then the [brightness] is ignored, and the theme brightness
// is determined from the [primaryColor].
//
// Only one of [primaryColor] or [brightness] may be specified.
//
// The [secondaryColor] is used for the selection colors needed by
// [ChoiceChip].
//
// This is used to generate the default chip theme for a [ThemeData].
message MaterialChipThemeDataNamedFromDefaults {
  DartBrightnessType.Enum brightness = 2;
  DartColorType primary_color = 3;
  DartColorType secondary_color = 4;
  FlutterTextStyleType label_style = 5;
}

// package:flutter/src/material/choice_chip.dart
//
// Create a chip that acts like a radio button.
//
// The [label], [selected], [autofocus], and [clipBehavior] arguments must
// not be null. The [pressElevation] and [elevation] must be null or
// non-negative. Typically, [pressElevation] is greater than [elevation].
message MaterialChoiceChip {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  WidgetType avatar = 3;
  WidgetType label = 4;
  FlutterTextStyleType label_style = 5;
  FlutterEdgeInsetsGeometryType label_padding = 6;
  double press_elevation = 8;
  bool selected = 9;
  DartColorType selected_color = 10;
  DartColorType disabled_color = 11;
  string tooltip = 12;
  FlutterBorderSideType side = 13;
  FlutterOutlinedBorderType shape = 14;
  DartClipType.Enum clip_behavior = 15;
  FlutterFocusNodeType focus_node = 16;
  bool autofocus = 17;
  DartColorType background_color = 19;
  FlutterEdgeInsetsGeometryType padding = 20;
  MaterialVisualDensityType visual_density = 21;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 22;
  double elevation = 23;
  DartColorType shadow_color = 24;
  DartColorType surface_tint_color = 25;
  FlutterIconThemeDataType icon_theme = 26;
  DartColorType selected_shadow_color = 27;
  bool show_checkmark = 28;
  DartColorType checkmark_color = 29;
  FlutterShapeBorderType avatar_border = 30;
}

// package:flutter/src/material/choice_chip.dart
//
// Create an elevated chip that acts like a radio button.
//
// The [label], [selected], [autofocus], and [clipBehavior] arguments must
// not be null. The [pressElevation] and [elevation] must be null or
// non-negative. Typically, [pressElevation] is greater than [elevation].
message MaterialChoiceChipNamedElevated {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  WidgetType avatar = 3;
  WidgetType label = 4;
  FlutterTextStyleType label_style = 5;
  FlutterEdgeInsetsGeometryType label_padding = 6;
  double press_elevation = 8;
  bool selected = 9;
  DartColorType selected_color = 10;
  DartColorType disabled_color = 11;
  string tooltip = 12;
  FlutterBorderSideType side = 13;
  FlutterOutlinedBorderType shape = 14;
  DartClipType.Enum clip_behavior = 15;
  FlutterFocusNodeType focus_node = 16;
  bool autofocus = 17;
  DartColorType background_color = 19;
  FlutterEdgeInsetsGeometryType padding = 20;
  MaterialVisualDensityType visual_density = 21;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 22;
  double elevation = 23;
  DartColorType shadow_color = 24;
  DartColorType surface_tint_color = 25;
  FlutterIconThemeDataType icon_theme = 26;
  DartColorType selected_shadow_color = 27;
  bool show_checkmark = 28;
  DartColorType checkmark_color = 29;
  FlutterShapeBorderType avatar_border = 30;
}

// package:flutter/src/material/circle_avatar.dart
//
// Creates a circle that represents a user.
message MaterialCircleAvatar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // Typically a [Text] widget. If the [CircleAvatar] is to have an image, use
  // [backgroundImage] instead.
  WidgetType child = 3;
  // The color with which to fill the circle. Changing the background
  // color will cause the avatar to animate to the new color.
  //
  // If a [backgroundColor] is not specified and [ThemeData.useMaterial3] is true,
  // [ColorScheme.primaryContainer] will be used, otherwise the theme's
  // [ThemeData.primaryColorLight] is used with dark foreground colors, and
  // [ThemeData.primaryColorDark] with light foreground colors.
  DartColorType background_color = 4;
  // The default text color for text in the circle.
  //
  // Defaults to the primary text theme color if no [backgroundColor] is
  // specified.
  //
  // If a [foregroundColor] is not specified and [ThemeData.useMaterial3] is true,
  // [ColorScheme.onPrimaryContainer] will be used, otherwise the theme's
  // [ThemeData.primaryColorLight] for dark background colors, and
  // [ThemeData.primaryColorDark] for light background colors.
  DartColorType foreground_color = 9;
  // The size of the avatar, expressed as the radius (half the diameter).
  //
  // If [radius] is specified, then neither [minRadius] nor [maxRadius] may be
  // specified. Specifying [radius] is equivalent to specifying a [minRadius]
  // and [maxRadius], both with the value of [radius].
  //
  // If neither [minRadius] nor [maxRadius] are specified, defaults to 20
  // logical pixels. This is the appropriate size for use with
  // [ListTile.leading].
  //
  // Changes to the [radius] are animated (including changing from an explicit
  // [radius] to a [minRadius]/[maxRadius] pair or vice versa).
  double radius = 10;
  // The minimum size of the avatar, expressed as the radius (half the
  // diameter).
  //
  // If [minRadius] is specified, then [radius] must not also be specified.
  //
  // Defaults to zero.
  //
  // Constraint changes are animated, but size changes due to the environment
  // itself changing are not. For example, changing the [minRadius] from 10 to
  // 20 when the [CircleAvatar] is in an unconstrained environment will cause
  // the avatar to animate from a 20 pixel diameter to a 40 pixel diameter.
  // However, if the [minRadius] is 40 and the [CircleAvatar] has a parent
  // [SizedBox] whose size changes instantaneously from 20 pixels to 40 pixels,
  // the size will snap to 40 pixels instantly.
  double min_radius = 11;
  // The maximum size of the avatar, expressed as the radius (half the
  // diameter).
  //
  // If [maxRadius] is specified, then [radius] must not also be specified.
  //
  // Defaults to [double.infinity].
  //
  // Constraint changes are animated, but size changes due to the environment
  // itself changing are not. For example, changing the [maxRadius] from 10 to
  // 20 when the [CircleAvatar] is in an unconstrained environment will cause
  // the avatar to animate from a 20 pixel diameter to a 40 pixel diameter.
  // However, if the [maxRadius] is 40 and the [CircleAvatar] has a parent
  // [SizedBox] whose size changes instantaneously from 20 pixels to 40 pixels,
  // the size will snap to 40 pixels instantly.
  double max_radius = 12;
}

// package:flutter/src/material/progress_indicator.dart
//
// Creates a circular progress indicator.
//
// {@macro flutter.material.ProgressIndicator.ProgressIndicator}
message MaterialCircularProgressIndicator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If non-null, the value of this progress indicator.
  //
  // A value of 0.0 means no progress and 1.0 means that progress is complete.
  // The value will be clamped to be in the range 0.0-1.0.
  //
  // If null, this progress indicator is indeterminate, which means the
  // indicator displays a predetermined animation that does not indicate how
  // much actual progress is being made.
  double value = 3;
  // The progress indicator's background color.
  //
  // It is up to the subclass to implement this in whatever way makes sense
  // for the given use case. See the subclass documentation for details.
  DartColorType background_color = 4;
  // {@template flutter.progress_indicator.ProgressIndicator.color}
  // The progress indicator's color.
  //
  // This is only used if [ProgressIndicator.valueColor] is null.
  // If [ProgressIndicator.color] is also null, then the ambient
  // [ProgressIndicatorThemeData.color] will be used. If that
  // is null then the current theme's [ColorScheme.primary] will
  // be used by default.
  // {@endtemplate}
  DartColorType color = 5;
  // The width of the line used to draw the circle.
  double stroke_width = 7;
  // The relative position of the stroke on a [CircularProgressIndicator].
  //
  // Values typically range from -1.0 ([strokeAlignInside], inside stroke)
  // to 1.0 ([strokeAlignOutside], outside stroke),
  // without any bound constraints (e.g., a value of -2.0 is not typical, but allowed).
  // A value of 0 ([strokeAlignCenter], default) will center the border
  // on the edge of the widget.
  double stroke_align = 8;
  // {@template flutter.progress_indicator.ProgressIndicator.semanticsLabel}
  // The [SemanticsProperties.label] for this progress indicator.
  //
  // This value indicates the purpose of the progress bar, and will be
  // read out by screen readers to indicate the purpose of this progress
  // indicator.
  // {@endtemplate}
  string semantics_label = 9;
  // {@template flutter.progress_indicator.ProgressIndicator.semanticsValue}
  // The [SemanticsProperties.value] for this progress indicator.
  //
  // This will be used in conjunction with the [semanticsLabel] by
  // screen reading software to identify the widget, and is primarily
  // intended for use with determinate progress indicators to announce
  // how far along they are.
  //
  // For determinate progress indicators, this will be defaulted to
  // [ProgressIndicator.value] expressed as a percentage, i.e. `0.1` will
  // become '10%'.
  // {@endtemplate}
  string semantics_value = 10;
  // The progress indicator's line ending.
  //
  // This determines the shape of the stroke ends of the progress indicator.
  // By default, [strokeCap] is null.
  // When [value] is null (indeterminate), the stroke ends are set to
  // [StrokeCap.square]. When [value] is not null, the stroke
  // ends are set to [StrokeCap.butt].
  //
  // Setting [strokeCap] to [StrokeCap.round] will result in a rounded end.
  // Setting [strokeCap] to [StrokeCap.butt] with [value] == null will result
  // in a slightly different indeterminate animation; the indicator completely
  // disappears and reappears on its minimum value.
  // Setting [strokeCap] to [StrokeCap.square] with [value] != null will
  // result in a different display of [value]. The indicator will start
  // drawing from slightly less than the start, and end slightly after
  // the end. This will produce an alternative result, as the
  // default behavior, for example, that a [value] of 0.5 starts at 90 degrees
  // and ends at 270 degrees. With [StrokeCap.square], it could start 85
  // degrees and end at 275 degrees.
  DartStrokeCapType.Enum stroke_cap = 11;
}

// package:flutter/src/material/progress_indicator.dart
//
// Creates an adaptive progress indicator that is a
// [CupertinoActivityIndicator] in iOS and [CircularProgressIndicator] in
// material theme/non-iOS.
//
// The [value], [valueColor], [strokeWidth], [semanticsLabel], and
// [semanticsValue] will be ignored in iOS.
//
// {@macro flutter.material.ProgressIndicator.ProgressIndicator}
message MaterialCircularProgressIndicatorNamedAdaptive {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If non-null, the value of this progress indicator.
  //
  // A value of 0.0 means no progress and 1.0 means that progress is complete.
  // The value will be clamped to be in the range 0.0-1.0.
  //
  // If null, this progress indicator is indeterminate, which means the
  // indicator displays a predetermined animation that does not indicate how
  // much actual progress is being made.
  double value = 3;
  // The progress indicator's background color.
  //
  // It is up to the subclass to implement this in whatever way makes sense
  // for the given use case. See the subclass documentation for details.
  DartColorType background_color = 4;
  // The width of the line used to draw the circle.
  double stroke_width = 6;
  // {@template flutter.progress_indicator.ProgressIndicator.semanticsLabel}
  // The [SemanticsProperties.label] for this progress indicator.
  //
  // This value indicates the purpose of the progress bar, and will be
  // read out by screen readers to indicate the purpose of this progress
  // indicator.
  // {@endtemplate}
  string semantics_label = 7;
  // {@template flutter.progress_indicator.ProgressIndicator.semanticsValue}
  // The [SemanticsProperties.value] for this progress indicator.
  //
  // This will be used in conjunction with the [semanticsLabel] by
  // screen reading software to identify the widget, and is primarily
  // intended for use with determinate progress indicators to announce
  // how far along they are.
  //
  // For determinate progress indicators, this will be defaulted to
  // [ProgressIndicator.value] expressed as a percentage, i.e. `0.1` will
  // become '10%'.
  // {@endtemplate}
  string semantics_value = 8;
  // The progress indicator's line ending.
  //
  // This determines the shape of the stroke ends of the progress indicator.
  // By default, [strokeCap] is null.
  // When [value] is null (indeterminate), the stroke ends are set to
  // [StrokeCap.square]. When [value] is not null, the stroke
  // ends are set to [StrokeCap.butt].
  //
  // Setting [strokeCap] to [StrokeCap.round] will result in a rounded end.
  // Setting [strokeCap] to [StrokeCap.butt] with [value] == null will result
  // in a slightly different indeterminate animation; the indicator completely
  // disappears and reappears on its minimum value.
  // Setting [strokeCap] to [StrokeCap.square] with [value] != null will
  // result in a different display of [value]. The indicator will start
  // drawing from slightly less than the start, and end slightly after
  // the end. This will produce an alternative result, as the
  // default behavior, for example, that a [value] of 0.5 starts at 90 degrees
  // and ends at 270 degrees. With [StrokeCap.square], it could start 85
  // degrees and end at 275 degrees.
  DartStrokeCapType.Enum stroke_cap = 9;
  // The relative position of the stroke on a [CircularProgressIndicator].
  //
  // Values typically range from -1.0 ([strokeAlignInside], inside stroke)
  // to 1.0 ([strokeAlignOutside], outside stroke),
  // without any bound constraints (e.g., a value of -2.0 is not typical, but allowed).
  // A value of 0 ([strokeAlignCenter], default) will center the border
  // on the edge of the widget.
  double stroke_align = 10;
}

// package:flutter/src/material/action_buttons.dart
//
// Creates a Material Design close icon button.
message MaterialCloseButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The color to use for the icon.
  //
  // Defaults to the [IconThemeData.color] specified in the ambient [IconTheme],
  // which usually matches the ambient [Theme]'s [ThemeData.iconTheme].
  DartColorType color = 3;
  // Customizes this icon button's appearance.
  //
  // The [style] is only used for Material 3 [IconButton]s. If [ThemeData.useMaterial3]
  // is set to true, [style] is preferred for icon button customization, and any
  // parameters defined in [style] will override the same parameters in [IconButton].
  //
  // Null by default.
  MaterialButtonStyleType style = 5;
}

// package:flutter/src/material/action_buttons.dart
//
// Creates an icon that shows the appropriate "close" image for
// the current platform (as obtained from the [Theme]).
message MaterialCloseButtonIcon {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
}

// package:flutter/src/material/color_scheme.dart
//
// Create a ColorScheme instance from the given colors.
//
// [ColorScheme.fromSeed] can be used as a simpler way to create a full
// color scheme derived from a single seed color.
//
// For the color parameters that are nullable, it is still recommended
// that applications provide values for them. They are only nullable due
// to backwards compatibility concerns.
//
// If a color is not provided, the closest fallback color from the given
// colors will be used for it (e.g. [primaryContainer] will default
// to [primary]). Material Design 3 makes use of these colors for many
// component defaults, so for the best results the application should
// supply colors for all the parameters. An easy way to ensure this is to
// use [ColorScheme.fromSeed] to generate a full set of colors.
//
// During the migration to Material Design 3, if an app's
// [ThemeData.useMaterial3] is false, then components will only
// use the following colors for defaults:
//
// * [primary]
// * [onPrimary]
// * [secondary]
// * [onSecondary]
// * [error]
// * [onError]
// * [background]
// * [onBackground]
// * [surface]
// * [onSurface]
message MaterialColorScheme {
  // The overall brightness of this color scheme.
  DartBrightnessType.Enum brightness = 2;
  // The color displayed most frequently across your apps screens and components.
  DartColorType primary = 3;
  // A color that's clearly legible when drawn on [primary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_primary = 4;
  DartColorType primary_container = 5;
  DartColorType on_primary_container = 6;
  // An accent color used for less prominent components in the UI, such as
  // filter chips, while expanding the opportunity for color expression.
  DartColorType secondary = 7;
  // A color that's clearly legible when drawn on [secondary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_secondary = 8;
  DartColorType secondary_container = 9;
  DartColorType on_secondary_container = 10;
  DartColorType tertiary = 11;
  DartColorType on_tertiary = 12;
  DartColorType tertiary_container = 13;
  DartColorType on_tertiary_container = 14;
  // The color to use for input validation errors, e.g. for
  // [InputDecoration.errorText].
  DartColorType error = 15;
  // A color that's clearly legible when drawn on [error].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [error] and [onError] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_error = 16;
  DartColorType error_container = 17;
  DartColorType on_error_container = 18;
  // A color that typically appears behind scrollable content.
  DartColorType background = 19;
  // A color that's clearly legible when drawn on [background].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [background] and [onBackground] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_background = 20;
  // The background color for widgets like [Card].
  DartColorType surface = 21;
  // A color that's clearly legible when drawn on [surface].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [surface] and [onSurface] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_surface = 22;
  DartColorType surface_variant = 23;
  DartColorType on_surface_variant = 24;
  DartColorType outline = 25;
  DartColorType outline_variant = 26;
  DartColorType shadow = 27;
  DartColorType scrim = 28;
  DartColorType inverse_surface = 29;
  DartColorType on_inverse_surface = 30;
  DartColorType inverse_primary = 31;
  DartColorType surface_tint = 32;
}

// package:flutter/src/material/color_scheme.dart
//
// Create the dark color scheme that matches the
// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
//
// This constructor shouldn't be used to update the Material 3 color scheme.
//
// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
// from a single seed color based on the Material 3 color system.
// Override the `brightness` property of [ColorScheme.fromSeed] to create a
// dark color scheme.
//
// {@tool snippet}
// This example demonstrates how to create a color scheme similar to [ColorScheme.dark]
// using the [ColorScheme.fromSeed] constructor:
//
// ```dart
// colorScheme: ColorScheme.fromSeed(
//   seedColor: const Color(0xffbb86fc),
//   brightness: Brightness.dark,
// ).copyWith(
//   primaryContainer: const Color(0xffbb86fc),
//   onPrimaryContainer: Colors.black,
//   secondaryContainer: const Color(0xff03dac6),
//   onSecondaryContainer: Colors.black,
//   error: const Color(0xffcf6679),
//   onError: Colors.black,
// ),
// ```
// {@end-tool}
message MaterialColorSchemeNamedDark {
  // The overall brightness of this color scheme.
  DartBrightnessType.Enum brightness = 2;
  // The color displayed most frequently across your apps screens and components.
  DartColorType primary = 3;
  // A color that's clearly legible when drawn on [primary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_primary = 4;
  DartColorType primary_container = 5;
  DartColorType on_primary_container = 6;
  // An accent color used for less prominent components in the UI, such as
  // filter chips, while expanding the opportunity for color expression.
  DartColorType secondary = 7;
  // A color that's clearly legible when drawn on [secondary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_secondary = 8;
  DartColorType secondary_container = 9;
  DartColorType on_secondary_container = 10;
  DartColorType tertiary = 11;
  DartColorType on_tertiary = 12;
  DartColorType tertiary_container = 13;
  DartColorType on_tertiary_container = 14;
  // The color to use for input validation errors, e.g. for
  // [InputDecoration.errorText].
  DartColorType error = 15;
  // A color that's clearly legible when drawn on [error].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [error] and [onError] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_error = 16;
  DartColorType error_container = 17;
  DartColorType on_error_container = 18;
  // A color that typically appears behind scrollable content.
  DartColorType background = 19;
  // A color that's clearly legible when drawn on [background].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [background] and [onBackground] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_background = 20;
  // The background color for widgets like [Card].
  DartColorType surface = 21;
  // A color that's clearly legible when drawn on [surface].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [surface] and [onSurface] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_surface = 22;
  DartColorType surface_variant = 23;
  DartColorType on_surface_variant = 24;
  DartColorType outline = 25;
  DartColorType outline_variant = 26;
  DartColorType shadow = 27;
  DartColorType scrim = 28;
  DartColorType inverse_surface = 29;
  DartColorType on_inverse_surface = 30;
  DartColorType inverse_primary = 31;
  DartColorType surface_tint = 32;
}

// package:flutter/src/material/color_scheme.dart
//
// Generate a [ColorScheme] derived from the given `seedColor`.
//
// Using the seedColor as a starting point, a set of tonal palettes are
// constructed. These tonal palettes are based on the Material 3 Color
// system and provide all the needed colors for a [ColorScheme]. These
// colors are designed to work well together and meet contrast
// requirements for accessibility.
//
// If any of the optional color parameters are non-null they will be
// used in place of the generated colors for that field in the resulting
// color scheme. This allows apps to override specific colors for their
// needs.
//
// Given the nature of the algorithm, the seedColor may not wind up as
// one of the ColorScheme colors.
//
// See also:
//
//  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
//    Material 3 Color system specification.
//  * <https://pub.dev/packages/material_color_utilities>, the package
//    used to generate the tonal palettes needed for the scheme.
message MaterialColorSchemeNamedFromSeed {
  DartColorType seed_color = 2;
  DartBrightnessType.Enum brightness = 3;
  DartColorType primary = 4;
  DartColorType on_primary = 5;
  DartColorType primary_container = 6;
  DartColorType on_primary_container = 7;
  DartColorType secondary = 8;
  DartColorType on_secondary = 9;
  DartColorType secondary_container = 10;
  DartColorType on_secondary_container = 11;
  DartColorType tertiary = 12;
  DartColorType on_tertiary = 13;
  DartColorType tertiary_container = 14;
  DartColorType on_tertiary_container = 15;
  DartColorType error = 16;
  DartColorType on_error = 17;
  DartColorType error_container = 18;
  DartColorType on_error_container = 19;
  DartColorType outline = 20;
  DartColorType outline_variant = 21;
  DartColorType background = 22;
  DartColorType on_background = 23;
  DartColorType surface = 24;
  DartColorType on_surface = 25;
  DartColorType surface_variant = 26;
  DartColorType on_surface_variant = 27;
  DartColorType inverse_surface = 28;
  DartColorType on_inverse_surface = 29;
  DartColorType inverse_primary = 30;
  DartColorType shadow = 31;
  DartColorType scrim = 32;
  DartColorType surface_tint = 33;
}

// package:flutter/src/material/color_scheme.dart
//
// Creates a color scheme from a [MaterialColor] swatch.
//
// In Material 3, this constructor is ignored by [ThemeData] when creating
// its default color scheme. Instead, [ThemeData] uses [ColorScheme.fromSeed]
// to create its default color scheme. This constructor shouldn't be used
// to update the Material 3 color scheme. It will be phased out gradually;
// see https://github.com/flutter/flutter/issues/120064 for more details.
//
// If [ThemeData.useMaterial3] is false, then this constructor is used by
// [ThemeData] to create its default color scheme.
message MaterialColorSchemeNamedFromSwatch {
  DartColorType accent_color = 3;
  DartColorType card_color = 4;
  DartColorType background_color = 5;
  DartColorType error_color = 6;
  DartBrightnessType.Enum brightness = 7;
}

// package:flutter/src/material/color_scheme.dart
//
// Create a high contrast ColorScheme based on the dark
// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
//
// This constructor shouldn't be used to update the Material 3 color scheme.
//
// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
// from a single seed color based on the Material 3 color system.
// Override the `brightness` property of [ColorScheme.fromSeed] to create a
// dark color scheme.
//
// {@tool snippet}
// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastDark]
// using the [ColorScheme.fromSeed] constructor:
//
// ```dart
// colorScheme: ColorScheme.fromSeed(
//   seedColor: const Color(0xffefb7ff),
//   brightness: Brightness.dark,
// ).copyWith(
//   primaryContainer: const Color(0xffefb7ff),
//   onPrimaryContainer: Colors.black,
//   secondaryContainer: const Color(0xff66fff9),
//   onSecondaryContainer: Colors.black,
//   error: const Color(0xff9b374d),
//   onError: Colors.white,
// ),
// ```
// {@end-tool}
message MaterialColorSchemeNamedHighContrastDark {
  // The overall brightness of this color scheme.
  DartBrightnessType.Enum brightness = 2;
  // The color displayed most frequently across your apps screens and components.
  DartColorType primary = 3;
  // A color that's clearly legible when drawn on [primary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_primary = 4;
  DartColorType primary_container = 5;
  DartColorType on_primary_container = 6;
  // An accent color used for less prominent components in the UI, such as
  // filter chips, while expanding the opportunity for color expression.
  DartColorType secondary = 7;
  // A color that's clearly legible when drawn on [secondary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_secondary = 8;
  DartColorType secondary_container = 9;
  DartColorType on_secondary_container = 10;
  DartColorType tertiary = 11;
  DartColorType on_tertiary = 12;
  DartColorType tertiary_container = 13;
  DartColorType on_tertiary_container = 14;
  // The color to use for input validation errors, e.g. for
  // [InputDecoration.errorText].
  DartColorType error = 15;
  // A color that's clearly legible when drawn on [error].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [error] and [onError] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_error = 16;
  DartColorType error_container = 17;
  DartColorType on_error_container = 18;
  // A color that typically appears behind scrollable content.
  DartColorType background = 19;
  // A color that's clearly legible when drawn on [background].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [background] and [onBackground] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_background = 20;
  // The background color for widgets like [Card].
  DartColorType surface = 21;
  // A color that's clearly legible when drawn on [surface].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [surface] and [onSurface] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_surface = 22;
  DartColorType surface_variant = 23;
  DartColorType on_surface_variant = 24;
  DartColorType outline = 25;
  DartColorType outline_variant = 26;
  DartColorType shadow = 27;
  DartColorType scrim = 28;
  DartColorType inverse_surface = 29;
  DartColorType on_inverse_surface = 30;
  DartColorType inverse_primary = 31;
  DartColorType surface_tint = 32;
}

// package:flutter/src/material/color_scheme.dart
//
// Create a high contrast ColorScheme based on a purple primary color that
// matches the [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
//
// This constructor shouldn't be used to update the Material 3 color scheme.
//
// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
// from a single seed color based on the Material 3 color system.
//
// {@tool snippet}
// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastLight]
// using the [ColorScheme.fromSeed] constructor:
//
// ```dart
// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff0000ba)).copyWith(
//   primaryContainer: const Color(0xff0000ba),
//   onPrimaryContainer: Colors.white,
//   secondaryContainer: const Color(0xff66fff9),
//   onSecondaryContainer: Colors.black,
//   error: const Color(0xff790000),
//   onError: Colors.white,
// ),
// ```
// {@end-tool}
message MaterialColorSchemeNamedHighContrastLight {
  // The overall brightness of this color scheme.
  DartBrightnessType.Enum brightness = 2;
  // The color displayed most frequently across your apps screens and components.
  DartColorType primary = 3;
  // A color that's clearly legible when drawn on [primary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_primary = 4;
  DartColorType primary_container = 5;
  DartColorType on_primary_container = 6;
  // An accent color used for less prominent components in the UI, such as
  // filter chips, while expanding the opportunity for color expression.
  DartColorType secondary = 7;
  // A color that's clearly legible when drawn on [secondary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_secondary = 8;
  DartColorType secondary_container = 9;
  DartColorType on_secondary_container = 10;
  DartColorType tertiary = 11;
  DartColorType on_tertiary = 12;
  DartColorType tertiary_container = 13;
  DartColorType on_tertiary_container = 14;
  // The color to use for input validation errors, e.g. for
  // [InputDecoration.errorText].
  DartColorType error = 15;
  // A color that's clearly legible when drawn on [error].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [error] and [onError] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_error = 16;
  DartColorType error_container = 17;
  DartColorType on_error_container = 18;
  // A color that typically appears behind scrollable content.
  DartColorType background = 19;
  // A color that's clearly legible when drawn on [background].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [background] and [onBackground] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_background = 20;
  // The background color for widgets like [Card].
  DartColorType surface = 21;
  // A color that's clearly legible when drawn on [surface].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [surface] and [onSurface] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_surface = 22;
  DartColorType surface_variant = 23;
  DartColorType on_surface_variant = 24;
  DartColorType outline = 25;
  DartColorType outline_variant = 26;
  DartColorType shadow = 27;
  DartColorType scrim = 28;
  DartColorType inverse_surface = 29;
  DartColorType on_inverse_surface = 30;
  DartColorType inverse_primary = 31;
  DartColorType surface_tint = 32;
}

// package:flutter/src/material/color_scheme.dart
//
// Create a light ColorScheme based on a purple primary color that matches the
// [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
//
// This constructor shouldn't be used to update the Material 3 color scheme.
//
// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
// from a single seed color based on the Material 3 color system.
//
// {@tool snippet}
// This example demonstrates how to create a color scheme similar to [ColorScheme.light]
// using the [ColorScheme.fromSeed] constructor:
//
// ```dart
// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff6200ee)).copyWith(
//   primaryContainer: const Color(0xff6200ee),
//   onPrimaryContainer: Colors.white,
//   secondaryContainer: const Color(0xff03dac6),
//   onSecondaryContainer: Colors.black,
//   error: const Color(0xffb00020),
//   onError: Colors.white,
// ),
// ```
// {@end-tool}
message MaterialColorSchemeNamedLight {
  // The overall brightness of this color scheme.
  DartBrightnessType.Enum brightness = 2;
  // The color displayed most frequently across your apps screens and components.
  DartColorType primary = 3;
  // A color that's clearly legible when drawn on [primary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_primary = 4;
  DartColorType primary_container = 5;
  DartColorType on_primary_container = 6;
  // An accent color used for less prominent components in the UI, such as
  // filter chips, while expanding the opportunity for color expression.
  DartColorType secondary = 7;
  // A color that's clearly legible when drawn on [secondary].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_secondary = 8;
  DartColorType secondary_container = 9;
  DartColorType on_secondary_container = 10;
  DartColorType tertiary = 11;
  DartColorType on_tertiary = 12;
  DartColorType tertiary_container = 13;
  DartColorType on_tertiary_container = 14;
  // The color to use for input validation errors, e.g. for
  // [InputDecoration.errorText].
  DartColorType error = 15;
  // A color that's clearly legible when drawn on [error].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [error] and [onError] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_error = 16;
  DartColorType error_container = 17;
  DartColorType on_error_container = 18;
  // A color that typically appears behind scrollable content.
  DartColorType background = 19;
  // A color that's clearly legible when drawn on [background].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [background] and [onBackground] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_background = 20;
  // The background color for widgets like [Card].
  DartColorType surface = 21;
  // A color that's clearly legible when drawn on [surface].
  //
  // To ensure that an app is accessible, a contrast ratio between
  // [surface] and [onSurface] of at least 4.5:1 is recommended. See
  // <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  DartColorType on_surface = 22;
  DartColorType surface_variant = 23;
  DartColorType on_surface_variant = 24;
  DartColorType outline = 25;
  DartColorType outline_variant = 26;
  DartColorType shadow = 27;
  DartColorType scrim = 28;
  DartColorType inverse_surface = 29;
  DartColorType on_inverse_surface = 30;
  DartColorType inverse_primary = 31;
  DartColorType surface_tint = 32;
}

// package:flutter/src/material/data_table.dart
//
// Creates an object to hold the data for a cell in a [DataTable].
//
// The first argument is the widget to show for the cell, typically
// a [Text] or [DropdownButton] widget.
//
// If the cell has no data, then a [Text] widget with placeholder
// text should be provided instead, and then the [placeholder]
// argument should be set to true.
message MaterialDataCell {
  // The data for the row.
  //
  // Typically a [Text] widget or a [DropdownButton] widget.
  //
  // If the cell has no data, then a [Text] widget with placeholder
  // text should be provided instead, and [placeholder] should be set
  // to true.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 2;
  // Whether the [child] is actually a placeholder.
  //
  // If this is true, the default text style for the cell is changed
  // to be appropriate for placeholder text.
  bool placeholder = 3;
  // Whether to show an edit icon at the end of the cell.
  //
  // This does not make the cell actually editable; the caller must
  // implement editing behavior if desired (initiated from the
  // [onTap] callback).
  //
  // If this is set, [onTap] should also be set, otherwise tapping
  // the icon will have no effect.
  bool show_edit_icon = 4;
}

// package:flutter/src/material/data_table.dart
//
// Creates the configuration for a column of a [DataTable].
message MaterialDataColumn {
  // The column heading.
  //
  // Typically, this will be a [Text] widget. It could also be an
  // [Icon] (typically using size 18), or a [Row] with an icon and
  // some text.
  //
  // The [label] is placed within a [Row] along with the
  // sort indicator (if applicable). By default, [label] only occupy minimal
  // space. It is recommended to place the label content in an [Expanded] or
  // [Flexible] as [label] to control how the content flexes. Otherwise,
  // an exception will occur when the available space is insufficient.
  //
  // By default, [DefaultTextStyle.softWrap] of this subtree will be set to false.
  // Use [DefaultTextStyle.merge] to override it if needed.
  //
  // The label should not include the sort indicator.
  WidgetType label = 2;
  // The column heading's tooltip.
  //
  // This is a longer description of the column heading, for cases
  // where the heading might have been abbreviated to keep the column
  // width to a reasonable size.
  string tooltip = 3;
  // Whether this column represents numeric data or not.
  //
  // The contents of cells of columns containing numeric data are
  // right-aligned.
  bool numeric = 4;
}

// package:flutter/src/material/data_table.dart
//
// Creates the configuration for a row of a [DataTable].
message MaterialDataRow {
  // A [Key] that uniquely identifies this row. This is used to
  // ensure that if a row is added or removed, any stateful widgets
  // related to this row (e.g. an in-progress checkbox animation)
  // remain on the right row visually.
  //
  // If the table never changes once created, no key is necessary.
  FlutterLocalKeyType key = 2;
  // Whether the row is selected.
  //
  // If [onSelectChanged] is non-null for any row in the table, then
  // a checkbox is shown at the start of each row. If the row is
  // selected (true), the checkbox will be checked and the row will
  // be highlighted.
  //
  // Otherwise, the checkbox, if present, will not be checked.
  bool selected = 3;
  // The data for this row.
  //
  // There must be exactly as many cells as there are columns in the
  // table.
  repeated MaterialDataCellType cells = 8;
}

// package:flutter/src/material/data_table.dart
//
// Creates the configuration for a row of a [DataTable], deriving
// the key from a row index.
message MaterialDataRowNamedByIndex {
  int32 index = 2;
  // Whether the row is selected.
  //
  // If [onSelectChanged] is non-null for any row in the table, then
  // a checkbox is shown at the start of each row. If the row is
  // selected (true), the checkbox will be checked and the row will
  // be highlighted.
  //
  // Otherwise, the checkbox, if present, will not be checked.
  bool selected = 3;
  // The data for this row.
  //
  // There must be exactly as many cells as there are columns in the
  // table.
  repeated MaterialDataCellType cells = 8;
}

// package:flutter/src/material/data_table.dart
//
// Creates a widget describing a data table.
//
// The [columns] argument must be a list of as many [DataColumn]
// objects as the table is to have columns, ignoring the leading
// checkbox column if any. The [columns] argument must have a
// length greater than zero.
//
// The [rows] argument must be a list of as many [DataRow] objects
// as the table is to have rows, ignoring the leading heading row
// that contains the column headings (derived from the [columns]
// argument). There may be zero rows, but the rows argument must
// not be null.
//
// Each [DataRow] object in [rows] must have as many [DataCell]
// objects in the [DataRow.cells] list as the table has columns.
//
// If the table is sorted, the column that provides the current
// primary key should be specified by index in [sortColumnIndex], 0
// meaning the first column in [columns], 1 being the next one, and
// so forth.
//
// The actual sort order can be specified using [sortAscending]; if
// the sort order is ascending, this should be true (the default),
// otherwise it should be false.
message MaterialDataTable {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The configuration and labels for the columns in the table.
  repeated MaterialDataColumnType columns = 3;
  // The current primary sort key's column.
  //
  // If non-null, indicates that the indicated column is the column
  // by which the data is sorted. The number must correspond to the
  // index of the relevant column in [columns].
  //
  // Setting this will cause the relevant column to have a sort
  // indicator displayed.
  //
  // When this is null, it implies that the table's sort order does
  // not correspond to any of the columns.
  //
  // The direction of the sort is specified using [sortAscending].
  int32 sort_column_index = 4;
  // Whether the column mentioned in [sortColumnIndex], if any, is sorted
  // in ascending order.
  //
  // If true, the order is ascending (meaning the rows with the
  // smallest values for the current sort column are first in the
  // table).
  //
  // If false, the order is descending (meaning the rows with the
  // smallest values for the current sort column are last in the
  // table).
  //
  // Ascending order is represented by an upwards-facing arrow.
  bool sort_ascending = 5;
  // {@template flutter.material.dataTable.decoration}
  // The background and border decoration for the table.
  // {@endtemplate}
  //
  // If null, [DataTableThemeData.decoration] is used. By default there is no
  // decoration.
  FlutterDecorationType decoration = 7;
  double data_row_min_height = 9;
  double data_row_max_height = 10;
  // {@template flutter.material.dataTable.dataTextStyle}
  // The text style for data rows.
  // {@endtemplate}
  //
  // If null, [DataTableThemeData.dataTextStyle] is used. By default, the text
  // style is [TextTheme.bodyMedium].
  FlutterTextStyleType data_text_style = 11;
  // {@template flutter.material.dataTable.headingRowHeight}
  // The height of the heading row.
  // {@endtemplate}
  //
  // If null, [DataTableThemeData.headingRowHeight] is used. This value
  // defaults to 56.0 to adhere to the Material Design specifications.
  double heading_row_height = 13;
  // {@template flutter.material.dataTable.headingTextStyle}
  // The text style for the heading row.
  // {@endtemplate}
  //
  // If null, [DataTableThemeData.headingTextStyle] is used. By default, the
  // text style is [TextTheme.titleSmall].
  FlutterTextStyleType heading_text_style = 14;
  // {@template flutter.material.dataTable.horizontalMargin}
  // The horizontal margin between the edges of the table and the content
  // in the first and last cells of each row.
  //
  // When a checkbox is displayed, it is also the margin between the checkbox
  // the content in the first data column.
  // {@endtemplate}
  //
  // If null, [DataTableThemeData.horizontalMargin] is used. This value
  // defaults to 24.0 to adhere to the Material Design specifications.
  //
  // If [checkboxHorizontalMargin] is null, then [horizontalMargin] is also the
  // margin between the edge of the table and the checkbox, as well as the
  // margin between the checkbox and the content in the first data column.
  double horizontal_margin = 15;
  // {@template flutter.material.dataTable.columnSpacing}
  // The horizontal margin between the contents of each data column.
  // {@endtemplate}
  //
  // If null, [DataTableThemeData.columnSpacing] is used. This value defaults
  // to 56.0 to adhere to the Material Design specifications.
  double column_spacing = 16;
  // {@template flutter.material.dataTable.showCheckboxColumn}
  // Whether the widget should display checkboxes for selectable rows.
  //
  // If true, a [Checkbox] will be placed at the beginning of each row that is
  // selectable. However, if [DataRow.onSelectChanged] is not set for any row,
  // checkboxes will not be placed, even if this value is true.
  //
  // If false, all rows will not display a [Checkbox].
  // {@endtemplate}
  bool show_checkbox_column = 17;
  // Whether a border at the bottom of the table is displayed.
  //
  // By default, a border is not shown at the bottom to allow for a border
  // around the table defined by [decoration].
  bool show_bottom_border = 18;
  // {@template flutter.material.dataTable.dividerThickness}
  // The width of the divider that appears between [TableRow]s.
  //
  // Must be greater than or equal to zero.
  // {@endtemplate}
  //
  // If null, [DataTableThemeData.dividerThickness] is used. This value
  // defaults to 1.0.
  double divider_thickness = 19;
  // The data to show in each row (excluding the row that contains
  // the column headings).
  //
  // The list may be empty.
  repeated MaterialDataRowType rows = 20;
  // {@template flutter.material.dataTable.checkboxHorizontalMargin}
  // Horizontal margin around the checkbox, if it is displayed.
  // {@endtemplate}
  //
  // If null, [DataTableThemeData.checkboxHorizontalMargin] is used. If that is
  // also null, then [horizontalMargin] is used as the margin between the edge
  // of the table and the checkbox, as well as the margin between the checkbox
  // and the content in the first data column. This value defaults to 24.0.
  double checkbox_horizontal_margin = 21;
  // The style to use when painting the boundary and interior divisions of the table.
  FlutterTableBorderType border = 22;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // This can be used to clip the content within the border of the [DataTable].
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 23;
}

// package:flutter/src/material/data_table_theme.dart
//
// Constructs a data table theme that configures all descendant
// [DataTable] widgets.
message MaterialDataTableTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [DataTable] widgets.
  MaterialDataTableThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/data_table_theme.dart
//
// Creates a theme that can be used for [ThemeData.dataTableTheme].
message MaterialDataTableThemeData {
  // {@macro flutter.material.dataTable.decoration}
  FlutterDecorationType decoration = 2;
  double data_row_min_height = 4;
  double data_row_max_height = 5;
  // {@macro flutter.material.dataTable.dataTextStyle}
  FlutterTextStyleType data_text_style = 6;
  // {@macro flutter.material.dataTable.headingRowHeight}
  double heading_row_height = 8;
  // {@macro flutter.material.dataTable.headingTextStyle}
  FlutterTextStyleType heading_text_style = 9;
  // {@macro flutter.material.dataTable.horizontalMargin}
  double horizontal_margin = 10;
  // {@macro flutter.material.dataTable.columnSpacing}
  double column_spacing = 11;
  // {@macro flutter.material.dataTable.dividerThickness}
  double divider_thickness = 12;
  // {@macro flutter.material.dataTable.checkboxHorizontalMargin}
  double checkbox_horizontal_margin = 13;
}

// package:flutter/src/material/date_picker.dart
//
// A Material-style date picker dialog.
message MaterialDatePickerDialog {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  DartDateTimeType initial_date = 3;
  DartDateTimeType first_date = 4;
  DartDateTimeType last_date = 5;
  DartDateTimeType current_date = 6;
  // The initial mode of date entry method for the date picker dialog.
  //
  // See [DatePickerEntryMode] for more details on the different data entry
  // modes available.
  MaterialDatePickerEntryModeType.Enum initial_entry_mode = 7;
  // The text that is displayed on the cancel button.
  string cancel_text = 9;
  // The text that is displayed on the confirm button.
  string confirm_text = 10;
  // The text that is displayed at the top of the header.
  //
  // This is used to indicate to the user what they are selecting a date for.
  string help_text = 11;
  // The initial display of the calendar picker.
  MaterialDatePickerModeType.Enum initial_calendar_mode = 12;
  // The error text displayed if the entered date is not in the correct format.
  string error_format_text = 13;
  // The error text displayed if the date is not valid.
  //
  // A date is not valid if it is earlier than [firstDate], later than
  // [lastDate], or doesn't pass the [selectableDayPredicate].
  string error_invalid_text = 14;
  // The hint text displayed in the [TextField].
  //
  // If this is null, it will default to the date format string. For example,
  // 'mm/dd/yyyy' for en_US.
  string field_hint_text = 15;
  // The label text displayed in the [TextField].
  //
  // If this is null, it will default to the words representing the date format
  // string. For example, 'Month, Day, Year' for en_US.
  string field_label_text = 16;
  // {@template flutter.material.datePickerDialog}
  // The keyboard type of the [TextField].
  //
  // If this is null, it will default to [TextInputType.datetime]
  // {@endtemplate}
  FlutterTextInputTypeType keyboard_type = 17;
  // Restoration ID to save and restore the state of the [DatePickerDialog].
  //
  // If it is non-null, the date picker will persist and restore the
  // date selected on the dialog.
  //
  // The state of this widget is persisted in a [RestorationBucket] claimed
  // from the surrounding [RestorationScope] using the provided restoration ID.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  string restoration_id = 18;
  // {@macro flutter.material.date_picker.switchToInputEntryModeIcon}
  FlutterIconType switch_to_input_entry_mode_icon = 20;
  // {@macro flutter.material.date_picker.switchToCalendarEntryModeIcon}
  FlutterIconType switch_to_calendar_entry_mode_icon = 21;
}

// package:flutter/src/material/date_picker_theme.dart
//
// Creates a [DatePickerTheme] that controls visual parameters for
// descendent [DatePickerDialog]s.
message MaterialDatePickerTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the visual properties used by descendant [DatePickerDialog]
  // widgets.
  MaterialDatePickerThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/date_picker_theme.dart
//
// Creates a [DatePickerThemeData] that can be used to override default properties
// in a [DatePickerTheme] widget.
message MaterialDatePickerThemeData {
  // Overrides the default value of [Dialog.backgroundColor].
  DartColorType background_color = 2;
  // Overrides the default value of [Dialog.elevation].
  //
  // See also:
  //   [Material.elevation], which explains how elevation is related to a component's shadow.
  double elevation = 3;
  // Overrides the default value of [Dialog.shadowColor].
  //
  // See also:
  //   [Material.shadowColor], which explains how the shadow is rendered.
  DartColorType shadow_color = 4;
  // Overrides the default value of [Dialog.surfaceTintColor].
  //
  // See also:
  //   [Material.surfaceTintColor], which explains how this color is related to
  //   [elevation] and [backgroundColor].
  DartColorType surface_tint_color = 5;
  // Overrides the default value of [Dialog.shape].
  //
  // If [elevation] is greater than zero then a shadow is shown and the shadow's
  // shape mirrors the shape of the dialog.
  FlutterShapeBorderType shape = 6;
  // Overrides the header's default background fill color.
  //
  // The dialog's header displays the currently selected date.
  DartColorType header_background_color = 7;
  // Overrides the header's default color used for text labels and icons.
  //
  // The dialog's header displays the currently selected date.
  //
  // This is used instead of the [TextStyle.color] property of [headerHeadlineStyle]
  // and [headerHelpStyle].
  DartColorType header_foreground_color = 8;
  // Overrides the header's default headline text style.
  //
  // The dialog's header displays the currently selected date.
  //
  // The [TextStyle.color] of the [headerHeadlineStyle] is not used,
  // [headerForegroundColor] is used instead.
  FlutterTextStyleType header_headline_style = 9;
  // Overrides the header's default help text style.
  //
  // The help text (also referred to as "supporting text" in the Material
  // spec) is usually a prompt to the user at the top of the header
  // (i.e. 'Select date').
  //
  // The [TextStyle.color] of the [headerHelpStyle] is not used,
  // [headerForegroundColor] is used instead.
  //
  // See also:
  //   [DatePickerDialog.helpText], which specifies the help text.
  FlutterTextStyleType header_help_style = 10;
  // Overrides the default text style used for the row of weekday
  // labels at the top of the date picker grid.
  FlutterTextStyleType weekday_style = 11;
  // Overrides the default text style used for each individual day
  // label in the grid of the date picker.
  //
  // The [TextStyle.color] of the [dayStyle] is not used,
  // [dayForegroundColor] is used instead.
  FlutterTextStyleType day_style = 12;
  // Overrides the border used to paint the
  // [DatePickerDialog.currentDate] label in the grid of the date
  // picker.
  //
  // The border side's [BorderSide.color] is not used,
  // [todayForegroundColor] is used instead.
  FlutterBorderSideType today_border = 18;
  // Overrides the default text style used to paint each of the year
  // entries in the year selector of the date picker.
  //
  // The [TextStyle.color] of the [yearStyle] is not used,
  // [yearForegroundColor] is used instead.
  FlutterTextStyleType year_style = 19;
  // Overrides the default [Scaffold.backgroundColor] for
  // [DateRangePickerDialog].
  DartColorType range_picker_background_color = 23;
  // Overrides the default elevation of the full screen
  // [DateRangePickerDialog].
  //
  // See also:
  //   [Material.elevation], which explains how elevation is related to a component's shadow.
  double range_picker_elevation = 24;
  // Overrides the color of the shadow painted below a full screen
  // [DateRangePickerDialog].
  //
  // See also:
  //   [Material.shadowColor], which explains how the shadow is rendered.
  DartColorType range_picker_shadow_color = 25;
  // Overrides the default color of the surface tint overlay applied
  // to the [backgroundColor] of a full screen
  // [DateRangePickerDialog]'s to indicate elevation.
  //
  // See also:
  //   [Material.surfaceTintColor], which explains how this color is related to
  //   [elevation].
  DartColorType range_picker_surface_tint_color = 26;
  // Overrides the default overall shape of a full screen
  // [DateRangePickerDialog].
  //
  // If [elevation] is greater than zero then a shadow is shown and the shadow's
  // shape mirrors the shape of the dialog.
  //
  //   [Material.surfaceTintColor], which explains how this color is related to
  //   [elevation].
  FlutterShapeBorderType range_picker_shape = 27;
  // Overrides the default background fill color for [DateRangePickerDialog].
  //
  // The dialog's header displays the currently selected date range.
  DartColorType range_picker_header_background_color = 28;
  // Overrides the default color used for text labels and icons in
  // the header of a full screen [DateRangePickerDialog]
  //
  // The dialog's header displays the currently selected date range.
  //
  // This is used instead of any colors provided by
  // [rangePickerHeaderHeadlineStyle] or [rangePickerHeaderHelpStyle].
  DartColorType range_picker_header_foreground_color = 29;
  // Overrides the default text style used for the headline text in
  // the header of a full screen [DateRangePickerDialog].
  //
  // The dialog's header displays the currently selected date range.
  //
  // The [TextStyle.color] of [rangePickerHeaderHeadlineStyle] is not used,
  // [rangePickerHeaderForegroundColor] is used instead.
  FlutterTextStyleType range_picker_header_headline_style = 30;
  // Overrides the default text style used for the help text of the
  // header of a full screen [DateRangePickerDialog].
  //
  // The help text (also referred to as "supporting text" in the Material
  // spec) is usually a prompt to the user at the top of the header
  // (i.e. 'Select date').
  //
  // The [TextStyle.color] of the [rangePickerHeaderHelpStyle] is not used,
  // [rangePickerHeaderForegroundColor] is used instead.
  //
  // See also:
  //   [DateRangePickerDialog.helpText], which specifies the help text.
  FlutterTextStyleType range_picker_header_help_style = 31;
  // Overrides the default background color used to paint days
  // selected between the start and end dates in a
  // [DateRangePickerDialog].
  DartColorType range_selection_background_color = 32;
  // Overrides the default color used to paint the horizontal divider
  // below the header text when dialog is in in portrait orientation
  // and vertical divider when the dialog is in landscape orientation.
  DartColorType divider_color = 34;
  // Overrides the [InputDatePickerFormField]'s input decoration theme.
  // If this is null, [ThemeData.inputDecorationTheme] is used instead.
  MaterialInputDecorationThemeType input_decoration_theme = 35;
  // Overrides the default style of the cancel button of a [DatePickerDialog].
  MaterialButtonStyleType cancel_button_style = 36;
  // Overrides the default style of the confirm (OK) button of a [DatePickerDialog].
  MaterialButtonStyleType confirm_button_style = 37;
}

// package:flutter/src/material/date_picker.dart
//
// A Material-style date range picker dialog.
message MaterialDateRangePickerDialog {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The date range that the date range picker starts with when it opens.
  //
  // If an initial date range is provided, `initialDateRange.start`
  // and `initialDateRange.end` must both fall between or on [firstDate] and
  // [lastDate]. For all of these [DateTime] values, only their dates are
  // considered. Their time fields are ignored.
  //
  // If [initialDateRange] is non-null, then it will be used as the initially
  // selected date range. If it is provided, `initialDateRange.start` must be
  // before or on `initialDateRange.end`.
  MaterialDateTimeRangeType initial_date_range = 3;
  // The earliest allowable date on the date range.
  DartDateTimeType first_date = 4;
  // The latest allowable date on the date range.
  DartDateTimeType last_date = 5;
  // The [currentDate] represents the current day (i.e. today).
  //
  // This date will be highlighted in the day grid.
  //
  // If `null`, the date of `DateTime.now()` will be used.
  DartDateTimeType current_date = 6;
  // The initial date range picker entry mode.
  //
  // The date range has two main modes: [DatePickerEntryMode.calendar] (a
  // scrollable calendar month grid) or [DatePickerEntryMode.input] (two text
  // input fields) mode.
  //
  // It defaults to [DatePickerEntryMode.calendar].
  MaterialDatePickerEntryModeType.Enum initial_entry_mode = 7;
  // The label displayed at the top of the dialog.
  //
  // If null, the localized value of
  // [MaterialLocalizations.dateRangePickerHelpText] is used.
  string help_text = 8;
  // The label on the cancel button for the text input mode.
  //
  // If null, the localized value of
  // [MaterialLocalizations.cancelButtonLabel] is used.
  string cancel_text = 9;
  // The label on the "OK" button for the text input mode.
  //
  // If null, the localized value of
  // [MaterialLocalizations.okButtonLabel] is used.
  string confirm_text = 10;
  // The label on the save button for the fullscreen calendar mode.
  //
  // If null, the localized value of
  // [MaterialLocalizations.saveButtonLabel] is used.
  string save_text = 11;
  // The message used when the date range is invalid (e.g. start date is after
  // end date).
  //
  // If null, the localized value of
  // [MaterialLocalizations.invalidDateRangeLabel] is used.
  string error_invalid_range_text = 12;
  // The message used when an input text isn't in a proper date format.
  //
  // If null, the localized value of
  // [MaterialLocalizations.invalidDateFormatLabel] is used.
  string error_format_text = 13;
  // The message used when an input text isn't a selectable date.
  //
  // If null, the localized value of
  // [MaterialLocalizations.dateOutOfRangeLabel] is used.
  string error_invalid_text = 14;
  // The text used to prompt the user when no text has been entered in the
  // start field.
  //
  // If null, the localized value of
  // [MaterialLocalizations.dateHelpText] is used.
  string field_start_hint_text = 15;
  // The text used to prompt the user when no text has been entered in the
  // end field.
  //
  // If null, the localized value of [MaterialLocalizations.dateHelpText] is
  // used.
  string field_end_hint_text = 16;
  // The label for the start date text input field.
  //
  // If null, the localized value of [MaterialLocalizations.dateRangeStartLabel]
  // is used.
  string field_start_label_text = 17;
  // The label for the end date text input field.
  //
  // If null, the localized value of [MaterialLocalizations.dateRangeEndLabel]
  // is used.
  string field_end_label_text = 18;
  // {@macro flutter.material.datePickerDialog}
  FlutterTextInputTypeType keyboard_type = 19;
  // Restoration ID to save and restore the state of the [DateRangePickerDialog].
  //
  // If it is non-null, the date range picker will persist and restore the
  // date range selected on the dialog.
  //
  // The state of this widget is persisted in a [RestorationBucket] claimed
  // from the surrounding [RestorationScope] using the provided restoration ID.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  string restoration_id = 20;
  // {@macro flutter.material.date_picker.switchToInputEntryModeIcon}
  FlutterIconType switch_to_input_entry_mode_icon = 21;
  // {@macro flutter.material.date_picker.switchToCalendarEntryModeIcon}
  FlutterIconType switch_to_calendar_entry_mode_icon = 22;
}

// package:flutter/src/material/date.dart
//
// Creates a date range for the given start and end [DateTime].
message MaterialDateTimeRange {
  // The start of the range of dates.
  DartDateTimeType start = 2;
  // The end of the range of dates.
  DartDateTimeType end = 3;
}

// package:flutter/src/material/tab_controller.dart
//
// Creates a default tab controller for the given [child] widget.
//
// The [length] argument is typically greater than one. The [length] must
// match [TabBar.tabs]'s and [TabBarView.children]'s length.
message MaterialDefaultTabController {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The total number of tabs.
  //
  // Typically greater than one. Must match [TabBar.tabs]'s and
  // [TabBarView.children]'s length.
  int32 length = 3;
  // The initial index of the selected tab.
  //
  // Defaults to zero.
  int32 initial_index = 4;
  // The widget below this widget in the tree.
  //
  // Typically a [Scaffold] whose [AppBar] includes a [TabBar].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
  // Controls the duration of DefaultTabController and TabBarView animations.
  //
  // Defaults to kTabScrollDuration.
  DartDurationType animation_duration = 6;
}

// package:flutter/src/material/desktop_text_selection.dart
message MaterialDesktopTextSelectionControls {
  
}

// package:flutter/src/material/desktop_text_selection_toolbar.dart
//
// Creates a const instance of DesktopTextSelectionToolbar.
message MaterialDesktopTextSelectionToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.material.DesktopTextSelectionToolbar.anchor}
  // The point where the toolbar will attempt to position itself as closely as
  // possible.
  // {@endtemplate}
  DartOffsetType anchor = 3;
  // {@macro flutter.material.TextSelectionToolbar.children}
  //
  // See also:
  //   * [DesktopTextSelectionToolbarButton], which builds a default
  //     Material-style desktop text selection toolbar text button.
  repeated WidgetType children = 4;
}

// package:flutter/src/material/desktop_text_selection_toolbar_button.dart
//
// Creates an instance of DesktopTextSelectionToolbarButton.
message MaterialDesktopTextSelectionToolbarButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.material.TextSelectionToolbarTextButton.child}
  WidgetType child = 4;
}

// package:flutter/src/material/desktop_text_selection_toolbar_button.dart
//
// Create an instance of [DesktopTextSelectionToolbarButton] whose child is
// a [Text] widget in the style of the Material text selection toolbar.
message MaterialDesktopTextSelectionToolbarButtonNamedText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterBuildContextType context = 3;
  string text = 5;
}

// package:flutter/src/material/dialog.dart
//
// Creates a dialog.
//
// Typically used in conjunction with [showDialog].
message MaterialDialog {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.material.dialog.backgroundColor}
  // The background color of the surface of this [Dialog].
  //
  // This sets the [Material.color] on this [Dialog]'s [Material].
  //
  // If `null`, [ThemeData.dialogBackgroundColor] is used.
  // {@endtemplate}
  DartColorType background_color = 3;
  // {@template flutter.material.dialog.elevation}
  // The z-coordinate of this [Dialog].
  //
  // Controls how far above the parent the dialog will appear. Elevation is
  // represented by a drop shadow if [shadowColor] is non null,
  // and a surface tint overlay on the background color if [surfaceTintColor] is
  // non null.
  //
  // If null then [DialogTheme.elevation] is used, and if that is null then
  // the elevation will match the Material Design specification for Dialogs.
  //
  // See also:
  //   * [Material.elevation], which describes how [elevation] effects the
  //     drop shadow or surface tint overlay.
  //   * [shadowColor], color of the drop shadow used to indicate the elevation.
  //   * [surfaceTintColor], color of an overlay on top of the background
  //     color used to indicate the elevation.
  //   * <https://m3.material.io/components/dialogs/overview>, the Material
  //     Design specification for dialogs.
  // {@endtemplate}
  double elevation = 4;
  // {@template flutter.material.dialog.shadowColor}
  // The color used to paint a drop shadow under the dialog's [Material],
  // which reflects the dialog's [elevation].
  //
  // If null and [ThemeData.useMaterial3] is true then no drop shadow will
  // be rendered.
  //
  // If null and [ThemeData.useMaterial3] is false then it will default to
  // [ThemeData.shadowColor].
  //
  // See also:
  //   * [Material.shadowColor], which describes how the drop shadow is painted.
  //   * [elevation], which affects how the drop shadow is painted.
  //   * [surfaceTintColor], which can be used to indicate elevation through
  //     tinting the background color.
  // {@endtemplate}
  DartColorType shadow_color = 5;
  // {@template flutter.material.dialog.surfaceTintColor}
  // The color used as a surface tint overlay on the dialog's background color,
  // which reflects the dialog's [elevation].
  //
  // If [ThemeData.useMaterial3] is false property has no effect.
  //
  // If null and [ThemeData.useMaterial3] is true then [ThemeData]'s
  // [ColorScheme.surfaceTint] will be used.
  //
  // To disable this feature, set [surfaceTintColor] to [Colors.transparent].
  //
  // See also:
  //   * [Material.surfaceTintColor], which describes how the surface tint will
  //     be applied to the background color of the dialog.
  //   * [elevation], which affects the opacity of the surface tint.
  //   * [shadowColor], which can be used to indicate elevation through
  //     a drop shadow.
  // {@endtemplate}
  DartColorType surface_tint_color = 6;
  // {@template flutter.material.dialog.insetAnimationDuration}
  // The duration of the animation to show when the system keyboard intrudes
  // into the space that the dialog is placed in.
  //
  // Defaults to 100 milliseconds when [Dialog] is used, and [Duration.zero]
  // when [Dialog.fullscreen] is used.
  // {@endtemplate}
  DartDurationType inset_animation_duration = 7;
  // {@template flutter.material.dialog.insetAnimationCurve}
  // The curve to use for the animation shown when the system keyboard intrudes
  // into the space that the dialog is placed in.
  //
  // Defaults to [Curves.decelerate].
  // {@endtemplate}
  FlutterSrcAnimationCurveType inset_animation_curve = 8;
  // {@template flutter.material.dialog.insetPadding}
  // The amount of padding added to [MediaQueryData.viewInsets] on the outside
  // of the dialog. This defines the minimum space between the screen's edges
  // and the dialog.
  //
  // Defaults to `EdgeInsets.symmetric(horizontal: 40.0, vertical: 24.0)`.
  // {@endtemplate}
  FlutterEdgeInsetsType inset_padding = 9;
  // {@template flutter.material.dialog.clipBehavior}
  // Controls how the contents of the dialog are clipped (or not) to the given
  // [shape].
  //
  // See the enum [Clip] for details of all possible options and their common
  // use cases.
  //
  // Defaults to [Clip.none].
  // {@endtemplate}
  DartClipType.Enum clip_behavior = 10;
  // {@template flutter.material.dialog.shape}
  // The shape of this dialog's border.
  //
  // Defines the dialog's [Material.shape].
  //
  // The default shape is a [RoundedRectangleBorder] with a radius of 4.0
  // {@endtemplate}
  FlutterShapeBorderType shape = 11;
  // {@template flutter.material.dialog.alignment}
  // How to align the [Dialog].
  //
  // If null, then [DialogTheme.alignment] is used. If that is also null, the
  // default is [Alignment.center].
  // {@endtemplate}
  FlutterAlignmentGeometryType alignment = 12;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 13;
}

// package:flutter/src/material/dialog.dart
//
// Creates a fullscreen dialog.
//
// Typically used in conjunction with [showDialog].
message MaterialDialogNamedFullscreen {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.material.dialog.backgroundColor}
  // The background color of the surface of this [Dialog].
  //
  // This sets the [Material.color] on this [Dialog]'s [Material].
  //
  // If `null`, [ThemeData.dialogBackgroundColor] is used.
  // {@endtemplate}
  DartColorType background_color = 3;
  // {@template flutter.material.dialog.insetAnimationDuration}
  // The duration of the animation to show when the system keyboard intrudes
  // into the space that the dialog is placed in.
  //
  // Defaults to 100 milliseconds when [Dialog] is used, and [Duration.zero]
  // when [Dialog.fullscreen] is used.
  // {@endtemplate}
  DartDurationType inset_animation_duration = 4;
  // {@template flutter.material.dialog.insetAnimationCurve}
  // The curve to use for the animation shown when the system keyboard intrudes
  // into the space that the dialog is placed in.
  //
  // Defaults to [Curves.decelerate].
  // {@endtemplate}
  FlutterSrcAnimationCurveType inset_animation_curve = 5;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 6;
}

// package:flutter/src/material/dialog_theme.dart
//
// Creates a dialog theme that can be used for [ThemeData.dialogTheme].
message MaterialDialogTheme {
  // Overrides the default value for [Dialog.backgroundColor].
  DartColorType background_color = 2;
  // Overrides the default value for [Dialog.elevation].
  double elevation = 3;
  // Overrides the default value for [Dialog.shadowColor].
  DartColorType shadow_color = 4;
  // Overrides the default value for [Dialog.surfaceTintColor].
  DartColorType surface_tint_color = 5;
  // Overrides the default value for [Dialog.shape].
  FlutterShapeBorderType shape = 6;
  // Overrides the default value for [Dialog.alignment].
  FlutterAlignmentGeometryType alignment = 7;
  // Used to configure the [IconTheme] for the [AlertDialog.icon] widget.
  DartColorType icon_color = 8;
  // Overrides the default value for [DefaultTextStyle] for [SimpleDialog.title] and
  // [AlertDialog.title].
  FlutterTextStyleType title_text_style = 9;
  // Overrides the default value for [DefaultTextStyle] for [SimpleDialog.children] and
  // [AlertDialog.content].
  FlutterTextStyleType content_text_style = 10;
  // Overrides the default value for [AlertDialog.actionsPadding].
  FlutterEdgeInsetsGeometryType actions_padding = 11;
}

// package:flutter/src/material/divider.dart
//
// Creates a Material Design divider.
//
// The [height], [thickness], [indent], and [endIndent] must be null or
// non-negative.
message MaterialDivider {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The divider's height extent.
  //
  // The divider itself is always drawn as a horizontal line that is centered
  // within the height specified by this value.
  //
  // If this is null, then the [DividerThemeData.space] is used. If that is
  // also null, then this defaults to 16.0.
  double height = 3;
  // The thickness of the line drawn within the divider.
  //
  // A divider with a [thickness] of 0.0 is always drawn as a line with a
  // height of exactly one device pixel.
  //
  // If this is null, then the [DividerThemeData.thickness] is used. If
  // that is also null, then this defaults to 0.0.
  double thickness = 4;
  // The amount of empty space to the leading edge of the divider.
  //
  // If this is null, then the [DividerThemeData.indent] is used. If that is
  // also null, then this defaults to 0.0.
  double indent = 5;
  // The amount of empty space to the trailing edge of the divider.
  //
  // If this is null, then the [DividerThemeData.endIndent] is used. If that is
  // also null, then this defaults to 0.0.
  double end_indent = 6;
  // The color to use when painting the line.
  //
  // If this is null, then the [DividerThemeData.color] is used. If that is
  // also null, then [ThemeData.dividerColor] is used.
  //
  // {@tool snippet}
  //
  // ```dart
  // const Divider(
  //   color: Colors.deepOrange,
  // )
  // ```
  // {@end-tool}
  DartColorType color = 7;
}

// package:flutter/src/material/divider_theme.dart
//
// Creates a divider theme that controls the configurations for
// [Divider]s, [VerticalDivider]s, dividers between [ListTile]s, and dividers
// between rows in [DataTable]s in its widget subtree.
message MaterialDividerTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties for descendant [Divider]s, [VerticalDivider]s, dividers
  // between [ListTile]s, and dividers between rows in [DataTable]s.
  MaterialDividerThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/divider_theme.dart
//
// Creates a theme that can be used for [DividerTheme] or
// [ThemeData.dividerTheme].
message MaterialDividerThemeData {
  // The color of [Divider]s and [VerticalDivider]s, also
  // used between [ListTile]s, between rows in [DataTable]s, and so forth.
  DartColorType color = 2;
  // The [Divider]'s height or the [VerticalDivider]'s width.
  //
  // This represents the amount of horizontal or vertical space the divider
  // takes up.
  double space = 3;
  // The thickness of the line drawn within the divider.
  double thickness = 4;
  // The amount of empty space at the leading edge of [Divider] or top edge of
  // [VerticalDivider].
  double indent = 5;
  // The amount of empty space at the trailing edge of [Divider] or bottom edge
  // of [VerticalDivider].
  double end_indent = 6;
}

// package:flutter/src/material/drawer.dart
//
// Creates a Material Design drawer.
//
// Typically used in the [Scaffold.drawer] property.
//
// The [elevation] must be non-negative.
message MaterialDrawer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Sets the color of the [Material] that holds all of the [Drawer]'s
  // contents.
  //
  // If this is null, then [DrawerThemeData.backgroundColor] is used. If that
  // is also null, then it falls back to [Material]'s default.
  DartColorType background_color = 3;
  // The z-coordinate at which to place this drawer relative to its parent.
  //
  // This controls the size of the shadow below the drawer.
  //
  // If this is null, then [DrawerThemeData.elevation] is used. If that
  // is also null, then it defaults to 16.0.
  double elevation = 4;
  // The color used to paint a drop shadow under the drawer's [Material],
  // which reflects the drawer's [elevation].
  //
  // If null and [ThemeData.useMaterial3] is true then no drop shadow will
  // be rendered.
  //
  // If null and [ThemeData.useMaterial3] is false then it will default to
  // [ThemeData.shadowColor].
  //
  // See also:
  //   * [Material.shadowColor], which describes how the drop shadow is painted.
  //   * [elevation], which affects how the drop shadow is painted.
  //   * [surfaceTintColor], which can be used to indicate elevation through
  //     tinting the background color.
  DartColorType shadow_color = 5;
  // The color used as a surface tint overlay on the drawer's background color,
  // which reflects the drawer's [elevation].
  //
  // If [ThemeData.useMaterial3] is false property has no effect.
  //
  // If null and [ThemeData.useMaterial3] is true then [ThemeData]'s
  // [ColorScheme.surfaceTint] will be used.
  //
  // To disable this feature, set [surfaceTintColor] to [Colors.transparent].
  //
  // See also:
  //   * [Material.surfaceTintColor], which describes how the surface tint will
  //     be applied to the background color of the drawer.
  //   * [elevation], which affects the opacity of the surface tint.
  //   * [shadowColor], which can be used to indicate elevation through
  //     a drop shadow.
  DartColorType surface_tint_color = 6;
  // The shape of the drawer.
  //
  // Defines the drawer's [Material.shape].
  //
  // If this is null, then [DrawerThemeData.shape] is used. If that
  // is also null, then it falls back to [Material]'s default.
  FlutterShapeBorderType shape = 7;
  // The width of the drawer.
  //
  // If this is null, then [DrawerThemeData.width] is used. If that is also
  // null, then it falls back to the Material spec's default (304.0).
  double width = 8;
  // The widget below this widget in the tree.
  //
  // Typically a [SliverList].
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 9;
  // The semantic label of the drawer used by accessibility frameworks to
  // announce screen transitions when the drawer is opened and closed.
  //
  // If this label is not provided, it will default to
  // [MaterialLocalizations.drawerLabel].
  //
  // See also:
  //
  //  * [SemanticsConfiguration.namesRoute], for a description of how this
  //    value is used.
  string semantic_label = 10;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // The [clipBehavior] argument specifies how to clip the drawer's [shape].
  //
  // If the drawer has a [shape], it defaults to [Clip.hardEdge]. Otherwise,
  // defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 11;
}

// package:flutter/src/material/action_buttons.dart
//
// Creates a Material Design drawer icon button.
message MaterialDrawerButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Customizes this icon button's appearance.
  //
  // The [style] is only used for Material 3 [IconButton]s. If [ThemeData.useMaterial3]
  // is set to true, [style] is preferred for icon button customization, and any
  // parameters defined in [style] will override the same parameters in [IconButton].
  //
  // Null by default.
  MaterialButtonStyleType style = 3;
}

// package:flutter/src/material/action_buttons.dart
//
// Creates an icon that shows the appropriate "close" image for
// the current platform (as obtained from the [Theme]).
message MaterialDrawerButtonIcon {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
}

// package:flutter/src/material/drawer.dart
//
// Creates a controller for a [Drawer].
//
// Rarely used directly.
//
// The [child] argument is typically a [Drawer].
message MaterialDrawerController {
  // The widget below this widget in the tree.
  //
  // Typically a [Drawer].
  WidgetType child = 3;
  // The alignment of the [Drawer].
  //
  // This controls the direction in which the user should swipe to open and
  // close the drawer.
  MaterialDrawerAlignmentType.Enum alignment = 4;
  // Whether or not the drawer is opened or closed.
  //
  // This parameter is primarily used by the state restoration framework
  // to restore the drawer's animation controller to the open or closed state
  // depending on what was last saved to the target platform before the
  // application was killed.
  bool is_drawer_open = 5;
  // {@template flutter.material.DrawerController.dragStartBehavior}
  // Determines the way that drag start behavior is handled.
  //
  // If set to [DragStartBehavior.start], the drag behavior used for opening
  // and closing a drawer will begin at the position where the drag gesture won
  // the arena. If set to [DragStartBehavior.down] it will begin at the position
  // where a down event is first detected.
  //
  // In general, setting this to [DragStartBehavior.start] will make drag
  // animation smoother and setting it to [DragStartBehavior.down] will make
  // drag behavior feel slightly more reactive.
  //
  // By default, the drag start behavior is [DragStartBehavior.start].
  //
  // See also:
  //
  //  * [DragGestureRecognizer.dragStartBehavior], which gives an example for
  //    the different behaviors.
  //
  // {@endtemplate}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 7;
  // The color to use for the scrim that obscures the underlying content while
  // a drawer is open.
  //
  // If this is null, then [DrawerThemeData.scrimColor] is used. If that
  // is also null, then it defaults to [Colors.black54].
  DartColorType scrim_color = 8;
  // The width of the area within which a horizontal swipe will open the
  // drawer.
  //
  // By default, the value used is 20.0 added to the padding edge of
  // `MediaQuery.paddingOf(context)` that corresponds to [alignment].
  // This ensures that the drag area for notched devices is not obscured. For
  // example, if [alignment] is set to [DrawerAlignment.start] and
  // `TextDirection.of(context)` is set to [TextDirection.ltr],
  // 20.0 will be added to `MediaQuery.paddingOf(context).left`.
  double edge_drag_width = 9;
  // Determines if the [Drawer] can be opened with a drag gesture.
  //
  // By default, the drag gesture is enabled.
  bool enable_open_drag_gesture = 10;
}

// package:flutter/src/material/drawer.dart
message MaterialDrawerControllerState {
  
}

// package:flutter/src/material/drawer_header.dart
//
// Creates a Material Design drawer header.
//
// Requires one of its ancestors to be a [Material] widget.
message MaterialDrawerHeader {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Decoration for the main drawer header [Container]; useful for applying
  // backgrounds.
  //
  // This decoration will extend under the system status bar.
  //
  // If this is changed, it will be animated according to [duration] and [curve].
  FlutterDecorationType decoration = 3;
  // The margin around the drawer header.
  FlutterEdgeInsetsGeometryType margin = 4;
  // The padding by which to inset [child].
  //
  // The [DrawerHeader] additionally offsets the child by the height of the
  // system status bar.
  //
  // If the child is null, the padding has no effect.
  FlutterEdgeInsetsGeometryType padding = 5;
  // The duration for animations of the [decoration].
  DartDurationType duration = 6;
  // The curve for animations of the [decoration].
  FlutterSrcAnimationCurveType curve = 7;
  // A widget to be placed inside the drawer header, inset by the [padding].
  //
  // This widget will be sized to the size of the header. To position the child
  // precisely, consider using an [Align] or [Center] widget.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 8;
}

// package:flutter/src/material/drawer_theme.dart
//
// Creates a theme that defines the [DrawerThemeData] properties for a
// [Drawer].
message MaterialDrawerTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the background color, scrim color, elevation, and shape for
  // descendant [Drawer] widgets.
  MaterialDrawerThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/drawer_theme.dart
//
// Creates a theme that can be used for [ThemeData.drawerTheme] and
// [DrawerTheme].
message MaterialDrawerThemeData {
  // Overrides the default value of [Drawer.backgroundColor].
  DartColorType background_color = 2;
  // Overrides the default value of [DrawerController.scrimColor].
  DartColorType scrim_color = 3;
  // Overrides the default value of [Drawer.elevation].
  double elevation = 4;
  // Overrides the default value for [Drawer.shadowColor].
  DartColorType shadow_color = 5;
  // Overrides the default value for [Drawer.surfaceTintColor].
  DartColorType surface_tint_color = 6;
  // Overrides the default value of [Drawer.shape].
  FlutterShapeBorderType shape = 7;
  // Overrides the default value of [Drawer.shape] for a end drawer.
  FlutterShapeBorderType end_shape = 8;
  // Overrides the default value of [Drawer.width].
  double width = 9;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider value indicator that resembles a drop shape.
message MaterialDropSliderValueIndicatorShape {
  
}

// package:flutter/src/material/dropdown.dart
//
// Creates a dropdown button.
//
// The [items] must have distinct values. If [value] isn't null then it
// must be equal to one of the [DropdownMenuItem] values. If [items] or
// [onChanged] is null, the button will be disabled, the down arrow
// will be greyed out.
//
// If [value] is null and the button is enabled, [hint] will be displayed
// if it is non-null.
//
// If [value] is null and the button is disabled, [disabledHint] will be displayed
// if it is non-null. If [disabledHint] is null, then [hint] will be displayed
// if it is non-null.
//
// The [dropdownColor] argument specifies the background color of the
// dropdown when it is open. If it is null, the current theme's
// [ThemeData.canvasColor] will be used instead.
message MaterialDropdownButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // A placeholder widget that is displayed by the dropdown button.
  //
  // If [value] is null and the dropdown is enabled ([items] and [onChanged] are non-null),
  // this widget is displayed as a placeholder for the dropdown button's value.
  //
  // If [value] is null and the dropdown is disabled and [disabledHint] is null,
  // this widget is used as the placeholder.
  WidgetType hint = 6;
  // A preferred placeholder widget that is displayed when the dropdown is disabled.
  //
  // If [value] is null, the dropdown is disabled ([items] or [onChanged] is null),
  // this widget is displayed as a placeholder for the dropdown button's value.
  WidgetType disabled_hint = 7;
  // The z-coordinate at which to place the menu when open.
  //
  // The following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12,
  // 16, and 24. See [kElevationToShadow].
  //
  // Defaults to 8, the appropriate elevation for dropdown buttons.
  int32 elevation = 10;
  // The text style to use for text in the dropdown button and the dropdown
  // menu that appears when you tap the button.
  //
  // To use a separate text style for selected item when it's displayed within
  // the dropdown button, consider using [selectedItemBuilder].
  //
  // {@tool dartpad}
  // This sample shows a `DropdownButton` with a dropdown button text style
  // that is different than its menu items.
  //
  // ** See code in examples/api/lib/material/dropdown/dropdown_button.style.0.dart **
  // {@end-tool}
  //
  // Defaults to the [TextTheme.titleMedium] value of the current
  // [ThemeData.textTheme] of the current [Theme].
  FlutterTextStyleType style = 11;
  // The widget to use for drawing the drop-down button's underline.
  //
  // Defaults to a 0.0 width bottom border with color 0xFFBDBDBD.
  WidgetType underline = 12;
  // The widget to use for the drop-down button's icon.
  //
  // Defaults to an [Icon] with the [Icons.arrow_drop_down] glyph.
  WidgetType icon = 13;
  // The color of any [Icon] descendant of [icon] if this button is disabled,
  // i.e. if [onChanged] is null.
  //
  // Defaults to [MaterialColor.shade400] of [Colors.grey] when the theme's
  // [ThemeData.brightness] is [Brightness.light] and to
  // [Colors.white10] when it is [Brightness.dark]
  DartColorType icon_disabled_color = 14;
  // The color of any [Icon] descendant of [icon] if this button is enabled,
  // i.e. if [onChanged] is defined.
  //
  // Defaults to [MaterialColor.shade700] of [Colors.grey] when the theme's
  // [ThemeData.brightness] is [Brightness.light] and to
  // [Colors.white70] when it is [Brightness.dark]
  DartColorType icon_enabled_color = 15;
  // The size to use for the drop-down button's down arrow icon button.
  //
  // Defaults to 24.0.
  double icon_size = 16;
  // Reduce the button's height.
  //
  // By default this button's height is the same as its menu items' heights.
  // If isDense is true, the button's height is reduced by about half. This
  // can be useful when the button is embedded in a container that adds
  // its own decorations, like [InputDecorator].
  bool is_dense = 17;
  // Set the dropdown's inner contents to horizontally fill its parent.
  //
  // By default this button's inner width is the minimum size of its contents.
  // If [isExpanded] is true, the inner width is expanded to fill its
  // surrounding container.
  bool is_expanded = 18;
  // If null, then the menu item heights will vary according to each menu item's
  // intrinsic height.
  //
  // The default value is [kMinInteractiveDimension], which is also the minimum
  // height for menu items.
  //
  // If this value is null and there isn't enough vertical room for the menu,
  // then the menu's initial scroll offset may not align the selected item with
  // the dropdown button. That's because, in this case, the initial scroll
  // offset is computed as if all of the menu item heights were
  // [kMinInteractiveDimension].
  double item_height = 19;
  // The color for the button's [Material] when it has the input focus.
  DartColorType focus_color = 20;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 21;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 22;
  // The background color of the dropdown.
  //
  // If it is not provided, the theme's [ThemeData.canvasColor] will be used
  // instead.
  DartColorType dropdown_color = 23;
  // The maximum height of the menu.
  //
  // The maximum height of the menu must be at least one row shorter than
  // the height of the app's view. This ensures that a tappable area
  // outside of the simple menu is present so the user can dismiss the menu.
  //
  // If this property is set above the maximum allowable height threshold
  // mentioned above, then the menu defaults to being padded at the top
  // and bottom of the menu by at one menu item's height.
  double menu_max_height = 24;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // By default, platform-specific feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 25;
  // Defines how the hint or the selected item is positioned within the button.
  //
  // Defaults to [AlignmentDirectional.centerStart].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 26;
  // Defines the corner radii of the menu's rounded rectangle shape.
  FlutterBorderRadiusType border_radius = 27;
  // Padding around the visible portion of the dropdown widget.
  //
  // As the padding increases, the size of the [DropdownButton] will also
  // increase. The padding is included in the clickable area of the dropdown
  // widget, so this can make the widget easier to click.
  //
  // Padding can be useful when used with a custom border. The clickable
  // area will stay flush with the border, as opposed to an external [Padding]
  // widget which will leave a non-clickable gap.
  FlutterEdgeInsetsGeometryType padding = 28;
}

// package:flutter/src/material/dropdown.dart
//
// Creates a [DropdownButton] widget that is a [FormField], wrapped in an
// [InputDecorator].
//
// For a description of the `onSaved`, `validator`, or `autovalidateMode`
// parameters, see [FormField]. For the rest (other than [decoration]), see
// [DropdownButton].
message MaterialDropdownButtonFormField {
  FlutterKeyType key = 2;
  WidgetType hint = 6;
  WidgetType disabled_hint = 7;
  int32 elevation = 10;
  FlutterTextStyleType style = 11;
  WidgetType icon = 12;
  DartColorType icon_disabled_color = 13;
  DartColorType icon_enabled_color = 14;
  double icon_size = 15;
  bool is_dense = 16;
  bool is_expanded = 17;
  double item_height = 18;
  DartColorType focus_color = 19;
  FlutterFocusNodeType focus_node = 20;
  bool autofocus = 21;
  DartColorType dropdown_color = 22;
  MaterialInputDecorationType decoration = 23;
  FlutterAutovalidateModeType.Enum autovalidate_mode = 26;
  double menu_max_height = 27;
  bool enable_feedback = 28;
  FlutterAlignmentGeometryType alignment = 29;
  FlutterBorderRadiusType border_radius = 30;
  FlutterEdgeInsetsGeometryType padding = 31;
}

// package:flutter/src/material/dropdown.dart
//
// Creates a [DropdownButtonHideUnderline]. A non-null [child] must
// be given.
message MaterialDropdownButtonHideUnderline {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 3;
}

// package:flutter/src/material/dropdown.dart
//
// Creates an item for a dropdown menu.
//
// The [child] argument is required.
message MaterialDropdownMenuItem {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether or not a user can select this menu item.
  //
  // Defaults to `true`.
  bool enabled = 5;
  // Defines how the item is positioned within the container.
  //
  // Defaults to [AlignmentDirectional.centerStart].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 6;
  // The widget below this widget in the tree.
  //
  // Typically a [Text] widget.
  WidgetType child = 7;
}

// package:flutter/src/material/dropdown_menu_theme.dart
//
// Creates a [DropdownMenuTheme] that controls visual parameters for
// descendant [DropdownMenu]s.
message MaterialDropdownMenuTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the visual properties used by descendant [DropdownMenu]
  // widgets.
  MaterialDropdownMenuThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/dropdown_menu_theme.dart
//
// Creates a [DropdownMenuThemeData] that can be used to override default properties
// in a [DropdownMenuTheme] widget.
message MaterialDropdownMenuThemeData {
  // Overrides the default value for [DropdownMenu.textStyle].
  FlutterTextStyleType text_style = 2;
  // The input decoration theme for the [TextField]s in a [DropdownMenu].
  //
  // If this is null, the [DropdownMenu] provides its own defaults.
  MaterialInputDecorationThemeType input_decoration_theme = 3;
  // Overrides the menu's default style in a [DropdownMenu].
  //
  // Any values not set in the [MenuStyle] will use the menu default for that
  // property.
  MaterialMenuStyleType menu_style = 4;
}

// package:flutter/src/material/elevated_button.dart
//
// Create an ElevatedButton.
message MaterialElevatedButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [themeStyleOf] and [defaultStyleOf]. [MaterialStateProperty]s
  // that resolve to non-null values will similarly override the corresponding
  // [MaterialStateProperty]s in [themeStyleOf] and [defaultStyleOf].
  //
  // Null by default.
  MaterialButtonStyleType style = 7;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 8;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // {@macro flutter.material.inkwell.statesController}
  MaterialMaterialStatesControllerType states_controller = 11;
  // Typically the button's label.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 12;
}

// package:flutter/src/material/elevated_button.dart
//
// Create an elevated button from a pair of widgets that serve as the button's
// [icon] and [label].
//
// The icon and label are arranged in a row and padded by 12 logical pixels
// at the start, and 16 at the end, with an 8 pixel gap in between.
message MaterialElevatedButtonNamedIcon {
  FlutterKeyType key = 2;
  MaterialButtonStyleType style = 7;
  FlutterFocusNodeType focus_node = 8;
  bool autofocus = 9;
  DartClipType.Enum clip_behavior = 10;
  MaterialMaterialStatesControllerType states_controller = 11;
  WidgetType icon = 12;
  WidgetType label = 13;
}

// package:flutter/src/material/elevated_button_theme.dart
//
// Create a [ElevatedButtonTheme].
message MaterialElevatedButtonTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The configuration of this theme.
  MaterialElevatedButtonThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/elevated_button_theme.dart
//
// Creates an [ElevatedButtonThemeData].
//
// The [style] may be null.
message MaterialElevatedButtonThemeData {
  // Overrides for [ElevatedButton]'s default style.
  //
  // Non-null properties or non-null resolved [MaterialStateProperty]
  // values override the [ButtonStyle] returned by
  // [ElevatedButton.defaultStyleOf].
  //
  // If [style] is null, then this theme doesn't override anything.
  MaterialButtonStyleType style = 2;
}

// package:flutter/src/material/action_buttons.dart
//
// Creates a Material Design end drawer icon button.
message MaterialEndDrawerButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Customizes this icon button's appearance.
  //
  // The [style] is only used for Material 3 [IconButton]s. If [ThemeData.useMaterial3]
  // is set to true, [style] is preferred for icon button customization, and any
  // parameters defined in [style] will override the same parameters in [IconButton].
  //
  // Null by default.
  MaterialButtonStyleType style = 3;
}

// package:flutter/src/material/action_buttons.dart
//
// Creates an icon that shows the appropriate "end drawer" image for
// the current platform (as obtained from the [Theme]).
message MaterialEndDrawerButtonIcon {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
}

// package:flutter/src/material/expand_icon.dart
//
// Creates an [ExpandIcon] with the given padding, and a callback that is
// triggered when the icon is pressed.
message MaterialExpandIcon {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether the icon is in an expanded state.
  //
  // Rebuilding the widget with a different [isExpanded] value will trigger
  // the animation, but will not trigger the [onPressed] callback.
  bool is_expanded = 3;
  // The size of the icon.
  //
  // Defaults to 24.
  double size = 4;
  // The padding around the icon. The entire padded icon will react to input
  // gestures.
  //
  // Defaults to a padding of 8 on all sides.
  FlutterEdgeInsetsGeometryType padding = 6;
  // {@template flutter.material.ExpandIcon.color}
  // The color of the icon.
  //
  // Defaults to [Colors.black54] when the theme's
  // [ThemeData.brightness] is [Brightness.light] and to
  // [Colors.white60] when it is [Brightness.dark]. This adheres to the
  // Material Design specifications for [icons](https://material.io/design/iconography/system-icons.html#color)
  // and for [dark theme](https://material.io/design/color/dark-theme.html#ui-application)
  // {@endtemplate}
  DartColorType color = 7;
  // The color of the icon when it is disabled,
  // i.e. if [onPressed] is null.
  //
  // Defaults to [Colors.black38] when the theme's
  // [ThemeData.brightness] is [Brightness.light] and to
  // [Colors.white38] when it is [Brightness.dark]. This adheres to the
  // Material Design specifications for [icons](https://material.io/design/iconography/system-icons.html#color)
  // and for [dark theme](https://material.io/design/color/dark-theme.html#ui-application)
  DartColorType disabled_color = 8;
  // The color of the icon when the icon is expanded.
  //
  // Defaults to [Colors.black54] when the theme's
  // [ThemeData.brightness] is [Brightness.light] and to
  // [Colors.white] when it is [Brightness.dark]. This adheres to the
  // Material Design specifications for [icons](https://material.io/design/iconography/system-icons.html#color)
  // and for [dark theme](https://material.io/design/color/dark-theme.html#ui-application)
  DartColorType expanded_color = 9;
}

// package:flutter/src/material/expansion_panel.dart
//
// Creates an expansion panel list widget. The [expansionCallback] is
// triggered when an expansion panel expand/collapse button is pushed.
message MaterialExpansionPanelList {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The duration of the expansion animation.
  DartDurationType animation_duration = 5;
  // The padding that surrounds the panel header when expanded.
  //
  // By default, 16px of space is added to the header vertically (above and below)
  // during expansion.
  FlutterEdgeInsetsType expanded_header_padding = 6;
  // Defines color for the divider when [ExpansionPanel.isExpanded] is false.
  //
  // If [dividerColor] is null, then [DividerThemeData.color] is used. If that
  // is null, then [ThemeData.dividerColor] is used.
  DartColorType divider_color = 7;
  // Defines elevation for the [ExpansionPanel] while it's expanded.
  //
  // By default, the value of elevation is 2.
  double elevation = 8;
  // {@macro flutter.material.ExpandIcon.color}
  DartColorType expand_icon_color = 9;
  // Defines the [MaterialGap.size] of the [MaterialGap] which is placed
  // between the [ExpansionPanelList.children] when they're expanded.
  //
  // Defaults to `16.0`.
  double material_gap_size = 10;
}

// package:flutter/src/material/expansion_panel.dart
//
// Creates a radio expansion panel list widget.
//
// This widget allows for at most one panel in the list to be open. The
// expansion panel callback is triggered when an expansion panel
// expand/collapse button is pushed. The [children] objects must be instances
// of [ExpansionPanelRadio].
//
// {@tool dartpad}
// Here is a simple example of how to implement ExpansionPanelList.radio.
//
// ** See code in examples/api/lib/material/expansion_panel/expansion_panel_list.expansion_panel_list_radio.0.dart **
// {@end-tool}
message MaterialExpansionPanelListNamedRadio {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The duration of the expansion animation.
  DartDurationType animation_duration = 5;
  // The padding that surrounds the panel header when expanded.
  //
  // By default, 16px of space is added to the header vertically (above and below)
  // during expansion.
  FlutterEdgeInsetsType expanded_header_padding = 7;
  // Defines color for the divider when [ExpansionPanel.isExpanded] is false.
  //
  // If [dividerColor] is null, then [DividerThemeData.color] is used. If that
  // is null, then [ThemeData.dividerColor] is used.
  DartColorType divider_color = 8;
  // Defines elevation for the [ExpansionPanel] while it's expanded.
  //
  // By default, the value of elevation is 2.
  double elevation = 9;
  // {@macro flutter.material.ExpandIcon.color}
  DartColorType expand_icon_color = 10;
  // Defines the [MaterialGap.size] of the [MaterialGap] which is placed
  // between the [ExpansionPanelList.children] when they're expanded.
  //
  // Defaults to `16.0`.
  double material_gap_size = 11;
}

// package:flutter/src/material/expansion_tile.dart
//
// Creates a single-line [ListTile] with an expansion arrow icon that expands or collapses
// the tile to reveal or hide the [children]. The [initiallyExpanded] property must
// be non-null.
message MaterialExpansionTile {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // A widget to display before the title.
  //
  // Typically a [CircleAvatar] widget.
  //
  // Depending on the value of [controlAffinity], the [leading] widget
  // may replace the rotating expansion arrow icon.
  WidgetType leading = 3;
  // The primary content of the list item.
  //
  // Typically a [Text] widget.
  WidgetType title = 4;
  // Additional content displayed below the title.
  //
  // Typically a [Text] widget.
  WidgetType subtitle = 5;
  // The widgets that are displayed when the tile expands.
  //
  // Typically [ListTile] widgets.
  repeated WidgetType children = 7;
  // A widget to display after the title.
  //
  // Depending on the value of [controlAffinity], the [trailing] widget
  // may replace the rotating expansion arrow icon.
  WidgetType trailing = 8;
  // Specifies if the list tile is initially expanded (true) or collapsed (false, the default).
  bool initially_expanded = 9;
  // Specifies whether the state of the children is maintained when the tile expands and collapses.
  //
  // When true, the children are kept in the tree while the tile is collapsed.
  // When false (default), the children are removed from the tree when the tile is
  // collapsed and recreated upon expansion.
  bool maintain_state = 10;
  // Specifies padding for the [ListTile].
  //
  // Analogous to [ListTile.contentPadding], this property defines the insets for
  // the [leading], [title], [subtitle] and [trailing] widgets. It does not inset
  // the expanded [children] widgets.
  //
  // If this property is null then [ExpansionTileThemeData.tilePadding] is used. If that
  // is also null then the tile's padding is `EdgeInsets.symmetric(horizontal: 16.0)`.
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  FlutterEdgeInsetsGeometryType tile_padding = 11;
  // Specifies the alignment of each child within [children] when the tile is expanded.
  //
  // The internals of the expanded tile make use of a [Column] widget for
  // [children], and the `crossAxisAlignment` parameter is passed directly into
  // the [Column].
  //
  // Modifying this property controls the cross axis alignment of each child
  // within its [Column]. The width of the [Column] that houses [children] will
  // be the same as the widest child widget in [children]. The width of the
  // [Column] might not be equal to the width of the expanded tile.
  //
  // To align the [Column] along the expanded tile, use the [expandedAlignment]
  // property instead.
  //
  // When the value is null, the value of [expandedCrossAxisAlignment] is
  // [CrossAxisAlignment.center].
  FlutterCrossAxisAlignmentType.Enum expanded_cross_axis_alignment = 12;
  // Specifies the alignment of [children], which are arranged in a column when
  // the tile is expanded.
  //
  // The internals of the expanded tile make use of a [Column] widget for
  // [children], and [Align] widget to align the column. The [expandedAlignment]
  // parameter is passed directly into the [Align].
  //
  // Modifying this property controls the alignment of the column within the
  // expanded tile, not the alignment of [children] widgets within the column.
  // To align each child within [children], see [expandedCrossAxisAlignment].
  //
  // The width of the column is the width of the widest child widget in [children].
  //
  // If this property is null then [ExpansionTileThemeData.expandedAlignment]is used. If that
  // is also null then the value of [expandedAlignment] is [Alignment.center].
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  FlutterAlignmentType expanded_alignment = 13;
  // Specifies padding for [children].
  //
  // If this property is null then [ExpansionTileThemeData.childrenPadding] is used. If that
  // is also null then the value of [childrenPadding] is [EdgeInsets.zero].
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  FlutterEdgeInsetsGeometryType children_padding = 14;
  // The color to display behind the sublist when expanded.
  //
  // If this property is null then [ExpansionTileThemeData.backgroundColor] is used. If that
  // is also null then Colors.transparent is used.
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  DartColorType background_color = 15;
  // When not null, defines the background color of tile when the sublist is collapsed.
  //
  // If this property is null then [ExpansionTileThemeData.collapsedBackgroundColor] is used.
  // If that is also null then Colors.transparent is used.
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  DartColorType collapsed_background_color = 16;
  // The color of the tile's titles when the sublist is expanded.
  //
  // Used to override to the [ListTileThemeData.textColor].
  //
  // If this property is null then [ExpansionTileThemeData.textColor] is used. If that
  // is also null then and [ThemeData.useMaterial3] is true, color of the [TextTheme.bodyLarge]
  // will be used for the [title] and [subtitle]. Otherwise, defaults to [ColorScheme.primary] color.
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  DartColorType text_color = 17;
  // The color of the tile's titles when the sublist is collapsed.
  //
  // Used to override to the [ListTileThemeData.textColor].
  //
  // If this property is null then [ExpansionTileThemeData.collapsedTextColor] is used.
  // If that is also null and [ThemeData.useMaterial3] is true, color of the
  // [TextTheme.bodyLarge] will be used for the [title] and [subtitle]. Otherwise,
  // defaults to color of the [TextTheme.titleMedium].
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  DartColorType collapsed_text_color = 18;
  // The icon color of tile's expansion arrow icon when the sublist is expanded.
  //
  // Used to override to the [ListTileThemeData.iconColor].
  //
  // If this property is null then [ExpansionTileThemeData.iconColor] is used. If that
  // is also null then the value of [ColorScheme.primary] is used.
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  DartColorType icon_color = 19;
  // The icon color of tile's expansion arrow icon when the sublist is collapsed.
  //
  // Used to override to the [ListTileThemeData.iconColor].
  //
  // If this property is null then [ExpansionTileThemeData.collapsedIconColor] is used. If that
  // is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurface] is used. Otherwise,
  // defaults to [ThemeData.unselectedWidgetColor] color.
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  DartColorType collapsed_icon_color = 20;
  // The tile's border shape when the sublist is expanded.
  //
  // If this property is null, the [ExpansionTileThemeData.shape] is used. If that
  // is also null, a [Border] with vertical sides default to [ThemeData.dividerColor] is used
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  FlutterShapeBorderType shape = 21;
  // The tile's border shape when the sublist is collapsed.
  //
  // If this property is null, the [ExpansionTileThemeData.collapsedShape] is used. If that
  // is also null, a [Border] with vertical sides default to Color [Colors.transparent] is used
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  FlutterShapeBorderType collapsed_shape = 22;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // If this property is null, the [ExpansionTileThemeData.clipBehavior] is used. If that
  // is also null, a [Clip.none] is used
  //
  // See also:
  //
  // * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s
  //   [ExpansionTileThemeData].
  DartClipType.Enum clip_behavior = 23;
  // Typically used to force the expansion arrow icon to the tile's leading or trailing edge.
  //
  // By default, the value of [controlAffinity] is [ListTileControlAffinity.platform],
  // which means that the expansion arrow icon will appear on the tile's trailing edge.
  MaterialListTileControlAffinityType.Enum control_affinity = 24;
  // If provided, the controller can be used to expand and collapse tiles.
  //
  // In cases were control over the tile's state is needed from a callback triggered
  // by a widget within the tile, [ExpansionTileController.of] may be more convenient
  // than supplying a controller.
  MaterialExpansionTileControllerType controller = 25;
  // {@macro flutter.material.ListTile.dense}
  bool dense = 26;
  // Defines how compact the expansion tile's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  MaterialVisualDensityType visual_density = 27;
  // {@macro flutter.material.ListTile.enableFeedback}
  bool enable_feedback = 28;
  // Whether this expansion tile is interactive.
  //
  // If false, the internal [ListTile] will be disabled, changing its
  // appearance according to the theme and disabling user interaction.
  //
  // Even if disabled, the expansion can still be toggled programmatically
  // through an [ExpansionTileController].
  bool enabled = 29;
  // Used to override the expansion animation curve and duration.
  //
  // If [AnimationStyle.duration] is provided, it will be used to override
  // the expansion animation duration. If it is null, then [AnimationStyle.duration]
  // from the [ExpansionTileThemeData.expansionAnimationStyle] will be used.
  // Otherwise, defaults to 200ms.
  //
  // If [AnimationStyle.curve] is provided, it will be used to override
  // the expansion animation curve. If it is null, then [AnimationStyle.curve]
  // from the [ExpansionTileThemeData.expansionAnimationStyle] will be used.
  // Otherwise, defaults to [Curves.easeIn].
  //
  // To disable the theme animation, use [AnimationStyle.noAnimation].
  //
  // {@tool dartpad}
  // This sample showcases how to override the [ExpansionTile] expansion
  // animation curve and duration using [AnimationStyle].
  //
  // ** See code in examples/api/lib/material/expansion_tile/expansion_tile.2.dart **
  // {@end-tool}
  FlutterSrcAnimationAnimationStyleType expansion_animation_style = 30;
}

// package:flutter/src/material/expansion_tile.dart
//
// Create a controller to be used with [ExpansionTile.controller].
message MaterialExpansionTileController {
  
}

// package:flutter/src/material/expansion_tile_theme.dart
//
// Applies the given theme [data] to [child].
message MaterialExpansionTileTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies color, alignment, and text style values for
  // descendant [ExpansionTile] widgets.
  MaterialExpansionTileThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/expansion_tile_theme.dart
//
// Creates a [ExpansionTileThemeData].
message MaterialExpansionTileThemeData {
  // Overrides the default value of [ExpansionTile.backgroundColor].
  DartColorType background_color = 2;
  // Overrides the default value of [ExpansionTile.collapsedBackgroundColor].
  DartColorType collapsed_background_color = 3;
  // Overrides the default value of [ExpansionTile.tilePadding].
  FlutterEdgeInsetsGeometryType tile_padding = 4;
  // Overrides the default value of [ExpansionTile.expandedAlignment].
  FlutterAlignmentGeometryType expanded_alignment = 5;
  // Overrides the default value of [ExpansionTile.childrenPadding].
  FlutterEdgeInsetsGeometryType children_padding = 6;
  // Overrides the default value of [ExpansionTile.iconColor].
  DartColorType icon_color = 7;
  // Overrides the default value of [ExpansionTile.collapsedIconColor].
  DartColorType collapsed_icon_color = 8;
  // Overrides the default value of [ExpansionTile.textColor].
  DartColorType text_color = 9;
  // Overrides the default value of [ExpansionTile.collapsedTextColor].
  DartColorType collapsed_text_color = 10;
  // Overrides the default value of [ExpansionTile.shape].
  FlutterShapeBorderType shape = 11;
  // Overrides the default value of [ExpansionTile.collapsedShape].
  FlutterShapeBorderType collapsed_shape = 12;
  // Overrides the default value of [ExpansionTile.clipBehavior].
  DartClipType.Enum clip_behavior = 13;
  // Overrides the default value of [ExpansionTile.expansionAnimationStyle].
  FlutterSrcAnimationAnimationStyleType expansion_animation_style = 14;
}

// package:flutter/src/material/filled_button.dart
//
// Create a FilledButton.
message MaterialFilledButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [themeStyleOf] and [defaultStyleOf]. [MaterialStateProperty]s
  // that resolve to non-null values will similarly override the corresponding
  // [MaterialStateProperty]s in [themeStyleOf] and [defaultStyleOf].
  //
  // Null by default.
  MaterialButtonStyleType style = 7;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 8;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // {@macro flutter.material.inkwell.statesController}
  MaterialMaterialStatesControllerType states_controller = 11;
  // Typically the button's label.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 12;
}

// package:flutter/src/material/filled_button.dart
//
// Create a filled button from [icon] and [label].
//
// The icon and label are arranged in a row with padding at the start and end
// and a gap between them.
message MaterialFilledButtonNamedIcon {
  FlutterKeyType key = 2;
  MaterialButtonStyleType style = 7;
  FlutterFocusNodeType focus_node = 8;
  bool autofocus = 9;
  DartClipType.Enum clip_behavior = 10;
  MaterialMaterialStatesControllerType states_controller = 11;
  WidgetType icon = 12;
  WidgetType label = 13;
}

// package:flutter/src/material/filled_button.dart
//
// Create a tonal variant of FilledButton.
//
// A filled tonal button is an alternative middle ground between
// [FilledButton] and [OutlinedButton]. Theyre useful in contexts where
// a lower-priority button requires slightly more emphasis than an
// outline would give, such as "Next" in an onboarding flow.
message MaterialFilledButtonNamedTonal {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [themeStyleOf] and [defaultStyleOf]. [MaterialStateProperty]s
  // that resolve to non-null values will similarly override the corresponding
  // [MaterialStateProperty]s in [themeStyleOf] and [defaultStyleOf].
  //
  // Null by default.
  MaterialButtonStyleType style = 7;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 8;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // {@macro flutter.material.inkwell.statesController}
  MaterialMaterialStatesControllerType states_controller = 11;
  // Typically the button's label.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 12;
}

// package:flutter/src/material/filled_button.dart
//
// Create a filled tonal button from [icon] and [label].
//
// The icon and label are arranged in a row with padding at the start and end
// and a gap between them.
message MaterialFilledButtonNamedTonalIcon {
  FlutterKeyType key = 2;
  MaterialButtonStyleType style = 7;
  FlutterFocusNodeType focus_node = 8;
  bool autofocus = 9;
  DartClipType.Enum clip_behavior = 10;
  MaterialMaterialStatesControllerType states_controller = 11;
  WidgetType icon = 12;
  WidgetType label = 13;
}

// package:flutter/src/material/filled_button_theme.dart
//
// Create a [FilledButtonTheme].
message MaterialFilledButtonTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The configuration of this theme.
  MaterialFilledButtonThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/filled_button_theme.dart
//
// Creates an [FilledButtonThemeData].
//
// The [style] may be null.
message MaterialFilledButtonThemeData {
  // Overrides for [FilledButton]'s default style.
  //
  // Non-null properties or non-null resolved [MaterialStateProperty]
  // values override the [ButtonStyle] returned by
  // [FilledButton.defaultStyleOf].
  //
  // If [style] is null, then this theme doesn't override anything.
  MaterialButtonStyleType style = 2;
}

// package:flutter/src/material/filter_chip.dart
//
// Create a chip that acts like a checkbox.
//
// The [selected], [label], [autofocus], and [clipBehavior] arguments must
// not be null. The [pressElevation] and [elevation] must be null or
// non-negative. Typically, [pressElevation] is greater than [elevation].
message MaterialFilterChip {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  WidgetType avatar = 3;
  WidgetType label = 4;
  FlutterTextStyleType label_style = 5;
  FlutterEdgeInsetsGeometryType label_padding = 6;
  bool selected = 7;
  WidgetType delete_icon = 9;
  DartColorType delete_icon_color = 11;
  string delete_button_tooltip_message = 12;
  double press_elevation = 13;
  DartColorType disabled_color = 14;
  DartColorType selected_color = 15;
  string tooltip = 16;
  FlutterBorderSideType side = 17;
  FlutterOutlinedBorderType shape = 18;
  DartClipType.Enum clip_behavior = 19;
  FlutterFocusNodeType focus_node = 20;
  bool autofocus = 21;
  DartColorType background_color = 23;
  FlutterEdgeInsetsGeometryType padding = 24;
  MaterialVisualDensityType visual_density = 25;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 26;
  double elevation = 27;
  DartColorType shadow_color = 28;
  DartColorType surface_tint_color = 29;
  FlutterIconThemeDataType icon_theme = 30;
  DartColorType selected_shadow_color = 31;
  bool show_checkmark = 32;
  DartColorType checkmark_color = 33;
  FlutterShapeBorderType avatar_border = 34;
}

// package:flutter/src/material/filter_chip.dart
//
// Create an elevated chip that acts like a checkbox.
//
// The [selected], [label], [autofocus], and [clipBehavior] arguments must
// not be null. The [pressElevation] and [elevation] must be null or
// non-negative. Typically, [pressElevation] is greater than [elevation].
message MaterialFilterChipNamedElevated {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  WidgetType avatar = 3;
  WidgetType label = 4;
  FlutterTextStyleType label_style = 5;
  FlutterEdgeInsetsGeometryType label_padding = 6;
  bool selected = 7;
  WidgetType delete_icon = 9;
  DartColorType delete_icon_color = 11;
  string delete_button_tooltip_message = 12;
  double press_elevation = 13;
  DartColorType disabled_color = 14;
  DartColorType selected_color = 15;
  string tooltip = 16;
  FlutterBorderSideType side = 17;
  FlutterOutlinedBorderType shape = 18;
  DartClipType.Enum clip_behavior = 19;
  FlutterFocusNodeType focus_node = 20;
  bool autofocus = 21;
  DartColorType background_color = 23;
  FlutterEdgeInsetsGeometryType padding = 24;
  MaterialVisualDensityType visual_density = 25;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 26;
  double elevation = 27;
  DartColorType shadow_color = 28;
  DartColorType surface_tint_color = 29;
  FlutterIconThemeDataType icon_theme = 30;
  DartColorType selected_shadow_color = 31;
  bool show_checkmark = 32;
  DartColorType checkmark_color = 33;
  FlutterShapeBorderType avatar_border = 34;
}

// package:flutter/src/material/flexible_space_bar.dart
//
// Creates a flexible space bar.
//
// Most commonly used in the [AppBar.flexibleSpace] field.
message MaterialFlexibleSpaceBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The primary contents of the flexible space bar when expanded.
  //
  // Typically a [Text] widget.
  WidgetType title = 3;
  // Shown behind the [title] when expanded.
  //
  // Typically an [Image] widget with [Image.fit] set to [BoxFit.cover].
  WidgetType background = 4;
  // Whether the title should be centered.
  //
  // By default this property is true if the current target platform
  // is [TargetPlatform.iOS] or [TargetPlatform.macOS], false otherwise.
  bool center_title = 5;
  // Defines how far the [title] is inset from either the widget's
  // bottom-left or its center.
  //
  // Typically this property is used to adjust how far the title is
  // inset from the bottom-left and it is specified along with
  // [centerTitle] false.
  //
  // By default the value of this property is
  // `EdgeInsetsDirectional.only(start: 72, bottom: 16)` if the title is
  // not centered, `EdgeInsetsDirectional.only(start: 0, bottom: 16)` otherwise.
  FlutterEdgeInsetsGeometryType title_padding = 6;
  // Collapse effect while scrolling.
  //
  // Defaults to [CollapseMode.parallax].
  MaterialCollapseModeType.Enum collapse_mode = 7;
  // Stretch effect while over-scrolling.
  //
  // Defaults to include [StretchMode.zoomBackground].
  repeated MaterialStretchModeType.Enum stretch_modes = 8;
  // Defines how much the title is scaled when the FlexibleSpaceBar is expanded
  // due to the user scrolling downwards. The title is scaled uniformly on the
  // x and y axes while maintaining its bottom-left position (bottom-center if
  // [centerTitle] is true).
  //
  // Defaults to 1.5 and must be greater than 1.
  double expanded_title_scale = 9;
}

// package:flutter/src/material/flexible_space_bar.dart
//
// Creates a Flexible Space Bar Settings widget.
//
// Used by [Scaffold] and [SliverAppBar]. [child] must have a
// [FlexibleSpaceBar] widget in its tree for the settings to take affect.
message MaterialFlexibleSpaceBarSettings {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Affects how transparent the text within the toolbar appears.
  double toolbar_opacity = 3;
  // Minimum height of the resulting [FlexibleSpaceBar] when fully collapsed.
  double min_extent = 4;
  // Maximum height of the resulting [FlexibleSpaceBar] when fully expanded.
  double max_extent = 5;
  // If the [FlexibleSpaceBar.title] or the [FlexibleSpaceBar.background] is
  // not null, then this value is used to calculate the relative scale of
  // these elements upon initialization.
  double current_extent = 6;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 7;
  // True if the FlexibleSpaceBar overlaps the primary scrollable's contents.
  //
  // This value is used by the [AppBar] to resolve
  // [AppBar.backgroundColor] against [MaterialState.scrolledUnder],
  // i.e. to enable apps to specify different colors when content
  // has been scrolled up and behind the app bar.
  //
  // Null if the caller hasn't determined if the FlexibleSpaceBar
  // overlaps the primary scrollable's contents.
  bool is_scrolled_under = 8;
  // True if the FlexibleSpaceBar has a leading widget.
  //
  // This value is used by the [FlexibleSpaceBar] to determine
  // if there should be a gap between the leading widget and
  // the title.
  //
  // Null if the caller hasn't determined if the FlexibleSpaceBar
  // has a leading widget.
  bool has_leading = 9;
}

// package:flutter/src/material/floating_action_button.dart
//
// Creates a circular floating action button.
//
// The [elevation], [highlightElevation], and [disabledElevation] parameters,
// if specified, must be non-negative.
message MaterialFloatingActionButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // Typically an [Icon].
  WidgetType child = 3;
  // Text that describes the action that will occur when the button is pressed.
  //
  // This text is displayed when the user long-presses on the button and is
  // used for accessibility.
  string tooltip = 4;
  // The default foreground color for icons and text within the button.
  //
  // If this property is null, then the
  // [FloatingActionButtonThemeData.foregroundColor] of
  // [ThemeData.floatingActionButtonTheme] is used. If that property is also
  // null, then the [ColorScheme.onSecondary] color of [ThemeData.colorScheme]
  // is used.
  DartColorType foreground_color = 5;
  // The button's background color.
  //
  // If this property is null, then the
  // [FloatingActionButtonThemeData.backgroundColor] of
  // [ThemeData.floatingActionButtonTheme] is used. If that property is also
  // null, then the [Theme]'s [ColorScheme.secondary] color is used.
  DartColorType background_color = 6;
  // The color to use for filling the button when the button has input focus.
  //
  // Defaults to [ThemeData.focusColor] for the current theme.
  DartColorType focus_color = 7;
  // The color to use for filling the button when the button has a pointer
  // hovering over it.
  //
  // Defaults to [ThemeData.hoverColor] for the current theme.
  DartColorType hover_color = 8;
  // The splash color for this [FloatingActionButton]'s [InkWell].
  //
  // If null, [FloatingActionButtonThemeData.splashColor] is used, if that is
  // null, [ThemeData.splashColor] is used.
  DartColorType splash_color = 9;
  // The z-coordinate at which to place this button relative to its parent.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 6, the appropriate elevation for floating action buttons. The
  // value is always non-negative.
  //
  // See also:
  //
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double elevation = 11;
  // The z-coordinate at which to place this button relative to its parent when
  // the button has the input focus.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 8, the appropriate elevation for floating action buttons
  // while they have focus. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double focus_elevation = 12;
  // The z-coordinate at which to place this button relative to its parent when
  // the button is enabled and has a pointer hovering over it.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 8, the appropriate elevation for floating action buttons while
  // they have a pointer hovering over them. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double hover_elevation = 13;
  // The z-coordinate at which to place this button relative to its parent when
  // the user is touching the button.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 12, the appropriate elevation for floating action buttons
  // while they are being touched. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  double highlight_elevation = 14;
  // The z-coordinate at which to place this button when the button is disabled
  // ([onPressed] is null).
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to the same value as [elevation]. Setting this to zero makes the
  // floating action button work similar to an [ElevatedButton] but the titular
  // "floating" effect is lost. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  double disabled_elevation = 15;
  // Controls the size of this button.
  //
  // By default, floating action buttons are non-mini and have a height and
  // width of 56.0 logical pixels. Mini floating action buttons have a height
  // and width of 40.0 logical pixels with a layout width and height of 48.0
  // logical pixels. (The extra 4 pixels of padding on each side are added as a
  // result of the floating action button having [MaterialTapTargetSize.padded]
  // set on the underlying [RawMaterialButton.materialTapTargetSize].)
  bool mini = 18;
  // The shape of the button's [Material].
  //
  // The button's highlight and splash are clipped to this shape. If the
  // button has an elevation, then its drop shadow is defined by this
  // shape as well.
  FlutterShapeBorderType shape = 19;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 20;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 21;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 22;
  // Configures the minimum size of the tap target.
  //
  // Defaults to [ThemeData.materialTapTargetSize].
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 23;
  // True if this is an "extended" floating action button.
  //
  // Typically [extended] buttons have a [StadiumBorder] [shape]
  // and have been created with the [FloatingActionButton.extended]
  // constructor.
  //
  // The [Scaffold] animates the appearance of ordinary floating
  // action buttons with scale and rotation transitions. Extended
  // floating action buttons are scaled and faded in.
  bool is_extended = 24;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // If null, [FloatingActionButtonThemeData.enableFeedback] is used.
  // If both are null, then default value is true.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 25;
}

// package:flutter/src/material/floating_action_button.dart
//
// Creates a wider [StadiumBorder]-shaped floating action button with
// an optional [icon] and a [label].
//
// The [elevation], [highlightElevation], and [disabledElevation] parameters,
// if specified, must be non-negative.
//
// See also:
//  * <https://m3.material.io/components/extended-fab>
message MaterialFloatingActionButtonNamedExtended {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Text that describes the action that will occur when the button is pressed.
  //
  // This text is displayed when the user long-presses on the button and is
  // used for accessibility.
  string tooltip = 3;
  // The default foreground color for icons and text within the button.
  //
  // If this property is null, then the
  // [FloatingActionButtonThemeData.foregroundColor] of
  // [ThemeData.floatingActionButtonTheme] is used. If that property is also
  // null, then the [ColorScheme.onSecondary] color of [ThemeData.colorScheme]
  // is used.
  DartColorType foreground_color = 4;
  // The button's background color.
  //
  // If this property is null, then the
  // [FloatingActionButtonThemeData.backgroundColor] of
  // [ThemeData.floatingActionButtonTheme] is used. If that property is also
  // null, then the [Theme]'s [ColorScheme.secondary] color is used.
  DartColorType background_color = 5;
  // The color to use for filling the button when the button has input focus.
  //
  // Defaults to [ThemeData.focusColor] for the current theme.
  DartColorType focus_color = 6;
  // The color to use for filling the button when the button has a pointer
  // hovering over it.
  //
  // Defaults to [ThemeData.hoverColor] for the current theme.
  DartColorType hover_color = 7;
  // The z-coordinate at which to place this button relative to its parent.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 6, the appropriate elevation for floating action buttons. The
  // value is always non-negative.
  //
  // See also:
  //
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double elevation = 9;
  // The z-coordinate at which to place this button relative to its parent when
  // the button has the input focus.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 8, the appropriate elevation for floating action buttons
  // while they have focus. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double focus_elevation = 10;
  // The z-coordinate at which to place this button relative to its parent when
  // the button is enabled and has a pointer hovering over it.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 8, the appropriate elevation for floating action buttons while
  // they have a pointer hovering over them. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double hover_elevation = 11;
  // The splash color for this [FloatingActionButton]'s [InkWell].
  //
  // If null, [FloatingActionButtonThemeData.splashColor] is used, if that is
  // null, [ThemeData.splashColor] is used.
  DartColorType splash_color = 12;
  // The z-coordinate at which to place this button relative to its parent when
  // the user is touching the button.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 12, the appropriate elevation for floating action buttons
  // while they are being touched. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  double highlight_elevation = 13;
  // The z-coordinate at which to place this button when the button is disabled
  // ([onPressed] is null).
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to the same value as [elevation]. Setting this to zero makes the
  // floating action button work similar to an [ElevatedButton] but the titular
  // "floating" effect is lost. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  double disabled_elevation = 14;
  // The shape of the button's [Material].
  //
  // The button's highlight and splash are clipped to this shape. If the
  // button has an elevation, then its drop shadow is defined by this
  // shape as well.
  FlutterShapeBorderType shape = 17;
  // True if this is an "extended" floating action button.
  //
  // Typically [extended] buttons have a [StadiumBorder] [shape]
  // and have been created with the [FloatingActionButton.extended]
  // constructor.
  //
  // The [Scaffold] animates the appearance of ordinary floating
  // action buttons with scale and rotation transitions. Extended
  // floating action buttons are scaled and faded in.
  bool is_extended = 18;
  // Configures the minimum size of the tap target.
  //
  // Defaults to [ThemeData.materialTapTargetSize].
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 19;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 20;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 21;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 22;
  // The spacing between the icon and the label for an extended
  // [FloatingActionButton].
  //
  // If null, [FloatingActionButtonThemeData.extendedIconLabelSpacing] is used.
  // If that is also null, the default is 8.0.
  double extended_icon_label_spacing = 23;
  // The padding for an extended [FloatingActionButton]'s content.
  //
  // If null, [FloatingActionButtonThemeData.extendedPadding] is used. If that
  // is also null, the default is
  // `EdgeInsetsDirectional.only(start: 16.0, end: 20.0)` if an icon is
  // provided, and `EdgeInsetsDirectional.only(start: 20.0, end: 20.0)` if not.
  FlutterEdgeInsetsGeometryType extended_padding = 24;
  // The text style for an extended [FloatingActionButton]'s label.
  //
  // If null, [FloatingActionButtonThemeData.extendedTextStyle] is used. If
  // that is also null, then [TextTheme.labelLarge] with a letter spacing of 1.2
  // is used.
  FlutterTextStyleType extended_text_style = 25;
  WidgetType icon = 26;
  WidgetType label = 27;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // If null, [FloatingActionButtonThemeData.enableFeedback] is used.
  // If both are null, then default value is true.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 28;
}

// package:flutter/src/material/floating_action_button.dart
//
// Creates a large circular floating action button.
//
// This constructor overrides the default size constraints of the floating
// action button.
//
// The [elevation], [focusElevation], [hoverElevation], [highlightElevation],
// and [disabledElevation] parameters, if specified, must be non-negative.
message MaterialFloatingActionButtonNamedLarge {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // Typically an [Icon].
  WidgetType child = 3;
  // Text that describes the action that will occur when the button is pressed.
  //
  // This text is displayed when the user long-presses on the button and is
  // used for accessibility.
  string tooltip = 4;
  // The default foreground color for icons and text within the button.
  //
  // If this property is null, then the
  // [FloatingActionButtonThemeData.foregroundColor] of
  // [ThemeData.floatingActionButtonTheme] is used. If that property is also
  // null, then the [ColorScheme.onSecondary] color of [ThemeData.colorScheme]
  // is used.
  DartColorType foreground_color = 5;
  // The button's background color.
  //
  // If this property is null, then the
  // [FloatingActionButtonThemeData.backgroundColor] of
  // [ThemeData.floatingActionButtonTheme] is used. If that property is also
  // null, then the [Theme]'s [ColorScheme.secondary] color is used.
  DartColorType background_color = 6;
  // The color to use for filling the button when the button has input focus.
  //
  // Defaults to [ThemeData.focusColor] for the current theme.
  DartColorType focus_color = 7;
  // The color to use for filling the button when the button has a pointer
  // hovering over it.
  //
  // Defaults to [ThemeData.hoverColor] for the current theme.
  DartColorType hover_color = 8;
  // The splash color for this [FloatingActionButton]'s [InkWell].
  //
  // If null, [FloatingActionButtonThemeData.splashColor] is used, if that is
  // null, [ThemeData.splashColor] is used.
  DartColorType splash_color = 9;
  // The z-coordinate at which to place this button relative to its parent.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 6, the appropriate elevation for floating action buttons. The
  // value is always non-negative.
  //
  // See also:
  //
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double elevation = 11;
  // The z-coordinate at which to place this button relative to its parent when
  // the button has the input focus.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 8, the appropriate elevation for floating action buttons
  // while they have focus. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double focus_elevation = 12;
  // The z-coordinate at which to place this button relative to its parent when
  // the button is enabled and has a pointer hovering over it.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 8, the appropriate elevation for floating action buttons while
  // they have a pointer hovering over them. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double hover_elevation = 13;
  // The z-coordinate at which to place this button relative to its parent when
  // the user is touching the button.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 12, the appropriate elevation for floating action buttons
  // while they are being touched. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  double highlight_elevation = 14;
  // The z-coordinate at which to place this button when the button is disabled
  // ([onPressed] is null).
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to the same value as [elevation]. Setting this to zero makes the
  // floating action button work similar to an [ElevatedButton] but the titular
  // "floating" effect is lost. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  double disabled_elevation = 15;
  // The shape of the button's [Material].
  //
  // The button's highlight and splash are clipped to this shape. If the
  // button has an elevation, then its drop shadow is defined by this
  // shape as well.
  FlutterShapeBorderType shape = 18;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 19;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 20;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 21;
  // Configures the minimum size of the tap target.
  //
  // Defaults to [ThemeData.materialTapTargetSize].
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 22;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // If null, [FloatingActionButtonThemeData.enableFeedback] is used.
  // If both are null, then default value is true.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 23;
}

// package:flutter/src/material/floating_action_button.dart
//
// Creates a small circular floating action button.
//
// This constructor overrides the default size constraints of the floating
// action button.
//
// The [elevation], [focusElevation], [hoverElevation], [highlightElevation],
// and [disabledElevation] parameters, if specified, must be non-negative.
message MaterialFloatingActionButtonNamedSmall {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // Typically an [Icon].
  WidgetType child = 3;
  // Text that describes the action that will occur when the button is pressed.
  //
  // This text is displayed when the user long-presses on the button and is
  // used for accessibility.
  string tooltip = 4;
  // The default foreground color for icons and text within the button.
  //
  // If this property is null, then the
  // [FloatingActionButtonThemeData.foregroundColor] of
  // [ThemeData.floatingActionButtonTheme] is used. If that property is also
  // null, then the [ColorScheme.onSecondary] color of [ThemeData.colorScheme]
  // is used.
  DartColorType foreground_color = 5;
  // The button's background color.
  //
  // If this property is null, then the
  // [FloatingActionButtonThemeData.backgroundColor] of
  // [ThemeData.floatingActionButtonTheme] is used. If that property is also
  // null, then the [Theme]'s [ColorScheme.secondary] color is used.
  DartColorType background_color = 6;
  // The color to use for filling the button when the button has input focus.
  //
  // Defaults to [ThemeData.focusColor] for the current theme.
  DartColorType focus_color = 7;
  // The color to use for filling the button when the button has a pointer
  // hovering over it.
  //
  // Defaults to [ThemeData.hoverColor] for the current theme.
  DartColorType hover_color = 8;
  // The splash color for this [FloatingActionButton]'s [InkWell].
  //
  // If null, [FloatingActionButtonThemeData.splashColor] is used, if that is
  // null, [ThemeData.splashColor] is used.
  DartColorType splash_color = 9;
  // The z-coordinate at which to place this button relative to its parent.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 6, the appropriate elevation for floating action buttons. The
  // value is always non-negative.
  //
  // See also:
  //
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double elevation = 11;
  // The z-coordinate at which to place this button relative to its parent when
  // the button has the input focus.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 8, the appropriate elevation for floating action buttons
  // while they have focus. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double focus_elevation = 12;
  // The z-coordinate at which to place this button relative to its parent when
  // the button is enabled and has a pointer hovering over it.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 8, the appropriate elevation for floating action buttons while
  // they have a pointer hovering over them. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  //  * [disabledElevation], the elevation when the button is disabled.
  double hover_elevation = 13;
  // The z-coordinate at which to place this button relative to its parent when
  // the user is touching the button.
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to 12, the appropriate elevation for floating action buttons
  // while they are being touched. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  double highlight_elevation = 14;
  // The z-coordinate at which to place this button when the button is disabled
  // ([onPressed] is null).
  //
  // This controls the size of the shadow below the floating action button.
  //
  // Defaults to the same value as [elevation]. Setting this to zero makes the
  // floating action button work similar to an [ElevatedButton] but the titular
  // "floating" effect is lost. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  double disabled_elevation = 15;
  // The shape of the button's [Material].
  //
  // The button's highlight and splash are clipped to this shape. If the
  // button has an elevation, then its drop shadow is defined by this
  // shape as well.
  FlutterShapeBorderType shape = 18;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 19;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 20;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 21;
  // Configures the minimum size of the tap target.
  //
  // Defaults to [ThemeData.materialTapTargetSize].
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 22;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // If null, [FloatingActionButtonThemeData.enableFeedback] is used.
  // If both are null, then default value is true.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 23;
}

// package:flutter/src/material/floating_action_button_theme.dart
//
// Creates a theme that can be used for
// [ThemeData.floatingActionButtonTheme].
message MaterialFloatingActionButtonThemeData {
  // Color to be used for the unselected, enabled [FloatingActionButton]'s
  // foreground.
  DartColorType foreground_color = 2;
  // Color to be used for the unselected, enabled [FloatingActionButton]'s
  // background.
  DartColorType background_color = 3;
  // The color to use for filling the button when the button has input focus.
  DartColorType focus_color = 4;
  // The color to use for filling the button when the button has a pointer
  // hovering over it.
  DartColorType hover_color = 5;
  // The splash color for this [FloatingActionButton]'s [InkWell].
  DartColorType splash_color = 6;
  // The z-coordinate to be used for the unselected, enabled
  // [FloatingActionButton]'s elevation foreground.
  double elevation = 7;
  // The z-coordinate at which to place this button relative to its parent when
  // the button has the input focus.
  //
  // This controls the size of the shadow below the floating action button.
  double focus_elevation = 8;
  // The z-coordinate at which to place this button relative to its parent when
  // the button is enabled and has a pointer hovering over it.
  //
  // This controls the size of the shadow below the floating action button.
  double hover_elevation = 9;
  // The z-coordinate to be used for the disabled [FloatingActionButton]'s
  // elevation foreground.
  double disabled_elevation = 10;
  // The z-coordinate to be used for the selected, enabled
  // [FloatingActionButton]'s elevation foreground.
  double highlight_elevation = 11;
  // The shape to be used for the floating action button's [Material].
  FlutterShapeBorderType shape = 12;
  // If specified, defines the feedback property for [FloatingActionButton].
  //
  // If [FloatingActionButton.enableFeedback] is provided, [enableFeedback] is
  // ignored.
  bool enable_feedback = 13;
  // Overrides the default icon size for the [FloatingActionButton];
  double icon_size = 14;
  // Overrides the default size constraints for the [FloatingActionButton].
  FlutterBoxConstraintsType size_constraints = 15;
  // Overrides the default size constraints for [FloatingActionButton.small].
  FlutterBoxConstraintsType small_size_constraints = 16;
  // Overrides the default size constraints for [FloatingActionButton.large].
  FlutterBoxConstraintsType large_size_constraints = 17;
  // Overrides the default size constraints for [FloatingActionButton.extended].
  FlutterBoxConstraintsType extended_size_constraints = 18;
  // The spacing between the icon and the label for an extended
  // [FloatingActionButton].
  double extended_icon_label_spacing = 19;
  // The padding for an extended [FloatingActionButton]'s content.
  FlutterEdgeInsetsGeometryType extended_padding = 20;
  // The text style for an extended [FloatingActionButton]'s label.
  FlutterTextStyleType extended_text_style = 21;
}

// package:flutter/src/material/flutter_logo.dart
//
// Creates a widget that paints the Flutter logo.
//
// The [size] defaults to the value given by the current [IconTheme].
//
// The [textColor], [style], [duration], and [curve] arguments must not be
// null.
message MaterialFlutterLogo {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The size of the logo in logical pixels.
  //
  // The logo will be fit into a square this size.
  //
  // Defaults to the current [IconTheme] size, if any. If there is no
  // [IconTheme], or it does not specify an explicit size, then it defaults to
  // 24.0.
  double size = 3;
  // The color used to paint the "Flutter" text on the logo, if [style] is
  // [FlutterLogoStyle.horizontal] or [FlutterLogoStyle.stacked].
  //
  // If possible, the default (a medium grey) should be used against a white
  // background.
  DartColorType text_color = 4;
  // Whether and where to draw the "Flutter" text. By default, only the logo
  // itself is drawn.
  FlutterFlutterLogoStyleType.Enum style = 5;
  // The length of time for the animation if the [style] or [textColor]
  // properties are changed.
  DartDurationType duration = 6;
  // The curve for the logo animation if the [style] or [textColor] change.
  FlutterSrcAnimationCurveType curve = 7;
}

// package:flutter/src/material/grid_tile.dart
//
// Creates a grid tile.
//
// Must have a child. Does not typically have both a header and a footer.
message MaterialGridTile {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget to show over the top of this grid tile.
  //
  // Typically a [GridTileBar].
  WidgetType header = 3;
  // The widget to show over the bottom of this grid tile.
  //
  // Typically a [GridTileBar].
  WidgetType footer = 4;
  // The widget that fills the tile.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 5;
}

// package:flutter/src/material/grid_tile_bar.dart
//
// Creates a grid tile bar.
//
// Typically used to with [GridTile].
message MaterialGridTileBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The color to paint behind the child widgets.
  //
  // Defaults to transparent.
  DartColorType background_color = 3;
  // A widget to display before the title.
  //
  // Typically an [Icon] or an [IconButton] widget.
  WidgetType leading = 4;
  // The primary content of the list item.
  //
  // Typically a [Text] widget.
  WidgetType title = 5;
  // Additional content displayed below the title.
  //
  // Typically a [Text] widget.
  WidgetType subtitle = 6;
  // A widget to display after the title.
  //
  // Typically an [Icon] or an [IconButton] widget.
  WidgetType trailing = 7;
}

// package:flutter/src/material/icon_button.dart
//
// Creates an icon button.
//
// Icon buttons are commonly used in the [AppBar.actions] field, but they can
// be used in many other places as well.
//
// Requires one of its ancestors to be a [Material] widget. This requirement
// no longer exists if [ThemeData.useMaterial3] is set to true.
//
// The [icon] argument must be specified, and is typically either an [Icon]
// or an [ImageIcon].
message MaterialIconButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The size of the icon inside the button.
  //
  // If null, uses [IconThemeData.size]. If it is also null, the default size
  // is 24.0.
  //
  // The size given here is passed down to the widget in the [icon] property
  // via an [IconTheme]. Setting the size here instead of in, for example, the
  // [Icon.size] property allows the [IconButton] to size the splash area to
  // fit the [Icon]. If you were to set the size of the [Icon] using
  // [Icon.size] instead, then the [IconButton] would default to 24.0 and then
  // the [Icon] itself would likely get clipped.
  //
  // This property is only used when [icon] is or contains an [Icon] widget. It will be
  // ignored if other widgets are used, such as an [Image].
  //
  // If [ThemeData.useMaterial3] is set to true and this is null, the size of the
  // [IconButton] would default to 24.0. The size given here is passed down to the
  // [ButtonStyle.iconSize] property.
  double icon_size = 3;
  // Defines how compact the icon button's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // This property can be null. If null, it defaults to [VisualDensity.standard]
  // in Material Design 3 to make sure the button will be circular on all platforms.
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 4;
  // The padding around the button's icon. The entire padded icon will react
  // to input gestures.
  //
  // This property can be null. If null, it defaults to 8.0 padding on all sides.
  FlutterEdgeInsetsGeometryType padding = 5;
  // Defines how the icon is positioned within the IconButton.
  //
  // This property can be null. If null, it defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 6;
  // The splash radius.
  //
  // If [ThemeData.useMaterial3] is set to true, this will not be used.
  //
  // If null, default splash radius of [Material.defaultSplashRadius] is used.
  double splash_radius = 7;
  // The color to use for the icon inside the button, if the icon is enabled.
  // Defaults to leaving this up to the [icon] widget.
  //
  // The icon is enabled if [onPressed] is not null.
  //
  // ```dart
  // IconButton(
  //   color: Colors.blue,
  //   icon: const Icon(Icons.sunny_snowing),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  DartColorType color = 8;
  // The color for the button when it has the input focus.
  //
  // If [ThemeData.useMaterial3] is set to true, this [focusColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in focused state, which paints on top of
  // the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [focusColor] below:
  //
  // ```dart
  // IconButton(
  //   focusColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.sunny),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to [ThemeData.focusColor] of the ambient theme.
  DartColorType focus_color = 9;
  // The color for the button when a pointer is hovering over it.
  //
  // If [ThemeData.useMaterial3] is set to true, this [hoverColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in hovered state, which paints on top of
  // the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [hoverColor] below:
  //
  // ```dart
  // IconButton(
  //   hoverColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.ac_unit),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to [ThemeData.hoverColor] of the ambient theme.
  DartColorType hover_color = 10;
  // The secondary color of the button when the button is in the down (pressed)
  // state. The highlight color is represented as a solid color that is overlaid over the
  // button color (if any). If the highlight color has transparency, the button color
  // will show through. The highlight fades in quickly as the button is held down.
  //
  // If [ThemeData.useMaterial3] is set to true, this [highlightColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in pressed state, which paints on top
  // of the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [highlightColor] below:
  //
  // ```dart
  // IconButton(
  //   highlightColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.question_mark),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to the Theme's highlight color, [ThemeData.highlightColor].
  DartColorType highlight_color = 11;
  // The primary color of the button when the button is in the down (pressed) state.
  // The splash is represented as a circular overlay that appears above the
  // [highlightColor] overlay. The splash overlay has a center point that matches
  // the hit point of the user touch event. The splash overlay will expand to
  // fill the button area if the touch is held for long enough time. If the splash
  // color has transparency then the highlight and button color will show through.
  //
  // If [ThemeData.useMaterial3] is set to true, this will not be used. Use
  // [highlightColor] instead to show the overlay color of the button when the button
  // is in the pressed state.
  //
  // Defaults to the Theme's splash color, [ThemeData.splashColor].
  DartColorType splash_color = 12;
  // The color to use for the icon inside the button, if the icon is disabled.
  // Defaults to the [ThemeData.disabledColor] of the current [Theme].
  //
  // The icon is disabled if [onPressed] is null.
  DartColorType disabled_color = 13;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 16;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 17;
  // Text that describes the action that will occur when the button is pressed.
  //
  // This text is displayed when the user long-presses on the button and is
  // used for accessibility.
  string tooltip = 18;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 19;
  // Optional size constraints for the button.
  //
  // When unspecified, defaults to:
  // ```dart
  // const BoxConstraints(
  //   minWidth: kMinInteractiveDimension,
  //   minHeight: kMinInteractiveDimension,
  // )
  // ```
  // where [kMinInteractiveDimension] is 48.0, and then with visual density
  // applied.
  //
  // The default constraints ensure that the button is accessible.
  // Specifying this parameter enables creation of buttons smaller than
  // the minimum size, but it is not recommended.
  //
  // The visual density uses the [visualDensity] parameter if specified,
  // and `Theme.of(context).visualDensity` otherwise.
  FlutterBoxConstraintsType constraints = 20;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [_IconButtonM3.themeStyleOf] and [_IconButtonM3.defaultStyleOf].
  // [MaterialStateProperty]s that resolve to non-null values will similarly
  // override the corresponding [MaterialStateProperty]s in [_IconButtonM3.themeStyleOf]
  // and [_IconButtonM3.defaultStyleOf].
  //
  // The [style] is only used for Material 3 [IconButton]. If [ThemeData.useMaterial3]
  // is set to true, [style] is preferred for icon button customization, and any
  // parameters defined in [style] will override the same parameters in [IconButton].
  //
  // For example, if [IconButton]'s [visualDensity] is set to [VisualDensity.standard]
  // and [style]'s [visualDensity] is set to [VisualDensity.compact],
  // the icon button will have [VisualDensity.compact] to define the button's layout.
  //
  // Null by default.
  MaterialButtonStyleType style = 21;
  // The optional selection state of the icon button.
  //
  // If this property is null, the button will behave as a normal push button,
  // otherwise, the button will toggle between showing [icon] and [selectedIcon]
  // based on the value of [isSelected]. If true, it will show [selectedIcon],
  // if false it will show [icon].
  //
  // This property is only used if [ThemeData.useMaterial3] is true.
  bool is_selected = 22;
  // The icon to display inside the button when [isSelected] is true. This property
  // can be null. The original [icon] will be used for both selected and unselected
  // status if it is null.
  //
  // The [Icon.size] and [Icon.color] of the icon is configured automatically
  // based on the [iconSize] and [color] properties using an [IconTheme] and
  // therefore should not be explicitly configured in the icon widget.
  //
  // This property is only used if [ThemeData.useMaterial3] is true.
  //
  // See also:
  //
  // * [Icon], for icons based on glyphs from fonts instead of images.
  // * [ImageIcon], for showing icons from [AssetImage]s or other [ImageProvider]s.
  WidgetType selected_icon = 23;
  // The icon to display inside the button.
  //
  // The [Icon.size] and [Icon.color] of the icon is configured automatically
  // based on the [iconSize] and [color] properties of _this_ widget using an
  // [IconTheme] and therefore should not be explicitly given in the icon
  // widget.
  //
  // See [Icon], [ImageIcon].
  WidgetType icon = 24;
}

// package:flutter/src/material/icon_button.dart
//
// Create a filled variant of IconButton.
//
// Filled icon buttons have higher visual impact and should be used for
// high emphasis actions, such as turning off a microphone or camera.
message MaterialIconButtonNamedFilled {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The size of the icon inside the button.
  //
  // If null, uses [IconThemeData.size]. If it is also null, the default size
  // is 24.0.
  //
  // The size given here is passed down to the widget in the [icon] property
  // via an [IconTheme]. Setting the size here instead of in, for example, the
  // [Icon.size] property allows the [IconButton] to size the splash area to
  // fit the [Icon]. If you were to set the size of the [Icon] using
  // [Icon.size] instead, then the [IconButton] would default to 24.0 and then
  // the [Icon] itself would likely get clipped.
  //
  // This property is only used when [icon] is or contains an [Icon] widget. It will be
  // ignored if other widgets are used, such as an [Image].
  //
  // If [ThemeData.useMaterial3] is set to true and this is null, the size of the
  // [IconButton] would default to 24.0. The size given here is passed down to the
  // [ButtonStyle.iconSize] property.
  double icon_size = 3;
  // Defines how compact the icon button's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // This property can be null. If null, it defaults to [VisualDensity.standard]
  // in Material Design 3 to make sure the button will be circular on all platforms.
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 4;
  // The padding around the button's icon. The entire padded icon will react
  // to input gestures.
  //
  // This property can be null. If null, it defaults to 8.0 padding on all sides.
  FlutterEdgeInsetsGeometryType padding = 5;
  // Defines how the icon is positioned within the IconButton.
  //
  // This property can be null. If null, it defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 6;
  // The splash radius.
  //
  // If [ThemeData.useMaterial3] is set to true, this will not be used.
  //
  // If null, default splash radius of [Material.defaultSplashRadius] is used.
  double splash_radius = 7;
  // The color to use for the icon inside the button, if the icon is enabled.
  // Defaults to leaving this up to the [icon] widget.
  //
  // The icon is enabled if [onPressed] is not null.
  //
  // ```dart
  // IconButton(
  //   color: Colors.blue,
  //   icon: const Icon(Icons.sunny_snowing),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  DartColorType color = 8;
  // The color for the button when it has the input focus.
  //
  // If [ThemeData.useMaterial3] is set to true, this [focusColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in focused state, which paints on top of
  // the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [focusColor] below:
  //
  // ```dart
  // IconButton(
  //   focusColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.sunny),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to [ThemeData.focusColor] of the ambient theme.
  DartColorType focus_color = 9;
  // The color for the button when a pointer is hovering over it.
  //
  // If [ThemeData.useMaterial3] is set to true, this [hoverColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in hovered state, which paints on top of
  // the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [hoverColor] below:
  //
  // ```dart
  // IconButton(
  //   hoverColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.ac_unit),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to [ThemeData.hoverColor] of the ambient theme.
  DartColorType hover_color = 10;
  // The secondary color of the button when the button is in the down (pressed)
  // state. The highlight color is represented as a solid color that is overlaid over the
  // button color (if any). If the highlight color has transparency, the button color
  // will show through. The highlight fades in quickly as the button is held down.
  //
  // If [ThemeData.useMaterial3] is set to true, this [highlightColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in pressed state, which paints on top
  // of the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [highlightColor] below:
  //
  // ```dart
  // IconButton(
  //   highlightColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.question_mark),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to the Theme's highlight color, [ThemeData.highlightColor].
  DartColorType highlight_color = 11;
  // The primary color of the button when the button is in the down (pressed) state.
  // The splash is represented as a circular overlay that appears above the
  // [highlightColor] overlay. The splash overlay has a center point that matches
  // the hit point of the user touch event. The splash overlay will expand to
  // fill the button area if the touch is held for long enough time. If the splash
  // color has transparency then the highlight and button color will show through.
  //
  // If [ThemeData.useMaterial3] is set to true, this will not be used. Use
  // [highlightColor] instead to show the overlay color of the button when the button
  // is in the pressed state.
  //
  // Defaults to the Theme's splash color, [ThemeData.splashColor].
  DartColorType splash_color = 12;
  // The color to use for the icon inside the button, if the icon is disabled.
  // Defaults to the [ThemeData.disabledColor] of the current [Theme].
  //
  // The icon is disabled if [onPressed] is null.
  DartColorType disabled_color = 13;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 16;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 17;
  // Text that describes the action that will occur when the button is pressed.
  //
  // This text is displayed when the user long-presses on the button and is
  // used for accessibility.
  string tooltip = 18;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 19;
  // Optional size constraints for the button.
  //
  // When unspecified, defaults to:
  // ```dart
  // const BoxConstraints(
  //   minWidth: kMinInteractiveDimension,
  //   minHeight: kMinInteractiveDimension,
  // )
  // ```
  // where [kMinInteractiveDimension] is 48.0, and then with visual density
  // applied.
  //
  // The default constraints ensure that the button is accessible.
  // Specifying this parameter enables creation of buttons smaller than
  // the minimum size, but it is not recommended.
  //
  // The visual density uses the [visualDensity] parameter if specified,
  // and `Theme.of(context).visualDensity` otherwise.
  FlutterBoxConstraintsType constraints = 20;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [_IconButtonM3.themeStyleOf] and [_IconButtonM3.defaultStyleOf].
  // [MaterialStateProperty]s that resolve to non-null values will similarly
  // override the corresponding [MaterialStateProperty]s in [_IconButtonM3.themeStyleOf]
  // and [_IconButtonM3.defaultStyleOf].
  //
  // The [style] is only used for Material 3 [IconButton]. If [ThemeData.useMaterial3]
  // is set to true, [style] is preferred for icon button customization, and any
  // parameters defined in [style] will override the same parameters in [IconButton].
  //
  // For example, if [IconButton]'s [visualDensity] is set to [VisualDensity.standard]
  // and [style]'s [visualDensity] is set to [VisualDensity.compact],
  // the icon button will have [VisualDensity.compact] to define the button's layout.
  //
  // Null by default.
  MaterialButtonStyleType style = 21;
  // The optional selection state of the icon button.
  //
  // If this property is null, the button will behave as a normal push button,
  // otherwise, the button will toggle between showing [icon] and [selectedIcon]
  // based on the value of [isSelected]. If true, it will show [selectedIcon],
  // if false it will show [icon].
  //
  // This property is only used if [ThemeData.useMaterial3] is true.
  bool is_selected = 22;
  // The icon to display inside the button when [isSelected] is true. This property
  // can be null. The original [icon] will be used for both selected and unselected
  // status if it is null.
  //
  // The [Icon.size] and [Icon.color] of the icon is configured automatically
  // based on the [iconSize] and [color] properties using an [IconTheme] and
  // therefore should not be explicitly configured in the icon widget.
  //
  // This property is only used if [ThemeData.useMaterial3] is true.
  //
  // See also:
  //
  // * [Icon], for icons based on glyphs from fonts instead of images.
  // * [ImageIcon], for showing icons from [AssetImage]s or other [ImageProvider]s.
  WidgetType selected_icon = 23;
  // The icon to display inside the button.
  //
  // The [Icon.size] and [Icon.color] of the icon is configured automatically
  // based on the [iconSize] and [color] properties of _this_ widget using an
  // [IconTheme] and therefore should not be explicitly given in the icon
  // widget.
  //
  // See [Icon], [ImageIcon].
  WidgetType icon = 24;
}

// package:flutter/src/material/icon_button.dart
//
// Create a filled tonal variant of IconButton.
//
// Filled tonal icon buttons are a middle ground between filled and outlined
// icon buttons. Theyre useful in contexts where the button requires slightly
// more emphasis than an outline would give, such as a secondary action paired
// with a high emphasis action.
message MaterialIconButtonNamedFilledTonal {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The size of the icon inside the button.
  //
  // If null, uses [IconThemeData.size]. If it is also null, the default size
  // is 24.0.
  //
  // The size given here is passed down to the widget in the [icon] property
  // via an [IconTheme]. Setting the size here instead of in, for example, the
  // [Icon.size] property allows the [IconButton] to size the splash area to
  // fit the [Icon]. If you were to set the size of the [Icon] using
  // [Icon.size] instead, then the [IconButton] would default to 24.0 and then
  // the [Icon] itself would likely get clipped.
  //
  // This property is only used when [icon] is or contains an [Icon] widget. It will be
  // ignored if other widgets are used, such as an [Image].
  //
  // If [ThemeData.useMaterial3] is set to true and this is null, the size of the
  // [IconButton] would default to 24.0. The size given here is passed down to the
  // [ButtonStyle.iconSize] property.
  double icon_size = 3;
  // Defines how compact the icon button's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // This property can be null. If null, it defaults to [VisualDensity.standard]
  // in Material Design 3 to make sure the button will be circular on all platforms.
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 4;
  // The padding around the button's icon. The entire padded icon will react
  // to input gestures.
  //
  // This property can be null. If null, it defaults to 8.0 padding on all sides.
  FlutterEdgeInsetsGeometryType padding = 5;
  // Defines how the icon is positioned within the IconButton.
  //
  // This property can be null. If null, it defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 6;
  // The splash radius.
  //
  // If [ThemeData.useMaterial3] is set to true, this will not be used.
  //
  // If null, default splash radius of [Material.defaultSplashRadius] is used.
  double splash_radius = 7;
  // The color to use for the icon inside the button, if the icon is enabled.
  // Defaults to leaving this up to the [icon] widget.
  //
  // The icon is enabled if [onPressed] is not null.
  //
  // ```dart
  // IconButton(
  //   color: Colors.blue,
  //   icon: const Icon(Icons.sunny_snowing),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  DartColorType color = 8;
  // The color for the button when it has the input focus.
  //
  // If [ThemeData.useMaterial3] is set to true, this [focusColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in focused state, which paints on top of
  // the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [focusColor] below:
  //
  // ```dart
  // IconButton(
  //   focusColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.sunny),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to [ThemeData.focusColor] of the ambient theme.
  DartColorType focus_color = 9;
  // The color for the button when a pointer is hovering over it.
  //
  // If [ThemeData.useMaterial3] is set to true, this [hoverColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in hovered state, which paints on top of
  // the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [hoverColor] below:
  //
  // ```dart
  // IconButton(
  //   hoverColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.ac_unit),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to [ThemeData.hoverColor] of the ambient theme.
  DartColorType hover_color = 10;
  // The secondary color of the button when the button is in the down (pressed)
  // state. The highlight color is represented as a solid color that is overlaid over the
  // button color (if any). If the highlight color has transparency, the button color
  // will show through. The highlight fades in quickly as the button is held down.
  //
  // If [ThemeData.useMaterial3] is set to true, this [highlightColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in pressed state, which paints on top
  // of the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [highlightColor] below:
  //
  // ```dart
  // IconButton(
  //   highlightColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.question_mark),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to the Theme's highlight color, [ThemeData.highlightColor].
  DartColorType highlight_color = 11;
  // The primary color of the button when the button is in the down (pressed) state.
  // The splash is represented as a circular overlay that appears above the
  // [highlightColor] overlay. The splash overlay has a center point that matches
  // the hit point of the user touch event. The splash overlay will expand to
  // fill the button area if the touch is held for long enough time. If the splash
  // color has transparency then the highlight and button color will show through.
  //
  // If [ThemeData.useMaterial3] is set to true, this will not be used. Use
  // [highlightColor] instead to show the overlay color of the button when the button
  // is in the pressed state.
  //
  // Defaults to the Theme's splash color, [ThemeData.splashColor].
  DartColorType splash_color = 12;
  // The color to use for the icon inside the button, if the icon is disabled.
  // Defaults to the [ThemeData.disabledColor] of the current [Theme].
  //
  // The icon is disabled if [onPressed] is null.
  DartColorType disabled_color = 13;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 16;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 17;
  // Text that describes the action that will occur when the button is pressed.
  //
  // This text is displayed when the user long-presses on the button and is
  // used for accessibility.
  string tooltip = 18;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 19;
  // Optional size constraints for the button.
  //
  // When unspecified, defaults to:
  // ```dart
  // const BoxConstraints(
  //   minWidth: kMinInteractiveDimension,
  //   minHeight: kMinInteractiveDimension,
  // )
  // ```
  // where [kMinInteractiveDimension] is 48.0, and then with visual density
  // applied.
  //
  // The default constraints ensure that the button is accessible.
  // Specifying this parameter enables creation of buttons smaller than
  // the minimum size, but it is not recommended.
  //
  // The visual density uses the [visualDensity] parameter if specified,
  // and `Theme.of(context).visualDensity` otherwise.
  FlutterBoxConstraintsType constraints = 20;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [_IconButtonM3.themeStyleOf] and [_IconButtonM3.defaultStyleOf].
  // [MaterialStateProperty]s that resolve to non-null values will similarly
  // override the corresponding [MaterialStateProperty]s in [_IconButtonM3.themeStyleOf]
  // and [_IconButtonM3.defaultStyleOf].
  //
  // The [style] is only used for Material 3 [IconButton]. If [ThemeData.useMaterial3]
  // is set to true, [style] is preferred for icon button customization, and any
  // parameters defined in [style] will override the same parameters in [IconButton].
  //
  // For example, if [IconButton]'s [visualDensity] is set to [VisualDensity.standard]
  // and [style]'s [visualDensity] is set to [VisualDensity.compact],
  // the icon button will have [VisualDensity.compact] to define the button's layout.
  //
  // Null by default.
  MaterialButtonStyleType style = 21;
  // The optional selection state of the icon button.
  //
  // If this property is null, the button will behave as a normal push button,
  // otherwise, the button will toggle between showing [icon] and [selectedIcon]
  // based on the value of [isSelected]. If true, it will show [selectedIcon],
  // if false it will show [icon].
  //
  // This property is only used if [ThemeData.useMaterial3] is true.
  bool is_selected = 22;
  // The icon to display inside the button when [isSelected] is true. This property
  // can be null. The original [icon] will be used for both selected and unselected
  // status if it is null.
  //
  // The [Icon.size] and [Icon.color] of the icon is configured automatically
  // based on the [iconSize] and [color] properties using an [IconTheme] and
  // therefore should not be explicitly configured in the icon widget.
  //
  // This property is only used if [ThemeData.useMaterial3] is true.
  //
  // See also:
  //
  // * [Icon], for icons based on glyphs from fonts instead of images.
  // * [ImageIcon], for showing icons from [AssetImage]s or other [ImageProvider]s.
  WidgetType selected_icon = 23;
  // The icon to display inside the button.
  //
  // The [Icon.size] and [Icon.color] of the icon is configured automatically
  // based on the [iconSize] and [color] properties of _this_ widget using an
  // [IconTheme] and therefore should not be explicitly given in the icon
  // widget.
  //
  // See [Icon], [ImageIcon].
  WidgetType icon = 24;
}

// package:flutter/src/material/icon_button.dart
//
// Create a filled tonal variant of IconButton.
//
// Outlined icon buttons are medium-emphasis buttons. Theyre useful when an
// icon button needs more emphasis than a standard icon button but less than
// a filled or filled tonal icon button.
message MaterialIconButtonNamedOutlined {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The size of the icon inside the button.
  //
  // If null, uses [IconThemeData.size]. If it is also null, the default size
  // is 24.0.
  //
  // The size given here is passed down to the widget in the [icon] property
  // via an [IconTheme]. Setting the size here instead of in, for example, the
  // [Icon.size] property allows the [IconButton] to size the splash area to
  // fit the [Icon]. If you were to set the size of the [Icon] using
  // [Icon.size] instead, then the [IconButton] would default to 24.0 and then
  // the [Icon] itself would likely get clipped.
  //
  // This property is only used when [icon] is or contains an [Icon] widget. It will be
  // ignored if other widgets are used, such as an [Image].
  //
  // If [ThemeData.useMaterial3] is set to true and this is null, the size of the
  // [IconButton] would default to 24.0. The size given here is passed down to the
  // [ButtonStyle.iconSize] property.
  double icon_size = 3;
  // Defines how compact the icon button's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // This property can be null. If null, it defaults to [VisualDensity.standard]
  // in Material Design 3 to make sure the button will be circular on all platforms.
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 4;
  // The padding around the button's icon. The entire padded icon will react
  // to input gestures.
  //
  // This property can be null. If null, it defaults to 8.0 padding on all sides.
  FlutterEdgeInsetsGeometryType padding = 5;
  // Defines how the icon is positioned within the IconButton.
  //
  // This property can be null. If null, it defaults to [Alignment.center].
  //
  // See also:
  //
  //  * [Alignment], a class with convenient constants typically used to
  //    specify an [AlignmentGeometry].
  //  * [AlignmentDirectional], like [Alignment] for specifying alignments
  //    relative to text direction.
  FlutterAlignmentGeometryType alignment = 6;
  // The splash radius.
  //
  // If [ThemeData.useMaterial3] is set to true, this will not be used.
  //
  // If null, default splash radius of [Material.defaultSplashRadius] is used.
  double splash_radius = 7;
  // The color to use for the icon inside the button, if the icon is enabled.
  // Defaults to leaving this up to the [icon] widget.
  //
  // The icon is enabled if [onPressed] is not null.
  //
  // ```dart
  // IconButton(
  //   color: Colors.blue,
  //   icon: const Icon(Icons.sunny_snowing),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  DartColorType color = 8;
  // The color for the button when it has the input focus.
  //
  // If [ThemeData.useMaterial3] is set to true, this [focusColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in focused state, which paints on top of
  // the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [focusColor] below:
  //
  // ```dart
  // IconButton(
  //   focusColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.sunny),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to [ThemeData.focusColor] of the ambient theme.
  DartColorType focus_color = 9;
  // The color for the button when a pointer is hovering over it.
  //
  // If [ThemeData.useMaterial3] is set to true, this [hoverColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in hovered state, which paints on top of
  // the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [hoverColor] below:
  //
  // ```dart
  // IconButton(
  //   hoverColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.ac_unit),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to [ThemeData.hoverColor] of the ambient theme.
  DartColorType hover_color = 10;
  // The secondary color of the button when the button is in the down (pressed)
  // state. The highlight color is represented as a solid color that is overlaid over the
  // button color (if any). If the highlight color has transparency, the button color
  // will show through. The highlight fades in quickly as the button is held down.
  //
  // If [ThemeData.useMaterial3] is set to true, this [highlightColor] will be mapped
  // to be the [ButtonStyle.overlayColor] in pressed state, which paints on top
  // of the button, as an overlay. Therefore, using a color with some transparency
  // is recommended. For example, one could customize the [highlightColor] below:
  //
  // ```dart
  // IconButton(
  //   highlightColor: Colors.orange.withOpacity(0.3),
  //   icon: const Icon(Icons.question_mark),
  //   onPressed: () {
  //     // ...
  //   },
  // )
  // ```
  //
  // Defaults to the Theme's highlight color, [ThemeData.highlightColor].
  DartColorType highlight_color = 11;
  // The primary color of the button when the button is in the down (pressed) state.
  // The splash is represented as a circular overlay that appears above the
  // [highlightColor] overlay. The splash overlay has a center point that matches
  // the hit point of the user touch event. The splash overlay will expand to
  // fill the button area if the touch is held for long enough time. If the splash
  // color has transparency then the highlight and button color will show through.
  //
  // If [ThemeData.useMaterial3] is set to true, this will not be used. Use
  // [highlightColor] instead to show the overlay color of the button when the button
  // is in the pressed state.
  //
  // Defaults to the Theme's splash color, [ThemeData.splashColor].
  DartColorType splash_color = 12;
  // The color to use for the icon inside the button, if the icon is disabled.
  // Defaults to the [ThemeData.disabledColor] of the current [Theme].
  //
  // The icon is disabled if [onPressed] is null.
  DartColorType disabled_color = 13;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 16;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 17;
  // Text that describes the action that will occur when the button is pressed.
  //
  // This text is displayed when the user long-presses on the button and is
  // used for accessibility.
  string tooltip = 18;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 19;
  // Optional size constraints for the button.
  //
  // When unspecified, defaults to:
  // ```dart
  // const BoxConstraints(
  //   minWidth: kMinInteractiveDimension,
  //   minHeight: kMinInteractiveDimension,
  // )
  // ```
  // where [kMinInteractiveDimension] is 48.0, and then with visual density
  // applied.
  //
  // The default constraints ensure that the button is accessible.
  // Specifying this parameter enables creation of buttons smaller than
  // the minimum size, but it is not recommended.
  //
  // The visual density uses the [visualDensity] parameter if specified,
  // and `Theme.of(context).visualDensity` otherwise.
  FlutterBoxConstraintsType constraints = 20;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [_IconButtonM3.themeStyleOf] and [_IconButtonM3.defaultStyleOf].
  // [MaterialStateProperty]s that resolve to non-null values will similarly
  // override the corresponding [MaterialStateProperty]s in [_IconButtonM3.themeStyleOf]
  // and [_IconButtonM3.defaultStyleOf].
  //
  // The [style] is only used for Material 3 [IconButton]. If [ThemeData.useMaterial3]
  // is set to true, [style] is preferred for icon button customization, and any
  // parameters defined in [style] will override the same parameters in [IconButton].
  //
  // For example, if [IconButton]'s [visualDensity] is set to [VisualDensity.standard]
  // and [style]'s [visualDensity] is set to [VisualDensity.compact],
  // the icon button will have [VisualDensity.compact] to define the button's layout.
  //
  // Null by default.
  MaterialButtonStyleType style = 21;
  // The optional selection state of the icon button.
  //
  // If this property is null, the button will behave as a normal push button,
  // otherwise, the button will toggle between showing [icon] and [selectedIcon]
  // based on the value of [isSelected]. If true, it will show [selectedIcon],
  // if false it will show [icon].
  //
  // This property is only used if [ThemeData.useMaterial3] is true.
  bool is_selected = 22;
  // The icon to display inside the button when [isSelected] is true. This property
  // can be null. The original [icon] will be used for both selected and unselected
  // status if it is null.
  //
  // The [Icon.size] and [Icon.color] of the icon is configured automatically
  // based on the [iconSize] and [color] properties using an [IconTheme] and
  // therefore should not be explicitly configured in the icon widget.
  //
  // This property is only used if [ThemeData.useMaterial3] is true.
  //
  // See also:
  //
  // * [Icon], for icons based on glyphs from fonts instead of images.
  // * [ImageIcon], for showing icons from [AssetImage]s or other [ImageProvider]s.
  WidgetType selected_icon = 23;
  // The icon to display inside the button.
  //
  // The [Icon.size] and [Icon.color] of the icon is configured automatically
  // based on the [iconSize] and [color] properties of _this_ widget using an
  // [IconTheme] and therefore should not be explicitly given in the icon
  // widget.
  //
  // See [Icon], [ImageIcon].
  WidgetType icon = 24;
}

// package:flutter/src/material/icon_button_theme.dart
//
// Create a [IconButtonTheme].
message MaterialIconButtonTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The configuration of this theme.
  MaterialIconButtonThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/icon_button_theme.dart
//
// Creates a [IconButtonThemeData].
//
// The [style] may be null.
message MaterialIconButtonThemeData {
  // Overrides for [IconButton]'s default style if [ThemeData.useMaterial3]
  // is set to true.
  //
  // Non-null properties or non-null resolved [MaterialStateProperty]
  // values override the default [ButtonStyle] in [IconButton].
  //
  // If [style] is null, then this theme doesn't override anything.
  MaterialButtonStyleType style = 2;
}

// package:flutter/src/material/ink_decoration.dart
//
// Paints a decoration (which can be a simple color) on a [Material].
//
// The [height] and [width] values include the [padding].
//
// The `color` argument is a shorthand for
// `decoration: BoxDecoration(color: color)`, which means you cannot supply
// both a `color` and a `decoration` argument. If you want to have both a
// `color` and a `decoration`, you can pass the color as the `color`
// argument to the `BoxDecoration`.
//
// If there is no intention to render anything on this decoration, consider
// using a [Container] with a [BoxDecoration] instead.
message MaterialInk {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Empty space to inscribe inside the [decoration]. The [child], if any, is
  // placed inside this padding.
  //
  // This padding is in addition to any padding inherent in the [decoration];
  // see [Decoration.padding].
  FlutterEdgeInsetsGeometryType padding = 3;
  DartColorType color = 4;
  FlutterDecorationType decoration = 5;
  // A width to apply to the [decoration] and the [child]. The width includes
  // any [padding].
  double width = 6;
  // A height to apply to the [decoration] and the [child]. The height includes
  // any [padding].
  double height = 7;
  // The [child] contained by the container.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 8;
}

// package:flutter/src/material/ink_well.dart
//
// Creates an area of a [Material] that responds to touch.
//
// Must have an ancestor [Material] widget in which to cause ink reactions.
message MaterialInkResponse {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // Whether this ink response should be clipped its bounds.
  //
  // This flag also controls whether the splash migrates to the center of the
  // [InkResponse] or not. If [containedInkWell] is true, the splash remains
  // centered around the tap location. If it is false, the splash migrates to
  // the center of the [InkResponse] as it grows.
  //
  // See also:
  //
  //  * [highlightShape], the shape of the focus, hover, and pressed
  //    highlights.
  //  * [borderRadius], which controls the corners when the box is a rectangle.
  //  * [getRectCallback], which controls the size and position of the box when
  //    it is a rectangle.
  bool contained_ink_well = 17;
  // The shape (e.g., circle, rectangle) to use for the highlight drawn around
  // this part of the material when pressed, hovered over, or focused.
  //
  // The same shape is used for the pressed highlight (see [highlightColor]),
  // the focus highlight (see [focusColor]), and the hover highlight (see
  // [hoverColor]).
  //
  // If the shape is [BoxShape.circle], then the highlight is centered on the
  // [InkResponse]. If the shape is [BoxShape.rectangle], then the highlight
  // fills the [InkResponse], or the rectangle provided by [getRectCallback] if
  // the callback is specified.
  //
  // See also:
  //
  //  * [containedInkWell], which controls clipping behavior.
  //  * [borderRadius], which controls the corners when the box is a rectangle.
  //  * [highlightColor], the color of the highlight.
  //  * [getRectCallback], which controls the size and position of the box when
  //    it is a rectangle.
  FlutterBoxShapeType.Enum highlight_shape = 18;
  // The radius of the ink splash.
  //
  // Splashes grow up to this size. By default, this size is determined from
  // the size of the rectangle provided by [getRectCallback], or the size of
  // the [InkResponse] itself.
  //
  // See also:
  //
  //  * [splashColor], the color of the splash.
  //  * [splashFactory], which defines the appearance of the splash.
  double radius = 19;
  // The border radius of the containing rectangle. This is effective only if
  // [highlightShape] is [BoxShape.rectangle].
  //
  // If this is null, it is interpreted as [BorderRadius.zero].
  FlutterBorderRadiusType border_radius = 20;
  // The custom clip border.
  //
  // If this is null, the ink response will not clip its content.
  FlutterShapeBorderType custom_border = 21;
  // The color of the ink response when the parent widget is focused. If this
  // property is null then the focus color of the theme,
  // [ThemeData.focusColor], will be used.
  //
  // See also:
  //
  //  * [highlightShape], the shape of the focus, hover, and pressed
  //    highlights.
  //  * [hoverColor], the color of the hover highlight.
  //  * [splashColor], the color of the splash.
  //  * [splashFactory], which defines the appearance of the splash.
  DartColorType focus_color = 22;
  // The color of the ink response when a pointer is hovering over it. If this
  // property is null then the hover color of the theme,
  // [ThemeData.hoverColor], will be used.
  //
  // See also:
  //
  //  * [highlightShape], the shape of the focus, hover, and pressed
  //    highlights.
  //  * [highlightColor], the color of the pressed highlight.
  //  * [focusColor], the color of the focus highlight.
  //  * [splashColor], the color of the splash.
  //  * [splashFactory], which defines the appearance of the splash.
  DartColorType hover_color = 23;
  // The highlight color of the ink response when pressed. If this property is
  // null then the highlight color of the theme, [ThemeData.highlightColor],
  // will be used.
  //
  // See also:
  //
  //  * [hoverColor], the color of the hover highlight.
  //  * [focusColor], the color of the focus highlight.
  //  * [highlightShape], the shape of the focus, hover, and pressed
  //    highlights.
  //  * [splashColor], the color of the splash.
  //  * [splashFactory], which defines the appearance of the splash.
  DartColorType highlight_color = 24;
  // The splash color of the ink response. If this property is null then the
  // splash color of the theme, [ThemeData.splashColor], will be used.
  //
  // See also:
  //
  //  * [splashFactory], which defines the appearance of the splash.
  //  * [radius], the (maximum) size of the ink splash.
  //  * [highlightColor], the color of the highlight.
  DartColorType splash_color = 26;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 28;
  // Whether to exclude the gestures introduced by this widget from the
  // semantics tree.
  //
  // For example, a long-press gesture for showing a tooltip is usually
  // excluded because the tooltip itself is included in the semantics
  // tree directly and so having a gesture to show it would result in
  // duplication of information.
  bool exclude_from_semantics = 29;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 30;
  // {@macro flutter.widgets.Focus.canRequestFocus}
  bool can_request_focus = 31;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 33;
  // {@template flutter.material.inkwell.statesController}
  // Represents the interactive "state" of this widget in terms of
  // a set of [MaterialState]s, like [MaterialState.pressed] and
  // [MaterialState.focused].
  //
  // Classes based on this one can provide their own
  // [MaterialStatesController] to which they've added listeners.
  // They can also update the controller's [MaterialStatesController.value]
  // however, this may only be done when it's safe to call
  // [State.setState], like in an event handler.
  // {@endtemplate}
  MaterialMaterialStatesControllerType states_controller = 34;
  // The duration of the animation that animates the hover effect.
  //
  // The default is 50ms.
  DartDurationType hover_duration = 35;
}

// package:flutter/src/material/ink_well.dart
//
// Creates an ink well.
//
// Must have an ancestor [Material] widget in which to cause ink reactions.
message MaterialInkWell {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // The color of the ink response when the parent widget is focused. If this
  // property is null then the focus color of the theme,
  // [ThemeData.focusColor], will be used.
  //
  // See also:
  //
  //  * [highlightShape], the shape of the focus, hover, and pressed
  //    highlights.
  //  * [hoverColor], the color of the hover highlight.
  //  * [splashColor], the color of the splash.
  //  * [splashFactory], which defines the appearance of the splash.
  DartColorType focus_color = 17;
  // The color of the ink response when a pointer is hovering over it. If this
  // property is null then the hover color of the theme,
  // [ThemeData.hoverColor], will be used.
  //
  // See also:
  //
  //  * [highlightShape], the shape of the focus, hover, and pressed
  //    highlights.
  //  * [highlightColor], the color of the pressed highlight.
  //  * [focusColor], the color of the focus highlight.
  //  * [splashColor], the color of the splash.
  //  * [splashFactory], which defines the appearance of the splash.
  DartColorType hover_color = 18;
  // The highlight color of the ink response when pressed. If this property is
  // null then the highlight color of the theme, [ThemeData.highlightColor],
  // will be used.
  //
  // See also:
  //
  //  * [hoverColor], the color of the hover highlight.
  //  * [focusColor], the color of the focus highlight.
  //  * [highlightShape], the shape of the focus, hover, and pressed
  //    highlights.
  //  * [splashColor], the color of the splash.
  //  * [splashFactory], which defines the appearance of the splash.
  DartColorType highlight_color = 19;
  // The splash color of the ink response. If this property is null then the
  // splash color of the theme, [ThemeData.splashColor], will be used.
  //
  // See also:
  //
  //  * [splashFactory], which defines the appearance of the splash.
  //  * [radius], the (maximum) size of the ink splash.
  //  * [highlightColor], the color of the highlight.
  DartColorType splash_color = 21;
  // The radius of the ink splash.
  //
  // Splashes grow up to this size. By default, this size is determined from
  // the size of the rectangle provided by [getRectCallback], or the size of
  // the [InkResponse] itself.
  //
  // See also:
  //
  //  * [splashColor], the color of the splash.
  //  * [splashFactory], which defines the appearance of the splash.
  double radius = 23;
  // The border radius of the containing rectangle. This is effective only if
  // [highlightShape] is [BoxShape.rectangle].
  //
  // If this is null, it is interpreted as [BorderRadius.zero].
  FlutterBorderRadiusType border_radius = 24;
  // The custom clip border.
  //
  // If this is null, the ink response will not clip its content.
  FlutterShapeBorderType custom_border = 25;
  bool enable_feedback = 26;
  // Whether to exclude the gestures introduced by this widget from the
  // semantics tree.
  //
  // For example, a long-press gesture for showing a tooltip is usually
  // excluded because the tooltip itself is included in the semantics
  // tree directly and so having a gesture to show it would result in
  // duplication of information.
  bool exclude_from_semantics = 27;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 28;
  // {@macro flutter.widgets.Focus.canRequestFocus}
  bool can_request_focus = 29;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 31;
  // {@template flutter.material.inkwell.statesController}
  // Represents the interactive "state" of this widget in terms of
  // a set of [MaterialState]s, like [MaterialState.pressed] and
  // [MaterialState.focused].
  //
  // Classes based on this one can provide their own
  // [MaterialStatesController] to which they've added listeners.
  // They can also update the controller's [MaterialStatesController.value]
  // however, this may only be done when it's safe to call
  // [State.setState], like in an event handler.
  // {@endtemplate}
  MaterialMaterialStatesControllerType states_controller = 32;
  // The duration of the animation that animates the hover effect.
  //
  // The default is 50ms.
  DartDurationType hover_duration = 33;
}

// package:flutter/src/material/input_chip.dart
//
// Creates an [InputChip].
//
// The [onPressed] and [onSelected] callbacks must not both be specified at
// the same time.
//
// The [pressElevation] and [elevation] must be null or non-negative.
// Typically, [pressElevation] is greater than [elevation].
message MaterialInputChip {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  WidgetType avatar = 3;
  WidgetType label = 4;
  FlutterTextStyleType label_style = 5;
  FlutterEdgeInsetsGeometryType label_padding = 6;
  bool selected = 7;
  bool is_enabled = 8;
  WidgetType delete_icon = 10;
  DartColorType delete_icon_color = 12;
  string delete_button_tooltip_message = 13;
  double press_elevation = 15;
  DartColorType disabled_color = 16;
  DartColorType selected_color = 17;
  string tooltip = 18;
  FlutterBorderSideType side = 19;
  FlutterOutlinedBorderType shape = 20;
  DartClipType.Enum clip_behavior = 21;
  FlutterFocusNodeType focus_node = 22;
  bool autofocus = 23;
  DartColorType background_color = 25;
  FlutterEdgeInsetsGeometryType padding = 26;
  MaterialVisualDensityType visual_density = 27;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 28;
  double elevation = 29;
  DartColorType shadow_color = 30;
  DartColorType surface_tint_color = 31;
  FlutterIconThemeDataType icon_theme = 32;
  DartColorType selected_shadow_color = 33;
  bool show_checkmark = 34;
  DartColorType checkmark_color = 35;
  FlutterShapeBorderType avatar_border = 36;
}

// package:flutter/src/material/input_date_picker_form_field.dart
//
// Creates a [TextFormField] configured to accept and validate a date.
//
// If the optional [initialDate] is provided, then it will be used to populate
// the text field. If the [fieldHintText] is provided, it will be shown.
//
// If [initialDate] is provided, it must not be before [firstDate] or after
// [lastDate]. If [selectableDayPredicate] is provided, it must return `true`
// for [initialDate].
//
// [firstDate] must be on or before [lastDate].
message MaterialInputDatePickerFormField {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  DartDateTimeType initial_date = 3;
  DartDateTimeType first_date = 4;
  DartDateTimeType last_date = 5;
  // The error text displayed if the entered date is not in the correct format.
  string error_format_text = 9;
  // The error text displayed if the date is not valid.
  //
  // A date is not valid if it is earlier than [firstDate], later than
  // [lastDate], or doesn't pass the [selectableDayPredicate].
  string error_invalid_text = 10;
  // The hint text displayed in the [TextField].
  //
  // If this is null, it will default to the date format string. For example,
  // 'mm/dd/yyyy' for en_US.
  string field_hint_text = 11;
  // The label text displayed in the [TextField].
  //
  // If this is null, it will default to the words representing the date format
  // string. For example, 'Month, Day, Year' for en_US.
  string field_label_text = 12;
  // The keyboard type of the [TextField].
  //
  // If this is null, it will default to [TextInputType.datetime]
  FlutterTextInputTypeType keyboard_type = 13;
  // {@macro flutter.widgets.editableText.autofocus}
  bool autofocus = 14;
  // Determines if an empty date would show [errorFormatText] or not.
  //
  // Defaults to false.
  //
  // If true, [errorFormatText] is not shown when the date input field is empty.
  bool accept_empty_date = 15;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 16;
}

// package:flutter/src/material/input_decorator.dart
//
// Creates a bundle of the border, labels, icons, and styles used to
// decorate a Material Design text field.
//
// Unless specified by [ThemeData.inputDecorationTheme], [InputDecorator]
// defaults [isDense] to false and [filled] to false. The default border is
// an instance of [UnderlineInputBorder]. If [border] is [InputBorder.none]
// then no border is drawn.
//
// Only one of [prefix] and [prefixText] can be specified.
//
// Similarly, only one of [suffix] and [suffixText] can be specified.
message MaterialInputDecoration {
  // An icon to show before the input field and outside of the decoration's
  // container.
  //
  // The size and color of the icon is configured automatically using an
  // [IconTheme] and therefore does not need to be explicitly given in the
  // icon widget.
  //
  // The trailing edge of the icon is padded by 16dps.
  //
  // The decoration's container is the area which is filled if [filled] is
  // true and bordered per the [border]. It's the area adjacent to
  // [icon] and above the widgets that contain [helperText],
  // [errorText], and [counterText].
  //
  // See [Icon], [ImageIcon].
  WidgetType icon = 2;
  // The color of the [icon].
  //
  // If [iconColor] is a [MaterialStateColor], then the effective
  // color can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  DartColorType icon_color = 3;
  // Optional widget that describes the input field.
  //
  // {@template flutter.material.inputDecoration.label}
  // When the input field is empty and unfocused, the label is displayed on
  // top of the input field (i.e., at the same location on the screen where
  // text may be entered in the input field). When the input field receives
  // focus (or if the field is non-empty), depending on [floatingLabelAlignment],
  // the label moves above, either vertically adjacent to, or to the center of
  // the input field.
  // {@endtemplate}
  //
  // This can be used, for example, to add multiple [TextStyle]'s to a label that would
  // otherwise be specified using [labelText], which only takes one [TextStyle].
  //
  // {@tool dartpad}
  // This example shows a `TextField` with a [Text.rich] widget as the [label].
  // The widget contains multiple [Text] widgets with different [TextStyle]'s.
  //
  // ** See code in examples/api/lib/material/input_decorator/input_decoration.label.0.dart **
  // {@end-tool}
  //
  // Only one of [label] and [labelText] can be specified.
  WidgetType label = 4;
  // Optional text that describes the input field.
  //
  // {@macro flutter.material.inputDecoration.label}
  //
  // If a more elaborate label is required, consider using [label] instead.
  // Only one of [label] and [labelText] can be specified.
  string label_text = 5;
  // {@template flutter.material.inputDecoration.labelStyle}
  // The style to use for [InputDecoration.labelText] when the label is on top
  // of the input field.
  //
  // If [labelStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // When the [InputDecoration.labelText] is above (i.e., vertically adjacent to)
  // the input field, the text uses the [floatingLabelStyle] instead.
  //
  // If null, defaults to a value derived from the base [TextStyle] for the
  // input field and the current [Theme].
  //
  // Specifying this style will override the default behavior
  // of [InputDecoration] that changes the color of the label to the
  // [InputDecoration.errorStyle] color or [ColorScheme.error].
  //
  // {@tool dartpad}
  // It's possible to override the label style for just the error state, or
  // just the default state, or both.
  //
  // In this example the [labelStyle] is specified with a [MaterialStateProperty]
  // which resolves to a text style whose color depends on the decorator's
  // error state.
  //
  // ** See code in examples/api/lib/material/input_decorator/input_decoration.label_style_error.0.dart **
  // {@end-tool}
  // {@endtemplate}
  FlutterTextStyleType label_style = 6;
  // {@template flutter.material.inputDecoration.floatingLabelStyle}
  // The style to use for [InputDecoration.labelText] when the label is
  // above (i.e., vertically adjacent to) the input field.
  //
  // When the [InputDecoration.labelText] is on top of the input field, the
  // text uses the [labelStyle] instead.
  //
  // If [floatingLabelStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to [labelStyle].
  //
  // Specifying this style will override the default behavior
  // of [InputDecoration] that changes the color of the label to the
  // [InputDecoration.errorStyle] color or [ColorScheme.error].
  //
  // {@tool dartpad}
  // It's possible to override the label style for just the error state, or
  // just the default state, or both.
  //
  // In this example the [floatingLabelStyle] is specified with a
  // [MaterialStateProperty] which resolves to a text style whose color depends
  // on the decorator's error state.
  //
  // ** See code in examples/api/lib/material/input_decorator/input_decoration.floating_label_style_error.0.dart **
  // {@end-tool}
  // {@endtemplate}
  FlutterTextStyleType floating_label_style = 7;
  // Text that provides context about the [InputDecorator.child]'s value, such
  // as how the value will be used.
  //
  // If non-null, the text is displayed below the [InputDecorator.child], in
  // the same location as [errorText]. If a non-null [errorText] value is
  // specified then the helper text is not shown.
  string helper_text = 8;
  // The style to use for the [helperText].
  //
  // If [helperStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  FlutterTextStyleType helper_style = 9;
  // The maximum number of lines the [helperText] can occupy.
  //
  // Defaults to null, which means that the [helperText] will be limited
  // to a single line with [TextOverflow.ellipsis].
  //
  // This value is passed along to the [Text.maxLines] attribute
  // of the [Text] widget used to display the helper.
  //
  // See also:
  //
  //  * [errorMaxLines], the equivalent but for the [errorText].
  int32 helper_max_lines = 10;
  // Text that suggests what sort of input the field accepts.
  //
  // Displayed on top of the [InputDecorator.child] (i.e., at the same location
  // on the screen where text may be entered in the [InputDecorator.child])
  // when the input [isEmpty] and either (a) [labelText] is null or (b) the
  // input has the focus.
  string hint_text = 11;
  // The style to use for the [hintText].
  //
  // If [hintStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // Also used for the [labelText] when the [labelText] is displayed on
  // top of the input field (i.e., at the same location on the screen where
  // text may be entered in the [InputDecorator.child]).
  //
  // If null, defaults to a value derived from the base [TextStyle] for the
  // input field and the current [Theme].
  FlutterTextStyleType hint_style = 12;
  // The direction to use for the [hintText].
  //
  // If null, defaults to a value derived from [Directionality] for the
  // input field and the current context.
  DartTextDirectionType.Enum hint_text_direction = 13;
  // The maximum number of lines the [hintText] can occupy.
  //
  // Defaults to the value of [TextField.maxLines] attribute.
  //
  // This value is passed along to the [Text.maxLines] attribute
  // of the [Text] widget used to display the hint text. [TextOverflow.ellipsis] is
  // used to handle the overflow when it is limited to single line.
  int32 hint_max_lines = 14;
  // The duration of the [hintText] fade in and fade out animations.
  //
  // If null, defaults to [InputDecorationTheme.hintFadeDuration].
  // If [InputDecorationTheme.hintFadeDuration] is null defaults to 20ms.
  DartDurationType hint_fade_duration = 15;
  // Optional widget that appears below the [InputDecorator.child] and the border.
  //
  // If non-null, the border's color animates to red and the [helperText] is not shown.
  //
  // Only one of [error] and [errorText] can be specified.
  WidgetType error = 16;
  // Text that appears below the [InputDecorator.child] and the border.
  //
  // If non-null, the border's color animates to red and the [helperText] is
  // not shown.
  //
  // In a [TextFormField], this is overridden by the value returned from
  // [TextFormField.validator], if that is not null.
  //
  // If a more elaborate error is required, consider using [error] instead.
  //
  // Only one of [error] and [errorText] can be specified.
  string error_text = 17;
  // {@template flutter.material.inputDecoration.errorStyle}
  // The style to use for the [InputDecoration.errorText].
  //
  // If null, defaults of a value derived from the base [TextStyle] for the
  // input field and the current [Theme].
  //
  // By default the color of style will be used by the label of
  // [InputDecoration] if [InputDecoration.errorText] is not null. See
  // [InputDecoration.labelStyle] or [InputDecoration.floatingLabelStyle] for
  // an example of how to replicate this behavior when specifying those
  // styles.
  // {@endtemplate}
  FlutterTextStyleType error_style = 18;
  // The maximum number of lines the [errorText] can occupy.
  //
  // Defaults to null, which means that the [errorText] will be limited
  // to a single line with [TextOverflow.ellipsis].
  //
  // This value is passed along to the [Text.maxLines] attribute
  // of the [Text] widget used to display the error.
  //
  // See also:
  //
  //  * [helperMaxLines], the equivalent but for the [helperText].
  int32 error_max_lines = 19;
  // {@template flutter.material.inputDecoration.floatingLabelBehavior}
  // Defines **how** the floating label should behave.
  //
  // When [FloatingLabelBehavior.auto] the label will float to the top only when
  // the field is focused or has some text content, otherwise it will appear
  // in the field in place of the content.
  //
  // When [FloatingLabelBehavior.always] the label will always float at the top
  // of the field above the content.
  //
  // When [FloatingLabelBehavior.never] the label will always appear in an empty
  // field in place of the content.
  // {@endtemplate}
  //
  // If null, [InputDecorationTheme.floatingLabelBehavior] will be used.
  //
  // See also:
  //
  //  * [floatingLabelAlignment] which defines **where** the floating label
  //    should be displayed.
  MaterialFloatingLabelBehaviorType.Enum floating_label_behavior = 20;
  // Whether the decoration is the same size as the input field.
  //
  // A collapsed decoration cannot have [labelText], [errorText], an [icon].
  //
  // To create a collapsed input decoration, use [InputDecoration.collapsed].
  bool is_collapsed = 22;
  // Whether the [InputDecorator.child] is part of a dense form (i.e., uses less vertical
  // space).
  //
  // Defaults to false.
  bool is_dense = 23;
  // The padding for the input decoration's container.
  //
  // {@macro flutter.material.input_decorator.container_description}
  //
  // By default the [contentPadding] reflects [isDense] and the type of the
  // [border].
  //
  // If [isCollapsed] is true then [contentPadding] is [EdgeInsets.zero].
  //
  // If `isOutline` property of [border] is false and if [filled] is true then
  // [contentPadding] is `EdgeInsets.fromLTRB(12, 8, 12, 8)` when [isDense]
  // is true and `EdgeInsets.fromLTRB(12, 12, 12, 12)` when [isDense] is false.
  // If `isOutline` property of [border] is false and if [filled] is false then
  // [contentPadding] is `EdgeInsets.fromLTRB(0, 8, 0, 8)` when [isDense] is
  // true and `EdgeInsets.fromLTRB(0, 12, 0, 12)` when [isDense] is false.
  //
  // If `isOutline` property of [border] is true then [contentPadding] is
  // `EdgeInsets.fromLTRB(12, 20, 12, 12)` when [isDense] is true
  // and `EdgeInsets.fromLTRB(12, 24, 12, 16)` when [isDense] is false.
  FlutterEdgeInsetsGeometryType content_padding = 24;
  // An icon that appears before the [prefix] or [prefixText] and before
  // the editable part of the text field, within the decoration's container.
  //
  // The size and color of the prefix icon is configured automatically using an
  // [IconTheme] and therefore does not need to be explicitly given in the
  // icon widget.
  //
  // The prefix icon is constrained with a minimum size of 48px by 48px, but
  // can be expanded beyond that. Anything larger than 24px will require
  // additional padding to ensure it matches the Material Design spec of 12px
  // padding between the left edge of the input and leading edge of the prefix
  // icon. The following snippet shows how to pad the leading edge of the
  // prefix icon:
  //
  // ```dart
  // prefixIcon: Padding(
  //   padding: const EdgeInsetsDirectional.only(start: 12.0),
  //   child: _myIcon, // _myIcon is a 48px-wide widget.
  // )
  // ```
  //
  // {@macro flutter.material.input_decorator.container_description}
  //
  // The prefix icon alignment can be changed using [Align] with a fixed `widthFactor` and
  // `heightFactor`.
  //
  // {@tool dartpad}
  // This example shows how the prefix icon alignment can be changed using [Align] with
  // a fixed `widthFactor` and `heightFactor`.
  //
  // ** See code in examples/api/lib/material/input_decorator/input_decoration.prefix_icon.0.dart **
  // {@end-tool}
  //
  // See also:
  //
  //  * [Icon] and [ImageIcon], which are typically used to show icons.
  //  * [prefix] and [prefixText], which are other ways to show content
  //    before the text field (but after the icon).
  //  * [suffixIcon], which is the same but on the trailing edge.
  //  * [Align] A widget that aligns its child within itself and optionally
  //    sizes itself based on the child's size.
  WidgetType prefix_icon = 25;
  // The constraints for the prefix icon.
  //
  // This can be used to modify the [BoxConstraints] surrounding [prefixIcon].
  //
  // This property is particularly useful for getting the decoration's height
  // less than 48px. This can be achieved by setting [isDense] to true and
  // setting the constraints' minimum height and width to a value lower than
  // 48px.
  //
  // {@tool dartpad}
  // This example shows the differences between two `TextField` widgets when
  // [prefixIconConstraints] is set to the default value and when one is not.
  //
  // The [isDense] property must be set to true to be able to
  // set the constraints smaller than 48px.
  //
  // If null, [BoxConstraints] with a minimum width and height of 48px is
  // used.
  //
  // ** See code in examples/api/lib/material/input_decorator/input_decoration.prefix_icon_constraints.0.dart **
  // {@end-tool}
  FlutterBoxConstraintsType prefix_icon_constraints = 26;
  // Optional widget to place on the line before the input.
  //
  // This can be used, for example, to add some padding to text that would
  // otherwise be specified using [prefixText], or to add a custom widget in
  // front of the input. The widget's baseline is lined up with the input
  // baseline.
  //
  // Only one of [prefix] and [prefixText] can be specified.
  //
  // The [prefix] appears after the [prefixIcon], if both are specified.
  //
  // See also:
  //
  //  * [suffix], the equivalent but on the trailing edge.
  WidgetType prefix = 27;
  // Optional text prefix to place on the line before the input.
  //
  // Uses the [prefixStyle]. Uses [hintStyle] if [prefixStyle] isn't specified.
  // The prefix text is not returned as part of the user's input.
  //
  // If a more elaborate prefix is required, consider using [prefix] instead.
  // Only one of [prefix] and [prefixText] can be specified.
  //
  // The [prefixText] appears after the [prefixIcon], if both are specified.
  //
  // See also:
  //
  //  * [suffixText], the equivalent but on the trailing edge.
  string prefix_text = 28;
  // The style to use for the [prefixText].
  //
  // If [prefixStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to the [hintStyle].
  //
  // See also:
  //
  //  * [suffixStyle], the equivalent but on the trailing edge.
  FlutterTextStyleType prefix_style = 29;
  // Optional color of the prefixIcon
  //
  // Defaults to [iconColor]
  //
  // If [prefixIconColor] is a [MaterialStateColor], then the effective
  // color can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  DartColorType prefix_icon_color = 30;
  // An icon that appears after the editable part of the text field and
  // after the [suffix] or [suffixText], within the decoration's container.
  //
  // The size and color of the suffix icon is configured automatically using an
  // [IconTheme] and therefore does not need to be explicitly given in the
  // icon widget.
  //
  // The suffix icon is constrained with a minimum size of 48px by 48px, but
  // can be expanded beyond that. Anything larger than 24px will require
  // additional padding to ensure it matches the Material Design spec of 12px
  // padding between the right edge of the input and trailing edge of the
  // prefix icon. The following snippet shows how to pad the trailing edge of
  // the suffix icon:
  //
  // ```dart
  // suffixIcon: Padding(
  //   padding: const EdgeInsetsDirectional.only(end: 12.0),
  //   child: _myIcon, // myIcon is a 48px-wide widget.
  // )
  // ```
  //
  // The decoration's container is the area which is filled if [filled] is
  // true and bordered per the [border]. It's the area adjacent to
  // [icon] and above the widgets that contain [helperText],
  // [errorText], and [counterText].
  //
  // The suffix icon alignment can be changed using [Align] with a fixed `widthFactor` and
  // `heightFactor`.
  //
  // {@tool dartpad}
  // This example shows how the suffix icon alignment can be changed using [Align] with
  // a fixed `widthFactor` and `heightFactor`.
  //
  // ** See code in examples/api/lib/material/input_decorator/input_decoration.suffix_icon.0.dart **
  // {@end-tool}
  //
  // See also:
  //
  //  * [Icon] and [ImageIcon], which are typically used to show icons.
  //  * [suffix] and [suffixText], which are other ways to show content
  //    after the text field (but before the icon).
  //  * [prefixIcon], which is the same but on the leading edge.
  //  * [Align] A widget that aligns its child within itself and optionally
  //    sizes itself based on the child's size.
  WidgetType suffix_icon = 31;
  // Optional widget to place on the line after the input.
  //
  // This can be used, for example, to add some padding to the text that would
  // otherwise be specified using [suffixText], or to add a custom widget after
  // the input. The widget's baseline is lined up with the input baseline.
  //
  // Only one of [suffix] and [suffixText] can be specified.
  //
  // The [suffix] appears before the [suffixIcon], if both are specified.
  //
  // See also:
  //
  //  * [prefix], the equivalent but on the leading edge.
  WidgetType suffix = 32;
  // Optional text suffix to place on the line after the input.
  //
  // Uses the [suffixStyle]. Uses [hintStyle] if [suffixStyle] isn't specified.
  // The suffix text is not returned as part of the user's input.
  //
  // If a more elaborate suffix is required, consider using [suffix] instead.
  // Only one of [suffix] and [suffixText] can be specified.
  //
  // The [suffixText] appears before the [suffixIcon], if both are specified.
  //
  // See also:
  //
  //  * [prefixText], the equivalent but on the leading edge.
  string suffix_text = 33;
  // The style to use for the [suffixText].
  //
  // If [suffixStyle] is a [MaterialStateTextStyle], then the effective text
  // style can depend on the [MaterialState.focused] state, i.e. if the
  // [TextField] is focused or not.
  //
  // If null, defaults to the [hintStyle].
  //
  // See also:
  //
  //  * [prefixStyle], the equivalent but on the leading edge.
  FlutterTextStyleType suffix_style = 34;
  // Optional color of the [suffixIcon].
  //
  // Defaults to [iconColor]
  //
  // If [suffixIconColor] is a [MaterialStateColor], then the effective
  // color can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  DartColorType suffix_icon_color = 35;
  // The constraints for the suffix icon.
  //
  // This can be used to modify the [BoxConstraints] surrounding [suffixIcon].
  //
  // This property is particularly useful for getting the decoration's height
  // less than 48px. This can be achieved by setting [isDense] to true and
  // setting the constraints' minimum height and width to a value lower than
  // 48px.
  //
  // If null, a [BoxConstraints] with a minimum width and height of 48px is
  // used.
  //
  // {@tool dartpad}
  // This example shows the differences between two `TextField` widgets when
  // [suffixIconConstraints] is set to the default value and when one is not.
  //
  // The [isDense] property must be set to true to be able to
  // set the constraints smaller than 48px.
  //
  // If null, [BoxConstraints] with a minimum width and height of 48px is
  // used.
  //
  // ** See code in examples/api/lib/material/input_decorator/input_decoration.suffix_icon_constraints.0.dart **
  // {@end-tool}
  FlutterBoxConstraintsType suffix_icon_constraints = 36;
  // Optional custom counter widget to go in the place otherwise occupied by
  // [counterText]. If this property is non null, then [counterText] is
  // ignored.
  WidgetType counter = 37;
  // Optional text to place below the line as a character count.
  //
  // Rendered using [counterStyle]. Uses [helperStyle] if [counterStyle] is
  // null.
  //
  // The semantic label can be replaced by providing a [semanticCounterText].
  //
  // If null or an empty string and [counter] isn't specified, then nothing
  // will appear in the counter's location.
  string counter_text = 38;
  // The style to use for the [counterText].
  //
  // If [counterStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to the [helperStyle].
  FlutterTextStyleType counter_style = 39;
  // If true the decoration's container is filled with [fillColor].
  //
  // When [InputDecorator.isHovering] is true, the [hoverColor] is also blended
  // into the final fill color.
  //
  // Typically this field set to true if [border] is an [UnderlineInputBorder].
  //
  // {@template flutter.material.input_decorator.container_description}
  // The decoration's container is the area which is filled if [filled] is true
  // and bordered per the [border]. It's the area adjacent to [icon] and above
  // the widgets that contain [helperText], [errorText], and [counterText].
  // {@endtemplate}
  //
  // This property is false by default.
  bool filled = 40;
  // The base fill color of the decoration's container color.
  //
  // When [InputDecorator.isHovering] is true, the [hoverColor] is also blended
  // into the final fill color.
  //
  // By default the [fillColor] is based on the current
  // [InputDecorationTheme.fillColor].
  //
  // {@macro flutter.material.input_decorator.container_description}
  DartColorType fill_color = 41;
  // The fill color of the decoration's container when it has the input focus.
  //
  // By default the [focusColor] is based on the current
  // [InputDecorationTheme.focusColor].
  //
  // This [focusColor] is ignored by [TextField] and [TextFormField] because
  // they don't respond to focus changes by changing their decorator's
  // container color, they respond by changing their border to the
  // [focusedBorder], which you can change the color of.
  //
  // {@macro flutter.material.input_decorator.container_description}
  DartColorType focus_color = 42;
  // The color of the highlight for the decoration shown if the container
  // is being hovered over by a mouse.
  //
  // If [filled] is true, the [hoverColor] is blended with [fillColor] and
  // fills the decoration's container.
  //
  // If [filled] is false, and [InputDecorator.isFocused] is false, the color
  // is blended over the [enabledBorder]'s color.
  //
  // By default the [hoverColor] is based on the current [Theme].
  //
  // {@macro flutter.material.input_decorator.container_description}
  DartColorType hover_color = 43;
  // The border to display when the [InputDecorator] does not have the focus and
  // is showing an error.
  //
  // See also:
  //
  //  * [InputDecorator.isFocused], which is true if the [InputDecorator]'s child
  //    has the focus.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [focusedBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is null.
  //  * [focusedErrorBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is non-null.
  //  * [disabledBorder], displayed when [InputDecoration.enabled] is false
  //    and [InputDecoration.errorText] is null.
  //  * [enabledBorder], displayed when [InputDecoration.enabled] is true
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType error_border = 44;
  // The border to display when the [InputDecorator] has the focus and is not
  // showing an error.
  //
  // See also:
  //
  //  * [InputDecorator.isFocused], which is true if the [InputDecorator]'s child
  //    has the focus.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [errorBorder], displayed when [InputDecorator.isFocused] is false
  //    and [InputDecoration.errorText] is non-null.
  //  * [focusedErrorBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is non-null.
  //  * [disabledBorder], displayed when [InputDecoration.enabled] is false
  //    and [InputDecoration.errorText] is null.
  //  * [enabledBorder], displayed when [InputDecoration.enabled] is true
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType focused_border = 45;
  // The border to display when the [InputDecorator] has the focus and is
  // showing an error.
  //
  // See also:
  //
  //  * [InputDecorator.isFocused], which is true if the [InputDecorator]'s child
  //    has the focus.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [errorBorder], displayed when [InputDecorator.isFocused] is false
  //    and [InputDecoration.errorText] is non-null.
  //  * [focusedBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is null.
  //  * [disabledBorder], displayed when [InputDecoration.enabled] is false
  //    and [InputDecoration.errorText] is null.
  //  * [enabledBorder], displayed when [InputDecoration.enabled] is true
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType focused_error_border = 46;
  // The border to display when the [InputDecorator] is disabled and is not
  // showing an error.
  //
  // See also:
  //
  //  * [InputDecoration.enabled], which is false if the [InputDecorator] is disabled.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [errorBorder], displayed when [InputDecorator.isFocused] is false
  //    and [InputDecoration.errorText] is non-null.
  //  * [focusedBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is null.
  //  * [focusedErrorBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is non-null.
  //  * [enabledBorder], displayed when [InputDecoration.enabled] is true
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType disabled_border = 47;
  // The border to display when the [InputDecorator] is enabled and is not
  // showing an error.
  //
  // See also:
  //
  //  * [InputDecoration.enabled], which is false if the [InputDecorator] is disabled.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [errorBorder], displayed when [InputDecorator.isFocused] is false
  //    and [InputDecoration.errorText] is non-null.
  //  * [focusedBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is null.
  //  * [focusedErrorBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is non-null.
  //  * [disabledBorder], displayed when [InputDecoration.enabled] is false
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType enabled_border = 48;
  // The shape of the border to draw around the decoration's container.
  //
  // If [border] is a [MaterialStateUnderlineInputBorder]
  // or [MaterialStateOutlineInputBorder], then the effective border can depend on
  // the [MaterialState.focused] state, i.e. if the [TextField] is focused or not.
  //
  // If [border] derives from [InputBorder] the border's [InputBorder.borderSide],
  // i.e. the border's color and width, will be overridden to reflect the input
  // decorator's state. Only the border's shape is used. If custom  [BorderSide]
  // values are desired for a given state, all four borders  [errorBorder],
  // [focusedBorder], [enabledBorder], [disabledBorder]  must be set.
  //
  // The decoration's container is the area which is filled if [filled] is
  // true and bordered per the [border]. It's the area adjacent to
  // [InputDecoration.icon] and above the widgets that contain
  // [InputDecoration.helperText], [InputDecoration.errorText], and
  // [InputDecoration.counterText].
  //
  // The border's bounds, i.e. the value of `border.getOuterPath()`, define
  // the area to be filled.
  //
  // This property is only used when the appropriate one of [errorBorder],
  // [focusedBorder], [focusedErrorBorder], [disabledBorder], or [enabledBorder]
  // is not specified. This border's [InputBorder.borderSide] property is
  // configured by the InputDecorator, depending on the values of
  // [InputDecoration.errorText], [InputDecoration.enabled],
  // [InputDecorator.isFocused] and the current [Theme].
  //
  // Typically one of [UnderlineInputBorder] or [OutlineInputBorder].
  // If null, InputDecorator's default is `const UnderlineInputBorder()`.
  //
  // See also:
  //
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [UnderlineInputBorder], which draws a horizontal line at the
  //    bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  MaterialInputBorderType border = 49;
  // If false [helperText],[errorText], and [counterText] are not displayed,
  // and the opacity of the remaining visual elements is reduced.
  //
  // This property is true by default.
  bool enabled = 50;
  // A semantic label for the [counterText].
  //
  // Defaults to null.
  //
  // If provided, this replaces the semantic label of the [counterText].
  string semantic_counter_text = 51;
  // Typically set to true when the [InputDecorator] contains a multiline
  // [TextField] ([TextField.maxLines] is null or > 1) to override the default
  // behavior of aligning the label with the center of the [TextField].
  //
  // Defaults to false.
  bool align_label_with_hint = 52;
  // Defines minimum and maximum sizes for the [InputDecorator].
  //
  // Typically the decorator will fill the horizontal space it is given. For
  // larger screens, it may be useful to have the maximum width clamped to
  // a given value so it doesn't fill the whole screen. This property
  // allows you to control how big the decorator will be in its available
  // space.
  //
  // If null, then the ambient [ThemeData.inputDecorationTheme]'s
  // [InputDecorationTheme.constraints] will be used. If that
  // is null then the decorator will fill the available width with
  // a default height based on text size.
  FlutterBoxConstraintsType constraints = 53;
}

// package:flutter/src/material/input_decorator.dart
//
// Defines an [InputDecorator] that is the same size as the input field.
//
// This type of input decoration does not include a border by default.
//
// Sets the [isCollapsed] property to true.
message MaterialInputDecorationNamedCollapsed {
  // Text that suggests what sort of input the field accepts.
  //
  // Displayed on top of the [InputDecorator.child] (i.e., at the same location
  // on the screen where text may be entered in the [InputDecorator.child])
  // when the input [isEmpty] and either (a) [labelText] is null or (b) the
  // input has the focus.
  string hint_text = 2;
  // {@template flutter.material.inputDecoration.floatingLabelBehavior}
  // Defines **how** the floating label should behave.
  //
  // When [FloatingLabelBehavior.auto] the label will float to the top only when
  // the field is focused or has some text content, otherwise it will appear
  // in the field in place of the content.
  //
  // When [FloatingLabelBehavior.always] the label will always float at the top
  // of the field above the content.
  //
  // When [FloatingLabelBehavior.never] the label will always appear in an empty
  // field in place of the content.
  // {@endtemplate}
  //
  // If null, [InputDecorationTheme.floatingLabelBehavior] will be used.
  //
  // See also:
  //
  //  * [floatingLabelAlignment] which defines **where** the floating label
  //    should be displayed.
  MaterialFloatingLabelBehaviorType.Enum floating_label_behavior = 3;
  // The style to use for the [hintText].
  //
  // If [hintStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // Also used for the [labelText] when the [labelText] is displayed on
  // top of the input field (i.e., at the same location on the screen where
  // text may be entered in the [InputDecorator.child]).
  //
  // If null, defaults to a value derived from the base [TextStyle] for the
  // input field and the current [Theme].
  FlutterTextStyleType hint_style = 5;
  // The direction to use for the [hintText].
  //
  // If null, defaults to a value derived from [Directionality] for the
  // input field and the current context.
  DartTextDirectionType.Enum hint_text_direction = 6;
  // If true the decoration's container is filled with [fillColor].
  //
  // When [InputDecorator.isHovering] is true, the [hoverColor] is also blended
  // into the final fill color.
  //
  // Typically this field set to true if [border] is an [UnderlineInputBorder].
  //
  // {@template flutter.material.input_decorator.container_description}
  // The decoration's container is the area which is filled if [filled] is true
  // and bordered per the [border]. It's the area adjacent to [icon] and above
  // the widgets that contain [helperText], [errorText], and [counterText].
  // {@endtemplate}
  //
  // This property is false by default.
  bool filled = 7;
  // The base fill color of the decoration's container color.
  //
  // When [InputDecorator.isHovering] is true, the [hoverColor] is also blended
  // into the final fill color.
  //
  // By default the [fillColor] is based on the current
  // [InputDecorationTheme.fillColor].
  //
  // {@macro flutter.material.input_decorator.container_description}
  DartColorType fill_color = 8;
  // The fill color of the decoration's container when it has the input focus.
  //
  // By default the [focusColor] is based on the current
  // [InputDecorationTheme.focusColor].
  //
  // This [focusColor] is ignored by [TextField] and [TextFormField] because
  // they don't respond to focus changes by changing their decorator's
  // container color, they respond by changing their border to the
  // [focusedBorder], which you can change the color of.
  //
  // {@macro flutter.material.input_decorator.container_description}
  DartColorType focus_color = 9;
  // The color of the highlight for the decoration shown if the container
  // is being hovered over by a mouse.
  //
  // If [filled] is true, the [hoverColor] is blended with [fillColor] and
  // fills the decoration's container.
  //
  // If [filled] is false, and [InputDecorator.isFocused] is false, the color
  // is blended over the [enabledBorder]'s color.
  //
  // By default the [hoverColor] is based on the current [Theme].
  //
  // {@macro flutter.material.input_decorator.container_description}
  DartColorType hover_color = 10;
  // The shape of the border to draw around the decoration's container.
  //
  // If [border] is a [MaterialStateUnderlineInputBorder]
  // or [MaterialStateOutlineInputBorder], then the effective border can depend on
  // the [MaterialState.focused] state, i.e. if the [TextField] is focused or not.
  //
  // If [border] derives from [InputBorder] the border's [InputBorder.borderSide],
  // i.e. the border's color and width, will be overridden to reflect the input
  // decorator's state. Only the border's shape is used. If custom  [BorderSide]
  // values are desired for a given state, all four borders  [errorBorder],
  // [focusedBorder], [enabledBorder], [disabledBorder]  must be set.
  //
  // The decoration's container is the area which is filled if [filled] is
  // true and bordered per the [border]. It's the area adjacent to
  // [InputDecoration.icon] and above the widgets that contain
  // [InputDecoration.helperText], [InputDecoration.errorText], and
  // [InputDecoration.counterText].
  //
  // The border's bounds, i.e. the value of `border.getOuterPath()`, define
  // the area to be filled.
  //
  // This property is only used when the appropriate one of [errorBorder],
  // [focusedBorder], [focusedErrorBorder], [disabledBorder], or [enabledBorder]
  // is not specified. This border's [InputBorder.borderSide] property is
  // configured by the InputDecorator, depending on the values of
  // [InputDecoration.errorText], [InputDecoration.enabled],
  // [InputDecorator.isFocused] and the current [Theme].
  //
  // Typically one of [UnderlineInputBorder] or [OutlineInputBorder].
  // If null, InputDecorator's default is `const UnderlineInputBorder()`.
  //
  // See also:
  //
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [UnderlineInputBorder], which draws a horizontal line at the
  //    bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  MaterialInputBorderType border = 11;
  // If false [helperText],[errorText], and [counterText] are not displayed,
  // and the opacity of the remaining visual elements is reduced.
  //
  // This property is true by default.
  bool enabled = 12;
}

// package:flutter/src/material/input_decorator.dart
//
// Creates a value for [ThemeData.inputDecorationTheme] that
// defines default values for [InputDecorator].
message MaterialInputDecorationTheme {
  // {@macro flutter.material.inputDecoration.labelStyle}
  FlutterTextStyleType label_style = 2;
  // {@macro flutter.material.inputDecoration.floatingLabelStyle}
  FlutterTextStyleType floating_label_style = 3;
  // The style to use for [InputDecoration.helperText].
  //
  // If [helperStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  FlutterTextStyleType helper_style = 4;
  // The maximum number of lines the [InputDecoration.helperText] can occupy.
  //
  // Defaults to null, which means that the [InputDecoration.helperText] will
  // be limited to a single line with [TextOverflow.ellipsis].
  //
  // This value is passed along to the [Text.maxLines] attribute
  // of the [Text] widget used to display the helper.
  //
  // See also:
  //
  //  * [errorMaxLines], the equivalent but for the [InputDecoration.errorText].
  int32 helper_max_lines = 5;
  // The style to use for the [InputDecoration.hintText].
  //
  // If [hintStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // Also used for the [InputDecoration.labelText] when the
  // [InputDecoration.labelText] is displayed on top of the input field (i.e.,
  // at the same location on the screen where text may be entered in the input
  // field).
  //
  // If null, defaults to a value derived from the base [TextStyle] for the
  // input field and the current [Theme].
  FlutterTextStyleType hint_style = 6;
  // The duration of the [InputDecoration.hintText] fade in and fade out animations.
  DartDurationType hint_fade_duration = 7;
  // {@macro flutter.material.inputDecoration.errorStyle}
  FlutterTextStyleType error_style = 8;
  // The maximum number of lines the [InputDecoration.errorText] can occupy.
  //
  // Defaults to null, which means that the [InputDecoration.errorText] will be
  // limited to a single line with [TextOverflow.ellipsis].
  //
  // This value is passed along to the [Text.maxLines] attribute
  // of the [Text] widget used to display the error.
  //
  // See also:
  //
  //  * [helperMaxLines], the equivalent but for the [InputDecoration.helperText].
  int32 error_max_lines = 9;
  // {@macro flutter.material.inputDecoration.floatingLabelBehavior}
  //
  // Defaults to [FloatingLabelBehavior.auto].
  MaterialFloatingLabelBehaviorType.Enum floating_label_behavior = 10;
  // Whether the input decorator's child is part of a dense form (i.e., uses
  // less vertical space).
  //
  // Defaults to false.
  bool is_dense = 12;
  // The padding for the input decoration's container.
  //
  // The decoration's container is the area which is filled if
  // [InputDecoration.filled] is true and bordered per the [border].
  // It's the area adjacent to [InputDecoration.icon] and above the
  // [InputDecoration.icon] and above the widgets that contain
  // [InputDecoration.helperText], [InputDecoration.errorText], and
  // [InputDecoration.counterText].
  //
  // By default the [contentPadding] reflects [isDense] and the type of the
  // [border]. If [isCollapsed] is true then [contentPadding] is
  // [EdgeInsets.zero].
  FlutterEdgeInsetsGeometryType content_padding = 13;
  // Whether the decoration is the same size as the input field.
  //
  // A collapsed decoration cannot have [InputDecoration.labelText],
  // [InputDecoration.errorText], or an [InputDecoration.icon].
  bool is_collapsed = 14;
  // The Color to use for the [InputDecoration.icon].
  //
  // If [iconColor] is a [MaterialStateColor], then the effective
  // color can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to the [ColorScheme.primary].
  DartColorType icon_color = 15;
  // The style to use for the [InputDecoration.prefixText].
  //
  // If [prefixStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to the [hintStyle].
  FlutterTextStyleType prefix_style = 16;
  // The Color to use for the [InputDecoration.prefixIcon].
  //
  // If [prefixIconColor] is a [MaterialStateColor], then the effective
  // color can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to the [ColorScheme.primary].
  DartColorType prefix_icon_color = 17;
  // The style to use for the [InputDecoration.suffixText].
  //
  // If [suffixStyle] is a [MaterialStateTextStyle], then the effective
  // color can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to the [hintStyle].
  FlutterTextStyleType suffix_style = 18;
  // The Color to use for the [InputDecoration.suffixIcon].
  //
  // If [suffixIconColor] is a [MaterialStateColor], then the effective
  // color can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to the [ColorScheme.primary].
  DartColorType suffix_icon_color = 19;
  // The style to use for the [InputDecoration.counterText].
  //
  // If [counterStyle] is a [MaterialStateTextStyle], then the effective
  // text style can depend on the [MaterialState.focused] state, i.e.
  // if the [TextField] is focused or not.
  //
  // If null, defaults to the [helperStyle].
  FlutterTextStyleType counter_style = 20;
  // If true the decoration's container is filled with [fillColor].
  //
  // Typically this field set to true if [border] is an
  // [UnderlineInputBorder].
  //
  // The decoration's container is the area, defined by the border's
  // [InputBorder.getOuterPath], which is filled if [filled] is
  // true and bordered per the [border].
  //
  // This property is false by default.
  bool filled = 21;
  // The color to fill the decoration's container with, if [filled] is true.
  //
  // By default the fillColor is based on the current [Theme].
  //
  // The decoration's container is the area, defined by the border's
  // [InputBorder.getOuterPath], which is filled if [filled] is
  // true and bordered per the [border].
  DartColorType fill_color = 22;
  // The borderSide of the UnderlineInputBorder with `color` and `weight`.
  FlutterBorderSideType active_indicator_border = 23;
  // The borderSide of the OutlineInputBorder with `color` and `weight`.
  FlutterBorderSideType outline_border = 24;
  // The color to blend with the decoration's [fillColor] with, if [filled] is
  // true and the container has the input focus.
  //
  // By default the [focusColor] is based on the current [Theme].
  //
  // The decoration's container is the area, defined by the border's
  // [InputBorder.getOuterPath], which is filled if [filled] is
  // true and bordered per the [border].
  DartColorType focus_color = 25;
  // The color to blend with the decoration's [fillColor] with, if the
  // decoration is being hovered over by a mouse pointer.
  //
  // By default the [hoverColor] is based on the current [Theme].
  //
  // The decoration's container is the area, defined by the border's
  // [InputBorder.getOuterPath], which is filled if [filled] is
  // true and bordered per the [border].
  //
  // The container will be filled when hovered over even if [filled] is false.
  DartColorType hover_color = 26;
  // The border to display when the [InputDecorator] does not have the focus and
  // is showing an error.
  //
  // See also:
  //
  //  * [InputDecorator.isFocused], which is true if the [InputDecorator]'s child
  //    has the focus.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [focusedBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is null.
  //  * [focusedErrorBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is non-null.
  //  * [disabledBorder], displayed when [InputDecoration.enabled] is false
  //    and [InputDecoration.errorText] is null.
  //  * [enabledBorder], displayed when [InputDecoration.enabled] is true
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType error_border = 27;
  // The border to display when the [InputDecorator] has the focus and is not
  // showing an error.
  //
  // See also:
  //
  //  * [InputDecorator.isFocused], which is true if the [InputDecorator]'s child
  //    has the focus.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [errorBorder], displayed when [InputDecorator.isFocused] is false
  //    and [InputDecoration.errorText] is non-null.
  //  * [focusedErrorBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is non-null.
  //  * [disabledBorder], displayed when [InputDecoration.enabled] is false
  //    and [InputDecoration.errorText] is null.
  //  * [enabledBorder], displayed when [InputDecoration.enabled] is true
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType focused_border = 28;
  // The border to display when the [InputDecorator] has the focus and is
  // showing an error.
  //
  // See also:
  //
  //  * [InputDecorator.isFocused], which is true if the [InputDecorator]'s child
  //    has the focus.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [errorBorder], displayed when [InputDecorator.isFocused] is false
  //    and [InputDecoration.errorText] is non-null.
  //  * [focusedBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is null.
  //  * [disabledBorder], displayed when [InputDecoration.enabled] is false
  //    and [InputDecoration.errorText] is null.
  //  * [enabledBorder], displayed when [InputDecoration.enabled] is true
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType focused_error_border = 29;
  // The border to display when the [InputDecorator] is disabled and is not
  // showing an error.
  //
  // See also:
  //
  //  * [InputDecoration.enabled], which is false if the [InputDecorator] is disabled.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [errorBorder], displayed when [InputDecorator.isFocused] is false
  //    and [InputDecoration.errorText] is non-null.
  //  * [focusedBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is null.
  //  * [focusedErrorBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is non-null.
  //  * [enabledBorder], displayed when [InputDecoration.enabled] is true
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType disabled_border = 30;
  // The border to display when the [InputDecorator] is enabled and is not
  // showing an error.
  //
  // See also:
  //
  //  * [InputDecoration.enabled], which is false if the [InputDecorator] is disabled.
  //  * [InputDecoration.errorText], the error shown by the [InputDecorator], if non-null.
  //  * [border], for a description of where the [InputDecorator] border appears.
  //  * [UnderlineInputBorder], an [InputDecorator] border which draws a horizontal
  //    line at the bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [errorBorder], displayed when [InputDecorator.isFocused] is false
  //    and [InputDecoration.errorText] is non-null.
  //  * [focusedBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is null.
  //  * [focusedErrorBorder], displayed when [InputDecorator.isFocused] is true
  //    and [InputDecoration.errorText] is non-null.
  //  * [disabledBorder], displayed when [InputDecoration.enabled] is false
  //    and [InputDecoration.errorText] is null.
  MaterialInputBorderType enabled_border = 31;
  // The shape of the border to draw around the decoration's container.
  //
  // If [border] is a [MaterialStateUnderlineInputBorder]
  // or [MaterialStateOutlineInputBorder], then the effective border can depend on
  // the [MaterialState.focused] state, i.e. if the [TextField] is focused or not.
  //
  // The decoration's container is the area which is filled if [filled] is
  // true and bordered per the [border]. It's the area adjacent to
  // [InputDecoration.icon] and above the widgets that contain
  // [InputDecoration.helperText], [InputDecoration.errorText], and
  // [InputDecoration.counterText].
  //
  // The border's bounds, i.e. the value of `border.getOuterPath()`, define
  // the area to be filled.
  //
  // This property is only used when the appropriate one of [errorBorder],
  // [focusedBorder], [focusedErrorBorder], [disabledBorder], or [enabledBorder]
  // is not specified. This border's [InputBorder.borderSide] property is
  // configured by the InputDecorator, depending on the values of
  // [InputDecoration.errorText], [InputDecoration.enabled],
  // [InputDecorator.isFocused] and the current [Theme].
  //
  // Typically one of [UnderlineInputBorder] or [OutlineInputBorder].
  // If null, InputDecorator's default is `const UnderlineInputBorder()`.
  //
  // See also:
  //
  //  * [InputBorder.none], which doesn't draw a border.
  //  * [UnderlineInputBorder], which draws a horizontal line at the
  //    bottom of the input decorator's container.
  //  * [OutlineInputBorder], an [InputDecorator] border which draws a
  //    rounded rectangle around the input decorator's container.
  MaterialInputBorderType border = 32;
  // Typically set to true when the [InputDecorator] contains a multiline
  // [TextField] ([TextField.maxLines] is null or > 1) to override the default
  // behavior of aligning the label with the center of the [TextField].
  bool align_label_with_hint = 33;
  // Defines minimum and maximum sizes for the [InputDecorator].
  //
  // Typically the decorator will fill the horizontal space it is given. For
  // larger screens, it may be useful to have the maximum width clamped to
  // a given value so it doesn't fill the whole screen. This property
  // allows you to control how big the decorator will be in its available
  // space.
  //
  // If null, then the decorator will fill the available width with
  // a default height based on text size.
  //
  // See also:
  //
  //  * [InputDecoration.constraints], which can override this setting for a
  //    given decorator.
  FlutterBoxConstraintsType constraints = 34;
}

// package:flutter/src/material/input_decorator.dart
//
// Creates a widget that displays a border, labels, and icons,
// for a [TextField].
//
// The [isFocused], [isHovering], [expands], and [isEmpty] arguments must not
// be null.
message MaterialInputDecorator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The text and styles to use when decorating the child.
  //
  // Null [InputDecoration] properties are initialized with the corresponding
  // values from [ThemeData.inputDecorationTheme].
  MaterialInputDecorationType decoration = 3;
  // The style on which to base the label, hint, counter, and error styles
  // if the [decoration] does not provide explicit styles.
  //
  // If null, [baseStyle] defaults to the `titleMedium` style from the
  // current [Theme], see [ThemeData.textTheme].
  //
  // The [TextStyle.textBaseline] of the [baseStyle] is used to determine
  // the baseline used for text alignment.
  FlutterTextStyleType base_style = 4;
  // How the text in the decoration should be aligned horizontally.
  DartTextAlignType.Enum text_align = 5;
  // {@template flutter.material.InputDecorator.textAlignVertical}
  // How the text should be aligned vertically.
  //
  // Determines the alignment of the baseline within the available space of
  // the input (typically a TextField). For example, TextAlignVertical.top will
  // place the baseline such that the text, and any attached decoration like
  // prefix and suffix, is as close to the top of the input as possible without
  // overflowing. The heights of the prefix and suffix are similarly included
  // for other alignment values. If the height is greater than the height
  // available, then the prefix and suffix will be allowed to overflow first
  // before the text scrolls.
  // {@endtemplate}
  FlutterTextAlignVerticalType text_align_vertical = 6;
  // Whether the input field has focus.
  //
  // Determines the position of the label text and the color and weight of the
  // border.
  //
  // Defaults to false.
  //
  // See also:
  //
  //  * [InputDecoration.hoverColor], which is also blended into the focus
  //    color and fill color when the [isHovering] is true to produce the final
  //    color.
  bool is_focused = 7;
  // Whether the input field is being hovered over by a mouse pointer.
  //
  // Determines the container fill color, which is a blend of
  // [InputDecoration.hoverColor] with [InputDecoration.fillColor] when
  // true, and [InputDecoration.fillColor] when not.
  //
  // Defaults to false.
  bool is_hovering = 8;
  // If true, the height of the input field will be as large as possible.
  //
  // If wrapped in a widget that constrains its child's height, like Expanded
  // or SizedBox, the input field will only be affected if [expands] is set to
  // true.
  //
  // See [TextField.minLines] and [TextField.maxLines] for related ways to
  // affect the height of an input. When [expands] is true, both must be null
  // in order to avoid ambiguity in determining the height.
  //
  // Defaults to false.
  bool expands = 9;
  // Whether the input field is empty.
  //
  // Determines the position of the label text and whether to display the hint
  // text.
  //
  // Defaults to false.
  bool is_empty = 10;
  // The widget below this widget in the tree.
  //
  // Typically an [EditableText], [DropdownButton], or [InkWell].
  WidgetType child = 11;
}

// package:flutter/src/material/about.dart
//
// Creates a page that shows licenses for software used by the application.
//
// The arguments are all optional. The application name, if omitted, will be
// derived from the nearest [Title] widget. The version and legalese values
// default to the empty string.
//
// The licenses shown on the [LicensePage] are those returned by the
// [LicenseRegistry] API, which can be used to add more licenses to the list.
message MaterialLicensePage {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The name of the application.
  //
  // Defaults to the value of [Title.title], if a [Title] widget can be found.
  // Otherwise, defaults to [Platform.resolvedExecutable].
  string application_name = 3;
  // The version of this build of the application.
  //
  // This string is shown under the application name.
  //
  // Defaults to the empty string.
  string application_version = 4;
  // The icon to show below the application name.
  //
  // By default no icon is shown.
  //
  // Typically this will be an [ImageIcon] widget. It should honor the
  // [IconTheme]'s [IconThemeData.size].
  WidgetType application_icon = 5;
  // A string to show in small print.
  //
  // Typically this is a copyright notice.
  //
  // Defaults to the empty string.
  string application_legalese = 6;
}

// package:flutter/src/material/progress_indicator.dart
//
// Creates a linear progress indicator.
//
// {@macro flutter.material.ProgressIndicator.ProgressIndicator}
message MaterialLinearProgressIndicator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If non-null, the value of this progress indicator.
  //
  // A value of 0.0 means no progress and 1.0 means that progress is complete.
  // The value will be clamped to be in the range 0.0-1.0.
  //
  // If null, this progress indicator is indeterminate, which means the
  // indicator displays a predetermined animation that does not indicate how
  // much actual progress is being made.
  double value = 3;
  // The progress indicator's background color.
  //
  // It is up to the subclass to implement this in whatever way makes sense
  // for the given use case. See the subclass documentation for details.
  DartColorType background_color = 4;
  // {@template flutter.progress_indicator.ProgressIndicator.color}
  // The progress indicator's color.
  //
  // This is only used if [ProgressIndicator.valueColor] is null.
  // If [ProgressIndicator.color] is also null, then the ambient
  // [ProgressIndicatorThemeData.color] will be used. If that
  // is null then the current theme's [ColorScheme.primary] will
  // be used by default.
  // {@endtemplate}
  DartColorType color = 5;
  // {@template flutter.material.LinearProgressIndicator.minHeight}
  // The minimum height of the line used to draw the linear indicator.
  //
  // If [LinearProgressIndicator.minHeight] is null then it will use the
  // ambient [ProgressIndicatorThemeData.linearMinHeight]. If that is null
  // it will use 4dp.
  // {@endtemplate}
  double min_height = 7;
  // {@template flutter.progress_indicator.ProgressIndicator.semanticsLabel}
  // The [SemanticsProperties.label] for this progress indicator.
  //
  // This value indicates the purpose of the progress bar, and will be
  // read out by screen readers to indicate the purpose of this progress
  // indicator.
  // {@endtemplate}
  string semantics_label = 8;
  // {@template flutter.progress_indicator.ProgressIndicator.semanticsValue}
  // The [SemanticsProperties.value] for this progress indicator.
  //
  // This will be used in conjunction with the [semanticsLabel] by
  // screen reading software to identify the widget, and is primarily
  // intended for use with determinate progress indicators to announce
  // how far along they are.
  //
  // For determinate progress indicators, this will be defaulted to
  // [ProgressIndicator.value] expressed as a percentage, i.e. `0.1` will
  // become '10%'.
  // {@endtemplate}
  string semantics_value = 9;
  // The border radius of both the indicator and the track.
  //
  // By default it is [BorderRadius.zero], which produces a rectangular shape
  // with a rectangular indicator.
  FlutterBorderRadiusGeometryType border_radius = 10;
}

// package:flutter/src/material/list_tile.dart
//
// Creates a list tile.
//
// If [isThreeLine] is true, then [subtitle] must not be null.
//
// Requires one of its ancestors to be a [Material] widget.
message MaterialListTile {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // A widget to display before the title.
  //
  // Typically an [Icon] or a [CircleAvatar] widget.
  WidgetType leading = 3;
  // The primary content of the list tile.
  //
  // Typically a [Text] widget.
  //
  // This should not wrap. To enforce the single line limit, use
  // [Text.maxLines].
  WidgetType title = 4;
  // Additional content displayed below the title.
  //
  // Typically a [Text] widget.
  //
  // If [isThreeLine] is false, this should not wrap.
  //
  // If [isThreeLine] is true, this should be configured to take a maximum of
  // two lines. For example, you can use [Text.maxLines] to enforce the number
  // of lines.
  //
  // The subtitle's default [TextStyle] depends on [TextTheme.bodyMedium] except
  // [TextStyle.color]. The [TextStyle.color] depends on the value of [enabled]
  // and [selected].
  //
  // When [enabled] is false, the text color is set to [ThemeData.disabledColor].
  //
  // When [selected] is false, the text color is set to [ListTileTheme.textColor]
  // if it's not null and to [TextTheme.bodySmall]'s color if [ListTileTheme.textColor]
  // is null.
  WidgetType subtitle = 5;
  // A widget to display after the title.
  //
  // Typically an [Icon] widget.
  //
  // To show right-aligned metadata (assuming left-to-right reading order;
  // left-aligned for right-to-left reading order), consider using a [Row] with
  // [CrossAxisAlignment.baseline] alignment whose first item is [Expanded] and
  // whose second child is the metadata text, instead of using the [trailing]
  // property.
  WidgetType trailing = 6;
  // Whether this list tile is intended to display three lines of text.
  //
  // If true, then [subtitle] must be non-null (since it is expected to give
  // the second and third lines of text).
  //
  // If false, the list tile is treated as having one line if the subtitle is
  // null and treated as having two lines if the subtitle is non-null.
  //
  // When using a [Text] widget for [title] and [subtitle], you can enforce
  // line limits using [Text.maxLines].
  bool is_three_line = 7;
  // {@template flutter.material.ListTile.dense}
  // Whether this list tile is part of a vertically dense list.
  //
  // If this property is null then its value is based on [ListTileTheme.dense].
  //
  // Dense list tiles default to a smaller height.
  //
  // It is not recommended to set [dense] to true when [ThemeData.useMaterial3] is true.
  // {@endtemplate}
  bool dense = 8;
  // Defines how compact the list tile's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 9;
  // {@template flutter.material.ListTile.shape}
  // Defines the tile's [InkWell.customBorder] and [Ink.decoration] shape.
  // {@endtemplate}
  //
  // If this property is null then [ListTileThemeData.shape] is used. If that
  // is also null then a rectangular [Border] will be used.
  //
  // See also:
  //
  // * [ListTileTheme.of], which returns the nearest [ListTileTheme]'s
  //   [ListTileThemeData].
  FlutterShapeBorderType shape = 10;
  // Defines the font used for the [title].
  //
  // If this property is null then [ListTileThemeData.style] is used. If that
  // is also null then [ListTileStyle.list] is used.
  //
  // See also:
  //
  // * [ListTileTheme.of], which returns the nearest [ListTileTheme]'s
  //   [ListTileThemeData].
  MaterialListTileStyleType.Enum style = 11;
  // Defines the color used for icons and text when the list tile is selected.
  //
  // If this property is null then [ListTileThemeData.selectedColor]
  // is used. If that is also null then [ColorScheme.primary] is used.
  //
  // See also:
  //
  // * [ListTileTheme.of], which returns the nearest [ListTileTheme]'s
  //   [ListTileThemeData].
  DartColorType selected_color = 12;
  // Defines the default color for [leading] and [trailing] icons.
  //
  // If this property is null and [selected] is false then [ListTileThemeData.iconColor]
  // is used. If that is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurfaceVariant]
  // is used, otherwise if [ThemeData.brightness] is [Brightness.light], [Colors.black54] is used,
  // and if [ThemeData.brightness] is [Brightness.dark], the value is null.
  //
  // If this property is null and [selected] is true then [ListTileThemeData.selectedColor]
  // is used. If that is also null then [ColorScheme.primary] is used.
  //
  // If this color is a [MaterialStateColor] it will be resolved against
  // [MaterialState.selected] and [MaterialState.disabled] states.
  //
  // See also:
  //
  // * [ListTileTheme.of], which returns the nearest [ListTileTheme]'s
  //   [ListTileThemeData].
  DartColorType icon_color = 13;
  // Defines the text color for the [title], [subtitle], [leading], and [trailing].
  //
  // If this property is null and [selected] is false then [ListTileThemeData.textColor]
  // is used. If that is also null then default text color is used for the [title], [subtitle]
  // [leading], and [trailing]. Except for [subtitle], if [ThemeData.useMaterial3] is false,
  // [TextTheme.bodySmall] is used.
  //
  // If this property is null and [selected] is true then [ListTileThemeData.selectedColor]
  // is used. If that is also null then [ColorScheme.primary] is used.
  //
  // If this color is a [MaterialStateColor] it will be resolved against
  // [MaterialState.selected] and [MaterialState.disabled] states.
  //
  // See also:
  //
  // * [ListTileTheme.of], which returns the nearest [ListTileTheme]'s
  //   [ListTileThemeData].
  DartColorType text_color = 14;
  // The text style for ListTile's [title].
  //
  // If this property is null, then [ListTileThemeData.titleTextStyle] is used.
  // If that is also null and [ThemeData.useMaterial3] is true, [TextTheme.bodyLarge]
  // with [ColorScheme.onSurface] will be used. Otherwise, If ListTile style is
  // [ListTileStyle.list], [TextTheme.titleMedium] will be used and if ListTile style
  // is [ListTileStyle.drawer], [TextTheme.bodyLarge] will be used.
  FlutterTextStyleType title_text_style = 15;
  // The text style for ListTile's [subtitle].
  //
  // If this property is null, then [ListTileThemeData.subtitleTextStyle] is used.
  // If that is also null and [ThemeData.useMaterial3] is true, [TextTheme.bodyMedium]
  // with [ColorScheme.onSurfaceVariant] will be used, otherwise [TextTheme.bodyMedium]
  // with [TextTheme.bodySmall] color will be used.
  FlutterTextStyleType subtitle_text_style = 16;
  // The text style for ListTile's [leading] and [trailing].
  //
  // If this property is null, then [ListTileThemeData.leadingAndTrailingTextStyle] is used.
  // If that is also null and [ThemeData.useMaterial3] is true, [TextTheme.labelSmall]
  // with [ColorScheme.onSurfaceVariant] will be used, otherwise [TextTheme.bodyMedium]
  // will be used.
  FlutterTextStyleType leading_and_trailing_text_style = 17;
  // The tile's internal padding.
  //
  // Insets a [ListTile]'s contents: its [leading], [title], [subtitle],
  // and [trailing] widgets.
  //
  // If null, `EdgeInsets.symmetric(horizontal: 16.0)` is used.
  FlutterEdgeInsetsGeometryType content_padding = 18;
  // Whether this list tile is interactive.
  //
  // If false, this list tile is styled with the disabled color from the
  // current [Theme] and the [onTap] and [onLongPress] callbacks are
  // inoperative.
  bool enabled = 19;
  // If this tile is also [enabled] then icons and text are rendered with the same color.
  //
  // By default the selected color is the theme's primary color. The selected color
  // can be overridden with a [ListTileTheme].
  //
  // {@tool dartpad}
  // Here is an example of using a [StatefulWidget] to keep track of the
  // selected index, and using that to set the [selected] property on the
  // corresponding [ListTile].
  //
  // ** See code in examples/api/lib/material/list_tile/list_tile.selected.0.dart **
  // {@end-tool}
  bool selected = 24;
  // The color for the tile's [Material] when it has the input focus.
  DartColorType focus_color = 25;
  // The color for the tile's [Material] when a pointer is hovering over it.
  DartColorType hover_color = 26;
  // The color of splash for the tile's [Material].
  DartColorType splash_color = 27;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 28;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 29;
  // {@template flutter.material.ListTile.tileColor}
  // Defines the background color of `ListTile` when [selected] is false.
  //
  // If this property is null and [selected] is false then [ListTileThemeData.tileColor]
  // is used. If that is also null and [selected] is true, [selectedTileColor] is used.
  // When that is also null, the [ListTileTheme.selectedTileColor] is used, otherwise
  // [Colors.transparent] is used.
  //
  // {@endtemplate}
  DartColorType tile_color = 30;
  // Defines the background color of `ListTile` when [selected] is true.
  //
  // When the value if null, the [selectedTileColor] is set to [ListTileTheme.selectedTileColor]
  // if it's not null and to [Colors.transparent] if it's null.
  DartColorType selected_tile_color = 31;
  // {@template flutter.material.ListTile.enableFeedback}
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // When null, the default value is true.
  // {@endtemplate}
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 32;
  // The horizontal gap between the titles and the leading/trailing widgets.
  //
  // If null, then the value of [ListTileTheme.horizontalTitleGap] is used. If
  // that is also null, then a default value of 16 is used.
  double horizontal_title_gap = 33;
  // The minimum padding on the top and bottom of the title and subtitle widgets.
  //
  // If null, then the value of [ListTileTheme.minVerticalPadding] is used. If
  // that is also null, then a default value of 4 is used.
  double min_vertical_padding = 34;
  // The minimum width allocated for the [ListTile.leading] widget.
  //
  // If null, then the value of [ListTileTheme.minLeadingWidth] is used. If
  // that is also null, then a default value of 40 is used.
  double min_leading_width = 35;
  // Defines how [ListTile.leading] and [ListTile.trailing] are
  // vertically aligned relative to the [ListTile]'s titles
  // ([ListTile.title] and [ListTile.subtitle]).
  //
  // If this property is null then [ListTileThemeData.titleAlignment]
  // is used. If that is also null then [ListTileTitleAlignment.threeLine]
  // is used.
  //
  // See also:
  //
  // * [ListTileTheme.of], which returns the nearest [ListTileTheme]'s
  //   [ListTileThemeData].
  MaterialListTileTitleAlignmentType.Enum title_alignment = 36;
}

// package:flutter/src/material/list_tile_theme.dart
//
// Creates a list tile theme that defines the color and style parameters for
// descendant [ListTile]s.
//
// Only the [data] parameter should be used. The other parameters are
// redundant (are now obsolete) and will be deprecated in a future update.
message MaterialListTileTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  MaterialListTileThemeDataType data = 3;
  bool dense = 4;
  FlutterShapeBorderType shape = 5;
  MaterialListTileStyleType.Enum style = 6;
  DartColorType selected_color = 7;
  DartColorType icon_color = 8;
  DartColorType text_color = 9;
  FlutterEdgeInsetsGeometryType content_padding = 10;
  DartColorType tile_color = 11;
  DartColorType selected_tile_color = 12;
  bool enable_feedback = 13;
  double horizontal_title_gap = 15;
  double min_vertical_padding = 16;
  double min_leading_width = 17;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 18;
}

// package:flutter/src/material/list_tile_theme.dart
//
// Creates a [ListTileThemeData].
message MaterialListTileThemeData {
  // Overrides the default value of [ListTile.dense].
  bool dense = 2;
  // Overrides the default value of [ListTile.shape].
  FlutterShapeBorderType shape = 3;
  // Overrides the default value of [ListTile.style].
  MaterialListTileStyleType.Enum style = 4;
  // Overrides the default value of [ListTile.selectedColor].
  DartColorType selected_color = 5;
  // Overrides the default value of [ListTile.iconColor].
  DartColorType icon_color = 6;
  // Overrides the default value of [ListTile.textColor].
  DartColorType text_color = 7;
  // Overrides the default value of [ListTile.titleTextStyle].
  FlutterTextStyleType title_text_style = 8;
  // Overrides the default value of [ListTile.subtitleTextStyle].
  FlutterTextStyleType subtitle_text_style = 9;
  // Overrides the default value of [ListTile.leadingAndTrailingTextStyle].
  FlutterTextStyleType leading_and_trailing_text_style = 10;
  // Overrides the default value of [ListTile.contentPadding].
  FlutterEdgeInsetsGeometryType content_padding = 11;
  // Overrides the default value of [ListTile.tileColor].
  DartColorType tile_color = 12;
  // Overrides the default value of [ListTile.selectedTileColor].
  DartColorType selected_tile_color = 13;
  // Overrides the default value of [ListTile.horizontalTitleGap].
  double horizontal_title_gap = 14;
  // Overrides the default value of [ListTile.minVerticalPadding].
  double min_vertical_padding = 15;
  // Overrides the default value of [ListTile.minLeadingWidth].
  double min_leading_width = 16;
  // Overrides the default value of [ListTile.enableFeedback].
  bool enable_feedback = 17;
  // If specified, overrides the default value of [ListTile.visualDensity].
  MaterialVisualDensityType visual_density = 19;
  // If specified, overrides the default value of [ListTile.titleAlignment].
  MaterialListTileTitleAlignmentType.Enum title_alignment = 20;
}

// package:flutter/src/material/magnifier.dart
//
// Creates a [RawMagnifier] in the Material style.
//
// {@macro widgets.material.magnifier.androidDisclaimer}
message MaterialMagnifier {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Any additional offset the focal point requires to "point"
  // to the correct place.
  //
  // This is useful for instances where the magnifier is not pointing to something
  // directly below it.
  DartOffsetType additional_focal_point_offset = 3;
  // The border radius for this magnifier.
  FlutterBorderRadiusType border_radius = 4;
  // The color to tint the image in this [Magnifier].
  //
  // On native Android, there is a almost transparent gray tint to the
  // magnifier, in order to better distinguish the contents of the lens from
  // the background.
  DartColorType film_color = 5;
  // The shadows for this [Magnifier].
  repeated FlutterBoxShadowType shadows = 6;
  // The [Size] of this [Magnifier].
  //
  // This size does not include the border.
  DartSizeType size = 7;
}

// package:flutter/src/material/material.dart
//
// Creates a piece of material.
//
// The [elevation] must be non-negative.
//
// If a [shape] is specified, then the [borderRadius] property must be
// null and the [type] property must not be [MaterialType.circle]. If the
// [borderRadius] is specified, then the [type] property must not be
// [MaterialType.circle]. In both cases, these restrictions are intended to
// catch likely errors.
message MaterialMaterial {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The kind of material to show (e.g., card or canvas). This
  // affects the shape of the widget, the roundness of its corners if
  // the shape is rectangular, and the default color.
  MaterialMaterialTypeType.Enum type = 3;
  // {@template flutter.material.material.elevation}
  // The z-coordinate at which to place this material relative to its parent.
  //
  // This controls the size of the shadow below the material and the opacity
  // of the elevation overlay color if it is applied.
  //
  // If this is non-zero, the contents of the material are clipped, because the
  // widget conceptually defines an independent printed piece of material.
  //
  // Defaults to 0. Changing this value will cause the shadow and the elevation
  // overlay or surface tint to animate over [Material.animationDuration].
  //
  // The value is non-negative.
  //
  // See also:
  //
  //  * [ThemeData.useMaterial3] which defines whether a surface tint or
  //    elevation overlay is used to indicate elevation.
  //  * [ThemeData.applyElevationOverlayColor] which controls the whether
  //    an overlay color will be applied to indicate elevation.
  //  * [Material.color] which may have an elevation overlay applied.
  //  * [Material.shadowColor] which will be used for the color of a drop shadow.
  //  * [Material.surfaceTintColor] which will be used as the overlay tint to
  //    show elevation.
  // {@endtemplate}
  double elevation = 4;
  // The color to paint the material.
  //
  // Must be opaque. To create a transparent piece of material, use
  // [MaterialType.transparency].
  //
  // If [ThemeData.useMaterial3] is true then an optional [surfaceTintColor]
  // overlay may be applied on top of this color to indicate elevation.
  //
  // If [ThemeData.useMaterial3] is false and [ThemeData.applyElevationOverlayColor]
  // is true and [ThemeData.brightness] is [Brightness.dark] then a
  // semi-transparent overlay color will be composited on top of this
  // color to indicate the elevation. This is no longer needed for Material
  // Design 3, which uses [surfaceTintColor].
  //
  // By default, the color is derived from the [type] of material.
  DartColorType color = 5;
  // The color to paint the shadow below the material.
  //
  // {@template flutter.material.material.shadowColor}
  // If null and [ThemeData.useMaterial3] is true then [ThemeData]'s
  // [ColorScheme.shadow] will be used. If [ThemeData.useMaterial3] is false
  // then [ThemeData.shadowColor] will be used.
  //
  // To remove the drop shadow when [elevation] is greater than 0, set
  // [shadowColor] to [Colors.transparent].
  //
  // See also:
  //  * [ThemeData.useMaterial3], which determines the default value for this
  //    property if it is null.
  //  * [ThemeData.applyElevationOverlayColor], which turns elevation overlay
  // on or off for dark themes.
  // {@endtemplate}
  DartColorType shadow_color = 6;
  // The color of the surface tint overlay applied to the material color
  // to indicate elevation.
  //
  // {@template flutter.material.material.surfaceTintColor}
  // Material Design 3 introduced a new way for some components to indicate
  // their elevation by using a surface tint color overlay on top of the
  // base material [color]. This overlay is painted with an opacity that is
  // related to the [elevation] of the material.
  //
  // If [ThemeData.useMaterial3] is false, then this property is not used.
  //
  // If [ThemeData.useMaterial3] is true and [surfaceTintColor] is not null and
  // not [Colors.transparent], then it will be used to overlay the base [color]
  // with an opacity based on the [elevation].
  //
  // Otherwise, no surface tint will be applied.
  //
  // See also:
  //
  //   * [ThemeData.useMaterial3], which turns this feature on.
  //   * [ElevationOverlay.applySurfaceTint], which is used to implement the
  //     tint.
  //   * https://m3.material.io/styles/color/the-color-system/color-roles
  //     which specifies how the overlay is applied.
  // {@endtemplate}
  DartColorType surface_tint_color = 7;
  // The typographical style to use for text within this material.
  FlutterTextStyleType text_style = 8;
  // If non-null, the corners of this box are rounded by this
  // [BorderRadiusGeometry] value.
  //
  // Otherwise, the corners specified for the current [type] of material are
  // used.
  //
  // If [shape] is non null then the border radius is ignored.
  //
  // Must be null if [type] is [MaterialType.circle].
  FlutterBorderRadiusGeometryType border_radius = 9;
  // Defines the material's shape as well its shadow.
  //
  // {@template flutter.material.material.shape}
  // If shape is non null, the [borderRadius] is ignored and the material's
  // clip boundary and shadow are defined by the shape.
  //
  // A shadow is only displayed if the [elevation] is greater than
  // zero.
  // {@endtemplate}
  FlutterShapeBorderType shape = 10;
  // Whether to paint the [shape] border in front of the [child].
  //
  // The default value is true.
  // If false, the border will be painted behind the [child].
  bool border_on_foreground = 11;
  // {@template flutter.material.Material.clipBehavior}
  // The content will be clipped (or not) according to this option.
  //
  // See the enum [Clip] for details of all possible options and their common
  // use cases.
  // {@endtemplate}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 12;
  // Defines the duration of animated changes for [shape], [elevation],
  // [shadowColor], [surfaceTintColor] and the elevation overlay if it is applied.
  //
  // The default value is [kThemeChangeDuration].
  DartDurationType animation_duration = 13;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 14;
}

// package:flutter/src/material/app.dart
//
// Creates a MaterialApp.
//
// At least one of [home], [routes], [onGenerateRoute], or [builder] must be
// non-null. If only [routes] is given, it must include an entry for the
// [Navigator.defaultRouteName] (`/`), since that is the route used when the
// application is launched with an intent that specifies an otherwise
// unsupported route.
//
// This class creates an instance of [WidgetsApp].
message MaterialMaterialApp {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.widgetsApp.home}
  WidgetType home = 5;
  // {@macro flutter.widgets.widgetsApp.initialRoute}
  string initial_route = 7;
  // {@macro flutter.widgets.widgetsApp.navigatorObservers}
  repeated FlutterNavigatorObserverType navigator_observers = 12;
  // {@macro flutter.widgets.widgetsApp.title}
  //
  // This value is passed unmodified to [WidgetsApp.title].
  string title = 14;
  // {@macro flutter.widgets.widgetsApp.color}
  DartColorType color = 16;
  // Default visual properties, like colors fonts and shapes, for this app's
  // material widgets.
  //
  // A second [darkTheme] [ThemeData] value, which is used to provide a dark
  // version of the user interface can also be specified. [themeMode] will
  // control which theme will be used if a [darkTheme] is provided.
  //
  // The default value of this property is the value of [ThemeData.light()].
  //
  // See also:
  //
  //  * [themeMode], which controls which theme to use.
  //  * [MediaQueryData.platformBrightness], which indicates the platform's
  //    desired brightness and is used to automatically toggle between [theme]
  //    and [darkTheme] in [MaterialApp].
  //  * [ThemeData.brightness], which indicates the [Brightness] of a theme's
  //    colors.
  MaterialThemeDataType theme = 17;
  // The [ThemeData] to use when a 'dark mode' is requested by the system.
  //
  // Some host platforms allow the users to select a system-wide 'dark mode',
  // or the application may want to offer the user the ability to choose a
  // dark theme just for this application. This is theme that will be used for
  // such cases. [themeMode] will control which theme will be used.
  //
  // This theme should have a [ThemeData.brightness] set to [Brightness.dark].
  //
  // Uses [theme] instead when null. Defaults to the value of
  // [ThemeData.light()] when both [darkTheme] and [theme] are null.
  //
  // See also:
  //
  //  * [themeMode], which controls which theme to use.
  //  * [MediaQueryData.platformBrightness], which indicates the platform's
  //    desired brightness and is used to automatically toggle between [theme]
  //    and [darkTheme] in [MaterialApp].
  //  * [ThemeData.brightness], which is typically set to the value of
  //    [MediaQueryData.platformBrightness].
  MaterialThemeDataType dark_theme = 18;
  // The [ThemeData] to use when 'high contrast' is requested by the system.
  //
  // Some host platforms (for example, iOS) allow the users to increase
  // contrast through an accessibility setting.
  //
  // Uses [theme] instead when null.
  //
  // See also:
  //
  //  * [MediaQueryData.highContrast], which indicates the platform's
  //    desire to increase contrast.
  MaterialThemeDataType high_contrast_theme = 19;
  // The [ThemeData] to use when a 'dark mode' and 'high contrast' is requested
  // by the system.
  //
  // Some host platforms (for example, iOS) allow the users to increase
  // contrast through an accessibility setting.
  //
  // This theme should have a [ThemeData.brightness] set to [Brightness.dark].
  //
  // Uses [darkTheme] instead when null.
  //
  // See also:
  //
  //  * [MediaQueryData.highContrast], which indicates the platform's
  //    desire to increase contrast.
  MaterialThemeDataType high_contrast_dark_theme = 20;
  // Determines which theme will be used by the application if both [theme]
  // and [darkTheme] are provided.
  //
  // If set to [ThemeMode.system], the choice of which theme to use will
  // be based on the user's system preferences. If the [MediaQuery.platformBrightnessOf]
  // is [Brightness.light], [theme] will be used. If it is [Brightness.dark],
  // [darkTheme] will be used (unless it is null, in which case [theme]
  // will be used.
  //
  // If set to [ThemeMode.light] the [theme] will always be used,
  // regardless of the user's system preference.
  //
  // If set to [ThemeMode.dark] the [darkTheme] will be used
  // regardless of the user's system preference. If [darkTheme] is null
  // then it will fallback to using [theme].
  //
  // The default value is [ThemeMode.system].
  //
  // See also:
  //
  //  * [theme], which is used when a light mode is selected.
  //  * [darkTheme], which is used when a dark mode is selected.
  //  * [ThemeData.brightness], which indicates to various parts of the
  //    system what kind of theme is being used.
  MaterialThemeModeType.Enum theme_mode = 21;
  // The duration of animated theme changes.
  //
  // When the theme changes (either by the [theme], [darkTheme] or [themeMode]
  // parameters changing) it is animated to the new theme over time.
  // The [themeAnimationDuration] determines how long this animation takes.
  //
  // To have the theme change immediately, you can set this to [Duration.zero].
  //
  // The default is [kThemeAnimationDuration].
  //
  // See also:
  //   [themeAnimationCurve], which defines the curve used for the animation.
  DartDurationType theme_animation_duration = 22;
  // The curve to apply when animating theme changes.
  //
  // The default is [Curves.linear].
  //
  // This is ignored if [themeAnimationDuration] is [Duration.zero].
  //
  // See also:
  //   [themeAnimationDuration], which defines how long the animation is.
  FlutterSrcAnimationCurveType theme_animation_curve = 23;
  // {@macro flutter.widgets.widgetsApp.locale}
  DartLocaleType locale = 24;
  // {@macro flutter.widgets.widgetsApp.supportedLocales}
  //
  // It is passed along unmodified to the [WidgetsApp] built by this widget.
  //
  // See also:
  //
  //  * [localizationsDelegates], which must be specified for localized
  //    applications.
  //  * [GlobalMaterialLocalizations], a [localizationsDelegates] value
  //    which provides material localizations for many languages.
  //  * The Flutter Internationalization Tutorial,
  //    <https://flutter.dev/tutorials/internationalization/>.
  repeated DartLocaleType supported_locales = 28;
  // Turns on a [GridPaper] overlay that paints a baseline grid
  // Material apps.
  //
  // Only available in debug mode.
  //
  // See also:
  //
  //  * <https://material.io/design/layout/spacing-methods.html>
  bool debug_show_material_grid = 29;
  // Turns on a performance overlay.
  //
  // See also:
  //
  //  * <https://flutter.dev/debugging/#performance-overlay>
  bool show_performance_overlay = 30;
  // Turns on checkerboarding of raster cache images.
  bool checkerboard_raster_cache_images = 31;
  // Turns on checkerboarding of layers rendered to offscreen bitmaps.
  bool checkerboard_offscreen_layers = 32;
  // Turns on an overlay that shows the accessibility information
  // reported by the framework.
  bool show_semantics_debugger = 33;
  // {@macro flutter.widgets.widgetsApp.debugShowCheckedModeBanner}
  bool debug_show_checked_mode_banner = 34;
  // {@macro flutter.widgets.widgetsApp.restorationScopeId}
  string restoration_scope_id = 37;
  // {@template flutter.material.materialApp.scrollBehavior}
  // The default [ScrollBehavior] for the application.
  //
  // [ScrollBehavior]s describe how [Scrollable] widgets behave. Providing
  // a [ScrollBehavior] can set the default [ScrollPhysics] across
  // an application, and manage [Scrollable] decorations like [Scrollbar]s and
  // [GlowingOverscrollIndicator]s.
  // {@endtemplate}
  //
  // When null, defaults to [MaterialScrollBehavior].
  //
  // See also:
  //
  //  * [ScrollConfiguration], which controls how [Scrollable] widgets behave
  //    in a subtree.
  FlutterScrollBehaviorType scroll_behavior = 38;
  // Used to override the theme animation curve and duration.
  //
  // If [AnimationStyle.duration] is provided, it will be used to override
  // the theme animation duration in the underlying [AnimatedTheme] widget.
  // If it is null, then [themeAnimationDuration] will be used. Otherwise,
  // defaults to 200ms.
  //
  // If [AnimationStyle.curve] is provided, it will be used to override
  // the theme animation curve in the underlying [AnimatedTheme] widget.
  // If it is null, then [themeAnimationCurve] will be used. Otherwise,
  // defaults to [Curves.linear].
  //
  // To disable the theme animation, use [AnimationStyle.noAnimation].
  //
  // {@tool dartpad}
  // This sample showcases how to override the theme animation curve and
  // duration in the [MaterialApp] widget using [AnimationStyle].
  //
  // ** See code in examples/api/lib/material/app/app.0.dart **
  // {@end-tool}
  FlutterSrcAnimationAnimationStyleType theme_animation_style = 39;
}

// package:flutter/src/material/app.dart
//
// Creates a [MaterialApp] that uses the [Router] instead of a [Navigator].
//
// {@macro flutter.widgets.WidgetsApp.router}
message MaterialMaterialAppNamedRouter {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.widgetsApp.routeInformationProvider}
  FlutterRouteInformationProviderType route_information_provider = 4;
  // {@macro flutter.widgets.widgetsApp.backButtonDispatcher}
  FlutterBackButtonDispatcherType back_button_dispatcher = 8;
  // {@macro flutter.widgets.widgetsApp.title}
  //
  // This value is passed unmodified to [WidgetsApp.title].
  string title = 10;
  // {@macro flutter.widgets.widgetsApp.color}
  DartColorType color = 13;
  // Default visual properties, like colors fonts and shapes, for this app's
  // material widgets.
  //
  // A second [darkTheme] [ThemeData] value, which is used to provide a dark
  // version of the user interface can also be specified. [themeMode] will
  // control which theme will be used if a [darkTheme] is provided.
  //
  // The default value of this property is the value of [ThemeData.light()].
  //
  // See also:
  //
  //  * [themeMode], which controls which theme to use.
  //  * [MediaQueryData.platformBrightness], which indicates the platform's
  //    desired brightness and is used to automatically toggle between [theme]
  //    and [darkTheme] in [MaterialApp].
  //  * [ThemeData.brightness], which indicates the [Brightness] of a theme's
  //    colors.
  MaterialThemeDataType theme = 14;
  // The [ThemeData] to use when a 'dark mode' is requested by the system.
  //
  // Some host platforms allow the users to select a system-wide 'dark mode',
  // or the application may want to offer the user the ability to choose a
  // dark theme just for this application. This is theme that will be used for
  // such cases. [themeMode] will control which theme will be used.
  //
  // This theme should have a [ThemeData.brightness] set to [Brightness.dark].
  //
  // Uses [theme] instead when null. Defaults to the value of
  // [ThemeData.light()] when both [darkTheme] and [theme] are null.
  //
  // See also:
  //
  //  * [themeMode], which controls which theme to use.
  //  * [MediaQueryData.platformBrightness], which indicates the platform's
  //    desired brightness and is used to automatically toggle between [theme]
  //    and [darkTheme] in [MaterialApp].
  //  * [ThemeData.brightness], which is typically set to the value of
  //    [MediaQueryData.platformBrightness].
  MaterialThemeDataType dark_theme = 15;
  // The [ThemeData] to use when 'high contrast' is requested by the system.
  //
  // Some host platforms (for example, iOS) allow the users to increase
  // contrast through an accessibility setting.
  //
  // Uses [theme] instead when null.
  //
  // See also:
  //
  //  * [MediaQueryData.highContrast], which indicates the platform's
  //    desire to increase contrast.
  MaterialThemeDataType high_contrast_theme = 16;
  // The [ThemeData] to use when a 'dark mode' and 'high contrast' is requested
  // by the system.
  //
  // Some host platforms (for example, iOS) allow the users to increase
  // contrast through an accessibility setting.
  //
  // This theme should have a [ThemeData.brightness] set to [Brightness.dark].
  //
  // Uses [darkTheme] instead when null.
  //
  // See also:
  //
  //  * [MediaQueryData.highContrast], which indicates the platform's
  //    desire to increase contrast.
  MaterialThemeDataType high_contrast_dark_theme = 17;
  // Determines which theme will be used by the application if both [theme]
  // and [darkTheme] are provided.
  //
  // If set to [ThemeMode.system], the choice of which theme to use will
  // be based on the user's system preferences. If the [MediaQuery.platformBrightnessOf]
  // is [Brightness.light], [theme] will be used. If it is [Brightness.dark],
  // [darkTheme] will be used (unless it is null, in which case [theme]
  // will be used.
  //
  // If set to [ThemeMode.light] the [theme] will always be used,
  // regardless of the user's system preference.
  //
  // If set to [ThemeMode.dark] the [darkTheme] will be used
  // regardless of the user's system preference. If [darkTheme] is null
  // then it will fallback to using [theme].
  //
  // The default value is [ThemeMode.system].
  //
  // See also:
  //
  //  * [theme], which is used when a light mode is selected.
  //  * [darkTheme], which is used when a dark mode is selected.
  //  * [ThemeData.brightness], which indicates to various parts of the
  //    system what kind of theme is being used.
  MaterialThemeModeType.Enum theme_mode = 18;
  // The duration of animated theme changes.
  //
  // When the theme changes (either by the [theme], [darkTheme] or [themeMode]
  // parameters changing) it is animated to the new theme over time.
  // The [themeAnimationDuration] determines how long this animation takes.
  //
  // To have the theme change immediately, you can set this to [Duration.zero].
  //
  // The default is [kThemeAnimationDuration].
  //
  // See also:
  //   [themeAnimationCurve], which defines the curve used for the animation.
  DartDurationType theme_animation_duration = 19;
  // The curve to apply when animating theme changes.
  //
  // The default is [Curves.linear].
  //
  // This is ignored if [themeAnimationDuration] is [Duration.zero].
  //
  // See also:
  //   [themeAnimationDuration], which defines how long the animation is.
  FlutterSrcAnimationCurveType theme_animation_curve = 20;
  // {@macro flutter.widgets.widgetsApp.locale}
  DartLocaleType locale = 21;
  // {@macro flutter.widgets.widgetsApp.supportedLocales}
  //
  // It is passed along unmodified to the [WidgetsApp] built by this widget.
  //
  // See also:
  //
  //  * [localizationsDelegates], which must be specified for localized
  //    applications.
  //  * [GlobalMaterialLocalizations], a [localizationsDelegates] value
  //    which provides material localizations for many languages.
  //  * The Flutter Internationalization Tutorial,
  //    <https://flutter.dev/tutorials/internationalization/>.
  repeated DartLocaleType supported_locales = 25;
  // Turns on a [GridPaper] overlay that paints a baseline grid
  // Material apps.
  //
  // Only available in debug mode.
  //
  // See also:
  //
  //  * <https://material.io/design/layout/spacing-methods.html>
  bool debug_show_material_grid = 26;
  // Turns on a performance overlay.
  //
  // See also:
  //
  //  * <https://flutter.dev/debugging/#performance-overlay>
  bool show_performance_overlay = 27;
  // Turns on checkerboarding of raster cache images.
  bool checkerboard_raster_cache_images = 28;
  // Turns on checkerboarding of layers rendered to offscreen bitmaps.
  bool checkerboard_offscreen_layers = 29;
  // Turns on an overlay that shows the accessibility information
  // reported by the framework.
  bool show_semantics_debugger = 30;
  // {@macro flutter.widgets.widgetsApp.debugShowCheckedModeBanner}
  bool debug_show_checked_mode_banner = 31;
  // {@macro flutter.widgets.widgetsApp.restorationScopeId}
  string restoration_scope_id = 34;
  // {@template flutter.material.materialApp.scrollBehavior}
  // The default [ScrollBehavior] for the application.
  //
  // [ScrollBehavior]s describe how [Scrollable] widgets behave. Providing
  // a [ScrollBehavior] can set the default [ScrollPhysics] across
  // an application, and manage [Scrollable] decorations like [Scrollbar]s and
  // [GlowingOverscrollIndicator]s.
  // {@endtemplate}
  //
  // When null, defaults to [MaterialScrollBehavior].
  //
  // See also:
  //
  //  * [ScrollConfiguration], which controls how [Scrollable] widgets behave
  //    in a subtree.
  FlutterScrollBehaviorType scroll_behavior = 35;
  // Used to override the theme animation curve and duration.
  //
  // If [AnimationStyle.duration] is provided, it will be used to override
  // the theme animation duration in the underlying [AnimatedTheme] widget.
  // If it is null, then [themeAnimationDuration] will be used. Otherwise,
  // defaults to 200ms.
  //
  // If [AnimationStyle.curve] is provided, it will be used to override
  // the theme animation curve in the underlying [AnimatedTheme] widget.
  // If it is null, then [themeAnimationCurve] will be used. Otherwise,
  // defaults to [Curves.linear].
  //
  // To disable the theme animation, use [AnimationStyle.noAnimation].
  //
  // {@tool dartpad}
  // This sample showcases how to override the theme animation curve and
  // duration in the [MaterialApp] widget using [AnimationStyle].
  //
  // ** See code in examples/api/lib/material/app/app.0.dart **
  // {@end-tool}
  FlutterSrcAnimationAnimationStyleType theme_animation_style = 36;
}

// package:flutter/src/material/banner.dart
//
// Creates a [MaterialBanner].
//
// The length of the [actions] list must not be empty. The [elevation] must
// be null or non-negative.
message MaterialMaterialBanner {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The content of the [MaterialBanner].
  //
  // Typically a [Text] widget.
  WidgetType content = 3;
  // Style for the text in the [content] of the [MaterialBanner].
  //
  // If `null`, [MaterialBannerThemeData.contentTextStyle] is used. If that is
  // also `null`, [TextTheme.bodyMedium] of [ThemeData.textTheme] is used.
  FlutterTextStyleType content_text_style = 4;
  // The set of actions that are displayed at the bottom or trailing side of
  // the [MaterialBanner].
  //
  // Typically this is a list of [TextButton] widgets.
  repeated WidgetType actions = 5;
  // The z-coordinate at which to place the material banner.
  //
  // This controls the size of the shadow below the material banner.
  //
  // Defines the banner's [Material.elevation].
  //
  // If this property is null, then [MaterialBannerThemeData.elevation] of
  // [ThemeData.bannerTheme] is used, if that is also null, the default value is 0.
  // If the elevation is 0, the [Scaffold]'s body will be pushed down by the
  // MaterialBanner when used with [ScaffoldMessenger].
  double elevation = 6;
  // The (optional) leading widget of the [MaterialBanner].
  //
  // Typically an [Icon] widget.
  WidgetType leading = 7;
  // The color of the surface of this [MaterialBanner].
  //
  // If `null`, [MaterialBannerThemeData.backgroundColor] is used. If that is
  // also `null`, [ColorScheme.surface] of [ThemeData.colorScheme] is used.
  DartColorType background_color = 8;
  // The color used as an overlay on [backgroundColor] to indicate elevation.
  //
  // If null, [MaterialBannerThemeData.surfaceTintColor] is used. If that
  // is also null, the default value is [ColorScheme.surfaceTint].
  //
  // See [Material.surfaceTintColor] for more details on how this
  // overlay is applied.
  DartColorType surface_tint_color = 9;
  // The color of the shadow below the [MaterialBanner].
  //
  // If this property is null, then [MaterialBannerThemeData.shadowColor] of
  // [ThemeData.bannerTheme] is used. If that is also null, the default value
  // is null.
  DartColorType shadow_color = 10;
  // The color of the divider.
  //
  // If this property is null, then [MaterialBannerThemeData.dividerColor] of
  // [ThemeData.bannerTheme] is used. If that is also null, the default value
  // is [ColorScheme.surfaceVariant].
  DartColorType divider_color = 11;
  // The amount of space by which to inset the [content].
  //
  // If the [actions] are below the [content], this defaults to
  // `EdgeInsetsDirectional.only(start: 16.0, top: 24.0, end: 16.0, bottom: 4.0)`.
  //
  // If the [actions] are trailing the [content], this defaults to
  // `EdgeInsetsDirectional.only(start: 16.0, top: 2.0)`.
  FlutterEdgeInsetsGeometryType padding = 12;
  // Empty space to surround the [MaterialBanner].
  //
  // If the [margin] is null then this defaults to
  // 0 if the banner's [elevation] is 0, 10 otherwise.
  FlutterEdgeInsetsGeometryType margin = 13;
  // The amount of space by which to inset the [leading] widget.
  //
  // This defaults to `EdgeInsetsDirectional.only(end: 16.0)`.
  FlutterEdgeInsetsGeometryType leading_padding = 14;
  // An override to force the [actions] to be below the [content] regardless of
  // how many there are.
  //
  // If this is true, the [actions] will be placed below the [content]. If
  // this is false, the [actions] will be placed on the trailing side of the
  // [content] if [actions]'s length is 1 and below the [content] if greater
  // than 1.
  //
  // Defaults to false.
  bool force_actions_below = 15;
  // The horizontal alignment of the [actions] when the [actions] laid out in a column.
  //
  // Defaults to [OverflowBarAlignment.end].
  FlutterOverflowBarAlignmentType.Enum overflow_alignment = 16;
}

// package:flutter/src/material/banner_theme.dart
//
// Creates a banner theme that controls the configurations for
// [MaterialBanner]s in its widget subtree.
message MaterialMaterialBannerTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties for descendant [MaterialBanner] widgets.
  MaterialMaterialBannerThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/banner_theme.dart
//
// Creates a theme that can be used for [MaterialBannerTheme] or
// [ThemeData.bannerTheme].
message MaterialMaterialBannerThemeData {
  // The background color of a [MaterialBanner].
  DartColorType background_color = 2;
  // Overrides the default value of [MaterialBanner.surfaceTintColor].
  DartColorType surface_tint_color = 3;
  // Overrides the default value of [MaterialBanner.shadowColor].
  DartColorType shadow_color = 4;
  // Overrides the default value of [MaterialBanner.dividerColor].
  DartColorType divider_color = 5;
  // Used to configure the [DefaultTextStyle] for the [MaterialBanner.content]
  // widget.
  FlutterTextStyleType content_text_style = 6;
  // Default value for [MaterialBanner.elevation].
  double elevation = 7;
  // The amount of space by which to inset [MaterialBanner.content].
  FlutterEdgeInsetsGeometryType padding = 8;
  // The amount of space by which to inset [MaterialBanner.leading].
  FlutterEdgeInsetsGeometryType leading_padding = 9;
}

// package:flutter/src/material/theme_data.dart
//
// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
// and its `cupertinoOverrideTheme`.
message MaterialMaterialBasedCupertinoThemeData {
  MaterialThemeDataType material_theme = 2;
}

// package:flutter/src/material/material_button.dart
//
// Creates a Material Design button.
//
// To create a custom Material button consider using [TextButton],
// [ElevatedButton], or [OutlinedButton].
//
// The [elevation], [hoverElevation], [focusElevation], [highlightElevation],
// and [disabledElevation] arguments must be non-negative, if specified.
message MaterialMaterialButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Defines the button's base colors, and the defaults for the button's minimum
  // size, internal padding, and shape.
  //
  // Defaults to `ButtonTheme.of(context).textTheme`.
  MaterialButtonTextThemeType.Enum text_theme = 7;
  // The color to use for this button's text.
  //
  // The button's [Material.textStyle] will be the current theme's button text
  // style, [TextTheme.labelLarge] of [ThemeData.textTheme], configured with this
  // color.
  //
  // The default text color depends on the button theme's text theme,
  // [ButtonThemeData.textTheme].
  //
  // If [textColor] is a [MaterialStateProperty<Color>], [disabledTextColor]
  // will be ignored.
  //
  // See also:
  //
  //  * [disabledTextColor], the text color to use when the button has been
  //    disabled.
  DartColorType text_color = 8;
  // The color to use for this button's text when the button is disabled.
  //
  // The button's [Material.textStyle] will be the current theme's button text
  // style, [TextTheme.labelLarge] of [ThemeData.textTheme], configured with this
  // color.
  //
  // The default value is the theme's disabled color,
  // [ThemeData.disabledColor].
  //
  // If [textColor] is a [MaterialStateProperty<Color>], [disabledTextColor]
  // will be ignored.
  //
  // See also:
  //
  //  * [textColor] - The color to use for this button's text when the button is [enabled].
  DartColorType disabled_text_color = 9;
  // The button's fill color, displayed by its [Material], while it
  // is in its default (unpressed, [enabled]) state.
  //
  // See also:
  //
  //  * [disabledColor] - the fill color of the button when the button is disabled.
  DartColorType color = 10;
  // The fill color of the button when the button is disabled.
  //
  // The default value of this color is the theme's disabled color,
  // [ThemeData.disabledColor].
  //
  // See also:
  //
  //  * [color] - the fill color of the button when the button is [enabled].
  DartColorType disabled_color = 11;
  // The fill color of the button's [Material] when it has the input focus.
  //
  // The button changed focus color when the button has the input focus. It
  // appears behind the button's child.
  DartColorType focus_color = 12;
  // The fill color of the button's [Material] when a pointer is hovering over
  // it.
  //
  // The button changes fill color when a pointer is hovering over the button.
  // It appears behind the button's child.
  DartColorType hover_color = 13;
  // The highlight color of the button's [InkWell].
  //
  // The highlight indicates that the button is actively being pressed. It
  // appears on top of the button's child and quickly spreads to fill
  // the button, and then fades out.
  //
  // If [textTheme] is [ButtonTextTheme.primary], the default highlight color is
  // transparent (in other words the highlight doesn't appear). Otherwise it's
  // the current theme's highlight color, [ThemeData.highlightColor].
  DartColorType highlight_color = 14;
  // The splash color of the button's [InkWell].
  //
  // The ink splash indicates that the button has been touched. It
  // appears on top of the button's child and spreads in an expanding
  // circle beginning where the touch occurred.
  //
  // The default splash color is the current theme's splash color,
  // [ThemeData.splashColor].
  //
  // The appearance of the splash can be configured with the theme's splash
  // factory, [ThemeData.splashFactory].
  DartColorType splash_color = 15;
  // The theme brightness to use for this button.
  //
  // Defaults to the theme's brightness in [ThemeData.brightness]. Setting
  // this value determines the button text's colors based on
  // [ButtonThemeData.getTextColor].
  //
  // See also:
  //
  //  * [ButtonTextTheme], uses [Brightness] to determine text color.
  DartBrightnessType.Enum color_brightness = 16;
  // The z-coordinate at which to place this button relative to its parent.
  //
  // This controls the size of the shadow below the raised button.
  //
  // Defaults to 2, the appropriate elevation for raised buttons. The value
  // is always non-negative.
  //
  // See also:
  //
  //  * [TextButton], a button with no elevation or fill color.
  //  * [focusElevation], the elevation when the button is focused.
  //  * [hoverElevation], the elevation when a pointer is hovering over the
  //    button.
  //  * [disabledElevation], the elevation when the button is disabled.
  //  * [highlightElevation], the elevation when the button is pressed.
  double elevation = 17;
  // The elevation for the button's [Material] when the button
  // is [enabled] and has the input focus.
  //
  // Defaults to 4.0. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [hoverElevation], the elevation when a pointer is hovering over the
  //    button.
  //  * [disabledElevation], the elevation when the button is disabled.
  //  * [highlightElevation], the elevation when the button is pressed.
  double focus_elevation = 18;
  // The elevation for the button's [Material] when the button
  // is [enabled] and a pointer is hovering over it.
  //
  // Defaults to 4.0. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [focusElevation], the elevation when the button is focused.
  //  * [disabledElevation], the elevation when the button is disabled.
  //  * [highlightElevation], the elevation when the button is pressed.
  double hover_elevation = 19;
  // The elevation for the button's [Material] relative to its parent when the
  // button is [enabled] and pressed.
  //
  // This controls the size of the shadow below the button. When a tap
  // down gesture occurs within the button, its [InkWell] displays a
  // [highlightColor] "highlight".
  //
  // Defaults to 8.0. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [focusElevation], the elevation when the button is focused.
  //  * [hoverElevation], the elevation when a pointer is hovering over the
  //    button.
  //  * [disabledElevation], the elevation when the button is disabled.
  double highlight_elevation = 20;
  // The elevation for the button's [Material] relative to its parent when the
  // button is not [enabled].
  //
  // Defaults to 0.0. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [highlightElevation], the elevation when the button is pressed.
  double disabled_elevation = 21;
  // The internal padding for the button's [child].
  //
  // Defaults to the value from the current [ButtonTheme],
  // [ButtonThemeData.padding].
  FlutterEdgeInsetsGeometryType padding = 22;
  // Defines how compact the button's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 23;
  // The shape of the button's [Material].
  //
  // The button's highlight and splash are clipped to this shape. If the
  // button has an elevation, then its drop shadow is defined by this
  // shape as well.
  //
  // Defaults to the value from the current [ButtonTheme],
  // [ButtonThemeData.shape].
  FlutterShapeBorderType shape = 24;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 25;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 26;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 27;
  // Configures the minimum size of the tap target.
  //
  // Defaults to [ThemeData.materialTapTargetSize].
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 28;
  // Defines the duration of animated changes for [shape] and [elevation].
  //
  // The default value is [kThemeChangeDuration].
  DartDurationType animation_duration = 29;
  // The smallest horizontal extent that the button will occupy.
  //
  // Defaults to the value from the current [ButtonTheme].
  double min_width = 30;
  // The vertical extent of the button.
  //
  // Defaults to the value from the current [ButtonTheme].
  double height = 31;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 32;
  // The button's label.
  //
  // Often a [Text] widget in all caps.
  WidgetType child = 33;
}

// package:flutter/src/material/mergeable_material.dart
//
// Creates a Material gap with a given size.
message MaterialMaterialGap {
  FlutterLocalKeyType key = 2;
  // The main axis extent of this gap. For example, if the [MergeableMaterial]
  // is vertical, then this is the height of the gap.
  double size = 3;
}

// package:flutter/src/material/app.dart
//
// Creates a MaterialScrollBehavior that decorates [Scrollable]s with
// [StretchingOverscrollIndicator]s and [Scrollbar]s based on the current
// platform and provided [ScrollableDetails].
//
// [ThemeData.useMaterial3] specifies the
// overscroll indicator that is used on [TargetPlatform.android], which
// defaults to true, resulting in a [StretchingOverscrollIndicator]. Setting
// [ThemeData.useMaterial3] to false will instead use a
// [GlowingOverscrollIndicator].
message MaterialMaterialScrollBehavior {
  
}

// package:flutter/src/material/mergeable_material.dart
//
// Creates a slice of [Material] that's mergeable within a
// [MergeableMaterial].
message MaterialMaterialSlice {
  FlutterLocalKeyType key = 2;
  // The contents of this slice.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
  // Defines the color for the slice.
  //
  // By default, the value of [color] is [ThemeData.cardColor].
  DartColorType color = 4;
}

// package:flutter/src/material/material_state.dart
//
// Creates a MaterialStatesController.
message MaterialMaterialStatesController {
  
}

// package:flutter/src/material/text_selection.dart
message MaterialMaterialTextSelectionControls {
  
}

// package:flutter/src/material/menu_anchor.dart
//
// Create a const [MenuAcceleratorCallbackBinding].
//
// The [child] parameter is required.
message MaterialMenuAcceleratorCallbackBinding {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether or not the associated label will host its own submenu or not.
  //
  // This setting determines when accelerators are active, since accelerators
  // for menu items that open submenus shouldn't be active when the submenu is
  // open.
  bool has_submenu = 4;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 5;
}

// package:flutter/src/material/menu_anchor.dart
//
// Creates a const [MenuAcceleratorLabel].
//
// The [label] parameter is required.
message MaterialMenuAcceleratorLabel {
  // The label string that should be displayed.
  //
  // The label string provides the label text, as well as the possible
  // characters which could be used as accelerators in the menu system.
  //
  // {@template flutter.material.menu_anchor.menu_accelerator_label.label}
  // To indicate which letters in the label are to be used as accelerators, add
  // an "&" character before the character in the string. If more than one
  // character has an "&" in front of it, then the characters appearing earlier
  // in the string are preferred. To represent a literal "&", insert "&&" into
  // the string. All other ampersands will be removed from the string before
  // calling [MenuAcceleratorLabel.builder]. Bare ampersands at the end of the
  // string or before whitespace are stripped and ignored.
  // {@endtemplate}
  //
  // See also:
  //
  // * [displayLabel], which returns the [label] with all of the ampersands
  //   stripped out of it, and double ampersands converted to ampersands.
  // * [stripAcceleratorMarkers], which returns the supplied string with all of
  //   the ampersands stripped out of it, and double ampersands converted to
  //   ampersands, and optionally calls a callback with the index of the
  //   accelerator character found.
  string label = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
}

// package:flutter/src/material/menu_anchor.dart
//
// Creates a const [MenuAnchor].
//
// The [menuChildren] argument is required.
message MaterialMenuAnchor {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // An optional controller that allows opening and closing of the menu from
  // other widgets.
  MaterialMenuControllerType controller = 3;
  // The [childFocusNode] attribute is the optional [FocusNode] also associated
  // the [child] or [builder] widget that opens the menu.
  //
  // The focus node should be attached to the widget that should receive focus
  // if keyboard focus traversal moves the focus off of the submenu with the
  // arrow keys.
  //
  // If not supplied, then keyboard traversal from the menu back to the
  // controlling button when the menu is open is disabled.
  FlutterFocusNodeType child_focus_node = 4;
  // The [MenuStyle] that defines the visual attributes of the menu bar.
  //
  // Colors and sizing of the menus is controllable via the [MenuStyle].
  //
  // Defaults to the ambient [MenuThemeData.style].
  MaterialMenuStyleType style = 5;
  // The offset of the menu relative to the alignment origin determined by
  // [MenuStyle.alignment] on the [style] attribute and the ambient
  // [Directionality].
  //
  // Use this for adjustments of the menu placement.
  //
  // Increasing [Offset.dy] values of [alignmentOffset] move the menu position
  // down.
  //
  // If the [MenuStyle.alignment] from [style] is not an [AlignmentDirectional]
  // (e.g. [Alignment]), then increasing [Offset.dx] values of
  // [alignmentOffset] move the menu position to the right.
  //
  // If the [MenuStyle.alignment] from [style] is an [AlignmentDirectional],
  // then in a [TextDirection.ltr] [Directionality], increasing [Offset.dx]
  // values of [alignmentOffset] move the menu position to the right. In a
  // [TextDirection.rtl] directionality, increasing [Offset.dx] values of
  // [alignmentOffset] move the menu position to the left.
  //
  // Defaults to [Offset.zero].
  DartOffsetType alignment_offset = 6;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 7;
  // Whether or not a tap event that closes the menu will be permitted to
  // continue on to the gesture arena.
  //
  // If false, then tapping outside of a menu when the menu is open will both
  // close the menu, and allow the tap to participate in the gesture arena. If
  // true, then it will only close the menu, and the tap event will be
  // consumed.
  //
  // Defaults to false.
  bool consume_outside_tap = 8;
  // Determine if the menu panel can be wrapped by a [UnconstrainedBox] which allows
  // the panel to render at its "natural" size.
  //
  // Defaults to true as it allows developers to render the menu panel at the
  // size it should be. When it is set to false, it can be useful when the menu should
  // be constrained in both main axis and cross axis, such as a [DropdownMenu].
  bool cross_axis_unconstrained = 11;
  // A list of children containing the menu items that are the contents of the
  // menu surrounded by this [MenuAnchor].
  //
  // {@macro flutter.material.MenuBar.shortcuts_note}
  repeated WidgetType menu_children = 12;
  // The optional child to be passed to the [builder].
  //
  // Supply this child if there is a portion of the widget tree built in
  // [builder] that doesn't depend on the `controller` or `context` supplied to
  // the [builder]. It will be more efficient, since Flutter doesn't then need
  // to rebuild this child when those change.
  WidgetType child = 14;
}

// package:flutter/src/material/menu_anchor.dart
//
// Creates a const [MenuBar].
//
// The [children] argument is required.
message MaterialMenuBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [MenuStyle] that defines the visual attributes of the menu bar.
  //
  // Colors and sizing of the menus is controllable via the [MenuStyle].
  //
  // Defaults to the ambient [MenuThemeData.style].
  MaterialMenuStyleType style = 3;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 4;
  // The [MenuController] to use for this menu bar.
  MaterialMenuControllerType controller = 5;
  // The list of menu items that are the top level children of the [MenuBar].
  //
  // A Widget in Flutter is immutable, so directly modifying the [children]
  // with [List] APIs such as `someMenuBarWidget.menus.add(...)` will result in
  // incorrect behaviors. Whenever the menus list is modified, a new list
  // object must be provided.
  //
  // {@macro flutter.material.MenuBar.shortcuts_note}
  repeated WidgetType children = 6;
}

// package:flutter/src/material/menu_bar_theme.dart
//
// Creates a theme that controls the configurations for [MenuBar] and
// [MenuItemButton] in its widget subtree.
message MaterialMenuBarTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties to set for [MenuBar] in this widget's descendants.
  MaterialMenuBarThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/menu_bar_theme.dart
//
// Creates a const set of properties used to configure [MenuTheme].
message MaterialMenuBarThemeData {
  // The [MenuStyle] of a [SubmenuButton] menu.
  //
  // Any values not set in the [MenuStyle] will use the menu default for that
  // property.
  MaterialMenuStyleType style = 2;
}

// package:flutter/src/material/menu_button_theme.dart
//
// Create a [MenuButtonTheme].
message MaterialMenuButtonTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The configuration of this theme.
  MaterialMenuButtonThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/menu_button_theme.dart
//
// Creates a [MenuButtonThemeData].
//
// The [style] may be null.
message MaterialMenuButtonThemeData {
  // Overrides for [SubmenuButton] and [MenuItemButton]'s default style.
  //
  // Non-null properties or non-null resolved [MaterialStateProperty] values
  // override the [ButtonStyle] returned by [SubmenuButton.defaultStyleOf] or
  // [MenuItemButton.defaultStyleOf].
  //
  // If [style] is null, then this theme doesn't override anything.
  MaterialButtonStyleType style = 2;
}

// package:flutter/src/material/menu_anchor.dart
message MaterialMenuController {
  
}

// package:flutter/src/material/menu_anchor.dart
//
// Creates a const [MenuItemButton].
//
// The [child] attribute is required.
message MaterialMenuItemButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Determine if hovering can request focus.
  //
  // Defaults to true.
  bool request_focus_on_hover = 5;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 7;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding properties in
  // [themeStyleOf] and [defaultStyleOf]. [MaterialStateProperty]s that resolve
  // to non-null values will similarly override the corresponding
  // [MaterialStateProperty]s in [themeStyleOf] and [defaultStyleOf].
  //
  // Null by default.
  MaterialButtonStyleType style = 9;
  // {@macro flutter.material.inkwell.statesController}
  MaterialMaterialStatesControllerType states_controller = 10;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 11;
  // An optional icon to display before the [child] label.
  WidgetType leading_icon = 12;
  // An optional icon to display after the [child] label.
  WidgetType trailing_icon = 13;
  // {@template flutter.material.menu_anchor.closeOnActivate}
  // Determines if the menu will be closed when a [MenuItemButton]
  // is pressed.
  //
  // Defaults to true.
  // {@endtemplate}
  bool close_on_activate = 14;
  // The widget displayed in the center of this button.
  //
  // Typically this is the button's label, using a [Text] widget.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 15;
}

// package:flutter/src/material/menu_style.dart
//
// Create a [MenuStyle].
message MaterialMenuStyle {
  // Defines how compact the menu's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all
  //    widgets within a [Theme].
  MaterialVisualDensityType visual_density = 13;
  // Determines the desired alignment of the submenu when opened relative to
  // the button that opens it.
  //
  // If there isn't sufficient space to open the menu with the given alignment,
  // and there's space on the other side of the button, then the alignment is
  // swapped to it's opposite (1 becomes -1, etc.), and the menu will try to
  // appear on the other side of the button. If there isn't enough space there
  // either, then the menu will be pushed as far over as necessary to display
  // as much of itself as possible, possibly overlapping the parent button.
  FlutterAlignmentGeometryType alignment = 14;
}

// package:flutter/src/material/menu_theme.dart
//
// Creates a const theme that controls the configurations for the menus
// created by the [SubmenuButton] or [MenuAnchor] widgets.
message MaterialMenuTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties for [MenuBar] and [MenuItemButton] in this widget's
  // descendants.
  MaterialMenuThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/menu_theme.dart
//
// Creates a const set of properties used to configure [MenuTheme].
message MaterialMenuThemeData {
  // The [MenuStyle] of a [SubmenuButton] menu.
  //
  // Any values not set in the [MenuStyle] will use the menu default for that
  // property.
  MaterialMenuStyleType style = 2;
}

// package:flutter/src/material/mergeable_material.dart
//
// Creates a mergeable Material list of items.
message MaterialMergeableMaterial {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The main layout axis.
  FlutterAxisType.Enum main_axis = 3;
  // The z-coordinate at which to place all the [Material] slices.
  //
  // Defaults to 2, the appropriate elevation for cards.
  double elevation = 4;
  // Whether connected pieces of [MaterialSlice] have dividers between them.
  bool has_dividers = 5;
  // The children of the [MergeableMaterial].
  repeated MaterialMergeableMaterialItemType children = 6;
  // Defines color used for dividers if [hasDividers] is true.
  //
  // If [dividerColor] is null, then [DividerThemeData.color] is used. If that
  // is null, then [ThemeData.dividerColor] is used.
  DartColorType divider_color = 7;
}

// package:flutter/src/material/navigation_bar.dart
//
// Creates a Material 3 Navigation Bar component.
//
// The value of [destinations] must be a list of two or more
// [NavigationDestination] values.
message MaterialNavigationBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Determines the transition time for each destination as it goes between
  // selected and unselected.
  DartDurationType animation_duration = 3;
  // Determines which one of the [destinations] is currently selected.
  //
  // When this is updated, the destination (from [destinations]) at
  // [selectedIndex] goes from unselected to selected.
  int32 selected_index = 4;
  // The list of destinations (usually [NavigationDestination]s) in this
  // [NavigationBar].
  //
  // When [selectedIndex] is updated, the destination from this list at
  // [selectedIndex] will animate from 0 (unselected) to 1.0 (selected). When
  // the animation is increasing or completed, the destination is considered
  // selected, when the animation is decreasing or dismissed, the destination
  // is considered unselected.
  repeated WidgetType destinations = 5;
  // The color of the [NavigationBar] itself.
  //
  // If null, [NavigationBarThemeData.backgroundColor] is used. If that
  // is also null, then if [ThemeData.useMaterial3] is true, the value is
  // [ColorScheme.surface]. If that is false, the default blends [ColorScheme.surface]
  // and [ColorScheme.onSurface] using an [ElevationOverlay].
  DartColorType background_color = 7;
  // The elevation of the [NavigationBar] itself.
  //
  // If null, [NavigationBarThemeData.elevation] is used. If that
  // is also null, then if [ThemeData.useMaterial3] is true then it will
  // be 3.0 otherwise 0.0.
  double elevation = 8;
  // The color used for the drop shadow to indicate elevation.
  //
  // If null, [NavigationBarThemeData.shadowColor] is used. If that
  // is also null, the default value is [Colors.transparent] which
  // indicates that no drop shadow will be displayed.
  //
  // See [Material.shadowColor] for more details on drop shadows.
  DartColorType shadow_color = 9;
  // The color used as an overlay on [backgroundColor] to indicate elevation.
  //
  // If null, [NavigationBarThemeData.surfaceTintColor] is used. If that
  // is also null, the default value is [ColorScheme.surfaceTint].
  //
  // See [Material.surfaceTintColor] for more details on how this
  // overlay is applied.
  DartColorType surface_tint_color = 10;
  // The color of the [indicatorShape] when this destination is selected.
  //
  // If null, [NavigationBarThemeData.indicatorColor] is used. If that
  // is also null and [ThemeData.useMaterial3] is true, [ColorScheme.secondaryContainer]
  // is used. Otherwise, [ColorScheme.secondary] with an opacity of 0.24 is used.
  DartColorType indicator_color = 11;
  // The shape of the selected indicator.
  //
  // If null, [NavigationBarThemeData.indicatorShape] is used. If that
  // is also null and [ThemeData.useMaterial3] is true, [StadiumBorder] is used.
  // Otherwise, [RoundedRectangleBorder] with a circular border radius of 16 is used.
  FlutterShapeBorderType indicator_shape = 12;
  // The height of the [NavigationBar] itself.
  //
  // If this is used in [Scaffold.bottomNavigationBar] and the scaffold is
  // full-screen, the safe area padding is also added to the height
  // automatically.
  //
  // The height does not adjust with [ThemeData.visualDensity] or
  // [MediaQueryData.textScaler] as this component loses usability at
  // larger and smaller sizes due to the truncating of labels or smaller tap
  // targets.
  //
  // If null, [NavigationBarThemeData.height] is used. If that
  // is also null, the default is 80.
  double height = 13;
  // Defines how the [destinations]' labels will be laid out and when they'll
  // be displayed.
  //
  // Can be used to show all labels, show only the selected label, or hide all
  // labels.
  //
  // If null, [NavigationBarThemeData.labelBehavior] is used. If that
  // is also null, the default is
  // [NavigationDestinationLabelBehavior.alwaysShow].
  MaterialNavigationDestinationLabelBehaviorType.Enum label_behavior = 14;
}

// package:flutter/src/material/navigation_bar_theme.dart
//
// Creates a navigation rail theme that controls the
// [NavigationBarThemeData] properties for a [NavigationBar].
message MaterialNavigationBarTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the background color, label text style, icon theme, and label
  // type values for descendant [NavigationBar] widgets.
  MaterialNavigationBarThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/navigation_bar_theme.dart
//
// Creates a theme that can be used for [ThemeData.navigationBarTheme] and
// [NavigationBarTheme].
message MaterialNavigationBarThemeData {
  // Overrides the default value of [NavigationBar.height].
  double height = 2;
  // Overrides the default value of [NavigationBar.backgroundColor].
  DartColorType background_color = 3;
  // Overrides the default value of [NavigationBar.elevation].
  double elevation = 4;
  // Overrides the default value of [NavigationBar.shadowColor].
  DartColorType shadow_color = 5;
  // Overrides the default value of [NavigationBar.surfaceTintColor].
  DartColorType surface_tint_color = 6;
  // Overrides the default value of [NavigationBar]'s selection indicator.
  DartColorType indicator_color = 7;
  // Overrides the default shape of the [NavigationBar]'s selection indicator.
  FlutterShapeBorderType indicator_shape = 8;
  // Overrides the default value of [NavigationBar.labelBehavior].
  MaterialNavigationDestinationLabelBehaviorType.Enum label_behavior = 11;
}

// package:flutter/src/material/navigation_bar.dart
//
// Creates a navigation bar destination with an icon and a label, to be used
// in the [NavigationBar.destinations].
message MaterialNavigationDestination {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The [Widget] (usually an [Icon]) that's displayed for this
  // [NavigationDestination].
  //
  // The icon will use [NavigationBarThemeData.iconTheme]. If this is
  // null, the default [IconThemeData] would use a size of 24.0 and
  // [ColorScheme.onSurface].
  WidgetType icon = 3;
  // The optional [Widget] (usually an [Icon]) that's displayed when this
  // [NavigationDestination] is selected.
  //
  // If [selectedIcon] is non-null, the destination will fade from
  // [icon] to [selectedIcon] when this destination goes from unselected to
  // selected.
  //
  // The icon will use [NavigationBarThemeData.iconTheme] with
  // [MaterialState.selected]. If this is null, the default [IconThemeData]
  // would use a size of 24.0 and [ColorScheme.onSurface].
  WidgetType selected_icon = 4;
  // The text label that appears below the icon of this
  // [NavigationDestination].
  //
  // The accompanying [Text] widget will use
  // [NavigationBarThemeData.labelTextStyle]. If this are null, the default
  // text style would use [TextTheme.labelSmall] with [ColorScheme.onSurface].
  string label = 5;
  // The text to display in the tooltip for this [NavigationDestination], when
  // the user long presses the destination.
  //
  // If [tooltip] is an empty string, no tooltip will be used.
  //
  // Defaults to null, in which case the [label] text will be used.
  string tooltip = 6;
  // Indicates that this destination is selectable.
  //
  // Defaults to true.
  bool enabled = 7;
}

// package:flutter/src/material/navigation_drawer.dart
//
// Creates a Material Design Navigation Drawer component.
message MaterialNavigationDrawer {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Defines the appearance of the items within the navigation drawer.
  //
  // The list contains [NavigationDrawerDestination] widgets and/or customized
  // widgets like headlines and dividers.
  repeated WidgetType children = 3;
  // The background color of the [Material] that holds the [NavigationDrawer]'s
  // contents.
  //
  // If this is null, then [NavigationDrawerThemeData.backgroundColor] is used.
  // If that is also null, then it falls back to [ColorScheme.surface].
  DartColorType background_color = 4;
  // The color used for the drop shadow to indicate elevation.
  //
  // If null, [NavigationDrawerThemeData.shadowColor] is used. If that
  // is also null, the default value is [Colors.transparent] which
  // indicates that no drop shadow will be displayed.
  //
  // See [Material.shadowColor] for more details on drop shadows.
  DartColorType shadow_color = 5;
  //  The surface tint of the [Material] that holds the [NavigationDrawer]'s
  // contents.
  //
  // If this is null, then [NavigationDrawerThemeData.surfaceTintColor] is used.
  // If that is also null, then it falls back to [Material.surfaceTintColor]'s default.
  DartColorType surface_tint_color = 6;
  // The elevation of the [NavigationDrawer] itself.
  //
  // If null, [NavigationDrawerThemeData.elevation] is used. If that
  // is also null, it will be 1.0.
  double elevation = 7;
  // The color of the [indicatorShape] when this destination is selected.
  //
  // If this is null, [NavigationDrawerThemeData.indicatorColor] is used.
  // If that is also null, defaults to [ColorScheme.secondaryContainer].
  DartColorType indicator_color = 8;
  // The shape of the selected indicator.
  //
  // If this is null, [NavigationDrawerThemeData.indicatorShape] is used.
  // If that is also null, defaults to [StadiumBorder].
  FlutterShapeBorderType indicator_shape = 9;
  // The index into destinations for the current selected
  // [NavigationDrawerDestination] or null if no destination is selected.
  //
  // A valid [selectedIndex] satisfies 0 <= [selectedIndex] < number of [NavigationDrawerDestination].
  // For an invalid [selectedIndex] like `-1`, all destinations will appear unselected.
  int32 selected_index = 11;
  // Defines the padding for [NavigationDrawerDestination] widgets (Drawer items).
  //
  // Defaults to `EdgeInsets.symmetric(horizontal: 12.0)`.
  FlutterEdgeInsetsGeometryType tile_padding = 12;
}

// package:flutter/src/material/navigation_drawer.dart
//
// Creates a navigation drawer destination.
message MaterialNavigationDrawerDestination {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Sets the color of the destination.
  //
  // If this is null, then [NavigationDrawerThemeData.backgroundColor].
  DartColorType background_color = 3;
  // The [Widget] (usually an [Icon]) that's displayed for this
  // [NavigationDestination].
  //
  // The icon will use [NavigationDrawerThemeData.iconTheme]. If this is
  // null, the default [IconThemeData] would use a size of 24.0 and
  // [ColorScheme.onSurfaceVariant].
  WidgetType icon = 4;
  // The optional [Widget] (usually an [Icon]) that's displayed when this
  // [NavigationDestination] is selected.
  //
  // If [selectedIcon] is non-null, the destination will fade from
  // [icon] to [selectedIcon] when this destination goes from unselected to
  // selected.
  //
  // The icon will use [NavigationDrawerThemeData.iconTheme] with
  // [MaterialState.selected]. If this is null, the default [IconThemeData]
  // would use a size of 24.0 and [ColorScheme.onSecondaryContainer].
  WidgetType selected_icon = 5;
  // The text label that appears on the right of the icon
  //
  // The accompanying [Text] widget will use
  // [NavigationDrawerThemeData.labelTextStyle]. If this are null, the default
  // text style would use [TextTheme.labelLarge] with [ColorScheme.onSurfaceVariant].
  WidgetType label = 6;
  // Indicates that this destination is selectable.
  //
  // Defaults to true.
  bool enabled = 7;
}

// package:flutter/src/material/navigation_drawer_theme.dart
//
// Creates a navigation rail theme that controls the
// [NavigationDrawerThemeData] properties for a [NavigationDrawer].
message MaterialNavigationDrawerTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the background color, label text style, icon theme, and label
  // type values for descendant [NavigationDrawer] widgets.
  MaterialNavigationDrawerThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/navigation_drawer_theme.dart
//
// Creates a theme that can be used for [ThemeData.navigationDrawerTheme] and
// [NavigationDrawerTheme].
message MaterialNavigationDrawerThemeData {
  // Overrides the default height of [NavigationDrawerDestination].
  double tile_height = 2;
  // Overrides the default value of [NavigationDrawer.backgroundColor].
  DartColorType background_color = 3;
  // Overrides the default value of [NavigationDrawer.elevation].
  double elevation = 4;
  // Overrides the default value of [NavigationDrawer.shadowColor].
  DartColorType shadow_color = 5;
  // Overrides the default value of [NavigationDrawer.surfaceTintColor].
  DartColorType surface_tint_color = 6;
  // Overrides the default value of [NavigationDrawer]'s selection indicator.
  DartColorType indicator_color = 7;
  // Overrides the default shape of the [NavigationDrawer]'s selection indicator.
  FlutterShapeBorderType indicator_shape = 8;
  // Overrides the default size of the [NavigationDrawer]'s selection indicator.
  DartSizeType indicator_size = 9;
}

// package:flutter/src/material/navigation_rail.dart
//
// Creates a Material Design navigation rail.
//
// The value of [destinations] must be a list of two or more
// [NavigationRailDestination] values.
//
// If [elevation] is specified, it must be non-negative.
//
// If [minWidth] is specified, it must be non-negative, and if
// [minExtendedWidth] is specified, it must be non-negative and greater than
// [minWidth].
//
// The [extended] argument can only be set to true when the [labelType] is
// null or [NavigationRailLabelType.none].
//
// If [backgroundColor], [elevation], [groupAlignment], [labelType],
// [unselectedLabelTextStyle], [selectedLabelTextStyle],
// [unselectedIconTheme], or [selectedIconTheme] are null, then their
// [NavigationRailThemeData] values will be used. If the corresponding
// [NavigationRailThemeData] property is null, then the navigation rail
// defaults are used. See the individual properties for more information.
//
// Typically used within a [Row] that defines the [Scaffold.body] property.
message MaterialNavigationRail {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Sets the color of the Container that holds all of the [NavigationRail]'s
  // contents.
  //
  // The default value is [NavigationRailThemeData.backgroundColor]. If
  // [NavigationRailThemeData.backgroundColor] is null, then the default value
  // is based on [ColorScheme.surface] of [ThemeData.colorScheme].
  DartColorType background_color = 3;
  // Indicates that the [NavigationRail] should be in the extended state.
  //
  // The extended state has a wider rail container, and the labels are
  // positioned next to the icons. [minExtendedWidth] can be used to set the
  // minimum width of the rail when it is in this state.
  //
  // The rail will implicitly animate between the extended and normal state.
  //
  // If the rail is going to be in the extended state, then the [labelType]
  // must be set to [NavigationRailLabelType.none].
  //
  // The default value is false.
  bool extended = 4;
  // The leading widget in the rail that is placed above the destinations.
  //
  // It is placed at the top of the rail, above the [destinations]. Its
  // location is not affected by [groupAlignment].
  //
  // This is commonly a [FloatingActionButton], but may also be a non-button,
  // such as a logo.
  //
  // The default value is null.
  WidgetType leading = 5;
  // The trailing widget in the rail that is placed below the destinations.
  //
  // The trailing widget is placed below the last [NavigationRailDestination].
  // It's location is affected by [groupAlignment].
  //
  // This is commonly a list of additional options or destinations that is
  // usually only rendered when [extended] is true.
  //
  // The default value is null.
  WidgetType trailing = 6;
  // Defines the appearance of the button items that are arrayed within the
  // navigation rail.
  //
  // The value must be a list of two or more [NavigationRailDestination]
  // values.
  repeated MaterialNavigationRailDestinationType destinations = 7;
  // The index into [destinations] for the current selected
  // [NavigationRailDestination] or null if no destination is selected.
  int32 selected_index = 8;
  // The rail's elevation or z-coordinate.
  //
  // If [Directionality] is [intl.TextDirection.LTR], the inner side is the
  // right side, and if [Directionality] is [intl.TextDirection.RTL], it is
  // the left side.
  //
  // The default value is 0.
  double elevation = 10;
  // The vertical alignment for the group of [destinations] within the rail.
  //
  // The [NavigationRailDestination]s are grouped together with the [trailing]
  // widget, between the [leading] widget and the bottom of the rail.
  //
  // The value must be between -1.0 and 1.0.
  //
  // If [groupAlignment] is -1.0, then the items are aligned to the top. If
  // [groupAlignment] is 0.0, then the items are aligned to the center. If
  // [groupAlignment] is 1.0, then the items are aligned to the bottom.
  //
  // The default is -1.0.
  //
  // See also:
  //   * [Alignment.y]
  //
  double group_alignment = 11;
  // Defines the layout and behavior of the labels for the default, unextended
  // [NavigationRail].
  //
  // When a navigation rail is [extended], the labels are always shown.
  //
  // The default value is [NavigationRailThemeData.labelType]. If
  // [NavigationRailThemeData.labelType] is null, then the default value is
  // [NavigationRailLabelType.none].
  //
  // See also:
  //
  //   * [NavigationRailLabelType] for information on the meaning of different
  //   types.
  MaterialNavigationRailLabelTypeType.Enum label_type = 12;
  // The [TextStyle] of a destination's label when it is unselected.
  //
  // When one of the [destinations] is selected the [selectedLabelTextStyle]
  // will be used instead.
  //
  // The default value is based on the [Theme]'s [TextTheme.bodyLarge]. The
  // default color is based on the [Theme]'s [ColorScheme.onSurface].
  //
  // Properties from this text style, or
  // [NavigationRailThemeData.unselectedLabelTextStyle] if this is null, are
  // merged into the defaults.
  FlutterTextStyleType unselected_label_text_style = 13;
  // The [TextStyle] of a destination's label when it is selected.
  //
  // When a [NavigationRailDestination] is not selected,
  // [unselectedLabelTextStyle] will be used.
  //
  // The default value is based on the [TextTheme.bodyLarge] of
  // [ThemeData.textTheme]. The default color is based on the [Theme]'s
  // [ColorScheme.primary].
  //
  // Properties from this text style,
  // or [NavigationRailThemeData.selectedLabelTextStyle] if this is null, are
  // merged into the defaults.
  FlutterTextStyleType selected_label_text_style = 14;
  // The visual properties of the icon in the unselected destination.
  //
  // If this field is not provided, or provided with any null properties, then
  // a copy of the [IconThemeData.fallback] with a custom [NavigationRail]
  // specific color will be used.
  //
  // The default value is the [Theme]'s [ThemeData.iconTheme] with a color
  // of the [Theme]'s [ColorScheme.onSurface] with an opacity of 0.64.
  // Properties from this icon theme, or
  // [NavigationRailThemeData.unselectedIconTheme] if this is null, are
  // merged into the defaults.
  FlutterIconThemeDataType unselected_icon_theme = 15;
  // The visual properties of the icon in the selected destination.
  //
  // When a [NavigationRailDestination] is not selected,
  // [unselectedIconTheme] will be used.
  //
  // The default value is the [Theme]'s [ThemeData.iconTheme] with a color
  // of the [Theme]'s [ColorScheme.primary]. Properties from this icon theme,
  // or [NavigationRailThemeData.selectedIconTheme] if this is null, are
  // merged into the defaults.
  FlutterIconThemeDataType selected_icon_theme = 16;
  // The smallest possible width for the rail regardless of the destination's
  // icon or label size.
  //
  // The default is 72.
  //
  // This value also defines the min width and min height of the destinations.
  //
  // To make a compact rail, set this to 56 and use
  // [NavigationRailLabelType.none].
  double min_width = 17;
  // The final width when the animation is complete for setting [extended] to
  // true.
  //
  // This is only used when [extended] is set to true.
  //
  // The default value is 256.
  double min_extended_width = 18;
  // If `true`, adds a rounded [NavigationIndicator] behind the selected
  // destination's icon.
  //
  // The indicator's shape will be circular if [labelType] is
  // [NavigationRailLabelType.none], or a [StadiumBorder] if [labelType] is
  // [NavigationRailLabelType.all] or [NavigationRailLabelType.selected].
  //
  // If `null`, defaults to [NavigationRailThemeData.useIndicator]. If that is
  // `null`, defaults to [ThemeData.useMaterial3].
  bool use_indicator = 19;
  // Overrides the default value of [NavigationRail]'s selection indicator color,
  // when [useIndicator] is true.
  //
  // If this is null, [NavigationRailThemeData.indicatorColor] is used. If
  // that is null, defaults to [ColorScheme.secondaryContainer].
  DartColorType indicator_color = 20;
  // Overrides the default value of [NavigationRail]'s selection indicator shape,
  // when [useIndicator] is true.
  //
  // If this is null, [NavigationRailThemeData.indicatorShape] is used. If
  // that is null, defaults to [StadiumBorder].
  FlutterShapeBorderType indicator_shape = 21;
}

// package:flutter/src/material/navigation_rail.dart
//
// Creates a destination that is used with [NavigationRail.destinations].
//
// When the [NavigationRail.labelType] is [NavigationRailLabelType.none], the
// label is still used for semantics, and may still be used if
// [NavigationRail.extended] is true.
message MaterialNavigationRailDestination {
  // The icon of the destination.
  //
  // Typically the icon is an [Icon] or an [ImageIcon] widget. If another type
  // of widget is provided then it should configure itself to match the current
  // [IconTheme] size and color.
  //
  // If [selectedIcon] is provided, this will only be displayed when the
  // destination is not selected.
  //
  // To make the [NavigationRail] more accessible, consider choosing an
  // icon with a stroked and filled version, such as [Icons.cloud] and
  // [Icons.cloud_queue]. The [icon] should be set to the stroked version and
  // [selectedIcon] to the filled version.
  WidgetType icon = 2;
  WidgetType selected_icon = 3;
  // The color of the [indicatorShape] when this destination is selected.
  DartColorType indicator_color = 4;
  // The shape of the selection indicator.
  FlutterShapeBorderType indicator_shape = 5;
  // The label for the destination.
  //
  // The label must be provided when used with the [NavigationRail]. When the
  // [NavigationRail.labelType] is [NavigationRailLabelType.none], the label is
  // still used for semantics, and may still be used if
  // [NavigationRail.extended] is true.
  WidgetType label = 6;
  // The amount of space to inset the destination item.
  FlutterEdgeInsetsGeometryType padding = 7;
  // Indicates that this destination is inaccessible.
  bool disabled = 8;
}

// package:flutter/src/material/navigation_rail_theme.dart
//
// Creates a navigation rail theme that controls the
// [NavigationRailThemeData] properties for a [NavigationRail].
message MaterialNavigationRailTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the background color, elevation, label text style, icon theme,
  // group alignment, and label type and border values for descendant
  // [NavigationRail] widgets.
  MaterialNavigationRailThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/navigation_rail_theme.dart
//
// Creates a theme that can be used for [ThemeData.navigationRailTheme].
message MaterialNavigationRailThemeData {
  // Color to be used for the [NavigationRail]'s background.
  DartColorType background_color = 2;
  // The z-coordinate to be used for the [NavigationRail]'s elevation.
  double elevation = 3;
  // The style to merge with the default text style for
  // [NavigationRailDestination] labels, when the destination is not selected.
  FlutterTextStyleType unselected_label_text_style = 4;
  // The style to merge with the default text style for
  // [NavigationRailDestination] labels, when the destination is selected.
  FlutterTextStyleType selected_label_text_style = 5;
  // The theme to merge with the default icon theme for
  // [NavigationRailDestination] icons, when the destination is not selected.
  FlutterIconThemeDataType unselected_icon_theme = 6;
  // The theme to merge with the default icon theme for
  // [NavigationRailDestination] icons, when the destination is selected.
  FlutterIconThemeDataType selected_icon_theme = 7;
  // The alignment for the [NavigationRailDestination]s as they are positioned
  // within the [NavigationRail].
  double group_alignment = 8;
  // The type that defines the layout and behavior of the labels in the
  // [NavigationRail].
  MaterialNavigationRailLabelTypeType.Enum label_type = 9;
  // Whether or not the selected [NavigationRailDestination] should include a
  // [NavigationIndicator].
  bool use_indicator = 10;
  // Overrides the default value of [NavigationRail]'s selection indicator color,
  // when [useIndicator] is true.
  DartColorType indicator_color = 11;
  // Overrides the default shape of the [NavigationRail]'s selection indicator.
  FlutterShapeBorderType indicator_shape = 12;
  // Overrides the default value of [NavigationRail]'s minimum width when it
  // is not extended.
  double min_width = 13;
  // Overrides the default value of [NavigationRail]'s minimum width when it
  // is extended.
  double min_extended_width = 14;
}

// package:flutter/src/material/input_border.dart
//
// Creates a rounded rectangle outline border for an [InputDecorator].
//
// If the [borderSide] parameter is [BorderSide.none], it will not draw a
// border. However, it will still define a shape (which you can see if
// [InputDecoration.filled] is true).
//
// If an application does not specify a [borderSide] parameter of
// value [BorderSide.none], the input decorator substitutes its own, using
// [copyWith], based on the current theme and [InputDecorator.isFocused].
//
// The [borderRadius] parameter defaults to a value where all four corners
// have a circular radius of 4.0. The corner radii must be circular, i.e.
// their [Radius.x] and [Radius.y] values must be the same.
//
// See also:
//
//  * [InputDecoration.floatingLabelBehavior], which should be set to
//    [FloatingLabelBehavior.never] when the [borderSide] is
//    [BorderSide.none]. If let as [FloatingLabelBehavior.auto], the label
//    will extend beyond the container as if the border were still being
//    drawn.
message MaterialOutlineInputBorder {
  // Defines the border line's color and weight.
  //
  // The [InputDecorator] creates copies of its input border, using [copyWith],
  // based on the current theme and [InputDecorator.isFocused].
  FlutterBorderSideType border_side = 2;
  // The radii of the border's rounded rectangle corners.
  //
  // The corner radii must be circular, i.e. their [Radius.x] and [Radius.y]
  // values must be the same.
  FlutterBorderRadiusType border_radius = 3;
  // Horizontal padding on either side of the border's
  // [InputDecoration.labelText] width gap.
  //
  // This value is used by the [paint] method to compute the actual gap width.
  double gap_padding = 4;
}

// package:flutter/src/material/outlined_button.dart
//
// Create an OutlinedButton.
message MaterialOutlinedButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [themeStyleOf] and [defaultStyleOf]. [MaterialStateProperty]s
  // that resolve to non-null values will similarly override the corresponding
  // [MaterialStateProperty]s in [themeStyleOf] and [defaultStyleOf].
  //
  // Null by default.
  MaterialButtonStyleType style = 7;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 8;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // {@macro flutter.material.inkwell.statesController}
  MaterialMaterialStatesControllerType states_controller = 11;
  // Typically the button's label.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 12;
}

// package:flutter/src/material/outlined_button.dart
//
// Create a text button from a pair of widgets that serve as the button's
// [icon] and [label].
//
// The icon and label are arranged in a row and padded by 12 logical pixels
// at the start, and 16 at the end, with an 8 pixel gap in between.
message MaterialOutlinedButtonNamedIcon {
  FlutterKeyType key = 2;
  MaterialButtonStyleType style = 5;
  FlutterFocusNodeType focus_node = 6;
  bool autofocus = 7;
  DartClipType.Enum clip_behavior = 8;
  MaterialMaterialStatesControllerType states_controller = 9;
  WidgetType icon = 10;
  WidgetType label = 11;
}

// package:flutter/src/material/outlined_button_theme.dart
//
// Create a [OutlinedButtonTheme].
message MaterialOutlinedButtonTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The configuration of this theme.
  MaterialOutlinedButtonThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/outlined_button_theme.dart
//
// Creates a [OutlinedButtonThemeData].
//
// The [style] may be null.
message MaterialOutlinedButtonThemeData {
  // Overrides for [OutlinedButton]'s default style.
  //
  // Non-null properties or non-null resolved [MaterialStateProperty]
  // values override the [ButtonStyle] returned by
  // [OutlinedButton.defaultStyleOf].
  //
  // If [style] is null, then this theme doesn't override anything.
  MaterialButtonStyleType style = 2;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider value indicator in the shape of an upside-down pear.
message MaterialPaddleRangeSliderValueIndicatorShape {
  
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider value indicator in the shape of an upside-down pear.
message MaterialPaddleSliderValueIndicatorShape {
  
}

// package:flutter/src/material/page_transitions_theme.dart
//
// Constructs an object that selects a transition based on the platform.
//
// By default the list of builders is: [ZoomPageTransitionsBuilder]
// for [TargetPlatform.android], and [CupertinoPageTransitionsBuilder] for
// [TargetPlatform.iOS] and [TargetPlatform.macOS].
message MaterialPageTransitionsTheme {
  
}

// package:flutter/src/material/paginated_data_table.dart
//
// Creates a widget describing a paginated [DataTable] on a [Card].
//
// The [header] should give the card's header, typically a [Text] widget.
//
// The [columns] argument must be a list of as many [DataColumn] objects as
// the table is to have columns, ignoring the leading checkbox column if any.
// The [columns] argument must have a length greater than zero and cannot be
// null.
//
// If the table is sorted, the column that provides the current primary key
// should be specified by index in [sortColumnIndex], 0 meaning the first
// column in [columns], 1 being the next one, and so forth.
//
// The actual sort order can be specified using [sortAscending]; if the sort
// order is ascending, this should be true (the default), otherwise it should
// be false.
//
// The [source] should be a long-lived [DataTableSource]. The same source
// should be provided each time a particular [PaginatedDataTable] widget is
// created; avoid creating a new [DataTableSource] with each new instance of
// the [PaginatedDataTable] widget unless the data table really is to now
// show entirely different data from a new source.
//
// Themed by [DataTableTheme]. [DataTableThemeData.decoration] is ignored.
// To modify the border or background color of the [PaginatedDataTable], use
// [CardTheme], since a [Card] wraps the inner [DataTable].
message MaterialPaginatedDataTable {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The table card's optional header.
  //
  // This is typically a [Text] widget, but can also be a [Row] of
  // [TextButton]s. To show icon buttons at the top end side of the table with
  // a header, set the [actions] property.
  //
  // If items in the table are selectable, then, when the selection is not
  // empty, the header is replaced by a count of the selected items. The
  // [actions] are still visible when items are selected.
  WidgetType header = 3;
  // Icon buttons to show at the top end side of the table. The [header] must
  // not be null to show the actions.
  //
  // Typically, the exact actions included in this list will vary based on
  // whether any rows are selected or not.
  //
  // These should be size 24.0 with default padding (8.0).
  repeated WidgetType actions = 4;
  // The configuration and labels for the columns in the table.
  repeated MaterialDataColumnType columns = 5;
  // The current primary sort key's column.
  //
  // See [DataTable.sortColumnIndex] for details.
  //
  // The direction of the sort is specified using [sortAscending].
  int32 sort_column_index = 6;
  // Whether the column mentioned in [sortColumnIndex], if any, is sorted
  // in ascending order.
  //
  // See [DataTable.sortAscending] for details.
  bool sort_ascending = 7;
  double data_row_min_height = 9;
  double data_row_max_height = 10;
  // The height of the heading row.
  //
  // This value is optional and defaults to 56.0 if not specified.
  double heading_row_height = 11;
  // The horizontal margin between the edges of the table and the content
  // in the first and last cells of each row.
  //
  // When a checkbox is displayed, it is also the margin between the checkbox
  // the content in the first data column.
  //
  // This value defaults to 24.0 to adhere to the Material Design specifications.
  //
  // If [checkboxHorizontalMargin] is null, then [horizontalMargin] is also the
  // margin between the edge of the table and the checkbox, as well as the
  // margin between the checkbox and the content in the first data column.
  double horizontal_margin = 12;
  // The horizontal margin between the contents of each data column.
  //
  // This value defaults to 56.0 to adhere to the Material Design specifications.
  double column_spacing = 13;
  // {@macro flutter.material.dataTable.showCheckboxColumn}
  bool show_checkbox_column = 14;
  // Flag to display the pagination buttons to go to the first and last pages.
  bool show_first_last_buttons = 15;
  // The index of the first row to display when the widget is first created.
  int32 initial_first_row_index = 16;
  // The number of rows to show on each page.
  //
  // See also:
  //
  //  * [onRowsPerPageChanged]
  //  * [defaultRowsPerPage]
  int32 rows_per_page = 18;
  // The options to offer for the rowsPerPage.
  //
  // The current [rowsPerPage] must be a value in this list.
  //
  // The values in this list should be sorted in ascending order.
  repeated int32 available_rows_per_page = 19;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 21;
  // Defines the color of the arrow heads in the footer.
  DartColorType arrow_head_color = 22;
  // Horizontal margin around the checkbox, if it is displayed.
  //
  // If null, then [horizontalMargin] is used as the margin between the edge
  // of the table and the checkbox, as well as the margin between the checkbox
  // and the content in the first data column. This value defaults to 24.0.
  double checkbox_horizontal_margin = 24;
  // {@macro flutter.widgets.scroll_view.controller}
  FlutterScrollControllerType controller = 25;
  // {@macro flutter.widgets.scroll_view.primary}
  bool primary = 26;
  // Controls the visibility of empty rows on the last page of a
  // [PaginatedDataTable].
  //
  // Defaults to `true`, which means empty rows will be populated on the
  // last page of the table if there is not enough content.
  // When set to `false`, empty rows will not be created.
  bool show_empty_rows = 28;
}

// package:flutter/src/material/popup_menu.dart
//
// Creates a horizontal divider for a popup menu.
//
// By default, the divider has a height of 16 logical pixels.
message MaterialPopupMenuDivider {
  FlutterKeyType key = 2;
  // The height of the divider entry.
  //
  // Defaults to 16 pixels.
  double height = 3;
}

// package:flutter/src/material/popup_menu.dart
//
// Creates an item for a popup menu.
//
// By default, the item is [enabled].
message MaterialPopupMenuItem {
  FlutterKeyType key = 2;
  // Whether the user is permitted to select this item.
  //
  // Defaults to true. If this is false, then the item will not react to
  // touches.
  bool enabled = 5;
  // The minimum height of the menu item.
  //
  // Defaults to [kMinInteractiveDimension] pixels.
  double height = 6;
  // The padding of the menu item.
  //
  // The [height] property may interact with the applied padding. For example,
  // If a [height] greater than the height of the sum of the padding and [child]
  // is provided, then the padding's effect will not be visible.
  //
  // If this is null and [ThemeData.useMaterial3] is true, the horizontal padding
  // defaults to 12.0 on both sides.
  //
  // If this is null and [ThemeData.useMaterial3] is false, the horizontal padding
  // defaults to 16.0 on both sides.
  FlutterEdgeInsetsType padding = 7;
  // The text style of the popup menu item.
  //
  // If this property is null, then [PopupMenuThemeData.textStyle] is used.
  // If [PopupMenuThemeData.textStyle] is also null, then [TextTheme.titleMedium]
  // of [ThemeData.textTheme] is used.
  FlutterTextStyleType text_style = 8;
  // The widget below this widget in the tree.
  //
  // Typically a single-line [ListTile] (for menus with icons) or a [Text]. An
  // appropriate [DefaultTextStyle] is put in scope for the child. In either
  // case, the text should be short enough that it won't wrap.
  WidgetType child = 11;
}

// package:flutter/src/material/popup_menu_theme.dart
//
// Creates a popup menu theme that controls the configurations for
// popup menus in its widget subtree.
message MaterialPopupMenuTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties for descendant popup menu widgets.
  MaterialPopupMenuThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/popup_menu_theme.dart
//
// Creates the set of properties used to configure [PopupMenuTheme].
message MaterialPopupMenuThemeData {
  // The background color of the popup menu.
  DartColorType color = 2;
  // The shape of the popup menu.
  FlutterShapeBorderType shape = 3;
  // The elevation of the popup menu.
  double elevation = 4;
  // The color used to paint shadow below the popup menu.
  DartColorType shadow_color = 5;
  // The color used as an overlay on [color] of the popup menu.
  DartColorType surface_tint_color = 6;
  // The text style of items in the popup menu.
  FlutterTextStyleType text_style = 7;
  // If specified, defines the feedback property for [PopupMenuButton].
  //
  // If [PopupMenuButton.enableFeedback] is provided, [enableFeedback] is ignored.
  bool enable_feedback = 9;
  // Whether the popup menu is positioned over or under the popup menu button.
  //
  // When not set, the position defaults to [PopupMenuPosition.over] which makes the
  // popup menu appear directly over the button that was used to create it.
  MaterialPopupMenuPositionType.Enum position = 11;
  // The color of the icon in the popup menu button.
  DartColorType icon_color = 12;
  // The size of the icon in the popup menu button.
  double icon_size = 13;
}

// package:flutter/src/material/progress_indicator_theme.dart
//
// Creates a theme that controls the configurations for [ProgressIndicator]
// widgets.
message MaterialProgressIndicatorTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties for descendant [ProgressIndicator] widgets.
  MaterialProgressIndicatorThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/progress_indicator_theme.dart
//
// Creates the set of properties used to configure [ProgressIndicator] widgets.
message MaterialProgressIndicatorThemeData {
  // The color of the [ProgressIndicator]'s indicator.
  //
  // If null, then it will use [ColorScheme.primary] of the ambient
  // [ThemeData.colorScheme].
  //
  // See also:
  //
  //  * [ProgressIndicator.color], which specifies the indicator color for a
  //    specific progress indicator.
  //  * [ProgressIndicator.valueColor], which specifies the indicator color
  //    a an animated color.
  DartColorType color = 2;
  // {@macro flutter.material.LinearProgressIndicator.trackColor}
  DartColorType linear_track_color = 3;
  // {@macro flutter.material.LinearProgressIndicator.minHeight}
  double linear_min_height = 4;
  // {@macro flutter.material.CircularProgressIndicator.trackColor}
  DartColorType circular_track_color = 5;
  // {@macro flutter.material.RefreshProgressIndicator.backgroundColor}
  DartColorType refresh_background_color = 6;
}

// package:flutter/src/material/radio_theme.dart
//
// Constructs a radio theme that configures all descendant [Radio] widgets.
message MaterialRadioTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [Radio] widgets.
  MaterialRadioThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/radio_theme.dart
//
// Creates a theme that can be used for [ThemeData.radioTheme].
message MaterialRadioThemeData {
  // {@macro flutter.material.radio.splashRadius}
  //
  // If specified, overrides the default value of [Radio.splashRadius]. The
  // default value is [kRadialReactionRadius].
  double splash_radius = 5;
  // {@macro flutter.material.radio.materialTapTargetSize}
  //
  // If specified, overrides the default value of
  // [Radio.materialTapTargetSize]. The default value is the value of
  // [ThemeData.materialTapTargetSize].
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 6;
  // {@macro flutter.material.radio.visualDensity}
  //
  // If specified, overrides the default value of [Radio.visualDensity]. The
  // default value is the value of [ThemeData.visualDensity].
  MaterialVisualDensityType visual_density = 7;
}

// package:flutter/src/material/slider_theme.dart
//
// Creates pair of start and end labels.
message MaterialRangeLabels {
  // The label of the start thumb.
  //
  // For LTR text direction, the start is the left thumb, and for RTL text
  // direction, the start is the right thumb.
  string start = 2;
  // The label of the end thumb.
  //
  // For LTR text direction, the end is the right thumb, and for RTL text
  // direction, the end is the left thumb.
  string end = 3;
}

// package:flutter/src/material/range_slider.dart
//
// Creates a Material Design range slider.
//
// The range slider widget itself does not maintain any state. Instead, when
// the state of the slider changes, the widget calls the [onChanged]
// callback. Most widgets that use a range slider will listen for the
// [onChanged] callback and rebuild the slider with new [values] to update
// the visual appearance of the slider. To know when the value starts to
// change, or when it is done changing, set the optional callbacks
// [onChangeStart] and/or [onChangeEnd].
//
// * [values], which determines currently selected values for this range
//   slider.
// * [onChanged], which is called while the user is selecting a new value for
//   the range slider.
// * [onChangeStart], which is called when the user starts to select a new
//   value for the range slider.
// * [onChangeEnd], which is called when the user is done selecting a new
//   value for the range slider.
//
// You can override some of the colors with the [activeColor] and
// [inactiveColor] properties, although more fine-grained control of the
// appearance is achieved using a [SliderThemeData].
//
// The [min] must be less than or equal to the [max].
//
// The [RangeValues.start] attribute of the [values] parameter must be less
// than or equal to its [RangeValues.end] attribute. The [RangeValues.start]
// and [RangeValues.end] attributes of the [values] parameter must be greater
// than or equal to the [min] parameter and less than or equal to the [max]
// parameter.
//
// The [divisions] parameter must be null or greater than zero.
message MaterialRangeSlider {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The currently selected values for this range slider.
  //
  // The slider's thumbs are drawn at horizontal positions that corresponds to
  // these values.
  MaterialRangeValuesType values = 3;
  // The minimum value the user can select.
  //
  // Defaults to 0.0. Must be less than or equal to [max].
  //
  // If the [max] is equal to the [min], then the slider is disabled.
  double min = 7;
  // The maximum value the user can select.
  //
  // Defaults to 1.0. Must be greater than or equal to [min].
  //
  // If the [max] is equal to the [min], then the slider is disabled.
  double max = 8;
  // The number of discrete divisions.
  //
  // Typically used with [labels] to show the current discrete values.
  //
  // If null, the slider is continuous.
  int32 divisions = 9;
  // Labels to show as text in the [SliderThemeData.rangeValueIndicatorShape]
  // when the slider is active and [SliderThemeData.showValueIndicator]
  // is satisfied.
  //
  // There are two labels: one for the start thumb and one for the end thumb.
  //
  // Each label is rendered using the active [ThemeData]'s
  // [TextTheme.bodyLarge] text style, with the theme data's
  // [ColorScheme.onPrimary] color. The label's text style can be overridden
  // with [SliderThemeData.valueIndicatorTextStyle].
  //
  // If null, then the value indicator will not be displayed.
  //
  // See also:
  //
  //  * [RangeSliderValueIndicatorShape] for how to create a custom value
  //    indicator shape.
  MaterialRangeLabelsType labels = 10;
  // The color of the track's active segment, i.e. the span of track between
  // the thumbs.
  //
  // Defaults to [ColorScheme.primary].
  //
  // Using a [SliderTheme] gives more fine-grained control over the
  // appearance of various components of the slider.
  DartColorType active_color = 11;
  // The color of the track's inactive segments, i.e. the span of tracks
  // between the min and the start thumb, and the end thumb and the max.
  //
  // Defaults to [ColorScheme.primary] with 24% opacity.
  //
  // Using a [SliderTheme] gives more fine-grained control over the
  // appearance of various components of the slider.
  DartColorType inactive_color = 12;
}

// package:flutter/src/material/slider_theme.dart
//
// Creates pair of start and end values.
message MaterialRangeValues {
  // The value of the start thumb.
  //
  // For LTR text direction, the start is the left thumb, and for RTL text
  // direction, the start is the right thumb.
  double start = 2;
  // The value of the end thumb.
  //
  // For LTR text direction, the end is the right thumb, and for RTL text
  // direction, the end is the left thumb.
  double end = 3;
}

// package:flutter/src/material/chip.dart
//
// Creates a RawChip.
//
// The [onPressed] and [onSelected] callbacks must not both be specified at
// the same time.
//
// The [pressElevation] and [elevation] must be null or non-negative.
// Typically, [pressElevation] is greater than [elevation].
message MaterialRawChip {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Defines the defaults for the chip properties if
  // they are not specified elsewhere.
  //
  // If null then [ChipThemeData.fromDefaults] will be used
  // for the default properties.
  MaterialChipThemeDataType default_properties = 3;
  WidgetType avatar = 4;
  WidgetType label = 5;
  FlutterTextStyleType label_style = 6;
  FlutterEdgeInsetsGeometryType padding = 7;
  MaterialVisualDensityType visual_density = 8;
  FlutterEdgeInsetsGeometryType label_padding = 9;
  WidgetType delete_icon = 10;
  DartColorType delete_icon_color = 12;
  string delete_button_tooltip_message = 13;
  double press_elevation = 16;
  // If set, this indicates that the chip should be disabled if all of the
  // tap callbacks ([onSelected], [onPressed]) are null.
  //
  // For example, the [Chip] class sets this to false because it can't be
  // disabled, even if no callbacks are set on it, since it is used for
  // displaying information only.
  //
  // Defaults to true.
  bool tap_enabled = 17;
  bool selected = 18;
  bool is_enabled = 19;
  DartColorType disabled_color = 20;
  DartColorType selected_color = 21;
  string tooltip = 22;
  FlutterBorderSideType side = 23;
  FlutterOutlinedBorderType shape = 24;
  DartClipType.Enum clip_behavior = 25;
  FlutterFocusNodeType focus_node = 26;
  bool autofocus = 27;
  DartColorType background_color = 29;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 30;
  double elevation = 31;
  DartColorType shadow_color = 32;
  DartColorType surface_tint_color = 33;
  FlutterIconThemeDataType icon_theme = 34;
  DartColorType selected_shadow_color = 35;
  bool show_checkmark = 36;
  DartColorType checkmark_color = 37;
  FlutterShapeBorderType avatar_border = 38;
}

// package:flutter/src/material/button.dart
//
// Create a button based on [Semantics], [Material], and [InkWell] widgets.
//
// The [elevation], [focusElevation], [hoverElevation], [highlightElevation],
// and [disabledElevation] parameters must be non-negative.
message MaterialRawMaterialButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Defines the default text style, with [Material.textStyle], for the
  // button's [child].
  //
  // If [TextStyle.color] is a [MaterialStateProperty<Color>], [MaterialStateProperty.resolve]
  // is used for the following [MaterialState]s:
  //
  //  * [MaterialState.pressed].
  //  * [MaterialState.hovered].
  //  * [MaterialState.focused].
  //  * [MaterialState.disabled].
  FlutterTextStyleType text_style = 7;
  // The color of the button's [Material].
  DartColorType fill_color = 8;
  // The color for the button's [Material] when it has the input focus.
  DartColorType focus_color = 9;
  // The color for the button's [Material] when a pointer is hovering over it.
  DartColorType hover_color = 10;
  // The highlight color for the button's [InkWell].
  DartColorType highlight_color = 11;
  // The splash color for the button's [InkWell].
  DartColorType splash_color = 12;
  // The elevation for the button's [Material] when the button
  // is [enabled] but not pressed.
  //
  // Defaults to 2.0. The value is always non-negative.
  //
  // See also:
  //
  //  * [highlightElevation], the default elevation.
  //  * [hoverElevation], the elevation when a pointer is hovering over the
  //    button.
  //  * [focusElevation], the elevation when the button is focused.
  //  * [disabledElevation], the elevation when the button is disabled.
  double elevation = 13;
  // The elevation for the button's [Material] when the button
  // is [enabled] and has the input focus.
  //
  // Defaults to 4.0. The value is always non-negative.
  //
  // If the button is [enabled], and being pressed (in the highlighted state),
  // or a mouse cursor is hovering over the button, then the [hoverElevation]
  // and [highlightElevation] take precedence over the [focusElevation].
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [hoverElevation], the elevation when a pointer is hovering over the
  //    button.
  //  * [disabledElevation], the elevation when the button is disabled.
  //  * [highlightElevation], the elevation when the button is pressed.
  double focus_elevation = 14;
  // The elevation for the button's [Material] when the button
  // is [enabled] and a pointer is hovering over it.
  //
  // Defaults to 4.0. The value is always non-negative.
  //
  // If the button is [enabled], and being pressed (in the highlighted state),
  // then the [highlightElevation] take precedence over the [hoverElevation].
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [focusElevation], the elevation when the button is focused.
  //  * [disabledElevation], the elevation when the button is disabled.
  //  * [highlightElevation], the elevation when the button is pressed.
  double hover_elevation = 15;
  // The elevation for the button's [Material] when the button
  // is [enabled] and pressed.
  //
  // Defaults to 8.0. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [hoverElevation], the elevation when a pointer is hovering over the
  //    button.
  //  * [focusElevation], the elevation when the button is focused.
  //  * [disabledElevation], the elevation when the button is disabled.
  double highlight_elevation = 16;
  // The elevation for the button's [Material] when the button
  // is not [enabled].
  //
  // Defaults to 0.0. The value is always non-negative.
  //
  // See also:
  //
  //  * [elevation], the default elevation.
  //  * [hoverElevation], the elevation when a pointer is hovering over the
  //    button.
  //  * [focusElevation], the elevation when the button is focused.
  //  * [highlightElevation], the elevation when the button is pressed.
  double disabled_elevation = 17;
  // The internal padding for the button's [child].
  FlutterEdgeInsetsGeometryType padding = 18;
  // Defines how compact the button's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], which specifies the [visualDensity] for all widgets
  //    within a [Theme].
  MaterialVisualDensityType visual_density = 19;
  // Defines the button's size.
  //
  // Typically used to constrain the button's minimum size.
  FlutterBoxConstraintsType constraints = 20;
  // The shape of the button's [Material].
  //
  // The button's highlight and splash are clipped to this shape. If the
  // button has an elevation, then its drop shadow is defined by this shape.
  //
  // If [shape] is a [MaterialStateProperty<ShapeBorder>], [MaterialStateProperty.resolve]
  // is used for the following [MaterialState]s:
  //
  // * [MaterialState.pressed].
  // * [MaterialState.hovered].
  // * [MaterialState.focused].
  // * [MaterialState.disabled].
  FlutterShapeBorderType shape = 21;
  // Defines the duration of animated changes for [shape] and [elevation].
  //
  // The default value is [kThemeChangeDuration].
  DartDurationType animation_duration = 22;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 23;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 24;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 25;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 26;
  // Typically the button's label.
  WidgetType child = 27;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 28;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider track with rectangular outer edges.
//
// The middle track segment is the selected range and is active, and the two
// outer track segments are inactive.
message MaterialRectangularRangeSliderTrackShape {
  
}

// package:flutter/src/material/slider_theme.dart
//
// Create a range slider value indicator that resembles a rectangular tooltip.
message MaterialRectangularRangeSliderValueIndicatorShape {
  
}

// package:flutter/src/material/slider_theme.dart
//
// Creates a slider track that draws 2 rectangles.
message MaterialRectangularSliderTrackShape {
  
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider value indicator that resembles a rectangular tooltip.
message MaterialRectangularSliderValueIndicatorShape {
  
}

// package:flutter/src/material/refresh_indicator.dart
message MaterialRefreshIndicatorState {
  
}

// package:flutter/src/material/progress_indicator.dart
//
// Creates a refresh progress indicator.
//
// Rather than creating a refresh progress indicator directly, consider using
// a [RefreshIndicator] together with a [Scrollable] widget.
//
// {@macro flutter.material.ProgressIndicator.ProgressIndicator}
message MaterialRefreshProgressIndicator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // If non-null, the value of this progress indicator.
  //
  // A value of 0.0 means no progress and 1.0 means that progress is complete.
  // The value will be clamped to be in the range 0.0-1.0.
  //
  // If null, this progress indicator is indeterminate, which means the
  // indicator displays a predetermined animation that does not indicate how
  // much actual progress is being made.
  double value = 3;
  // The progress indicator's background color.
  //
  // It is up to the subclass to implement this in whatever way makes sense
  // for the given use case. See the subclass documentation for details.
  DartColorType background_color = 4;
  // {@template flutter.progress_indicator.ProgressIndicator.color}
  // The progress indicator's color.
  //
  // This is only used if [ProgressIndicator.valueColor] is null.
  // If [ProgressIndicator.color] is also null, then the ambient
  // [ProgressIndicatorThemeData.color] will be used. If that
  // is null then the current theme's [ColorScheme.primary] will
  // be used by default.
  // {@endtemplate}
  DartColorType color = 5;
  // The width of the line used to draw the circle.
  double stroke_width = 7;
  // The relative position of the stroke on a [CircularProgressIndicator].
  //
  // Values typically range from -1.0 ([strokeAlignInside], inside stroke)
  // to 1.0 ([strokeAlignOutside], outside stroke),
  // without any bound constraints (e.g., a value of -2.0 is not typical, but allowed).
  // A value of 0 ([strokeAlignCenter], default) will center the border
  // on the edge of the widget.
  double stroke_align = 8;
  // {@template flutter.progress_indicator.ProgressIndicator.semanticsLabel}
  // The [SemanticsProperties.label] for this progress indicator.
  //
  // This value indicates the purpose of the progress bar, and will be
  // read out by screen readers to indicate the purpose of this progress
  // indicator.
  // {@endtemplate}
  string semantics_label = 9;
  // {@template flutter.progress_indicator.ProgressIndicator.semanticsValue}
  // The [SemanticsProperties.value] for this progress indicator.
  //
  // This will be used in conjunction with the [semanticsLabel] by
  // screen reading software to identify the widget, and is primarily
  // intended for use with determinate progress indicators to announce
  // how far along they are.
  //
  // For determinate progress indicators, this will be defaulted to
  // [ProgressIndicator.value] expressed as a percentage, i.e. `0.1` will
  // become '10%'.
  // {@endtemplate}
  string semantics_value = 10;
  // The progress indicator's line ending.
  //
  // This determines the shape of the stroke ends of the progress indicator.
  // By default, [strokeCap] is null.
  // When [value] is null (indeterminate), the stroke ends are set to
  // [StrokeCap.square]. When [value] is not null, the stroke
  // ends are set to [StrokeCap.butt].
  //
  // Setting [strokeCap] to [StrokeCap.round] will result in a rounded end.
  // Setting [strokeCap] to [StrokeCap.butt] with [value] == null will result
  // in a slightly different indeterminate animation; the indicator completely
  // disappears and reappears on its minimum value.
  // Setting [strokeCap] to [StrokeCap.square] with [value] != null will
  // result in a different display of [value]. The indicator will start
  // drawing from slightly less than the start, and end slightly after
  // the end. This will produce an alternative result, as the
  // default behavior, for example, that a [value] of 0.5 starts at 90 degrees
  // and ends at 270 degrees. With [StrokeCap.square], it could start 85
  // degrees and end at 275 degrees.
  DartStrokeCapType.Enum stroke_cap = 11;
  // {@macro flutter.material.material.elevation}
  double elevation = 12;
  // The amount of space by which to inset the whole indicator.
  // It accommodates the [elevation] of the indicator.
  FlutterEdgeInsetsGeometryType indicator_margin = 13;
  // The amount of space by which to inset the inner refresh indicator.
  FlutterEdgeInsetsGeometryType indicator_padding = 14;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider thumb that draws a circle.
message MaterialRoundRangeSliderThumbShape {
  // The preferred radius of the round thumb shape when the slider is enabled.
  //
  // If it is not provided, then the Material Design default of 10 is used.
  double enabled_thumb_radius = 2;
  // The preferred radius of the round thumb shape when the slider is disabled.
  //
  // If no disabledRadius is provided, then it is equal to the
  // [enabledThumbRadius].
  double disabled_thumb_radius = 3;
  // The resting elevation adds shadow to the unpressed thumb.
  //
  // The default is 1.
  double elevation = 4;
  // The pressed elevation adds shadow to the pressed thumb.
  //
  // The default is 6.
  double pressed_elevation = 5;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a range slider tick mark that draws a circle.
message MaterialRoundRangeSliderTickMarkShape {
  // The preferred radius of the round tick mark.
  //
  // If it is not provided, then 1/4 of the [SliderThemeData.trackHeight] is used.
  double tick_mark_radius = 2;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider thumb overlay that draws a circle.
message MaterialRoundSliderOverlayShape {
  // The preferred radius of the round thumb shape when enabled.
  //
  // If it is not provided, then half of the [SliderThemeData.trackHeight] is
  // used.
  double overlay_radius = 2;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider thumb that draws a circle.
message MaterialRoundSliderThumbShape {
  // The preferred radius of the round thumb shape when the slider is enabled.
  //
  // If it is not provided, then the Material Design default of 10 is used.
  double enabled_thumb_radius = 2;
  // The preferred radius of the round thumb shape when the slider is disabled.
  //
  // If no disabledRadius is provided, then it is equal to the
  // [enabledThumbRadius]
  double disabled_thumb_radius = 3;
  // The resting elevation adds shadow to the unpressed thumb.
  //
  // The default is 1.
  //
  // Use 0 for no shadow. The higher the value, the larger the shadow. For
  // example, a value of 12 will create a very large shadow.
  //
  double elevation = 4;
  // The pressed elevation adds shadow to the pressed thumb.
  //
  // The default is 6.
  //
  // Use 0 for no shadow. The higher the value, the larger the shadow. For
  // example, a value of 12 will create a very large shadow.
  double pressed_elevation = 5;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider tick mark that draws a circle.
message MaterialRoundSliderTickMarkShape {
  // The preferred radius of the round tick mark.
  //
  // If it is not provided, then 1/4 of the [SliderThemeData.trackHeight] is used.
  double tick_mark_radius = 2;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider track with rounded outer edges.
//
// The middle track segment is the selected range and is active, and the two
// outer track segments are inactive.
message MaterialRoundedRectRangeSliderTrackShape {
  
}

// package:flutter/src/material/slider_theme.dart
//
// Create a slider track that draws two rectangles with rounded outer edges.
message MaterialRoundedRectSliderTrackShape {
  
}

// package:flutter/src/material/scaffold.dart
//
// Creates a visual scaffold for Material Design widgets.
message MaterialScaffold {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // An app bar to display at the top of the scaffold.
  FlutterPreferredSizeWidgetType app_bar = 3;
  // The primary content of the scaffold.
  //
  // Displayed below the [appBar], above the bottom of the ambient
  // [MediaQuery]'s [MediaQueryData.viewInsets], and behind the
  // [floatingActionButton] and [drawer]. If [resizeToAvoidBottomInset] is
  // false then the body is not resized when the onscreen keyboard appears,
  // i.e. it is not inset by `viewInsets.bottom`.
  //
  // The widget in the body of the scaffold is positioned at the top-left of
  // the available space between the app bar and the bottom of the scaffold. To
  // center this widget instead, consider putting it in a [Center] widget and
  // having that be the body. To expand this widget instead, consider
  // putting it in a [SizedBox.expand].
  //
  // If you have a column of widgets that should normally fit on the screen,
  // but may overflow and would in such cases need to scroll, consider using a
  // [ListView] as the body of the scaffold. This is also a good choice for
  // the case where your body is a scrollable list.
  WidgetType body = 4;
  // A button displayed floating above [body], in the bottom right corner.
  //
  // Typically a [FloatingActionButton].
  WidgetType floating_action_button = 5;
  // A set of buttons that are displayed at the bottom of the scaffold.
  //
  // Typically this is a list of [TextButton] widgets. These buttons are
  // persistently visible, even if the [body] of the scaffold scrolls.
  //
  // These widgets will be wrapped in an [OverflowBar].
  //
  // The [persistentFooterButtons] are rendered above the
  // [bottomNavigationBar] but below the [body].
  repeated WidgetType persistent_footer_buttons = 8;
  // The alignment of the [persistentFooterButtons] inside the [OverflowBar].
  //
  // Defaults to [AlignmentDirectional.centerEnd].
  FlutterAlignmentDirectionalType persistent_footer_alignment = 9;
  // A panel displayed to the side of the [body], often hidden on mobile
  // devices. Swipes in from either left-to-right ([TextDirection.ltr]) or
  // right-to-left ([TextDirection.rtl])
  //
  // Typically a [Drawer].
  //
  // To open the drawer, use the [ScaffoldState.openDrawer] function.
  //
  // To close the drawer, use either [ScaffoldState.closeDrawer], [Navigator.pop]
  // or press the escape key on the keyboard.
  //
  // {@tool dartpad}
  // To disable the drawer edge swipe on mobile, set the
  // [Scaffold.drawerEnableOpenDragGesture] to false. Then, use
  // [ScaffoldState.openDrawer] to open the drawer and [Navigator.pop] to close
  // it.
  //
  // ** See code in examples/api/lib/material/scaffold/scaffold.drawer.0.dart **
  // {@end-tool}
  WidgetType drawer = 10;
  // A panel displayed to the side of the [body], often hidden on mobile
  // devices. Swipes in from right-to-left ([TextDirection.ltr]) or
  // left-to-right ([TextDirection.rtl])
  //
  // Typically a [Drawer].
  //
  // To open the drawer, use the [ScaffoldState.openEndDrawer] function.
  //
  // To close the drawer, use either [ScaffoldState.closeEndDrawer], [Navigator.pop]
  // or press the escape key on the keyboard.
  //
  // {@tool dartpad}
  // To disable the drawer edge swipe, set the
  // [Scaffold.endDrawerEnableOpenDragGesture] to false. Then, use
  // [ScaffoldState.openEndDrawer] to open the drawer and [Navigator.pop] to
  // close it.
  //
  // ** See code in examples/api/lib/material/scaffold/scaffold.end_drawer.0.dart **
  // {@end-tool}
  WidgetType end_drawer = 12;
  // A bottom navigation bar to display at the bottom of the scaffold.
  //
  // Snack bars slide from underneath the bottom navigation bar while bottom
  // sheets are stacked on top.
  //
  // The [bottomNavigationBar] is rendered below the [persistentFooterButtons]
  // and the [body].
  WidgetType bottom_navigation_bar = 14;
  // The persistent bottom sheet to display.
  //
  // A persistent bottom sheet shows information that supplements the primary
  // content of the app. A persistent bottom sheet remains visible even when
  // the user interacts with other parts of the app.
  //
  // A closely related widget is a modal bottom sheet, which is an alternative
  // to a menu or a dialog and prevents the user from interacting with the rest
  // of the app. Modal bottom sheets can be created and displayed with the
  // [showModalBottomSheet] function.
  //
  // Unlike the persistent bottom sheet displayed by [showBottomSheet]
  // this bottom sheet is not a [LocalHistoryEntry] and cannot be dismissed
  // with the scaffold appbar's back button.
  //
  // If a persistent bottom sheet created with [showBottomSheet] is already
  // visible, it must be closed before building the Scaffold with a new
  // [bottomSheet].
  //
  // The value of [bottomSheet] can be any widget at all. It's unlikely to
  // actually be a [BottomSheet], which is used by the implementations of
  // [showBottomSheet] and [showModalBottomSheet]. Typically it's a widget
  // that includes [Material].
  //
  // See also:
  //
  //  * [showBottomSheet], which displays a bottom sheet as a route that can
  //    be dismissed with the scaffold's back button.
  //  * [showModalBottomSheet], which displays a modal bottom sheet.
  //  * [BottomSheetThemeData], which can be used to customize the default
  //    bottom sheet property values when using a [BottomSheet].
  WidgetType bottom_sheet = 15;
  // The color of the [Material] widget that underlies the entire Scaffold.
  //
  // The theme's [ThemeData.scaffoldBackgroundColor] by default.
  DartColorType background_color = 16;
  // If true the [body] and the scaffold's floating widgets should size
  // themselves to avoid the onscreen keyboard whose height is defined by the
  // ambient [MediaQuery]'s [MediaQueryData.viewInsets] `bottom` property.
  //
  // For example, if there is an onscreen keyboard displayed above the
  // scaffold, the body can be resized to avoid overlapping the keyboard, which
  // prevents widgets inside the body from being obscured by the keyboard.
  //
  // Defaults to true.
  bool resize_to_avoid_bottom_inset = 17;
  // Whether this scaffold is being displayed at the top of the screen.
  //
  // If true then the height of the [appBar] will be extended by the height
  // of the screen's status bar, i.e. the top padding for [MediaQuery].
  //
  // The default value of this property, like the default value of
  // [AppBar.primary], is true.
  bool primary = 18;
  // {@macro flutter.material.DrawerController.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drawer_drag_start_behavior = 19;
  // If true, and [bottomNavigationBar] or [persistentFooterButtons]
  // is specified, then the [body] extends to the bottom of the Scaffold,
  // instead of only extending to the top of the [bottomNavigationBar]
  // or the [persistentFooterButtons].
  //
  // If true, a [MediaQuery] widget whose bottom padding matches the height
  // of the [bottomNavigationBar] will be added above the scaffold's [body].
  //
  // This property is often useful when the [bottomNavigationBar] has
  // a non-rectangular shape, like [CircularNotchedRectangle], which
  // adds a [FloatingActionButton] sized notch to the top edge of the bar.
  // In this case specifying `extendBody: true` ensures that scaffold's
  // body will be visible through the bottom navigation bar's notch.
  //
  // See also:
  //
  //  * [extendBodyBehindAppBar], which extends the height of the body
  //    to the top of the scaffold.
  bool extend_body = 20;
  // If true, and an [appBar] is specified, then the height of the [body] is
  // extended to include the height of the app bar and the top of the body
  // is aligned with the top of the app bar.
  //
  // This is useful if the app bar's [AppBar.backgroundColor] is not
  // completely opaque.
  //
  // This property is false by default.
  //
  // See also:
  //
  //  * [extendBody], which extends the height of the body to the bottom
  //    of the scaffold.
  bool extend_body_behind_app_bar = 21;
  // The color to use for the scrim that obscures primary content while a drawer is open.
  //
  // If this is null, then [DrawerThemeData.scrimColor] is used. If that
  // is also null, then it defaults to [Colors.black54].
  DartColorType drawer_scrim_color = 22;
  // The width of the area within which a horizontal swipe will open the
  // drawer.
  //
  // By default, the value used is 20.0 added to the padding edge of
  // `MediaQuery.paddingOf(context)` that corresponds to the surrounding
  // [TextDirection]. This ensures that the drag area for notched devices is
  // not obscured. For example, if `TextDirection.of(context)` is set to
  // [TextDirection.ltr], 20.0 will be added to
  // `MediaQuery.paddingOf(context).left`.
  double drawer_edge_drag_width = 23;
  // Determines if the [Scaffold.drawer] can be opened with a drag
  // gesture on mobile.
  //
  // On desktop platforms, the drawer is not draggable.
  //
  // By default, the drag gesture is enabled on mobile.
  bool drawer_enable_open_drag_gesture = 24;
  // Determines if the [Scaffold.endDrawer] can be opened with a
  // gesture on mobile.
  //
  // On desktop platforms, the drawer is not draggable.
  //
  // By default, the drag gesture is enabled on mobile.
  bool end_drawer_enable_open_drag_gesture = 25;
  // Restoration ID to save and restore the state of the [Scaffold].
  //
  // If it is non-null, the scaffold will persist and restore whether the
  // [drawer] and [endDrawer] was open or closed.
  //
  // The state of this widget is persisted in a [RestorationBucket] claimed
  // from the surrounding [RestorationScope] using the provided restoration ID.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  string restoration_id = 26;
}

// package:flutter/src/material/scaffold.dart
//
// Creates a widget that manages [SnackBar]s for [Scaffold] descendants.
message MaterialScaffoldMessenger {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/material/scaffold.dart
message MaterialScaffoldMessengerState {
  
}

// package:flutter/src/material/scaffold.dart
message MaterialScaffoldState {
  
}

// package:flutter/src/material/scrollbar.dart
//
// Creates a Material Design scrollbar that by default will connect to the
// closest Scrollable descendant of [child].
//
// The [child] should be a source of [ScrollNotification] notifications,
// typically a [Scrollable] widget.
//
// If the [controller] is null, the default behavior is to
// enable scrollbar dragging using the [PrimaryScrollController].
//
// When null, [thickness] defaults to 8.0 pixels on desktop and web, and 4.0
// pixels when on mobile platforms. A null [radius] will result in a default
// of an 8.0 pixel circular radius about the corners of the scrollbar thumb,
// except for when executing on [TargetPlatform.android], which will render the
// thumb without a radius.
message MaterialScrollbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.Scrollbar.child}
  WidgetType child = 3;
  // {@macro flutter.widgets.Scrollbar.controller}
  FlutterScrollControllerType controller = 4;
  // {@macro flutter.widgets.Scrollbar.thumbVisibility}
  //
  // If this property is null, then [ScrollbarThemeData.thumbVisibility] of
  // [ThemeData.scrollbarTheme] is used. If that is also null, the default value
  // is false.
  //
  // If the thumb visibility is related to the scrollbar's material state,
  // use the global [ScrollbarThemeData.thumbVisibility] or override the
  // sub-tree's theme data.
  bool thumb_visibility = 5;
  // {@macro flutter.widgets.Scrollbar.trackVisibility}
  //
  // If this property is null, then [ScrollbarThemeData.trackVisibility] of
  // [ThemeData.scrollbarTheme] is used. If that is also null, the default value
  // is false.
  //
  // If the track visibility is related to the scrollbar's material state,
  // use the global [ScrollbarThemeData.trackVisibility] or override the
  // sub-tree's theme data.
  //
  // Replaces deprecated [showTrackOnHover].
  bool track_visibility = 6;
  // The thickness of the scrollbar in the cross axis of the scrollable.
  //
  // If null, the default value is platform dependent. On [TargetPlatform.android],
  // the default thickness is 4.0 pixels. On [TargetPlatform.iOS],
  // [CupertinoScrollbar.defaultThickness] is used. The remaining platforms have a
  // default thickness of 8.0 pixels.
  double thickness = 7;
  // The [Radius] of the scrollbar thumb's rounded rectangle corners.
  //
  // If null, the default value is platform dependent. On [TargetPlatform.android],
  // no radius is applied to the scrollbar thumb. On [TargetPlatform.iOS],
  // [CupertinoScrollbar.defaultRadius] is used. The remaining platforms have a
  // default [Radius.circular] of 8.0 pixels.
  DartRadiusType radius = 8;
  // {@macro flutter.widgets.Scrollbar.interactive}
  bool interactive = 10;
  // {@macro flutter.widgets.Scrollbar.scrollbarOrientation}
  FlutterScrollbarOrientationType.Enum scrollbar_orientation = 11;
}

// package:flutter/src/material/scrollbar_theme.dart
//
// Constructs a scrollbar theme that configures all descendant [Scrollbar]
// widgets.
message MaterialScrollbarTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [Scrollbar] widgets.
  MaterialScrollbarThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/scrollbar_theme.dart
//
// Creates a theme that can be used for [ThemeData.scrollbarTheme].
message MaterialScrollbarThemeData {
  // Overrides the default value of [Scrollbar.radius] in all
  // descendant widgets.
  DartRadiusType radius = 5;
  // Overrides the default value of the [ScrollbarPainter.crossAxisMargin]
  // property in all descendant [Scrollbar] widgets.
  //
  // See also:
  //
  //  * [ScrollbarPainter.crossAxisMargin], which sets the distance from the
  //    scrollbar's side to the nearest edge in logical pixels.
  double cross_axis_margin = 9;
  // Overrides the default value of the [ScrollbarPainter.mainAxisMargin]
  // property in all descendant [Scrollbar] widgets.
  //
  // See also:
  //
  //  * [ScrollbarPainter.mainAxisMargin], which sets the distance from the
  //    scrollbar's start and end to the edge of the viewport in logical pixels.
  double main_axis_margin = 10;
  // Overrides the default value of the [ScrollbarPainter.minLength]
  // property in all descendant [Scrollbar] widgets.
  //
  // See also:
  //
  //  * [ScrollbarPainter.minLength], which sets the preferred smallest size
  //    the scrollbar can shrink to when the total scrollable extent is large,
  //    the current visible viewport is small, and the viewport is not
  //    overscrolled.
  double min_thumb_length = 11;
  // Overrides the default value of [Scrollbar.interactive] in all
  // descendant [Scrollbar] widgets.
  bool interactive = 12;
}

// package:flutter/src/material/search_anchor.dart
//
// Creates a Material Design search bar.
message MaterialSearchBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Controls the text being edited in the search bar's text field.
  //
  // If null, this widget will create its own [TextEditingController].
  FlutterTextEditingControllerType controller = 3;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 4;
  // Text that suggests what sort of input the field accepts.
  //
  // Displayed at the same location on the screen where text may be entered
  // when the input is empty.
  //
  // Defaults to null.
  string hint_text = 5;
  // A widget to display before the text input field.
  //
  // Typically the [leading] widget is an [Icon] or an [IconButton].
  WidgetType leading = 6;
  // A list of Widgets to display in a row after the text field.
  //
  // Typically these actions can represent additional modes of searching
  // (like voice search), an avatar, a separate high-level action (such as
  // current location) or an overflow menu. There should not be more than
  // two trailing actions.
  repeated WidgetType trailing = 7;
  // Optional size constraints for the search bar.
  //
  // If null, the value of [SearchBarThemeData.constraints] will be used. If
  // this is also null, then the constraints defaults to:
  // ```dart
  // const BoxConstraints(minWidth: 360.0, maxWidth: 800.0, minHeight: 56.0)
  // ```
  FlutterBoxConstraintsType constraints = 11;
  // {@macro flutter.widgets.editableText.textCapitalization}
  FlutterTextCapitalizationType.Enum text_capitalization = 22;
  // {@macro flutter.widgets.editableText.autofocus}
  bool auto_focus = 23;
  // {@macro flutter.widgets.TextField.textInputAction}
  FlutterTextInputActionType.Enum text_input_action = 24;
  // The type of action button to use for the keyboard.
  //
  // Defaults to the default value specified in [TextField].
  FlutterTextInputTypeType keyboard_type = 25;
}

// package:flutter/src/material/search_bar_theme.dart
//
// Constructs a search bar theme that configures all descendant [SearchBar] widgets.
message MaterialSearchBarTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [SearchBar] widgets.
  MaterialSearchBarThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/search_bar_theme.dart
//
// Creates a theme that can be used for [ThemeData.searchBarTheme].
message MaterialSearchBarThemeData {
  // Overrides the value of size constraints for [SearchBar].
  FlutterBoxConstraintsType constraints = 12;
  // Overrides the value of [SearchBar.textCapitalization].
  FlutterTextCapitalizationType.Enum text_capitalization = 13;
}

// package:flutter/src/material/search_anchor.dart
message MaterialSearchController {
  
}

// package:flutter/src/material/search_view_theme.dart
//
// Creates a const theme that controls the configurations for the search view
// created by the [SearchAnchor] widget.
message MaterialSearchViewTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [SearchAnchor] widgets.
  MaterialSearchViewThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/search_view_theme.dart
//
// Creates a theme that can be used for [ThemeData.searchViewTheme].
message MaterialSearchViewThemeData {
  // Overrides the default value of the [SearchAnchor.viewBackgroundColor].
  DartColorType background_color = 2;
  // Overrides the default value of the [SearchAnchor.viewElevation].
  double elevation = 3;
  // Overrides the default value of the [SearchAnchor.viewSurfaceTintColor].
  DartColorType surface_tint_color = 4;
  // Overrides the value of size constraints for [SearchAnchor.viewConstraints].
  FlutterBoxConstraintsType constraints = 5;
  // Overrides the default value of the [SearchAnchor.viewSide].
  FlutterBorderSideType side = 6;
  // Overrides the default value of the [SearchAnchor.viewShape].
  FlutterOutlinedBorderType shape = 7;
  // Overrides the default value for [SearchAnchor.headerTextStyle].
  FlutterTextStyleType header_text_style = 8;
  // Overrides the default value for [SearchAnchor.headerHintStyle].
  FlutterTextStyleType header_hint_style = 9;
  // Overrides the value of the divider color for [SearchAnchor.dividerColor].
  DartColorType divider_color = 10;
}

// package:flutter/src/material/segmented_button_theme.dart
//
// Creates a [SegmentedButtonTheme] that controls visual parameters for
// descendent [SegmentedButton]s.
message MaterialSegmentedButtonTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the visual properties used by descendant [SegmentedButton]
  // widgets.
  MaterialSegmentedButtonThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/segmented_button_theme.dart
//
// Creates a [SegmentedButtonThemeData] that can be used to override default properties
// in a [SegmentedButtonTheme] widget.
message MaterialSegmentedButtonThemeData {
  // Overrides the [SegmentedButton]'s default style.
  //
  // Non-null properties or non-null resolved [MaterialStateProperty]
  // values override the default values used by [SegmentedButton].
  //
  // If [style] is null, then this theme doesn't override anything.
  MaterialButtonStyleType style = 2;
  // Override for [SegmentedButton.selectedIcon] property.
  //
  // If non-null, then [selectedIcon] will be used instead of default
  // value for [SegmentedButton.selectedIcon].
  WidgetType selected_icon = 3;
}

// package:flutter/src/material/selectable_text.dart
//
// Creates a selectable text widget.
//
// If the [style] argument is null, the text will use the style from the
// closest enclosing [DefaultTextStyle].
//
// If the [showCursor], [autofocus], [dragStartBehavior],
// [selectionHeightStyle], [selectionWidthStyle] and [data] arguments are
// specified, the [maxLines] argument must be greater than zero.
message MaterialSelectableText {
  // The text to display.
  //
  // This will be null if a [textSpan] is provided instead.
  string data = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  // Defines the focus for this widget.
  //
  // Text is only selectable when widget is focused.
  //
  // The [focusNode] is a long-lived object that's typically managed by a
  // [StatefulWidget] parent. See [FocusNode] for more information.
  //
  // To give the focus to this widget, provide a [focusNode] and then
  // use the current [FocusScope] to request the focus:
  //
  // ```dart
  // FocusScope.of(context).requestFocus(myFocusNode);
  // ```
  //
  // This happens automatically when the widget is tapped.
  //
  // To be notified when the widget gains or loses the focus, add a listener
  // to the [focusNode]:
  //
  // ```dart
  // myFocusNode.addListener(() { print(myFocusNode.hasFocus); });
  // ```
  //
  // If null, this widget will create its own [FocusNode] with
  // [FocusNode.skipTraversal] parameter set to `true`, which causes the widget
  // to be skipped over during focus traversal.
  FlutterFocusNodeType focus_node = 4;
  // The style to use for the text.
  //
  // If null, defaults [DefaultTextStyle] of context.
  FlutterTextStyleType style = 5;
  // {@macro flutter.widgets.editableText.strutStyle}
  FlutterStrutStyleType strut_style = 6;
  // {@macro flutter.widgets.editableText.textAlign}
  DartTextAlignType.Enum text_align = 7;
  // {@macro flutter.widgets.editableText.textDirection}
  DartTextDirectionType.Enum text_direction = 8;
  // {@macro flutter.painting.textPainter.textScaler}
  FlutterTextScalerType text_scaler = 9;
  // {@macro flutter.widgets.editableText.showCursor}
  bool show_cursor = 10;
  // {@macro flutter.widgets.editableText.autofocus}
  bool autofocus = 11;
  // {@macro flutter.widgets.editableText.minLines}
  int32 min_lines = 12;
  // {@macro flutter.widgets.editableText.maxLines}
  int32 max_lines = 13;
  // {@macro flutter.widgets.editableText.cursorWidth}
  double cursor_width = 14;
  // {@macro flutter.widgets.editableText.cursorHeight}
  double cursor_height = 15;
  // {@macro flutter.widgets.editableText.cursorRadius}
  DartRadiusType cursor_radius = 16;
  // The color of the cursor.
  //
  // The cursor indicates the current text insertion point.
  //
  // If null then [DefaultSelectionStyle.cursorColor] is used. If that is also
  // null and [ThemeData.platform] is [TargetPlatform.iOS] or
  // [TargetPlatform.macOS], then [CupertinoThemeData.primaryColor] is used.
  // Otherwise [ColorScheme.primary] of [ThemeData.colorScheme] is used.
  DartColorType cursor_color = 17;
  // Controls how tall the selection highlight boxes are computed to be.
  //
  // See [ui.BoxHeightStyle] for details on available styles.
  DartBoxHeightStyleType.Enum selection_height_style = 18;
  // Controls how wide the selection highlight boxes are computed to be.
  //
  // See [ui.BoxWidthStyle] for details on available styles.
  DartBoxWidthStyleType.Enum selection_width_style = 19;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 20;
  // {@macro flutter.widgets.editableText.enableInteractiveSelection}
  bool enable_interactive_selection = 21;
  // {@macro flutter.widgets.editableText.selectionControls}
  FlutterTextSelectionControlsType selection_controls = 22;
  // {@macro flutter.widgets.editableText.scrollPhysics}
  FlutterScrollPhysicsType scroll_physics = 24;
  // {@macro flutter.widgets.Text.semanticsLabel}
  string semantics_label = 25;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 26;
  // {@macro flutter.painting.textPainter.textWidthBasis}
  FlutterTextWidthBasisType.Enum text_width_basis = 27;
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
  //
  // {@macro flutter.widgets.magnifier.intro}
  //
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.details}
  //
  // By default, builds a [CupertinoTextMagnifier] on iOS and [TextMagnifier]
  // on Android, and builds nothing on all other platforms. If it is desired to
  // suppress the magnifier, consider passing [TextMagnifierConfiguration.disabled].
  FlutterTextMagnifierConfigurationType magnifier_configuration = 30;
}

// package:flutter/src/material/selectable_text.dart
//
// Creates a selectable text widget with a [TextSpan].
//
// The [TextSpan.children] attribute of the [textSpan] parameter must only
// contain [TextSpan]s. Other types of [InlineSpan] are not allowed.
message MaterialSelectableTextNamedRich {
  // The text to display as a [TextSpan].
  //
  // This will be null if [data] is provided instead.
  FlutterTextSpanType text_span = 2;
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 3;
  // Defines the focus for this widget.
  //
  // Text is only selectable when widget is focused.
  //
  // The [focusNode] is a long-lived object that's typically managed by a
  // [StatefulWidget] parent. See [FocusNode] for more information.
  //
  // To give the focus to this widget, provide a [focusNode] and then
  // use the current [FocusScope] to request the focus:
  //
  // ```dart
  // FocusScope.of(context).requestFocus(myFocusNode);
  // ```
  //
  // This happens automatically when the widget is tapped.
  //
  // To be notified when the widget gains or loses the focus, add a listener
  // to the [focusNode]:
  //
  // ```dart
  // myFocusNode.addListener(() { print(myFocusNode.hasFocus); });
  // ```
  //
  // If null, this widget will create its own [FocusNode] with
  // [FocusNode.skipTraversal] parameter set to `true`, which causes the widget
  // to be skipped over during focus traversal.
  FlutterFocusNodeType focus_node = 4;
  // The style to use for the text.
  //
  // If null, defaults [DefaultTextStyle] of context.
  FlutterTextStyleType style = 5;
  // {@macro flutter.widgets.editableText.strutStyle}
  FlutterStrutStyleType strut_style = 6;
  // {@macro flutter.widgets.editableText.textAlign}
  DartTextAlignType.Enum text_align = 7;
  // {@macro flutter.widgets.editableText.textDirection}
  DartTextDirectionType.Enum text_direction = 8;
  // {@macro flutter.painting.textPainter.textScaler}
  FlutterTextScalerType text_scaler = 9;
  // {@macro flutter.widgets.editableText.showCursor}
  bool show_cursor = 10;
  // {@macro flutter.widgets.editableText.autofocus}
  bool autofocus = 11;
  // {@macro flutter.widgets.editableText.minLines}
  int32 min_lines = 12;
  // {@macro flutter.widgets.editableText.maxLines}
  int32 max_lines = 13;
  // {@macro flutter.widgets.editableText.cursorWidth}
  double cursor_width = 14;
  // {@macro flutter.widgets.editableText.cursorHeight}
  double cursor_height = 15;
  // {@macro flutter.widgets.editableText.cursorRadius}
  DartRadiusType cursor_radius = 16;
  // The color of the cursor.
  //
  // The cursor indicates the current text insertion point.
  //
  // If null then [DefaultSelectionStyle.cursorColor] is used. If that is also
  // null and [ThemeData.platform] is [TargetPlatform.iOS] or
  // [TargetPlatform.macOS], then [CupertinoThemeData.primaryColor] is used.
  // Otherwise [ColorScheme.primary] of [ThemeData.colorScheme] is used.
  DartColorType cursor_color = 17;
  // Controls how tall the selection highlight boxes are computed to be.
  //
  // See [ui.BoxHeightStyle] for details on available styles.
  DartBoxHeightStyleType.Enum selection_height_style = 18;
  // Controls how wide the selection highlight boxes are computed to be.
  //
  // See [ui.BoxWidthStyle] for details on available styles.
  DartBoxWidthStyleType.Enum selection_width_style = 19;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 20;
  // {@macro flutter.widgets.editableText.enableInteractiveSelection}
  bool enable_interactive_selection = 21;
  // {@macro flutter.widgets.editableText.selectionControls}
  FlutterTextSelectionControlsType selection_controls = 22;
  // {@macro flutter.widgets.editableText.scrollPhysics}
  FlutterScrollPhysicsType scroll_physics = 24;
  // {@macro flutter.widgets.Text.semanticsLabel}
  string semantics_label = 25;
  // {@macro dart.ui.textHeightBehavior}
  DartTextHeightBehaviorType text_height_behavior = 26;
  // {@macro flutter.painting.textPainter.textWidthBasis}
  FlutterTextWidthBasisType.Enum text_width_basis = 27;
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
  //
  // {@macro flutter.widgets.magnifier.intro}
  //
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.details}
  //
  // By default, builds a [CupertinoTextMagnifier] on iOS and [TextMagnifier]
  // on Android, and builds nothing on all other platforms. If it is desired to
  // suppress the magnifier, consider passing [TextMagnifierConfiguration.disabled].
  FlutterTextMagnifierConfigurationType magnifier_configuration = 30;
}

// package:flutter/src/material/selection_area.dart
//
// Creates a [SelectionArea].
//
// If [selectionControls] is null, a platform specific one is used.
message MaterialSelectionArea {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 3;
  // The delegate to build the selection handles and toolbar.
  //
  // If it is null, the platform specific selection control is used.
  FlutterTextSelectionControlsType selection_controls = 4;
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
  //
  // {@macro flutter.widgets.magnifier.intro}
  //
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.details}
  //
  // By default, builds a [CupertinoTextMagnifier] on iOS and [TextMagnifier]
  // on Android, and builds nothing on all other platforms. If it is desired to
  // suppress the magnifier, consider passing [TextMagnifierConfiguration.disabled].
  FlutterTextMagnifierConfigurationType magnifier_configuration = 6;
  // The child widget this selection area applies to.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 8;
}

// package:flutter/src/material/dialog.dart
//
// Creates a simple dialog.
//
// Typically used in conjunction with [showDialog].
message MaterialSimpleDialog {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The (optional) title of the dialog is displayed in a large font at the top
  // of the dialog.
  //
  // Typically a [Text] widget.
  WidgetType title = 3;
  // Padding around the title.
  //
  // If there is no title, no padding will be provided.
  //
  // By default, this provides the recommend Material Design padding of 24
  // pixels around the left, top, and right edges of the title.
  //
  // See [contentPadding] for the conventions regarding padding between the
  // [title] and the [children].
  FlutterEdgeInsetsGeometryType title_padding = 4;
  // Style for the text in the [title] of this [SimpleDialog].
  //
  // If null, [DialogTheme.titleTextStyle] is used. If that's null, defaults to
  // [TextTheme.titleLarge] of [ThemeData.textTheme].
  FlutterTextStyleType title_text_style = 5;
  // The (optional) content of the dialog is displayed in a
  // [SingleChildScrollView] underneath the title.
  //
  // Typically a list of [SimpleDialogOption]s.
  repeated WidgetType children = 6;
  // Padding around the content.
  //
  // By default, this is 12 pixels on the top and 16 pixels on the bottom. This
  // is intended to be combined with children that have 24 pixels of padding on
  // the left and right, and 8 pixels of padding on the top and bottom, so that
  // the content ends up being indented 20 pixels from the title, 24 pixels
  // from the bottom, and 24 pixels from the sides.
  //
  // The [SimpleDialogOption] widget uses such padding.
  //
  // If there is no [title], the [contentPadding] should be adjusted so that
  // the top padding ends up being 24 pixels.
  FlutterEdgeInsetsGeometryType content_padding = 7;
  // {@macro flutter.material.dialog.backgroundColor}
  DartColorType background_color = 8;
  // {@macro flutter.material.dialog.elevation}
  double elevation = 9;
  // {@macro flutter.material.dialog.shadowColor}
  DartColorType shadow_color = 10;
  // {@macro flutter.material.dialog.surfaceTintColor}
  DartColorType surface_tint_color = 11;
  // The semantic label of the dialog used by accessibility frameworks to
  // announce screen transitions when the dialog is opened and closed.
  //
  // If this label is not provided, a semantic label will be inferred from the
  // [title] if it is not null. If there is no title, the label will be taken
  // from [MaterialLocalizations.dialogLabel].
  //
  // See also:
  //
  //  * [SemanticsConfiguration.namesRoute], for a description of how this
  //    value is used.
  string semantic_label = 12;
  // {@macro flutter.material.dialog.insetPadding}
  FlutterEdgeInsetsType inset_padding = 13;
  // {@macro flutter.material.dialog.clipBehavior}
  DartClipType.Enum clip_behavior = 14;
  // {@macro flutter.material.dialog.shape}
  FlutterShapeBorderType shape = 15;
  // {@macro flutter.material.dialog.shape}
  FlutterAlignmentGeometryType alignment = 16;
}

// package:flutter/src/material/dialog.dart
//
// Creates an option for a [SimpleDialog].
message MaterialSimpleDialogOption {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The amount of space to surround the [child] with.
  //
  // Defaults to EdgeInsets.symmetric(vertical: 8.0, horizontal: 24.0).
  FlutterEdgeInsetsType padding = 4;
  // The widget below this widget in the tree.
  //
  // Typically a [Text] widget.
  WidgetType child = 5;
}

// package:flutter/src/material/slider.dart
//
// Creates a Material Design slider.
//
// The slider itself does not maintain any state. Instead, when the state of
// the slider changes, the widget calls the [onChanged] callback. Most
// widgets that use a slider will listen for the [onChanged] callback and
// rebuild the slider with a new [value] to update the visual appearance of
// the slider.
//
// * [value] determines currently selected value for this slider.
// * [onChanged] is called while the user is selecting a new value for the
//   slider.
// * [onChangeStart] is called when the user starts to select a new value for
//   the slider.
// * [onChangeEnd] is called when the user is done selecting a new value for
//   the slider.
//
// You can override some of the colors with the [activeColor] and
// [inactiveColor] properties, although more fine-grained control of the
// appearance is achieved using a [SliderThemeData].
message MaterialSlider {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The currently selected value for this slider.
  //
  // The slider's thumb is drawn at a position that corresponds to this value.
  double value = 3;
  // The secondary track value for this slider.
  //
  // If not null, a secondary track using [Slider.secondaryActiveColor] color
  // is drawn between the thumb and this value, over the inactive track.
  //
  // If less than [Slider.value], then the secondary track is not shown.
  //
  // It can be ideal for media scenarios such as showing the buffering progress
  // while the [Slider.value] shows the play progress.
  double secondary_track_value = 4;
  // The minimum value the user can select.
  //
  // Defaults to 0.0. Must be less than or equal to [max].
  //
  // If the [max] is equal to the [min], then the slider is disabled.
  double min = 8;
  // The maximum value the user can select.
  //
  // Defaults to 1.0. Must be greater than or equal to [min].
  //
  // If the [max] is equal to the [min], then the slider is disabled.
  double max = 9;
  // The number of discrete divisions.
  //
  // Typically used with [label] to show the current discrete value.
  //
  // If null, the slider is continuous.
  int32 divisions = 10;
  // A label to show above the slider when the slider is active and
  // [SliderThemeData.showValueIndicator] is satisfied.
  //
  // It is used to display the value of a discrete slider, and it is displayed
  // as part of the value indicator shape.
  //
  // The label is rendered using the active [ThemeData]'s [TextTheme.bodyLarge]
  // text style, with the theme data's [ColorScheme.onPrimary] color. The
  // label's text style can be overridden with
  // [SliderThemeData.valueIndicatorTextStyle].
  //
  // If null, then the value indicator will not be displayed.
  //
  // Ignored if this slider is created with [Slider.adaptive].
  //
  // See also:
  //
  //  * [SliderComponentShape] for how to create a custom value indicator
  //    shape.
  string label = 11;
  // The color to use for the portion of the slider track that is active.
  //
  // The "active" side of the slider is the side between the thumb and the
  // minimum value.
  //
  // If null, [SliderThemeData.activeTrackColor] of the ambient
  // [SliderTheme] is used. If that is null, [ColorScheme.primary] of the
  // surrounding [ThemeData] is used.
  //
  // Using a [SliderTheme] gives much more fine-grained control over the
  // appearance of various components of the slider.
  DartColorType active_color = 12;
  // The color for the inactive portion of the slider track.
  //
  // The "inactive" side of the slider is the side between the thumb and the
  // maximum value.
  //
  // If null, [SliderThemeData.inactiveTrackColor] of the ambient [SliderTheme]
  // is used. If that is null and [ThemeData.useMaterial3] is true,
  // [ColorScheme.surfaceVariant] will be used, otherwise [ColorScheme.primary]
  // with an opacity of 0.24 will be used.
  //
  // Using a [SliderTheme] gives much more fine-grained control over the
  // appearance of various components of the slider.
  //
  // Ignored if this slider is created with [Slider.adaptive].
  DartColorType inactive_color = 13;
  // The color to use for the portion of the slider track between the thumb and
  // the [Slider.secondaryTrackValue].
  //
  // Defaults to the [SliderThemeData.secondaryActiveTrackColor] of the current
  // [SliderTheme].
  //
  // If that is also null, defaults to [ColorScheme.primary] with an
  // opacity of 0.54.
  //
  // Using a [SliderTheme] gives much more fine-grained control over the
  // appearance of various components of the slider.
  //
  // Ignored if this slider is created with [Slider.adaptive].
  DartColorType secondary_active_color = 14;
  // The color of the thumb.
  //
  // If this color is null, [Slider] will use [activeColor], If [activeColor]
  // is also null, [Slider] will use [SliderThemeData.thumbColor].
  //
  // If that is also null, defaults to [ColorScheme.primary].
  //
  // * [CupertinoSlider] will have a white thumb
  // (like the native default iOS slider).
  DartColorType thumb_color = 15;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 19;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 20;
  // Allowed way for the user to interact with the [Slider].
  //
  // For example, if this is set to [SliderInteraction.tapOnly], the user can
  // interact with the slider only by tapping anywhere on the track. Sliding
  // will have no effect.
  //
  // Defaults to [SliderInteraction.tapAndSlide].
  MaterialSliderInteractionType.Enum allowed_interaction = 21;
}

// package:flutter/src/material/slider.dart
//
// Creates an adaptive [Slider] based on the target platform, following
// Material design's
// [Cross-platform guidelines](https://material.io/design/platform-guidance/cross-platform-adaptation.html).
//
// Creates a [CupertinoSlider] if the target platform is iOS or macOS, creates a
// Material Design slider otherwise.
//
// If a [CupertinoSlider] is created, the following parameters are ignored:
// [secondaryTrackValue], [label], [inactiveColor], [secondaryActiveColor],
// [semanticFormatterCallback].
//
// The target platform is based on the current [Theme]: [ThemeData.platform].
message MaterialSliderNamedAdaptive {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The currently selected value for this slider.
  //
  // The slider's thumb is drawn at a position that corresponds to this value.
  double value = 3;
  // The secondary track value for this slider.
  //
  // If not null, a secondary track using [Slider.secondaryActiveColor] color
  // is drawn between the thumb and this value, over the inactive track.
  //
  // If less than [Slider.value], then the secondary track is not shown.
  //
  // It can be ideal for media scenarios such as showing the buffering progress
  // while the [Slider.value] shows the play progress.
  double secondary_track_value = 4;
  // The minimum value the user can select.
  //
  // Defaults to 0.0. Must be less than or equal to [max].
  //
  // If the [max] is equal to the [min], then the slider is disabled.
  double min = 8;
  // The maximum value the user can select.
  //
  // Defaults to 1.0. Must be greater than or equal to [min].
  //
  // If the [max] is equal to the [min], then the slider is disabled.
  double max = 9;
  // The number of discrete divisions.
  //
  // Typically used with [label] to show the current discrete value.
  //
  // If null, the slider is continuous.
  int32 divisions = 10;
  // A label to show above the slider when the slider is active and
  // [SliderThemeData.showValueIndicator] is satisfied.
  //
  // It is used to display the value of a discrete slider, and it is displayed
  // as part of the value indicator shape.
  //
  // The label is rendered using the active [ThemeData]'s [TextTheme.bodyLarge]
  // text style, with the theme data's [ColorScheme.onPrimary] color. The
  // label's text style can be overridden with
  // [SliderThemeData.valueIndicatorTextStyle].
  //
  // If null, then the value indicator will not be displayed.
  //
  // Ignored if this slider is created with [Slider.adaptive].
  //
  // See also:
  //
  //  * [SliderComponentShape] for how to create a custom value indicator
  //    shape.
  string label = 11;
  // The color to use for the portion of the slider track that is active.
  //
  // The "active" side of the slider is the side between the thumb and the
  // minimum value.
  //
  // If null, [SliderThemeData.activeTrackColor] of the ambient
  // [SliderTheme] is used. If that is null, [ColorScheme.primary] of the
  // surrounding [ThemeData] is used.
  //
  // Using a [SliderTheme] gives much more fine-grained control over the
  // appearance of various components of the slider.
  DartColorType active_color = 13;
  // The color for the inactive portion of the slider track.
  //
  // The "inactive" side of the slider is the side between the thumb and the
  // maximum value.
  //
  // If null, [SliderThemeData.inactiveTrackColor] of the ambient [SliderTheme]
  // is used. If that is null and [ThemeData.useMaterial3] is true,
  // [ColorScheme.surfaceVariant] will be used, otherwise [ColorScheme.primary]
  // with an opacity of 0.24 will be used.
  //
  // Using a [SliderTheme] gives much more fine-grained control over the
  // appearance of various components of the slider.
  //
  // Ignored if this slider is created with [Slider.adaptive].
  DartColorType inactive_color = 14;
  // The color to use for the portion of the slider track between the thumb and
  // the [Slider.secondaryTrackValue].
  //
  // Defaults to the [SliderThemeData.secondaryActiveTrackColor] of the current
  // [SliderTheme].
  //
  // If that is also null, defaults to [ColorScheme.primary] with an
  // opacity of 0.54.
  //
  // Using a [SliderTheme] gives much more fine-grained control over the
  // appearance of various components of the slider.
  //
  // Ignored if this slider is created with [Slider.adaptive].
  DartColorType secondary_active_color = 15;
  // The color of the thumb.
  //
  // If this color is null, [Slider] will use [activeColor], If [activeColor]
  // is also null, [Slider] will use [SliderThemeData.thumbColor].
  //
  // If that is also null, defaults to [ColorScheme.primary].
  //
  // * [CupertinoSlider] will have a white thumb
  // (like the native default iOS slider).
  DartColorType thumb_color = 16;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 19;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 20;
  // Allowed way for the user to interact with the [Slider].
  //
  // For example, if this is set to [SliderInteraction.tapOnly], the user can
  // interact with the slider only by tapping anywhere on the track. Sliding
  // will have no effect.
  //
  // Defaults to [SliderInteraction.tapAndSlide].
  MaterialSliderInteractionType.Enum allowed_interaction = 21;
}

// package:flutter/src/material/slider_theme.dart
//
// Applies the given theme [data] to [child].
message MaterialSliderTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the color and shape values for descendant slider widgets.
  MaterialSliderThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/slider_theme.dart
//
// Create a [SliderThemeData] given a set of exact values.
//
// This will rarely be used directly. It is used by [lerp] to
// create intermediate themes based on two themes.
//
// The simplest way to create a SliderThemeData is to use
// [copyWith] on the one you get from [SliderTheme.of], or create an
// entirely new one with [SliderThemeData.fromPrimaryColors].
//
// {@tool snippet}
//
// ```dart
// class Blissful extends StatefulWidget {
//   const Blissful({super.key});
//
//   @override
//   State createState() => BlissfulState();
// }
//
// class BlissfulState extends State<Blissful> {
//   double _bliss = 0;
//
//   @override
//   Widget build(BuildContext context) {
//     return SliderTheme(
//       data: SliderTheme.of(context).copyWith(activeTrackColor: const Color(0xff404080)),
//       child: Slider(
//         onChanged: (double value) { setState(() { _bliss = value; }); },
//         value: _bliss,
//       ),
//     );
//   }
// }
// ```
// {@end-tool}
message MaterialSliderThemeData {
  // The height of the [Slider] track.
  double track_height = 2;
  // The color of the [Slider] track between the [Slider.min] position and the
  // current thumb position.
  DartColorType active_track_color = 3;
  // The color of the [Slider] track between the current thumb position and the
  // [Slider.max] position.
  DartColorType inactive_track_color = 4;
  // The color of the [Slider] track between the current thumb position and the
  // [Slider.secondaryTrackValue] position.
  DartColorType secondary_active_track_color = 5;
  // The color of the [Slider] track between the [Slider.min] position and the
  // current thumb position when the [Slider] is disabled.
  DartColorType disabled_active_track_color = 6;
  // The color of the [Slider] track between the current thumb position and the
  // [Slider.max] position when the [Slider] is disabled.
  DartColorType disabled_inactive_track_color = 7;
  // The color of the [Slider] track between the current thumb position and the
  // [Slider.secondaryTrackValue] position when the [Slider] is disabled.
  DartColorType disabled_secondary_active_track_color = 8;
  // The color of the track's tick marks that are drawn between the [Slider.min]
  // position and the current thumb position.
  DartColorType active_tick_mark_color = 9;
  // The color of the track's tick marks that are drawn between the current
  // thumb position and the [Slider.max] position.
  DartColorType inactive_tick_mark_color = 10;
  // The color of the track's tick marks that are drawn between the [Slider.min]
  // position and the current thumb position when the [Slider] is disabled.
  DartColorType disabled_active_tick_mark_color = 11;
  // The color of the track's tick marks that are drawn between the current
  // thumb position and the [Slider.max] position when the [Slider] is
  // disabled.
  DartColorType disabled_inactive_tick_mark_color = 12;
  // The color given to the [thumbShape] to draw itself with.
  DartColorType thumb_color = 13;
  // The color given to the perimeter of the top [rangeThumbShape] when the
  // thumbs are overlapping and the top [rangeValueIndicatorShape] when the
  // value indicators are overlapping.
  DartColorType overlapping_shape_stroke_color = 14;
  // The color given to the [thumbShape] to draw itself with when the
  // [Slider] is disabled.
  DartColorType disabled_thumb_color = 15;
  // The color of the overlay drawn around the slider thumb when it is
  // pressed, focused, or hovered.
  //
  // This is typically a semi-transparent color.
  DartColorType overlay_color = 16;
  // The color given to the [valueIndicatorShape] to draw itself with.
  DartColorType value_indicator_color = 17;
  // The color given to the [valueIndicatorShape] stroke.
  DartColorType value_indicator_stroke_color = 18;
  // The shape that will be used to draw the [Slider]'s overlay.
  //
  // Both the [overlayColor] and a non default [overlayShape] may be specified.
  // The default [overlayShape] refers to the [overlayColor].
  //
  // The default value is [RoundSliderOverlayShape].
  MaterialSliderComponentShapeType overlay_shape = 19;
  // The shape that will be used to draw the [Slider]'s tick marks.
  //
  // The [SliderTickMarkShape.getPreferredSize] is used to help determine the
  // location of each tick mark on the track. The slider's minimum size will
  // be at least this big.
  //
  // The default value is [RoundSliderTickMarkShape].
  //
  // See also:
  //
  //  * [RoundRangeSliderTickMarkShape], which is the default tick mark
  //    shape for the range slider.
  MaterialSliderTickMarkShapeType tick_mark_shape = 20;
  // The shape that will be used to draw the [Slider]'s thumb.
  //
  // The default value is [RoundSliderThumbShape].
  //
  // See also:
  //
  //  * [RoundRangeSliderThumbShape], which is the default thumb shape for
  //    the [RangeSlider].
  MaterialSliderComponentShapeType thumb_shape = 21;
  // The shape that will be used to draw the [Slider]'s track.
  //
  // The [SliderTrackShape.getPreferredRect] method is used to map
  // slider-relative gesture coordinates to the correct thumb position on the
  // track. It is also used to horizontally position tick marks, when the
  // slider is discrete.
  //
  // The default value is [RoundedRectSliderTrackShape].
  //
  // See also:
  //
  //  * [RoundedRectRangeSliderTrackShape], which is the default track
  //    shape for the [RangeSlider].
  MaterialSliderTrackShapeType track_shape = 22;
  // The shape that will be used to draw the [Slider]'s value
  // indicator.
  //
  // The default value is [PaddleSliderValueIndicatorShape].
  //
  // See also:
  //
  //  * [PaddleRangeSliderValueIndicatorShape], which is the default value
  //    indicator shape for the [RangeSlider].
  MaterialSliderComponentShapeType value_indicator_shape = 23;
  // The shape that will be used to draw the [RangeSlider]'s tick marks.
  //
  // The [RangeSliderTickMarkShape.getPreferredSize] is used to help determine
  // the location of each tick mark on the track. The slider's minimum size
  // will be at least this big.
  //
  // The default value is [RoundRangeSliderTickMarkShape].
  //
  // See also:
  //
  //  * [RoundSliderTickMarkShape], which is the default tick mark shape
  //    for the [Slider].
  MaterialRangeSliderTickMarkShapeType range_tick_mark_shape = 24;
  // The shape that will be used for the [RangeSlider]'s thumbs.
  //
  // By default the same shape is used for both thumbs, but strokes the top
  // thumb when it overlaps the bottom thumb. The top thumb is always the last
  // selected thumb.
  //
  // The default value is [RoundRangeSliderThumbShape].
  //
  // See also:
  //
  //  * [RoundSliderThumbShape], which is the default thumb shape for the
  //    [Slider].
  MaterialRangeSliderThumbShapeType range_thumb_shape = 25;
  // The shape that will be used to draw the [RangeSlider]'s track.
  //
  // The [SliderTrackShape.getPreferredRect] method is used to map
  // slider-relative gesture coordinates to the correct thumb position on the
  // track. It is also used to horizontally position the tick marks, when the
  // slider is discrete.
  //
  // The default value is [RoundedRectRangeSliderTrackShape].
  //
  // See also:
  //
  //  * [RoundedRectSliderTrackShape], which is the default track
  //    shape for the [Slider].
  MaterialRangeSliderTrackShapeType range_track_shape = 26;
  // The shape that will be used for the [RangeSlider]'s value indicators.
  //
  // The default shape uses the same value indicator for each thumb, but
  // strokes the top value indicator when it overlaps the bottom value
  // indicator. The top indicator corresponds to the top thumb, which is always
  // the most recently selected thumb.
  //
  // The default value is [PaddleRangeSliderValueIndicatorShape].
  //
  // See also:
  //
  //  * [PaddleSliderValueIndicatorShape], which is the default value
  //    indicator shape for the [Slider].
  MaterialRangeSliderValueIndicatorShapeType range_value_indicator_shape = 27;
  // Whether the value indicator should be shown for different types of
  // sliders.
  //
  // By default, [showValueIndicator] is set to
  // [ShowValueIndicator.onlyForDiscrete]. The value indicator is only shown
  // when the thumb is being touched.
  MaterialShowValueIndicatorType.Enum show_value_indicator = 28;
  // The text style for the text on the value indicator.
  FlutterTextStyleType value_indicator_text_style = 29;
  // Limits the thumb's separation distance.
  //
  // Use this only if you want to control the visual appearance of the thumbs
  // in terms of a logical pixel value. This can be done when you want a
  // specific look for thumbs when they are close together. To limit with the
  // real values, rather than logical pixels, the values can be restricted by
  // the parent.
  double min_thumb_separation = 30;
  // Allowed way for the user to interact with the [Slider].
  //
  // If specified, overrides the default value of [Slider.allowedInteraction].
  MaterialSliderInteractionType.Enum allowed_interaction = 33;
}

// package:flutter/src/material/slider_theme.dart
//
// Generates a SliderThemeData from three main colors.
//
// Usually these are the primary, dark and light colors from
// a [ThemeData].
//
// The opacities of these colors will be overridden with the Material Design
// defaults when assigning them to the slider theme component colors.
//
// This is used to generate the default slider theme for a [ThemeData].
message MaterialSliderThemeDataNamedFromPrimaryColors {
  DartColorType primary_color = 2;
  DartColorType primary_color_dark = 3;
  DartColorType primary_color_light = 4;
  FlutterTextStyleType value_indicator_text_style = 5;
}

// package:flutter/src/material/app_bar.dart
//
// Creates a Material Design app bar that can be placed in a [CustomScrollView].
message MaterialSliverAppBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.material.appbar.leading}
  //
  // This property is used to configure an [AppBar].
  WidgetType leading = 3;
  // {@macro flutter.material.appbar.automaticallyImplyLeading}
  //
  // This property is used to configure an [AppBar].
  bool automatically_imply_leading = 4;
  // {@macro flutter.material.appbar.title}
  //
  // This property is used to configure an [AppBar].
  WidgetType title = 5;
  // {@macro flutter.material.appbar.actions}
  //
  // This property is used to configure an [AppBar].
  repeated WidgetType actions = 6;
  // {@macro flutter.material.appbar.flexibleSpace}
  //
  // This property is used to configure an [AppBar].
  WidgetType flexible_space = 7;
  // {@macro flutter.material.appbar.bottom}
  //
  // This property is used to configure an [AppBar].
  FlutterPreferredSizeWidgetType bottom = 8;
  // {@macro flutter.material.appbar.elevation}
  //
  // This property is used to configure an [AppBar].
  double elevation = 9;
  // {@macro flutter.material.appbar.scrolledUnderElevation}
  //
  // This property is used to configure an [AppBar].
  double scrolled_under_elevation = 10;
  // {@macro flutter.material.appbar.shadowColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType shadow_color = 11;
  // {@macro flutter.material.appbar.surfaceTintColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType surface_tint_color = 12;
  // Whether to show the shadow appropriate for the [elevation] even if the
  // content is not scrolled under the [AppBar].
  //
  // Defaults to false, meaning that the [elevation] is only applied when the
  // [AppBar] is being displayed over content that is scrolled under it.
  //
  // When set to true, the [elevation] is applied regardless.
  //
  // Ignored when [elevation] is zero.
  bool force_elevated = 13;
  // {@macro flutter.material.appbar.backgroundColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType background_color = 14;
  // {@macro flutter.material.appbar.foregroundColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType foreground_color = 15;
  // {@macro flutter.material.appbar.iconTheme}
  //
  // This property is used to configure an [AppBar].
  FlutterIconThemeDataType icon_theme = 16;
  // {@macro flutter.material.appbar.actionsIconTheme}
  //
  // This property is used to configure an [AppBar].
  FlutterIconThemeDataType actions_icon_theme = 17;
  // {@macro flutter.material.appbar.primary}
  //
  // This property is used to configure an [AppBar].
  bool primary = 18;
  // {@macro flutter.material.appbar.centerTitle}
  //
  // This property is used to configure an [AppBar].
  bool center_title = 19;
  // {@macro flutter.material.appbar.excludeHeaderSemantics}
  //
  // This property is used to configure an [AppBar].
  bool exclude_header_semantics = 20;
  // {@macro flutter.material.appbar.titleSpacing}
  //
  // This property is used to configure an [AppBar].
  double title_spacing = 21;
  // Defines the height of the app bar when it is collapsed.
  //
  // By default, the collapsed height is [toolbarHeight]. If [bottom] widget is
  // specified, then its height from [PreferredSizeWidget.preferredSize] is
  // added to the height. If [primary] is true, then the [MediaQuery] top
  // padding, [EdgeInsets.top] of [MediaQueryData.padding], is added as well.
  //
  // If [pinned] and [floating] are true, with [bottom] set, the default
  // collapsed height is only the height of [PreferredSizeWidget.preferredSize]
  // with the [MediaQuery] top padding.
  double collapsed_height = 22;
  // The size of the app bar when it is fully expanded.
  //
  // By default, the total height of the toolbar and the bottom widget (if
  // any). If a [flexibleSpace] widget is specified this height should be big
  // enough to accommodate whatever that widget contains.
  //
  // This does not include the status bar height (which will be automatically
  // included if [primary] is true).
  double expanded_height = 23;
  // Whether the app bar should become visible as soon as the user scrolls
  // towards the app bar.
  //
  // Otherwise, the user will need to scroll near the top of the scroll view to
  // reveal the app bar.
  //
  // If [snap] is true then a scroll that exposes the app bar will trigger an
  // animation that slides the entire app bar into view. Similarly if a scroll
  // dismisses the app bar, the animation will slide it completely out of view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [floating] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar.mp4}
  // * App bar with [floating] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [pinned] and [snap].
  bool floating = 24;
  // Whether the app bar should remain visible at the start of the scroll view.
  //
  // The app bar can still expand and contract as the user scrolls, but it will
  // remain visible rather than being scrolled out of view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [pinned] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar.mp4}
  // * App bar with [pinned] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_pinned.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [floating].
  bool pinned = 25;
  // If [snap] and [floating] are true then the floating app bar will "snap"
  // into view.
  //
  // If [snap] is true then a scroll that exposes the floating app bar will
  // trigger an animation that slides the entire app bar into view. Similarly
  // if a scroll dismisses the app bar, the animation will slide the app bar
  // completely out of view. Additionally, setting [snap] to true will fully
  // expand the floating app bar when the framework tries to reveal the
  // contents of the app bar by calling [RenderObject.showOnScreen]. For
  // example, when a [TextField] in the floating app bar gains focus, if [snap]
  // is true, the framework will always fully expand the floating app bar, in
  // order to reveal the focused [TextField].
  //
  // Snapping only applies when the app bar is floating, not when the app bar
  // appears at the top of its scroll view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [snap] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating.mp4}
  // * App bar with [snap] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating_snap.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [pinned] and [floating].
  bool snap = 26;
  // Whether the app bar should stretch to fill the over-scroll area.
  //
  // The app bar can still expand and contract as the user scrolls, but it will
  // also stretch when the user over-scrolls.
  bool stretch = 27;
  // The offset of overscroll required to activate [onStretchTrigger].
  //
  // This defaults to 100.0.
  double stretch_trigger_offset = 28;
  // {@macro flutter.material.appbar.shape}
  //
  // This property is used to configure an [AppBar].
  FlutterShapeBorderType shape = 30;
  // {@macro flutter.material.appbar.toolbarHeight}
  //
  // This property is used to configure an [AppBar].
  double toolbar_height = 31;
  // {@macro flutter.material.appbar.leadingWidth}
  //
  // This property is used to configure an [AppBar].
  double leading_width = 32;
  // {@macro flutter.material.appbar.toolbarTextStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterTextStyleType toolbar_text_style = 33;
  // {@macro flutter.material.appbar.titleTextStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterTextStyleType title_text_style = 34;
  // {@macro flutter.material.appbar.systemOverlayStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterSystemUiOverlayStyleType system_overlay_style = 35;
  // {@macro flutter.material.appbar.forceMaterialTransparency}
  //
  // This property is used to configure an [AppBar].
  bool force_material_transparency = 36;
  // {@macro flutter.material.Material.clipBehavior}
  DartClipType.Enum clip_behavior = 37;
}

// package:flutter/src/material/app_bar.dart
//
// Creates a Material Design large top app bar that can be placed
// in a [CustomScrollView].
//
// Returns a [SliverAppBar] configured with appropriate defaults
// for a large top app bar as defined in Material 3. It starts fully
// expanded with the title in an area underneath the main row of icons.
// When the [CustomScrollView] is scrolled, the title will be scrolled
// under the main row. When it is fully collapsed, a smaller version of the
// title will fade in on the main row. The reverse will happen if it is
// expanded again.
//
// {@tool dartpad}
// This sample shows how to use [SliverAppBar.large] in a [CustomScrollView].
//
// ** See code in examples/api/lib/material/app_bar/sliver_app_bar.3.dart **
// {@end-tool}
//
// See also:
//
//   * [AppBar], for a small or center-aligned top app bar.
//   * [SliverAppBar.medium], for a medium top app bar.
//   * https://m3.material.io/components/top-app-bar/overview, the Material 3
//     app bar specification.
message MaterialSliverAppBarNamedLarge {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.material.appbar.leading}
  //
  // This property is used to configure an [AppBar].
  WidgetType leading = 3;
  // {@macro flutter.material.appbar.automaticallyImplyLeading}
  //
  // This property is used to configure an [AppBar].
  bool automatically_imply_leading = 4;
  // {@macro flutter.material.appbar.title}
  //
  // This property is used to configure an [AppBar].
  WidgetType title = 5;
  // {@macro flutter.material.appbar.actions}
  //
  // This property is used to configure an [AppBar].
  repeated WidgetType actions = 6;
  // {@macro flutter.material.appbar.flexibleSpace}
  //
  // This property is used to configure an [AppBar].
  WidgetType flexible_space = 7;
  // {@macro flutter.material.appbar.bottom}
  //
  // This property is used to configure an [AppBar].
  FlutterPreferredSizeWidgetType bottom = 8;
  // {@macro flutter.material.appbar.elevation}
  //
  // This property is used to configure an [AppBar].
  double elevation = 9;
  // {@macro flutter.material.appbar.scrolledUnderElevation}
  //
  // This property is used to configure an [AppBar].
  double scrolled_under_elevation = 10;
  // {@macro flutter.material.appbar.shadowColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType shadow_color = 11;
  // {@macro flutter.material.appbar.surfaceTintColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType surface_tint_color = 12;
  // Whether to show the shadow appropriate for the [elevation] even if the
  // content is not scrolled under the [AppBar].
  //
  // Defaults to false, meaning that the [elevation] is only applied when the
  // [AppBar] is being displayed over content that is scrolled under it.
  //
  // When set to true, the [elevation] is applied regardless.
  //
  // Ignored when [elevation] is zero.
  bool force_elevated = 13;
  // {@macro flutter.material.appbar.backgroundColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType background_color = 14;
  // {@macro flutter.material.appbar.foregroundColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType foreground_color = 15;
  // {@macro flutter.material.appbar.iconTheme}
  //
  // This property is used to configure an [AppBar].
  FlutterIconThemeDataType icon_theme = 16;
  // {@macro flutter.material.appbar.actionsIconTheme}
  //
  // This property is used to configure an [AppBar].
  FlutterIconThemeDataType actions_icon_theme = 17;
  // {@macro flutter.material.appbar.primary}
  //
  // This property is used to configure an [AppBar].
  bool primary = 18;
  // {@macro flutter.material.appbar.centerTitle}
  //
  // This property is used to configure an [AppBar].
  bool center_title = 19;
  // {@macro flutter.material.appbar.excludeHeaderSemantics}
  //
  // This property is used to configure an [AppBar].
  bool exclude_header_semantics = 20;
  // {@macro flutter.material.appbar.titleSpacing}
  //
  // This property is used to configure an [AppBar].
  double title_spacing = 21;
  // Defines the height of the app bar when it is collapsed.
  //
  // By default, the collapsed height is [toolbarHeight]. If [bottom] widget is
  // specified, then its height from [PreferredSizeWidget.preferredSize] is
  // added to the height. If [primary] is true, then the [MediaQuery] top
  // padding, [EdgeInsets.top] of [MediaQueryData.padding], is added as well.
  //
  // If [pinned] and [floating] are true, with [bottom] set, the default
  // collapsed height is only the height of [PreferredSizeWidget.preferredSize]
  // with the [MediaQuery] top padding.
  double collapsed_height = 22;
  // The size of the app bar when it is fully expanded.
  //
  // By default, the total height of the toolbar and the bottom widget (if
  // any). If a [flexibleSpace] widget is specified this height should be big
  // enough to accommodate whatever that widget contains.
  //
  // This does not include the status bar height (which will be automatically
  // included if [primary] is true).
  double expanded_height = 23;
  // Whether the app bar should become visible as soon as the user scrolls
  // towards the app bar.
  //
  // Otherwise, the user will need to scroll near the top of the scroll view to
  // reveal the app bar.
  //
  // If [snap] is true then a scroll that exposes the app bar will trigger an
  // animation that slides the entire app bar into view. Similarly if a scroll
  // dismisses the app bar, the animation will slide it completely out of view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [floating] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar.mp4}
  // * App bar with [floating] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [pinned] and [snap].
  bool floating = 24;
  // Whether the app bar should remain visible at the start of the scroll view.
  //
  // The app bar can still expand and contract as the user scrolls, but it will
  // remain visible rather than being scrolled out of view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [pinned] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar.mp4}
  // * App bar with [pinned] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_pinned.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [floating].
  bool pinned = 25;
  // If [snap] and [floating] are true then the floating app bar will "snap"
  // into view.
  //
  // If [snap] is true then a scroll that exposes the floating app bar will
  // trigger an animation that slides the entire app bar into view. Similarly
  // if a scroll dismisses the app bar, the animation will slide the app bar
  // completely out of view. Additionally, setting [snap] to true will fully
  // expand the floating app bar when the framework tries to reveal the
  // contents of the app bar by calling [RenderObject.showOnScreen]. For
  // example, when a [TextField] in the floating app bar gains focus, if [snap]
  // is true, the framework will always fully expand the floating app bar, in
  // order to reveal the focused [TextField].
  //
  // Snapping only applies when the app bar is floating, not when the app bar
  // appears at the top of its scroll view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [snap] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating.mp4}
  // * App bar with [snap] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating_snap.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [pinned] and [floating].
  bool snap = 26;
  // Whether the app bar should stretch to fill the over-scroll area.
  //
  // The app bar can still expand and contract as the user scrolls, but it will
  // also stretch when the user over-scrolls.
  bool stretch = 27;
  // The offset of overscroll required to activate [onStretchTrigger].
  //
  // This defaults to 100.0.
  double stretch_trigger_offset = 28;
  // {@macro flutter.material.appbar.shape}
  //
  // This property is used to configure an [AppBar].
  FlutterShapeBorderType shape = 30;
  // {@macro flutter.material.appbar.toolbarHeight}
  //
  // This property is used to configure an [AppBar].
  double toolbar_height = 31;
  // {@macro flutter.material.appbar.leadingWidth}
  //
  // This property is used to configure an [AppBar].
  double leading_width = 32;
  // {@macro flutter.material.appbar.toolbarTextStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterTextStyleType toolbar_text_style = 33;
  // {@macro flutter.material.appbar.titleTextStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterTextStyleType title_text_style = 34;
  // {@macro flutter.material.appbar.systemOverlayStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterSystemUiOverlayStyleType system_overlay_style = 35;
  // {@macro flutter.material.appbar.forceMaterialTransparency}
  //
  // This property is used to configure an [AppBar].
  bool force_material_transparency = 36;
  // {@macro flutter.material.Material.clipBehavior}
  DartClipType.Enum clip_behavior = 37;
}

// package:flutter/src/material/app_bar.dart
//
// Creates a Material Design medium top app bar that can be placed
// in a [CustomScrollView].
//
// Returns a [SliverAppBar] configured with appropriate defaults
// for a medium top app bar as defined in Material 3. It starts fully
// expanded with the title in an area underneath the main row of icons.
// When the [CustomScrollView] is scrolled, the title will be scrolled
// under the main row. When it is fully collapsed, a smaller version of the
// title will fade in on the main row. The reverse will happen if it is
// expanded again.
//
// {@tool dartpad}
// This sample shows how to use [SliverAppBar.medium] in a [CustomScrollView].
//
// ** See code in examples/api/lib/material/app_bar/sliver_app_bar.2.dart **
// {@end-tool}
//
// See also:
//
//   * [AppBar], for a small or center-aligned top app bar.
//   * [SliverAppBar.large], for a large top app bar.
//   * https://m3.material.io/components/top-app-bar/overview, the Material 3
//     app bar specification.
message MaterialSliverAppBarNamedMedium {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@macro flutter.material.appbar.leading}
  //
  // This property is used to configure an [AppBar].
  WidgetType leading = 3;
  // {@macro flutter.material.appbar.automaticallyImplyLeading}
  //
  // This property is used to configure an [AppBar].
  bool automatically_imply_leading = 4;
  // {@macro flutter.material.appbar.title}
  //
  // This property is used to configure an [AppBar].
  WidgetType title = 5;
  // {@macro flutter.material.appbar.actions}
  //
  // This property is used to configure an [AppBar].
  repeated WidgetType actions = 6;
  // {@macro flutter.material.appbar.flexibleSpace}
  //
  // This property is used to configure an [AppBar].
  WidgetType flexible_space = 7;
  // {@macro flutter.material.appbar.bottom}
  //
  // This property is used to configure an [AppBar].
  FlutterPreferredSizeWidgetType bottom = 8;
  // {@macro flutter.material.appbar.elevation}
  //
  // This property is used to configure an [AppBar].
  double elevation = 9;
  // {@macro flutter.material.appbar.scrolledUnderElevation}
  //
  // This property is used to configure an [AppBar].
  double scrolled_under_elevation = 10;
  // {@macro flutter.material.appbar.shadowColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType shadow_color = 11;
  // {@macro flutter.material.appbar.surfaceTintColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType surface_tint_color = 12;
  // Whether to show the shadow appropriate for the [elevation] even if the
  // content is not scrolled under the [AppBar].
  //
  // Defaults to false, meaning that the [elevation] is only applied when the
  // [AppBar] is being displayed over content that is scrolled under it.
  //
  // When set to true, the [elevation] is applied regardless.
  //
  // Ignored when [elevation] is zero.
  bool force_elevated = 13;
  // {@macro flutter.material.appbar.backgroundColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType background_color = 14;
  // {@macro flutter.material.appbar.foregroundColor}
  //
  // This property is used to configure an [AppBar].
  DartColorType foreground_color = 15;
  // {@macro flutter.material.appbar.iconTheme}
  //
  // This property is used to configure an [AppBar].
  FlutterIconThemeDataType icon_theme = 16;
  // {@macro flutter.material.appbar.actionsIconTheme}
  //
  // This property is used to configure an [AppBar].
  FlutterIconThemeDataType actions_icon_theme = 17;
  // {@macro flutter.material.appbar.primary}
  //
  // This property is used to configure an [AppBar].
  bool primary = 18;
  // {@macro flutter.material.appbar.centerTitle}
  //
  // This property is used to configure an [AppBar].
  bool center_title = 19;
  // {@macro flutter.material.appbar.excludeHeaderSemantics}
  //
  // This property is used to configure an [AppBar].
  bool exclude_header_semantics = 20;
  // {@macro flutter.material.appbar.titleSpacing}
  //
  // This property is used to configure an [AppBar].
  double title_spacing = 21;
  // Defines the height of the app bar when it is collapsed.
  //
  // By default, the collapsed height is [toolbarHeight]. If [bottom] widget is
  // specified, then its height from [PreferredSizeWidget.preferredSize] is
  // added to the height. If [primary] is true, then the [MediaQuery] top
  // padding, [EdgeInsets.top] of [MediaQueryData.padding], is added as well.
  //
  // If [pinned] and [floating] are true, with [bottom] set, the default
  // collapsed height is only the height of [PreferredSizeWidget.preferredSize]
  // with the [MediaQuery] top padding.
  double collapsed_height = 22;
  // The size of the app bar when it is fully expanded.
  //
  // By default, the total height of the toolbar and the bottom widget (if
  // any). If a [flexibleSpace] widget is specified this height should be big
  // enough to accommodate whatever that widget contains.
  //
  // This does not include the status bar height (which will be automatically
  // included if [primary] is true).
  double expanded_height = 23;
  // Whether the app bar should become visible as soon as the user scrolls
  // towards the app bar.
  //
  // Otherwise, the user will need to scroll near the top of the scroll view to
  // reveal the app bar.
  //
  // If [snap] is true then a scroll that exposes the app bar will trigger an
  // animation that slides the entire app bar into view. Similarly if a scroll
  // dismisses the app bar, the animation will slide it completely out of view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [floating] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar.mp4}
  // * App bar with [floating] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [pinned] and [snap].
  bool floating = 24;
  // Whether the app bar should remain visible at the start of the scroll view.
  //
  // The app bar can still expand and contract as the user scrolls, but it will
  // remain visible rather than being scrolled out of view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [pinned] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar.mp4}
  // * App bar with [pinned] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_pinned.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [floating].
  bool pinned = 25;
  // If [snap] and [floating] are true then the floating app bar will "snap"
  // into view.
  //
  // If [snap] is true then a scroll that exposes the floating app bar will
  // trigger an animation that slides the entire app bar into view. Similarly
  // if a scroll dismisses the app bar, the animation will slide the app bar
  // completely out of view. Additionally, setting [snap] to true will fully
  // expand the floating app bar when the framework tries to reveal the
  // contents of the app bar by calling [RenderObject.showOnScreen]. For
  // example, when a [TextField] in the floating app bar gains focus, if [snap]
  // is true, the framework will always fully expand the floating app bar, in
  // order to reveal the focused [TextField].
  //
  // Snapping only applies when the app bar is floating, not when the app bar
  // appears at the top of its scroll view.
  //
  // ## Animated Examples
  //
  // The following animations show how the app bar changes its scrolling
  // behavior based on the value of this property.
  //
  // * App bar with [snap] set to false:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating.mp4}
  // * App bar with [snap] set to true:
  //   {@animation 476 400 https://flutter.github.io/assets-for-api-docs/assets/material/app_bar_floating_snap.mp4}
  //
  // See also:
  //
  //  * [SliverAppBar] for more animated examples of how this property changes the
  //    behavior of the app bar in combination with [pinned] and [floating].
  bool snap = 26;
  // Whether the app bar should stretch to fill the over-scroll area.
  //
  // The app bar can still expand and contract as the user scrolls, but it will
  // also stretch when the user over-scrolls.
  bool stretch = 27;
  // The offset of overscroll required to activate [onStretchTrigger].
  //
  // This defaults to 100.0.
  double stretch_trigger_offset = 28;
  // {@macro flutter.material.appbar.shape}
  //
  // This property is used to configure an [AppBar].
  FlutterShapeBorderType shape = 30;
  // {@macro flutter.material.appbar.toolbarHeight}
  //
  // This property is used to configure an [AppBar].
  double toolbar_height = 31;
  // {@macro flutter.material.appbar.leadingWidth}
  //
  // This property is used to configure an [AppBar].
  double leading_width = 32;
  // {@macro flutter.material.appbar.toolbarTextStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterTextStyleType toolbar_text_style = 33;
  // {@macro flutter.material.appbar.titleTextStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterTextStyleType title_text_style = 34;
  // {@macro flutter.material.appbar.systemOverlayStyle}
  //
  // This property is used to configure an [AppBar].
  FlutterSystemUiOverlayStyleType system_overlay_style = 35;
  // {@macro flutter.material.appbar.forceMaterialTransparency}
  //
  // This property is used to configure an [AppBar].
  bool force_material_transparency = 36;
  // {@macro flutter.material.Material.clipBehavior}
  DartClipType.Enum clip_behavior = 37;
}

// package:flutter/src/material/snack_bar.dart
//
// Creates a snack bar.
//
// The [elevation] must be null or non-negative.
message MaterialSnackBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The primary content of the snack bar.
  //
  // Typically a [Text] widget.
  WidgetType content = 3;
  // The snack bar's background color.
  //
  // If not specified, it will use [SnackBarThemeData.backgroundColor] of
  // [ThemeData.snackBarTheme]. If that is not specified it will default to a
  // dark variation of [ColorScheme.surface] for light themes, or
  // [ColorScheme.onSurface] for dark themes.
  DartColorType background_color = 4;
  // The z-coordinate at which to place the snack bar. This controls the size
  // of the shadow below the snack bar.
  //
  // Defines the card's [Material.elevation].
  //
  // If this property is null, then [SnackBarThemeData.elevation] of
  // [ThemeData.snackBarTheme] is used, if that is also null, the default value
  // is 6.0.
  double elevation = 5;
  // Empty space to surround the snack bar.
  //
  // This property is only used when [behavior] is [SnackBarBehavior.floating].
  // It can not be used if [width] is specified.
  //
  // If this property is null, then [SnackBarThemeData.insetPadding] of
  // [ThemeData.snackBarTheme] is used. If that is also null, then the default is
  // `EdgeInsets.fromLTRB(15.0, 5.0, 15.0, 10.0)`.
  //
  // If this property is not null and [hitTestBehavior] is null, then [hitTestBehavior] default is [HitTestBehavior.deferToChild].
  FlutterEdgeInsetsGeometryType margin = 6;
  // The amount of padding to apply to the snack bar's content and optional
  // action.
  //
  // If this property is null, the default padding values are as follows:
  //
  // * [content]
  //     * Top and bottom paddings are 14.
  //     * Left padding is 24 if [behavior] is [SnackBarBehavior.fixed],
  //       16 if [behavior] is [SnackBarBehavior.floating].
  //     * Right padding is same as start padding if there is no [action],
  //       otherwise 0.
  // * [action]
  //     * Top and bottom paddings are 14.
  //     * Left and right paddings are half of [content]'s left padding.
  //
  // If this property is not null, the padding is as follows:
  //
  // * [content]
  //     * Left, top and bottom paddings are assigned normally.
  //     * Right padding is assigned normally if there is no [action],
  //       otherwise 0.
  // * [action]
  //     * Left padding is replaced with half the right padding.
  //     * Top and bottom paddings are assigned normally.
  //     * Right padding is replaced with one and a half times the
  //       right padding.
  FlutterEdgeInsetsGeometryType padding = 7;
  // The width of the snack bar.
  //
  // If width is specified, the snack bar will be centered horizontally in the
  // available space. This property is only used when [behavior] is
  // [SnackBarBehavior.floating]. It can not be used if [margin] is specified.
  //
  // If this property is null, then [SnackBarThemeData.width] of
  // [ThemeData.snackBarTheme] is used. If that is null, the snack bar will
  // take up the full device width less the margin.
  double width = 8;
  // The shape of the snack bar's [Material].
  //
  // Defines the snack bar's [Material.shape].
  //
  // If this property is null then [SnackBarThemeData.shape] of
  // [ThemeData.snackBarTheme] is used. If that's null then the shape will
  // depend on the [SnackBarBehavior]. For [SnackBarBehavior.fixed], no
  // overriding shape is specified, so the [SnackBar] is rectangular. For
  // [SnackBarBehavior.floating], it uses a [RoundedRectangleBorder] with a
  // circular corner radius of 4.0.
  FlutterShapeBorderType shape = 9;
  // Defines how the snack bar area, including margin, will behave during hit testing.
  //
  // If this property is null and [margin] is not null, then [HitTestBehavior.deferToChild] is used by default.
  //
  // Please refer to [HitTestBehavior] for a detailed explanation of every behavior.
  FlutterHitTestBehaviorType.Enum hit_test_behavior = 10;
  // This defines the behavior and location of the snack bar.
  //
  // Defines where a [SnackBar] should appear within a [Scaffold] and how its
  // location should be adjusted when the scaffold also includes a
  // [FloatingActionButton] or a [BottomNavigationBar]
  //
  // If this property is null, then [SnackBarThemeData.behavior] of
  // [ThemeData.snackBarTheme] is used. If that is null, then the default is
  // [SnackBarBehavior.fixed].
  //
  // If this value is [SnackBarBehavior.floating], the length of the bar
  // is defined by either [width] or [margin].
  MaterialSnackBarBehaviorType.Enum behavior = 11;
  // (optional) The percentage threshold for action widget's width before it overflows
  // to a new line.
  //
  // Must be between 0 and 1. If the width of the snackbar's [content] is greater
  // than this percentage of the width of the snackbar less the width of its [action],
  // then the [action] will appear below the [content].
  //
  // At a value of 0, the action will not overflow to a new line.
  //
  // Defaults to 0.25.
  double action_overflow_threshold = 13;
  // (optional) Whether to include a "close" icon widget.
  //
  // Tapping the icon will close the snack bar.
  bool show_close_icon = 14;
  // (optional) An optional color for the close icon, if [showCloseIcon] is
  // true.
  //
  // If this property is null, then [SnackBarThemeData.closeIconColor] of
  // [ThemeData.snackBarTheme] is used. If that is null, then the default is
  // inverse surface.
  //
  // If [closeIconColor] is a [MaterialStateColor], then the icon color will be
  // resolved against the set of [MaterialState]s that the action text
  // is in, thus allowing for different colors for states such as pressed,
  // hovered and others.
  DartColorType close_icon_color = 15;
  // The amount of time the snack bar should be displayed.
  //
  // Defaults to 4.0s.
  //
  // See also:
  //
  //  * [ScaffoldMessengerState.removeCurrentSnackBar], which abruptly hides the
  //    currently displayed snack bar, if any, and allows the next to be
  //    displayed.
  //  * <https://material.io/design/components/snackbars.html>
  DartDurationType duration = 16;
  // The direction in which the SnackBar can be dismissed.
  //
  // If this property is null, then [SnackBarThemeData.dismissDirection] of
  // [ThemeData.snackBarTheme] is used. If that is null, then the default is
  // [DismissDirection.down].
  FlutterDismissDirectionType.Enum dismiss_direction = 19;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 20;
}

// package:flutter/src/material/snack_bar_theme.dart
//
// Creates a theme that can be used for [ThemeData.snackBarTheme].
//
// The [elevation] must be null or non-negative.
message MaterialSnackBarThemeData {
  // Overrides the default value for [SnackBar.backgroundColor].
  //
  // If null, [SnackBar] defaults to dark grey: `Color(0xFF323232)`.
  DartColorType background_color = 2;
  // Overrides the default value for [SnackBarAction.textColor].
  //
  // If null, [SnackBarAction] defaults to [ColorScheme.secondary] of
  // [ThemeData.colorScheme] .
  DartColorType action_text_color = 3;
  // Overrides the default value for [SnackBarAction.disabledTextColor].
  //
  // If null, [SnackBarAction] defaults to [ColorScheme.onSurface] with its
  // opacity set to 0.30 if the [Theme]'s brightness is [Brightness.dark], 0.38
  // otherwise.
  DartColorType disabled_action_text_color = 4;
  // Used to configure the [DefaultTextStyle] for the [SnackBar.content] widget.
  //
  // If null, [SnackBar] defines its default.
  FlutterTextStyleType content_text_style = 5;
  // Overrides the default value for [SnackBar.elevation].
  //
  // If null, [SnackBar] uses a default of 6.0.
  double elevation = 6;
  // Overrides the default value for [SnackBar.shape].
  //
  // If null, [SnackBar] provides different defaults depending on the
  // [SnackBarBehavior]. For [SnackBarBehavior.fixed], no overriding shape is
  // specified, so the [SnackBar] is rectangular. For
  // [SnackBarBehavior.floating], it uses a [RoundedRectangleBorder] with a
  // circular corner radius of 4.0.
  FlutterShapeBorderType shape = 7;
  // Overrides the default value for [SnackBar.behavior].
  //
  // If null, [SnackBar] will default to [SnackBarBehavior.fixed].
  MaterialSnackBarBehaviorType.Enum behavior = 8;
  // Overrides the default value for [SnackBar.width].
  //
  // If this property is null, then the snack bar will take up the full device
  // width less the margin. This value is only used when [behavior] is
  // [SnackBarBehavior.floating].
  double width = 9;
  // Overrides the default value for [SnackBar.margin].
  //
  // This value is only used when [behavior] is [SnackBarBehavior.floating].
  FlutterEdgeInsetsType inset_padding = 10;
  // Overrides the default value for [SnackBar.showCloseIcon].
  //
  // Whether to show an optional "Close" icon.
  bool show_close_icon = 11;
  // Overrides the default value for [SnackBar.closeIconColor].
  //
  // This value is only used if [showCloseIcon] is true.
  DartColorType close_icon_color = 12;
  // Overrides the default value for [SnackBar.actionOverflowThreshold].
  //
  // Must be a value between 0 and 1, if present.
  double action_overflow_threshold = 13;
  // Overrides default value for [SnackBarAction.backgroundColor].
  //
  // If null, [SnackBarAction] falls back to [Colors.transparent].
  DartColorType action_background_color = 14;
  // Overrides default value for [SnackBarAction.].
  //
  // If null, [SnackBarAction] falls back to [Colors.transparent].
  DartColorType disabled_action_background_color = 15;
  // Overrides the default value for [SnackBar.dismissDirection].
  //
  // If null, [SnackBar] will default to [DismissDirection.down].
  FlutterDismissDirectionType.Enum dismiss_direction = 16;
}

// package:flutter/src/material/spell_check_suggestions_toolbar.dart
//
// Constructs a [SpellCheckSuggestionsToolbar].
//
// [buttonItems] must not contain more than four items, generally three
// suggestions and one delete button.
message MaterialSpellCheckSuggestionsToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.material.SpellCheckSuggestionsToolbar.anchor}
  // The focal point below which the toolbar attempts to position itself.
  // {@endtemplate}
  DartOffsetType anchor = 3;
  // The [ContextMenuButtonItem]s that will be turned into the correct button
  // widgets and displayed in the spell check suggestions toolbar.
  //
  // Must not contain more than four items, typically three suggestions and a
  // delete button.
  //
  // See also:
  //
  //  * [AdaptiveTextSelectionToolbar.buttonItems], the list of
  //    [ContextMenuButtonItem]s that are used to build the buttons of the
  //    text selection toolbar.
  //  * [CupertinoSpellCheckSuggestionsToolbar.buttonItems], the list of
  //    [ContextMenuButtonItem]s used to build the Cupertino style spell check
  //    suggestions toolbar.
  repeated FlutterContextMenuButtonItemType button_items = 4;
}

// package:flutter/src/material/spell_check_suggestions_toolbar_layout_delegate.dart
//
// Creates an instance of [SpellCheckSuggestionsToolbarLayoutDelegate].
message MaterialSpellCheckSuggestionsToolbarLayoutDelegate {
  // {@macro flutter.material.SpellCheckSuggestionsToolbar.anchor}
  //
  // Should be provided in local coordinates.
  DartOffsetType anchor = 2;
}

// package:flutter/src/material/spell_check_suggestions_toolbar.dart
//
// Constructs a [SpellCheckSuggestionsToolbar] with the default children for
// an [EditableText].
//
// See also:
//  * [CupertinoSpellCheckSuggestionsToolbar.editableText], which is similar
//    but builds an iOS-style toolbar.
message MaterialSpellCheckSuggestionsToolbarNamedEditableText {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  FlutterEditableTextStateType editable_text_state = 3;
}

// package:flutter/src/material/stepper.dart
//
// Creates a step for a [Stepper].
message MaterialStep {
  // The title of the step that typically describes it.
  WidgetType title = 2;
  // The subtitle of the step that appears below the title and has a smaller
  // font size. It typically gives more details that complement the title.
  //
  // If null, the subtitle is not shown.
  WidgetType subtitle = 3;
  // The content of the step that appears below the [title] and [subtitle].
  //
  // Below the content, every step has a 'continue' and 'cancel' button.
  WidgetType content = 4;
  // The state of the step which determines the styling of its components
  // and whether steps are interactive.
  MaterialStepStateType.Enum state = 5;
  // Whether or not the step is active. The flag only influences styling.
  bool is_active = 6;
  // Only [StepperType.horizontal], Optional widget that appears under the [title].
  // By default, uses the `bodyLarge` theme.
  WidgetType label = 7;
}

// package:flutter/src/material/stepper.dart
//
// Creates a stepper from a list of steps.
//
// This widget is not meant to be rebuilt with a different list of steps
// unless a key is provided in order to distinguish the old stepper from the
// new one.
message MaterialStepper {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The steps of the stepper whose titles, subtitles, icons always get shown.
  //
  // The length of [steps] must not change.
  repeated MaterialStepType steps = 3;
  // An object that can be used to control the position to which this scroll
  // view is scrolled.
  //
  // To control the initial scroll offset of the scroll view, provide a
  // [controller] with its [ScrollController.initialScrollOffset] property set.
  FlutterScrollControllerType controller = 4;
  // How the stepper's scroll view should respond to user input.
  //
  // For example, determines how the scroll view continues to
  // animate after the user stops dragging the scroll view.
  //
  // If the stepper is contained within another scrollable it
  // can be helpful to set this property to [ClampingScrollPhysics].
  FlutterScrollPhysicsType physics = 5;
  // The type of stepper that determines the layout. In the case of
  // [StepperType.horizontal], the content of the current step is displayed
  // underneath as opposed to the [StepperType.vertical] case where it is
  // displayed in-between.
  MaterialStepperTypeType.Enum type = 6;
  // The index into [steps] of the current step whose content is displayed.
  int32 current_step = 7;
  // The elevation of this stepper's [Material] when [type] is [StepperType.horizontal].
  double elevation = 12;
  // Custom margin on vertical stepper.
  FlutterEdgeInsetsGeometryType margin = 13;
  // The thickness of the connecting lines.
  double connector_thickness = 15;
}

// package:flutter/src/material/menu_anchor.dart
//
// Creates a const [SubmenuButton].
//
// The [child] and [menuChildren] attributes are required.
message MaterialSubmenuButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // An optional [MenuController] for this submenu.
  MaterialMenuControllerType controller = 7;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding properties in
  // [themeStyleOf] and [defaultStyleOf]. [MaterialStateProperty]s that resolve
  // to non-null values will similarly override the corresponding
  // [MaterialStateProperty]s in [themeStyleOf] and [defaultStyleOf].
  //
  // Null by default.
  MaterialButtonStyleType style = 8;
  // The [MenuStyle] of the menu specified by [menuChildren].
  //
  // Defaults to the value of [MenuThemeData.style] of the ambient [MenuTheme].
  MaterialMenuStyleType menu_style = 9;
  // The offset of the menu relative to the alignment origin determined by
  // [MenuStyle.alignment] on the [style] attribute.
  //
  // Use this for fine adjustments of the menu placement.
  //
  // Defaults to an offset that takes into account the padding of the menu so
  // that the top starting corner of the first menu item is aligned with the
  // top of the [MenuAnchor] region.
  DartOffsetType alignment_offset = 10;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 11;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 12;
  // {@macro flutter.material.inkwell.statesController}
  MaterialMaterialStatesControllerType states_controller = 13;
  // An optional icon to display before the [child].
  WidgetType leading_icon = 14;
  // An optional icon to display after the [child].
  WidgetType trailing_icon = 15;
  // The list of widgets that appear in the menu when it is opened.
  //
  // These can be any widget, but are typically either [MenuItemButton] or
  // [SubmenuButton] widgets.
  //
  // If [menuChildren] is empty, then the button for this menu item will be
  // disabled.
  repeated WidgetType menu_children = 16;
  // The widget displayed in the middle portion of this button.
  //
  // Typically this is the button's label, using a [Text] widget.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 17;
}

// package:flutter/src/material/switch.dart
//
// Creates a Material Design switch.
//
// The switch itself does not maintain any state. Instead, when the state of
// the switch changes, the widget calls the [onChanged] callback. Most widgets
// that use a switch will listen for the [onChanged] callback and rebuild the
// switch with a new [value] to update the visual appearance of the switch.
//
// The following arguments are required:
//
// * [value] determines whether this switch is on or off.
// * [onChanged] is called when the user toggles the switch on or off.
message MaterialSwitch {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this switch is on or off.
  bool value = 3;
  // {@template flutter.material.switch.activeColor}
  // The color to use when this switch is on.
  // {@endtemplate}
  //
  // Defaults to [ColorScheme.secondary].
  //
  // If [thumbColor] returns a non-null color in the [MaterialState.selected]
  // state, it will be used instead of this color.
  DartColorType active_color = 5;
  // {@template flutter.material.switch.activeTrackColor}
  // The color to use on the track when this switch is on.
  // {@endtemplate}
  //
  // Defaults to [ColorScheme.secondary] with the opacity set at 50%.
  //
  // If [trackColor] returns a non-null color in the [MaterialState.selected]
  // state, it will be used instead of this color.
  DartColorType active_track_color = 6;
  // {@template flutter.material.switch.inactiveThumbColor}
  // The color to use on the thumb when this switch is off.
  // {@endtemplate}
  //
  // Defaults to the colors described in the Material design specification.
  //
  // If [thumbColor] returns a non-null color in the default state, it will be
  // used instead of this color.
  DartColorType inactive_thumb_color = 7;
  // {@template flutter.material.switch.inactiveTrackColor}
  // The color to use on the track when this switch is off.
  // {@endtemplate}
  //
  // Defaults to the colors described in the Material design specification.
  //
  // If [trackColor] returns a non-null color in the default state, it will be
  // used instead of this color.
  DartColorType inactive_track_color = 8;
  // {@template flutter.material.switch.materialTapTargetSize}
  // Configures the minimum size of the tap target.
  // {@endtemplate}
  //
  // If null, then the value of [SwitchThemeData.materialTapTargetSize] is
  // used. If that is also null, then the value of
  // [ThemeData.materialTapTargetSize] is used.
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 18;
  // {@macro flutter.cupertino.CupertinoSwitch.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 19;
  // The color for the button's [Material] when it has the input focus.
  //
  // If [overlayColor] returns a non-null color in the [MaterialState.focused]
  // state, it will be used instead.
  //
  // If null, then the value of [SwitchThemeData.overlayColor] is used in the
  // focused state. If that is also null, then the value of
  // [ThemeData.focusColor] is used.
  DartColorType focus_color = 21;
  // The color for the button's [Material] when a pointer is hovering over it.
  //
  // If [overlayColor] returns a non-null color in the [MaterialState.hovered]
  // state, it will be used instead.
  //
  // If null, then the value of [SwitchThemeData.overlayColor] is used in the
  // hovered state. If that is also null, then the value of
  // [ThemeData.hoverColor] is used.
  DartColorType hover_color = 22;
  // {@template flutter.material.switch.splashRadius}
  // The splash radius of the circular [Material] ink response.
  // {@endtemplate}
  //
  // If null, then the value of [SwitchThemeData.splashRadius] is used. If that
  // is also null, then [kRadialReactionRadius] is used.
  double splash_radius = 24;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 25;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 27;
}

// package:flutter/src/material/switch_list_tile.dart
//
// Creates a combination of a list tile and a switch.
//
// The switch tile itself does not maintain any state. Instead, when the
// state of the switch changes, the widget calls the [onChanged] callback.
// Most widgets that use a switch will listen for the [onChanged] callback
// and rebuild the switch tile with a new [value] to update the visual
// appearance of the switch.
//
// The following arguments are required:
//
// * [value] determines whether this switch is on or off.
// * [onChanged] is called when the user toggles the switch on or off.
message MaterialSwitchListTile {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this switch is checked.
  bool value = 3;
  // {@macro flutter.material.switch.activeColor}
  //
  // Defaults to [ColorScheme.secondary] of the current [Theme].
  DartColorType active_color = 5;
  // {@macro flutter.material.switch.activeTrackColor}
  //
  // Defaults to [ThemeData.toggleableActiveColor] with the opacity set at 50%.
  //
  // Ignored if created with [SwitchListTile.adaptive].
  DartColorType active_track_color = 6;
  // {@macro flutter.material.switch.inactiveThumbColor}
  //
  // Defaults to the colors described in the Material design specification.
  //
  // Ignored if created with [SwitchListTile.adaptive].
  DartColorType inactive_thumb_color = 7;
  // {@macro flutter.material.switch.inactiveTrackColor}
  //
  // Defaults to the colors described in the Material design specification.
  //
  // Ignored if created with [SwitchListTile.adaptive].
  DartColorType inactive_track_color = 8;
  // {@macro flutter.material.switch.materialTapTargetSize}
  //
  // defaults to [MaterialTapTargetSize.shrinkWrap].
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 17;
  // {@macro flutter.cupertino.CupertinoSwitch.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 18;
  // {@macro flutter.material.switch.splashRadius}
  //
  // If null, then the value of [SwitchThemeData.splashRadius] is used. If that
  // is also null, then [kRadialReactionRadius] is used.
  double splash_radius = 21;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 22;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 24;
  // {@macro flutter.material.ListTile.tileColor}
  DartColorType tile_color = 25;
  // The primary content of the list tile.
  //
  // Typically a [Text] widget.
  WidgetType title = 26;
  // Additional content displayed below the title.
  //
  // Typically a [Text] widget.
  WidgetType subtitle = 27;
  // Whether this list tile is intended to display three lines of text.
  //
  // If false, the list tile is treated as having one line if the subtitle is
  // null and treated as having two lines if the subtitle is non-null.
  bool is_three_line = 28;
  // Whether this list tile is part of a vertically dense list.
  //
  // If this property is null then its value is based on [ListTileThemeData.dense].
  bool dense = 29;
  // The tile's internal padding.
  //
  // Insets a [SwitchListTile]'s contents: its [title], [subtitle],
  // [secondary], and [Switch] widgets.
  //
  // If null, [ListTile]'s default of `EdgeInsets.symmetric(horizontal: 16.0)`
  // is used.
  FlutterEdgeInsetsGeometryType content_padding = 30;
  // A widget to display on the opposite side of the tile from the switch.
  //
  // Typically an [Icon] widget.
  WidgetType secondary = 31;
  // Whether to render icons and text in the [activeColor].
  //
  // No effort is made to automatically coordinate the [selected] state and the
  // [value] state. To have the list tile appear selected when the switch is
  // on, pass the same value to both.
  //
  // Normally, this property is left to its default value, false.
  bool selected = 32;
  // Defines the position of control and [secondary], relative to text.
  //
  // By default, the value of [controlAffinity] is [ListTileControlAffinity.platform].
  MaterialListTileControlAffinityType.Enum control_affinity = 33;
  // {@macro flutter.material.ListTile.shape}
  FlutterShapeBorderType shape = 34;
  // If non-null, defines the background color when [SwitchListTile.selected] is true.
  DartColorType selected_tile_color = 35;
  // Defines how compact the list tile's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  MaterialVisualDensityType visual_density = 36;
  // {@macro flutter.material.ListTile.enableFeedback}
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 37;
  // The color for the tile's [Material] when a pointer is hovering over it.
  DartColorType hover_color = 38;
}

// package:flutter/src/material/switch_list_tile.dart
//
// Creates a Material [ListTile] with an adaptive [Switch], following
// Material design's
// [Cross-platform guidelines](https://material.io/design/platform-guidance/cross-platform-adaptation.html).
//
// This widget uses [Switch.adaptive] to change the graphics of the switch
// component based on the ambient [ThemeData.platform]. On iOS and macOS, a
// [CupertinoSwitch] will be used. On other platforms a Material design
// [Switch] will be used.
//
// If a [CupertinoSwitch] is created, the following parameters are
// ignored: [activeTrackColor], [inactiveThumbColor], [inactiveTrackColor],
// [activeThumbImage], [inactiveThumbImage].
message MaterialSwitchListTileNamedAdaptive {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this switch is checked.
  bool value = 3;
  // {@macro flutter.material.switch.activeColor}
  //
  // Defaults to [ColorScheme.secondary] of the current [Theme].
  DartColorType active_color = 5;
  // {@macro flutter.material.switch.activeTrackColor}
  //
  // Defaults to [ThemeData.toggleableActiveColor] with the opacity set at 50%.
  //
  // Ignored if created with [SwitchListTile.adaptive].
  DartColorType active_track_color = 6;
  // {@macro flutter.material.switch.inactiveThumbColor}
  //
  // Defaults to the colors described in the Material design specification.
  //
  // Ignored if created with [SwitchListTile.adaptive].
  DartColorType inactive_thumb_color = 7;
  // {@macro flutter.material.switch.inactiveTrackColor}
  //
  // Defaults to the colors described in the Material design specification.
  //
  // Ignored if created with [SwitchListTile.adaptive].
  DartColorType inactive_track_color = 8;
  // {@macro flutter.material.switch.materialTapTargetSize}
  //
  // defaults to [MaterialTapTargetSize.shrinkWrap].
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 17;
  // {@macro flutter.cupertino.CupertinoSwitch.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 18;
  // {@macro flutter.material.switch.splashRadius}
  //
  // If null, then the value of [SwitchThemeData.splashRadius] is used. If that
  // is also null, then [kRadialReactionRadius] is used.
  double splash_radius = 21;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 22;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 24;
  // {@macro flutter.cupertino.CupertinoSwitch.applyTheme}
  bool apply_cupertino_theme = 25;
  // {@macro flutter.material.ListTile.tileColor}
  DartColorType tile_color = 26;
  // The primary content of the list tile.
  //
  // Typically a [Text] widget.
  WidgetType title = 27;
  // Additional content displayed below the title.
  //
  // Typically a [Text] widget.
  WidgetType subtitle = 28;
  // Whether this list tile is intended to display three lines of text.
  //
  // If false, the list tile is treated as having one line if the subtitle is
  // null and treated as having two lines if the subtitle is non-null.
  bool is_three_line = 29;
  // Whether this list tile is part of a vertically dense list.
  //
  // If this property is null then its value is based on [ListTileThemeData.dense].
  bool dense = 30;
  // The tile's internal padding.
  //
  // Insets a [SwitchListTile]'s contents: its [title], [subtitle],
  // [secondary], and [Switch] widgets.
  //
  // If null, [ListTile]'s default of `EdgeInsets.symmetric(horizontal: 16.0)`
  // is used.
  FlutterEdgeInsetsGeometryType content_padding = 31;
  // A widget to display on the opposite side of the tile from the switch.
  //
  // Typically an [Icon] widget.
  WidgetType secondary = 32;
  // Whether to render icons and text in the [activeColor].
  //
  // No effort is made to automatically coordinate the [selected] state and the
  // [value] state. To have the list tile appear selected when the switch is
  // on, pass the same value to both.
  //
  // Normally, this property is left to its default value, false.
  bool selected = 33;
  // Defines the position of control and [secondary], relative to text.
  //
  // By default, the value of [controlAffinity] is [ListTileControlAffinity.platform].
  MaterialListTileControlAffinityType.Enum control_affinity = 34;
  // {@macro flutter.material.ListTile.shape}
  FlutterShapeBorderType shape = 35;
  // If non-null, defines the background color when [SwitchListTile.selected] is true.
  DartColorType selected_tile_color = 36;
  // Defines how compact the list tile's layout will be.
  //
  // {@macro flutter.material.themedata.visualDensity}
  MaterialVisualDensityType visual_density = 37;
  // {@macro flutter.material.ListTile.enableFeedback}
  //
  // See also:
  //
  //  * [Feedback] for providing platform-specific feedback to certain actions.
  bool enable_feedback = 38;
  // The color for the tile's [Material] when a pointer is hovering over it.
  DartColorType hover_color = 39;
}

// package:flutter/src/material/switch.dart
//
// Creates an adaptive [Switch] based on whether the target platform is iOS
// or macOS, following Material design's
// [Cross-platform guidelines](https://material.io/design/platform-guidance/cross-platform-adaptation.html).
//
// Creates a switch that looks and feels native when the [ThemeData.platform]
// is iOS or macOS, otherwise a Material Design switch is created.
//
// To provide a custom switch theme that's only used by this factory
// constructor, add a custom `Adaptation<SwitchThemeData>` class to
// [ThemeData.adaptations]. This can be useful in situations where you don't
// want the overall [ThemeData.switchTheme] to apply when this adaptive
// constructor is used.
//
// {@tool dartpad}
// This sample shows how to create and use subclasses of [Adaptation] that
// define adaptive [SwitchThemeData]s.
//
// ** See code in examples/api/lib/material/switch/switch.4.dart **
// {@end-tool}
//
// The target platform is based on the current [Theme]: [ThemeData.platform].
message MaterialSwitchNamedAdaptive {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Whether this switch is on or off.
  bool value = 3;
  // {@template flutter.material.switch.activeColor}
  // The color to use when this switch is on.
  // {@endtemplate}
  //
  // Defaults to [ColorScheme.secondary].
  //
  // If [thumbColor] returns a non-null color in the [MaterialState.selected]
  // state, it will be used instead of this color.
  DartColorType active_color = 5;
  // {@template flutter.material.switch.activeTrackColor}
  // The color to use on the track when this switch is on.
  // {@endtemplate}
  //
  // Defaults to [ColorScheme.secondary] with the opacity set at 50%.
  //
  // If [trackColor] returns a non-null color in the [MaterialState.selected]
  // state, it will be used instead of this color.
  DartColorType active_track_color = 6;
  // {@template flutter.material.switch.inactiveThumbColor}
  // The color to use on the thumb when this switch is off.
  // {@endtemplate}
  //
  // Defaults to the colors described in the Material design specification.
  //
  // If [thumbColor] returns a non-null color in the default state, it will be
  // used instead of this color.
  DartColorType inactive_thumb_color = 7;
  // {@template flutter.material.switch.inactiveTrackColor}
  // The color to use on the track when this switch is off.
  // {@endtemplate}
  //
  // Defaults to the colors described in the Material design specification.
  //
  // If [trackColor] returns a non-null color in the default state, it will be
  // used instead of this color.
  DartColorType inactive_track_color = 8;
  // {@template flutter.material.switch.materialTapTargetSize}
  // Configures the minimum size of the tap target.
  // {@endtemplate}
  //
  // If null, then the value of [SwitchThemeData.materialTapTargetSize] is
  // used. If that is also null, then the value of
  // [ThemeData.materialTapTargetSize] is used.
  //
  // See also:
  //
  //  * [MaterialTapTargetSize], for a description of how this affects tap targets.
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 13;
  // {@macro flutter.cupertino.CupertinoSwitch.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 19;
  // The color for the button's [Material] when it has the input focus.
  //
  // If [overlayColor] returns a non-null color in the [MaterialState.focused]
  // state, it will be used instead.
  //
  // If null, then the value of [SwitchThemeData.overlayColor] is used in the
  // focused state. If that is also null, then the value of
  // [ThemeData.focusColor] is used.
  DartColorType focus_color = 21;
  // The color for the button's [Material] when a pointer is hovering over it.
  //
  // If [overlayColor] returns a non-null color in the [MaterialState.hovered]
  // state, it will be used instead.
  //
  // If null, then the value of [SwitchThemeData.overlayColor] is used in the
  // hovered state. If that is also null, then the value of
  // [ThemeData.hoverColor] is used.
  DartColorType hover_color = 22;
  // {@template flutter.material.switch.splashRadius}
  // The splash radius of the circular [Material] ink response.
  // {@endtemplate}
  //
  // If null, then the value of [SwitchThemeData.splashRadius] is used. If that
  // is also null, then [kRadialReactionRadius] is used.
  double splash_radius = 24;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 25;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 27;
  // {@macro flutter.cupertino.CupertinoSwitch.applyTheme}
  bool apply_cupertino_theme = 28;
}

// package:flutter/src/material/switch_theme.dart
//
// Constructs a switch theme that configures all descendant [Switch] widgets.
message MaterialSwitchTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties used for all descendant [Switch] widgets.
  MaterialSwitchThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/switch_theme.dart
//
// Creates a theme that can be used for [ThemeData.switchTheme].
message MaterialSwitchThemeData {
  // {@macro flutter.material.switch.materialTapTargetSize}
  //
  // If specified, overrides the default value of
  // [Switch.materialTapTargetSize].
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 6;
  // {@macro flutter.material.switch.splashRadius}
  //
  // If specified, overrides the default value of [Switch.splashRadius].
  double splash_radius = 9;
}

// package:flutter/src/material/tabs.dart
//
// Creates a Material Design [TabBar] tab.
//
// At least one of [text], [icon], and [child] must be non-null. The [text]
// and [child] arguments must not be used at the same time. The
// [iconMargin] is only useful when [icon] and either one of [text] or
// [child] is non-null.
message MaterialTab {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The text to display as the tab's label.
  //
  // Must not be used in combination with [child].
  string text = 3;
  // An icon to display as the tab's label.
  WidgetType icon = 4;
  // The margin added around the tab's icon.
  //
  // Only useful when used in combination with [icon], and either one of
  // [text] or [child] is non-null.
  FlutterEdgeInsetsGeometryType icon_margin = 5;
  // The height of the [Tab].
  //
  // If null, the height will be calculated based on the content of the [Tab]. When `icon` is not
  // null along with `child` or `text`, the default height is 72.0 pixels. Without an `icon`, the
  // height is 46.0 pixels.
  double height = 6;
  // The widget to be used as the tab's label.
  //
  // Usually a [Text] widget, possibly wrapped in a [Semantics] widget.
  //
  // Must not be used in combination with [text].
  WidgetType child = 7;
}

// package:flutter/src/material/tabs.dart
//
// Creates a Material Design primary tab bar.
//
// The length of the [tabs] argument must match the [controller]'s
// [TabController.length].
//
// If a [TabController] is not provided, then there must be a
// [DefaultTabController] ancestor.
//
// The [indicatorWeight] parameter defaults to 2.
//
// The [indicatorPadding] parameter defaults to [EdgeInsets.zero].
//
// If [indicator] is not null or provided from [TabBarTheme],
// then [indicatorWeight] and [indicatorColor] are ignored.
message MaterialTabBar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Typically a list of two or more [Tab] widgets.
  //
  // The length of this list must match the [controller]'s [TabController.length]
  // and the length of the [TabBarView.children] list.
  repeated WidgetType tabs = 3;
  // This widget's selection and animation state.
  //
  // If [TabController] is not provided, then the value of [DefaultTabController.of]
  // will be used.
  MaterialTabControllerType controller = 4;
  // Whether this tab bar can be scrolled horizontally.
  //
  // If [isScrollable] is true, then each tab is as wide as needed for its label
  // and the entire [TabBar] is scrollable. Otherwise each tab gets an equal
  // share of the available space.
  bool is_scrollable = 5;
  // The amount of space by which to inset the tab bar.
  //
  // When [isScrollable] is false, this will yield the same result as if [TabBar] was wrapped
  // in a [Padding] widget. When [isScrollable] is true, the scrollable itself is inset,
  // allowing the padding to scroll with the tab bar, rather than enclosing it.
  FlutterEdgeInsetsGeometryType padding = 6;
  // The color of the line that appears below the selected tab.
  //
  // If this parameter is null, then the value of the Theme's indicatorColor
  // property is used.
  //
  // If [indicator] is specified or provided from [TabBarTheme],
  // this property is ignored.
  DartColorType indicator_color = 7;
  // Whether this tab bar should automatically adjust the [indicatorColor].
  //
  // The default value of this property is true.
  //
  // If [automaticIndicatorColorAdjustment] is true,
  // then the [indicatorColor] will be automatically adjusted to [Colors.white]
  // when the [indicatorColor] is same as [Material.color] of the [Material]
  // parent widget.
  bool automatic_indicator_color_adjustment = 8;
  // The thickness of the line that appears below the selected tab.
  //
  // The value of this parameter must be greater than zero.
  //
  // If [ThemeData.useMaterial3] is true and [TabBar] is used to create a
  // primary tab bar, the default value is 3.0. If the provided value is less
  // than 3.0, the default value is used.
  //
  // If [ThemeData.useMaterial3] is true and [TabBar.secondary] is used to
  // create a secondary tab bar, the default value is 2.0.
  //
  // If [ThemeData.useMaterial3] is false, the default value is 2.0.
  //
  // If [indicator] is specified or provided from [TabBarTheme],
  // this property is ignored.
  double indicator_weight = 9;
  // The padding for the indicator.
  //
  // The default value of this property is [EdgeInsets.zero].
  //
  // For [isScrollable] tab bars, specifying [kTabLabelPadding] will align
  // the indicator with the tab's text for [Tab] widgets and all but the
  // shortest [Tab.text] values.
  FlutterEdgeInsetsGeometryType indicator_padding = 10;
  // Defines the appearance of the selected tab indicator.
  //
  // If [indicator] is specified or provided from [TabBarTheme],
  // the [indicatorColor] and [indicatorWeight] properties are ignored.
  //
  // The default, underline-style, selected tab indicator can be defined with
  // [UnderlineTabIndicator].
  //
  // The indicator's size is based on the tab's bounds. If [indicatorSize]
  // is [TabBarIndicatorSize.tab] the tab's bounds are as wide as the space
  // occupied by the tab in the tab bar. If [indicatorSize] is
  // [TabBarIndicatorSize.label], then the tab's bounds are only as wide as
  // the tab widget itself.
  //
  // See also:
  //
  //  * [splashBorderRadius], which defines the clipping radius of the splash
  //    and is generally used with [BoxDecoration.borderRadius].
  FlutterDecorationType indicator = 11;
  // Defines how the selected tab indicator's size is computed.
  //
  // The size of the selected tab indicator is defined relative to the
  // tab's overall bounds if [indicatorSize] is [TabBarIndicatorSize.tab]
  // (the default) or relative to the bounds of the tab's widget if
  // [indicatorSize] is [TabBarIndicatorSize.label].
  //
  // The selected tab's location appearance can be refined further with
  // the [indicatorColor], [indicatorWeight], [indicatorPadding], and
  // [indicator] properties.
  MaterialTabBarIndicatorSizeType.Enum indicator_size = 12;
  // The color of the divider.
  //
  // If null and [ThemeData.useMaterial3] is true, [TabBarTheme.dividerColor]
  // color is used. If that is null and [ThemeData.useMaterial3] is true,
  // [ColorScheme.surfaceVariant] will be used, otherwise divider will not be drawn.
  DartColorType divider_color = 13;
  // The height of the divider.
  //
  // If null and [ThemeData.useMaterial3] is true, [TabBarTheme.dividerHeight] is used.
  // If that is also null and [ThemeData.useMaterial3] is true, 1.0 will be used.
  // Otherwise divider will not be drawn.
  double divider_height = 14;
  // The color of selected tab labels.
  //
  // If null, then [TabBarTheme.labelColor] is used. If that is also null and
  // [ThemeData.useMaterial3] is true, [ColorScheme.primary] will be used,
  // otherwise the color of the [ThemeData.primaryTextTheme]'s
  // [TextTheme.bodyLarge] text color is used.
  //
  // If [labelColor] (or, if null, [TabBarTheme.labelColor]) is a
  // [MaterialStateColor], then the effective tab color will depend on the
  // [MaterialState.selected] state, i.e. if the [Tab] is selected or not,
  // ignoring [unselectedLabelColor] even if it's non-null.
  //
  // When this color or the [TabBarTheme.labelColor] is specified, it overrides
  // the [TextStyle.color] specified for the [labelStyle] or the
  // [TabBarTheme.labelStyle].
  //
  // See also:
  //
  //   * [unselectedLabelColor], for color of unselected tab labels.
  DartColorType label_color = 15;
  // The text style of the selected tab labels.
  //
  // The color specified in [labelStyle] and [TabBarTheme.labelStyle] is used
  // to style the label when [labelColor] or [TabBarTheme.labelColor] are not
  // specified.
  //
  // If [unselectedLabelStyle] is null, then this text style will be used for
  // both selected and unselected label styles.
  //
  // If this property is null, then [TabBarTheme.labelStyle] will be used.
  //
  // If that is also null and [ThemeData.useMaterial3] is true, [TextTheme.titleSmall]
  // will be used, otherwise the text style of the [ThemeData.primaryTextTheme]'s
  // [TextTheme.bodyLarge] definition is used.
  FlutterTextStyleType label_style = 16;
  // The padding added to each of the tab labels.
  //
  // If there are few tabs with both icon and text and few
  // tabs with only icon or text, this padding is vertically
  // adjusted to provide uniform padding to all tabs.
  //
  // If this property is null, then [kTabLabelPadding] is used.
  FlutterEdgeInsetsGeometryType label_padding = 17;
  // The color of unselected tab labels.
  //
  // If [labelColor] (or, if null, [TabBarTheme.labelColor]) is a
  // [MaterialStateColor], then the unselected tabs are rendered with
  // that [MaterialStateColor]'s resolved color for unselected state, even if
  // [unselectedLabelColor] is non-null.
  //
  // If null, then [TabBarTheme.unselectedLabelColor] is used. If that is also
  // null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurfaceVariant]
  // will be used, otherwise unselected tab labels are rendered with
  // [labelColor] at 70% opacity.
  //
  // When this color or the [TabBarTheme.unselectedLabelColor] is specified, it
  // overrides the [TextStyle.color] specified for the [unselectedLabelStyle]
  // or the [TabBarTheme.unselectedLabelStyle].
  //
  // See also:
  //
  //  * [labelColor], for color of selected tab labels.
  DartColorType unselected_label_color = 18;
  // The text style of the unselected tab labels.
  //
  // The color specified in [unselectedLabelStyle] and [TabBarTheme.unselectedLabelStyle]
  // is used to style the label when [unselectedLabelColor] or [TabBarTheme.unselectedLabelColor]
  // are not specified.
  //
  // If this property is null, then [TabBarTheme.unselectedLabelStyle] will be used.
  //
  // If that is also null and [ThemeData.useMaterial3] is true, [TextTheme.titleSmall]
  // will be used, otherwise then the [labelStyle] value is used. If [labelStyle] is null,
  // the text style of the [ThemeData.primaryTextTheme]'s [TextTheme.bodyLarge]
  // definition is used.
  FlutterTextStyleType unselected_label_style = 19;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 20;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a long-press
  // will produce a short vibration, when feedback is enabled.
  //
  // Defaults to true.
  bool enable_feedback = 23;
  // How the [TabBar]'s scroll view should respond to user input.
  //
  // For example, determines how the scroll view continues to animate after the
  // user stops dragging the scroll view.
  //
  // Defaults to matching platform conventions.
  FlutterScrollPhysicsType physics = 25;
  // Defines the clipping radius of splashes that extend outside the bounds of the tab.
  //
  // This can be useful to match the [BoxDecoration.borderRadius] provided as [indicator].
  //
  // ```dart
  // TabBar(
  //   indicator: BoxDecoration(
  //     borderRadius: BorderRadius.circular(40),
  //   ),
  //   splashBorderRadius: BorderRadius.circular(40),
  //   tabs: const <Widget>[
  //     // ...
  //   ],
  // )
  // ```
  //
  // If this property is null, it is interpreted as [BorderRadius.zero].
  FlutterBorderRadiusType splash_border_radius = 27;
  // Specifies the horizontal alignment of the tabs within a [TabBar].
  //
  // If [TabBar.isScrollable] is false, only [TabAlignment.fill] and
  // [TabAlignment.center] are supported. Otherwise an exception is thrown.
  //
  // If [TabBar.isScrollable] is true, only [TabAlignment.start], [TabAlignment.startOffset],
  // and [TabAlignment.center] are supported. Otherwise an exception is thrown.
  //
  // If this is null, then the value of [TabBarTheme.tabAlignment] is used.
  //
  // If [TabBarTheme.tabAlignment] is null and [ThemeData.useMaterial3] is true,
  // then [TabAlignment.startOffset] is used if [isScrollable] is true,
  // otherwise [TabAlignment.fill] is used.
  //
  // If [TabBarTheme.tabAlignment] is null and [ThemeData.useMaterial3] is false,
  // then [TabAlignment.center] is used if [isScrollable] is true,
  // otherwise [TabAlignment.fill] is used.
  MaterialTabAlignmentType.Enum tab_alignment = 28;
}

// package:flutter/src/material/tabs.dart
//
// Creates a Material Design secondary tab bar.
//
// Secondary tabs are used within a content area to further separate related
// content and establish hierarchy.
//
// {@tool dartpad}
// This sample showcases nested Material 3 [TabBar]s. It consists of a primary
// [TabBar] with nested a secondary [TabBar]. The primary [TabBar] uses a
// [DefaultTabController] while the secondary [TabBar] uses a [TabController].
//
// ** See code in examples/api/lib/material/tabs/tab_bar.2.dart **
// {@end-tool}
//
// See also:
//
//  * [TabBar], for a primary tab bar.
//  * [TabBarView], which displays page views that correspond to each tab.
//  * [TabController], which coordinates tab selection between a [TabBar] and a [TabBarView].
//  * https://m3.material.io/components/tabs/overview, the Material 3
//     tab bar specification.
message MaterialTabBarNamedSecondary {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Typically a list of two or more [Tab] widgets.
  //
  // The length of this list must match the [controller]'s [TabController.length]
  // and the length of the [TabBarView.children] list.
  repeated WidgetType tabs = 3;
  // This widget's selection and animation state.
  //
  // If [TabController] is not provided, then the value of [DefaultTabController.of]
  // will be used.
  MaterialTabControllerType controller = 4;
  // Whether this tab bar can be scrolled horizontally.
  //
  // If [isScrollable] is true, then each tab is as wide as needed for its label
  // and the entire [TabBar] is scrollable. Otherwise each tab gets an equal
  // share of the available space.
  bool is_scrollable = 5;
  // The amount of space by which to inset the tab bar.
  //
  // When [isScrollable] is false, this will yield the same result as if [TabBar] was wrapped
  // in a [Padding] widget. When [isScrollable] is true, the scrollable itself is inset,
  // allowing the padding to scroll with the tab bar, rather than enclosing it.
  FlutterEdgeInsetsGeometryType padding = 6;
  // The color of the line that appears below the selected tab.
  //
  // If this parameter is null, then the value of the Theme's indicatorColor
  // property is used.
  //
  // If [indicator] is specified or provided from [TabBarTheme],
  // this property is ignored.
  DartColorType indicator_color = 7;
  // Whether this tab bar should automatically adjust the [indicatorColor].
  //
  // The default value of this property is true.
  //
  // If [automaticIndicatorColorAdjustment] is true,
  // then the [indicatorColor] will be automatically adjusted to [Colors.white]
  // when the [indicatorColor] is same as [Material.color] of the [Material]
  // parent widget.
  bool automatic_indicator_color_adjustment = 8;
  // The thickness of the line that appears below the selected tab.
  //
  // The value of this parameter must be greater than zero.
  //
  // If [ThemeData.useMaterial3] is true and [TabBar] is used to create a
  // primary tab bar, the default value is 3.0. If the provided value is less
  // than 3.0, the default value is used.
  //
  // If [ThemeData.useMaterial3] is true and [TabBar.secondary] is used to
  // create a secondary tab bar, the default value is 2.0.
  //
  // If [ThemeData.useMaterial3] is false, the default value is 2.0.
  //
  // If [indicator] is specified or provided from [TabBarTheme],
  // this property is ignored.
  double indicator_weight = 9;
  // The padding for the indicator.
  //
  // The default value of this property is [EdgeInsets.zero].
  //
  // For [isScrollable] tab bars, specifying [kTabLabelPadding] will align
  // the indicator with the tab's text for [Tab] widgets and all but the
  // shortest [Tab.text] values.
  FlutterEdgeInsetsGeometryType indicator_padding = 10;
  // Defines the appearance of the selected tab indicator.
  //
  // If [indicator] is specified or provided from [TabBarTheme],
  // the [indicatorColor] and [indicatorWeight] properties are ignored.
  //
  // The default, underline-style, selected tab indicator can be defined with
  // [UnderlineTabIndicator].
  //
  // The indicator's size is based on the tab's bounds. If [indicatorSize]
  // is [TabBarIndicatorSize.tab] the tab's bounds are as wide as the space
  // occupied by the tab in the tab bar. If [indicatorSize] is
  // [TabBarIndicatorSize.label], then the tab's bounds are only as wide as
  // the tab widget itself.
  //
  // See also:
  //
  //  * [splashBorderRadius], which defines the clipping radius of the splash
  //    and is generally used with [BoxDecoration.borderRadius].
  FlutterDecorationType indicator = 11;
  // Defines how the selected tab indicator's size is computed.
  //
  // The size of the selected tab indicator is defined relative to the
  // tab's overall bounds if [indicatorSize] is [TabBarIndicatorSize.tab]
  // (the default) or relative to the bounds of the tab's widget if
  // [indicatorSize] is [TabBarIndicatorSize.label].
  //
  // The selected tab's location appearance can be refined further with
  // the [indicatorColor], [indicatorWeight], [indicatorPadding], and
  // [indicator] properties.
  MaterialTabBarIndicatorSizeType.Enum indicator_size = 12;
  // The color of the divider.
  //
  // If null and [ThemeData.useMaterial3] is true, [TabBarTheme.dividerColor]
  // color is used. If that is null and [ThemeData.useMaterial3] is true,
  // [ColorScheme.surfaceVariant] will be used, otherwise divider will not be drawn.
  DartColorType divider_color = 13;
  // The height of the divider.
  //
  // If null and [ThemeData.useMaterial3] is true, [TabBarTheme.dividerHeight] is used.
  // If that is also null and [ThemeData.useMaterial3] is true, 1.0 will be used.
  // Otherwise divider will not be drawn.
  double divider_height = 14;
  // The color of selected tab labels.
  //
  // If null, then [TabBarTheme.labelColor] is used. If that is also null and
  // [ThemeData.useMaterial3] is true, [ColorScheme.primary] will be used,
  // otherwise the color of the [ThemeData.primaryTextTheme]'s
  // [TextTheme.bodyLarge] text color is used.
  //
  // If [labelColor] (or, if null, [TabBarTheme.labelColor]) is a
  // [MaterialStateColor], then the effective tab color will depend on the
  // [MaterialState.selected] state, i.e. if the [Tab] is selected or not,
  // ignoring [unselectedLabelColor] even if it's non-null.
  //
  // When this color or the [TabBarTheme.labelColor] is specified, it overrides
  // the [TextStyle.color] specified for the [labelStyle] or the
  // [TabBarTheme.labelStyle].
  //
  // See also:
  //
  //   * [unselectedLabelColor], for color of unselected tab labels.
  DartColorType label_color = 15;
  // The text style of the selected tab labels.
  //
  // The color specified in [labelStyle] and [TabBarTheme.labelStyle] is used
  // to style the label when [labelColor] or [TabBarTheme.labelColor] are not
  // specified.
  //
  // If [unselectedLabelStyle] is null, then this text style will be used for
  // both selected and unselected label styles.
  //
  // If this property is null, then [TabBarTheme.labelStyle] will be used.
  //
  // If that is also null and [ThemeData.useMaterial3] is true, [TextTheme.titleSmall]
  // will be used, otherwise the text style of the [ThemeData.primaryTextTheme]'s
  // [TextTheme.bodyLarge] definition is used.
  FlutterTextStyleType label_style = 16;
  // The padding added to each of the tab labels.
  //
  // If there are few tabs with both icon and text and few
  // tabs with only icon or text, this padding is vertically
  // adjusted to provide uniform padding to all tabs.
  //
  // If this property is null, then [kTabLabelPadding] is used.
  FlutterEdgeInsetsGeometryType label_padding = 17;
  // The color of unselected tab labels.
  //
  // If [labelColor] (or, if null, [TabBarTheme.labelColor]) is a
  // [MaterialStateColor], then the unselected tabs are rendered with
  // that [MaterialStateColor]'s resolved color for unselected state, even if
  // [unselectedLabelColor] is non-null.
  //
  // If null, then [TabBarTheme.unselectedLabelColor] is used. If that is also
  // null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurfaceVariant]
  // will be used, otherwise unselected tab labels are rendered with
  // [labelColor] at 70% opacity.
  //
  // When this color or the [TabBarTheme.unselectedLabelColor] is specified, it
  // overrides the [TextStyle.color] specified for the [unselectedLabelStyle]
  // or the [TabBarTheme.unselectedLabelStyle].
  //
  // See also:
  //
  //  * [labelColor], for color of selected tab labels.
  DartColorType unselected_label_color = 18;
  // The text style of the unselected tab labels.
  //
  // The color specified in [unselectedLabelStyle] and [TabBarTheme.unselectedLabelStyle]
  // is used to style the label when [unselectedLabelColor] or [TabBarTheme.unselectedLabelColor]
  // are not specified.
  //
  // If this property is null, then [TabBarTheme.unselectedLabelStyle] will be used.
  //
  // If that is also null and [ThemeData.useMaterial3] is true, [TextTheme.titleSmall]
  // will be used, otherwise then the [labelStyle] value is used. If [labelStyle] is null,
  // the text style of the [ThemeData.primaryTextTheme]'s [TextTheme.bodyLarge]
  // definition is used.
  FlutterTextStyleType unselected_label_style = 19;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 20;
  // Whether detected gestures should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a long-press
  // will produce a short vibration, when feedback is enabled.
  //
  // Defaults to true.
  bool enable_feedback = 23;
  // How the [TabBar]'s scroll view should respond to user input.
  //
  // For example, determines how the scroll view continues to animate after the
  // user stops dragging the scroll view.
  //
  // Defaults to matching platform conventions.
  FlutterScrollPhysicsType physics = 25;
  // Defines the clipping radius of splashes that extend outside the bounds of the tab.
  //
  // This can be useful to match the [BoxDecoration.borderRadius] provided as [indicator].
  //
  // ```dart
  // TabBar(
  //   indicator: BoxDecoration(
  //     borderRadius: BorderRadius.circular(40),
  //   ),
  //   splashBorderRadius: BorderRadius.circular(40),
  //   tabs: const <Widget>[
  //     // ...
  //   ],
  // )
  // ```
  //
  // If this property is null, it is interpreted as [BorderRadius.zero].
  FlutterBorderRadiusType splash_border_radius = 27;
  // Specifies the horizontal alignment of the tabs within a [TabBar].
  //
  // If [TabBar.isScrollable] is false, only [TabAlignment.fill] and
  // [TabAlignment.center] are supported. Otherwise an exception is thrown.
  //
  // If [TabBar.isScrollable] is true, only [TabAlignment.start], [TabAlignment.startOffset],
  // and [TabAlignment.center] are supported. Otherwise an exception is thrown.
  //
  // If this is null, then the value of [TabBarTheme.tabAlignment] is used.
  //
  // If [TabBarTheme.tabAlignment] is null and [ThemeData.useMaterial3] is true,
  // then [TabAlignment.startOffset] is used if [isScrollable] is true,
  // otherwise [TabAlignment.fill] is used.
  //
  // If [TabBarTheme.tabAlignment] is null and [ThemeData.useMaterial3] is false,
  // then [TabAlignment.center] is used if [isScrollable] is true,
  // otherwise [TabAlignment.fill] is used.
  MaterialTabAlignmentType.Enum tab_alignment = 28;
}

// package:flutter/src/material/tab_bar_theme.dart
//
// Creates a tab bar theme that can be used with [ThemeData.tabBarTheme].
message MaterialTabBarTheme {
  // Overrides the default value for [TabBar.indicator].
  FlutterDecorationType indicator = 2;
  // Overrides the default value for [TabBar.indicatorColor].
  DartColorType indicator_color = 3;
  // Overrides the default value for [TabBar.indicatorSize].
  MaterialTabBarIndicatorSizeType.Enum indicator_size = 4;
  // Overrides the default value for [TabBar.dividerColor].
  DartColorType divider_color = 5;
  // Overrides the default value for [TabBar.dividerHeight].
  double divider_height = 6;
  // Overrides the default value for [TabBar.labelColor].
  //
  // If [labelColor] is a [MaterialStateColor], then the effective color will
  // depend on the [MaterialState.selected] state, i.e. if the [Tab] is
  // selected or not. In case of unselected state, this [MaterialStateColor]'s
  // resolved color will be used even if [TabBar.unselectedLabelColor] or
  // [unselectedLabelColor] is non-null.
  DartColorType label_color = 7;
  // Overrides the default value for [TabBar.labelPadding].
  //
  // If there are few tabs with both icon and text and few
  // tabs with only icon or text, this padding is vertically
  // adjusted to provide uniform padding to all tabs.
  FlutterEdgeInsetsGeometryType label_padding = 8;
  // Overrides the default value for [TabBar.labelStyle].
  FlutterTextStyleType label_style = 9;
  // Overrides the default value for [TabBar.unselectedLabelColor].
  DartColorType unselected_label_color = 10;
  // Overrides the default value for [TabBar.unselectedLabelStyle].
  FlutterTextStyleType unselected_label_style = 11;
  // Overrides the default value for [TabBar.tabAlignment].
  MaterialTabAlignmentType.Enum tab_alignment = 15;
}

// package:flutter/src/material/tabs.dart
//
// Creates a page view with one child per tab.
//
// The length of [children] must be the same as the [controller]'s length.
message MaterialTabBarView {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // One widget per tab.
  //
  // Its length must match the length of the [TabBar.tabs]
  // list, as well as the [controller]'s [TabController.length].
  repeated WidgetType children = 3;
  // This widget's selection and animation state.
  //
  // If [TabController] is not provided, then the value of [DefaultTabController.of]
  // will be used.
  MaterialTabControllerType controller = 4;
  // How the page view should respond to user input.
  //
  // For example, determines how the page view continues to animate after the
  // user stops dragging the page view.
  //
  // The physics are modified to snap to page boundaries using
  // [PageScrollPhysics] prior to being used.
  //
  // Defaults to matching platform conventions.
  FlutterScrollPhysicsType physics = 5;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 6;
  // {@macro flutter.widgets.pageview.viewportFraction}
  double viewport_fraction = 7;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 8;
}

// package:flutter/src/material/tab_controller.dart
//
// Creates an object that manages the state required by [TabBar] and a
// [TabBarView].
//
// The [length] must not be negative. Typically it's a value greater than
// one, i.e. typically there are two or more tabs. The [length] must match
// [TabBar.tabs]'s and [TabBarView.children]'s length.
//
// The `initialIndex` must be valid given [length]. If [length] is zero, then
// `initialIndex` must be 0 (the default).
message MaterialTabController {
  int32 initial_index = 2;
  DartDurationType animation_duration = 3;
  // The total number of tabs.
  //
  // Typically greater than one. Must match [TabBar.tabs]'s and
  // [TabBarView.children]'s length.
  int32 length = 4;
  FlutterSrcSchedulerTickerProviderType vsync = 5;
}

// package:flutter/src/material/tabs.dart
//
// Creates a compact widget that indicates which tab has been selected.
message MaterialTabPageSelector {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // This widget's selection and animation state.
  //
  // If [TabController] is not provided, then the value of
  // [DefaultTabController.of] will be used.
  MaterialTabControllerType controller = 3;
  // The indicator circle's diameter (the default value is 12.0).
  double indicator_size = 4;
  // The indicator circle's fill color for unselected pages.
  //
  // If this parameter is null, then the indicator is filled with [Colors.transparent].
  DartColorType color = 5;
  // The indicator circle's fill color for selected pages and border color
  // for all indicator circles.
  //
  // If this parameter is null, then the indicator is filled with the theme's
  // [ColorScheme.secondary].
  DartColorType selected_color = 6;
  // The indicator circle's border style.
  //
  // Defaults to [BorderStyle.solid] if value is not specified.
  FlutterBorderStyleType.Enum border_style = 7;
}

// package:flutter/src/material/tabs.dart
//
// Creates an indicator used by [TabPageSelector].
message MaterialTabPageSelectorIndicator {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The indicator circle's background color.
  DartColorType background_color = 3;
  // The indicator circle's border color.
  DartColorType border_color = 4;
  // The indicator circle's diameter.
  double size = 5;
  // The indicator circle's border style.
  //
  // Defaults to [BorderStyle.solid] if value is not specified.
  FlutterBorderStyleType.Enum border_style = 6;
}

// package:flutter/src/material/data_table.dart
//
// Creates an ink well for a table row.
message MaterialTableRowInkWell {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 3;
}

// package:flutter/src/material/text_button.dart
//
// Create a [TextButton].
message MaterialTextButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Customizes this button's appearance.
  //
  // Non-null properties of this style override the corresponding
  // properties in [themeStyleOf] and [defaultStyleOf]. [MaterialStateProperty]s
  // that resolve to non-null values will similarly override the corresponding
  // [MaterialStateProperty]s in [themeStyleOf] and [defaultStyleOf].
  //
  // Null by default.
  MaterialButtonStyleType style = 7;
  // {@macro flutter.widgets.Focus.focusNode}
  FlutterFocusNodeType focus_node = 8;
  // {@macro flutter.widgets.Focus.autofocus}
  bool autofocus = 9;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.none].
  DartClipType.Enum clip_behavior = 10;
  // {@macro flutter.material.inkwell.statesController}
  MaterialMaterialStatesControllerType states_controller = 11;
  // Determine whether this subtree represents a button.
  //
  // If this is null, the screen reader will not announce "button" when this
  // is focused. This is useful for [MenuItemButton] and [SubmenuButton] when we
  // traverse the menu system.
  //
  // Defaults to true.
  bool is_semantic_button = 12;
  // Typically the button's label.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 13;
}

// package:flutter/src/material/text_button.dart
//
// Create a text button from a pair of widgets that serve as the button's
// [icon] and [label].
//
// The icon and label are arranged in a row and padded by 8 logical pixels
// at the ends, with an 8 pixel gap in between.
message MaterialTextButtonNamedIcon {
  FlutterKeyType key = 2;
  MaterialButtonStyleType style = 7;
  FlutterFocusNodeType focus_node = 8;
  bool autofocus = 9;
  DartClipType.Enum clip_behavior = 10;
  MaterialMaterialStatesControllerType states_controller = 11;
  WidgetType icon = 12;
  WidgetType label = 13;
}

// package:flutter/src/material/text_button_theme.dart
//
// Create a [TextButtonTheme].
message MaterialTextButtonTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The configuration of this theme.
  MaterialTextButtonThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/text_button_theme.dart
//
// Creates a [TextButtonThemeData].
//
// The [style] may be null.
message MaterialTextButtonThemeData {
  // Overrides for [TextButton]'s default style.
  //
  // Non-null properties or non-null resolved [MaterialStateProperty]
  // values override the [ButtonStyle] returned by
  // [TextButton.defaultStyleOf].
  //
  // If [style] is null, then this theme doesn't override anything.
  MaterialButtonStyleType style = 2;
}

// package:flutter/src/material/text_field.dart
//
// Creates a Material Design text field.
//
// If [decoration] is non-null (which is the default), the text field requires
// one of its ancestors to be a [Material] widget.
//
// To remove the decoration entirely (including the extra padding introduced
// by the decoration to save space for the labels), set the [decoration] to
// null.
//
// The [maxLines] property can be set to null to remove the restriction on
// the number of lines. By default, it is one, meaning this is a single-line
// text field. [maxLines] must not be zero.
//
// The [maxLength] property is set to null by default, which means the
// number of characters allowed in the text field is not restricted. If
// [maxLength] is set a character counter will be displayed below the
// field showing how many characters have been entered. If the value is
// set to a positive integer it will also display the maximum allowed
// number of characters to be entered. If the value is set to
// [TextField.noMaxLength] then only the current length is displayed.
//
// After [maxLength] characters have been input, additional input
// is ignored, unless [maxLengthEnforcement] is set to
// [MaxLengthEnforcement.none].
// The text field enforces the length with a [LengthLimitingTextInputFormatter],
// which is evaluated after the supplied [inputFormatters], if any.
// The [maxLength] value must be either null or greater than zero.
//
// If [maxLengthEnforcement] is set to [MaxLengthEnforcement.none], then more
// than [maxLength] characters may be entered, and the error counter and
// divider will switch to the [decoration].errorStyle when the limit is
// exceeded.
//
// The text cursor is not shown if [showCursor] is false or if [showCursor]
// is null (the default) and [readOnly] is true.
//
// The [selectionHeightStyle] and [selectionWidthStyle] properties allow
// changing the shape of the selection highlighting. These properties default
// to [ui.BoxHeightStyle.tight] and [ui.BoxWidthStyle.tight], respectively.
//
// See also:
//
//  * [maxLength], which discusses the precise meaning of "number of
//    characters" and how it may differ from the intuitive meaning.
message MaterialTextField {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Controls the text being edited.
  //
  // If null, this widget will create its own [TextEditingController].
  FlutterTextEditingControllerType controller = 3;
  // Defines the keyboard focus for this widget.
  //
  // The [focusNode] is a long-lived object that's typically managed by a
  // [StatefulWidget] parent. See [FocusNode] for more information.
  //
  // To give the keyboard focus to this widget, provide a [focusNode] and then
  // use the current [FocusScope] to request the focus:
  //
  // ```dart
  // FocusScope.of(context).requestFocus(myFocusNode);
  // ```
  //
  // This happens automatically when the widget is tapped.
  //
  // To be notified when the widget gains or loses the focus, add a listener
  // to the [focusNode]:
  //
  // ```dart
  // myFocusNode.addListener(() { print(myFocusNode.hasFocus); });
  // ```
  //
  // If null, this widget will create its own [FocusNode].
  //
  // ## Keyboard
  //
  // Requesting the focus will typically cause the keyboard to be shown
  // if it's not showing already.
  //
  // On Android, the user can hide the keyboard - without changing the focus -
  // with the system back button. They can restore the keyboard's visibility
  // by tapping on a text field. The user might hide the keyboard and
  // switch to a physical keyboard, or they might just need to get it
  // out of the way for a moment, to expose something it's
  // obscuring. In this case requesting the focus again will not
  // cause the focus to change, and will not make the keyboard visible.
  //
  // This widget builds an [EditableText] and will ensure that the keyboard is
  // showing when it is tapped by calling [EditableTextState.requestKeyboard()].
  FlutterFocusNodeType focus_node = 4;
  // {@macro flutter.widgets.undoHistory.controller}
  FlutterUndoHistoryControllerType undo_controller = 5;
  // The decoration to show around the text field.
  //
  // By default, draws a horizontal line under the text field but can be
  // configured to show an icon, label, hint text, and error text.
  //
  // Specify null to remove the decoration entirely (including the
  // extra padding introduced by the decoration to save space for the labels).
  MaterialInputDecorationType decoration = 6;
  FlutterTextInputTypeType keyboard_type = 7;
  // {@template flutter.widgets.TextField.textInputAction}
  // The type of action button to use for the keyboard.
  //
  // Defaults to [TextInputAction.newline] if [keyboardType] is
  // [TextInputType.multiline] and [TextInputAction.done] otherwise.
  // {@endtemplate}
  FlutterTextInputActionType.Enum text_input_action = 8;
  // {@macro flutter.widgets.editableText.textCapitalization}
  FlutterTextCapitalizationType.Enum text_capitalization = 9;
  // The style to use for the text being edited.
  //
  // This text style is also used as the base style for the [decoration].
  //
  // If null, [TextTheme.bodyLarge] will be used. When the text field is disabled,
  // [TextTheme.bodyLarge] with an opacity of 0.38 will be used instead.
  //
  // If null and [ThemeData.useMaterial3] is false, [TextTheme.titleMedium] will
  // be used. When the text field is disabled, [TextTheme.titleMedium] with
  // [ThemeData.disabledColor] will be used instead.
  FlutterTextStyleType style = 10;
  // {@macro flutter.widgets.editableText.strutStyle}
  FlutterStrutStyleType strut_style = 11;
  // {@macro flutter.widgets.editableText.textAlign}
  DartTextAlignType.Enum text_align = 12;
  // {@macro flutter.material.InputDecorator.textAlignVertical}
  FlutterTextAlignVerticalType text_align_vertical = 13;
  // {@macro flutter.widgets.editableText.textDirection}
  DartTextDirectionType.Enum text_direction = 14;
  // {@macro flutter.widgets.editableText.readOnly}
  bool read_only = 15;
  // {@macro flutter.widgets.editableText.showCursor}
  bool show_cursor = 16;
  // {@macro flutter.widgets.editableText.autofocus}
  bool autofocus = 17;
  // Represents the interactive "state" of this widget in terms of a set of
  // [MaterialState]s, including [MaterialState.disabled], [MaterialState.hovered],
  // [MaterialState.error], and [MaterialState.focused].
  //
  // Classes based on this one can provide their own
  // [MaterialStatesController] to which they've added listeners.
  // They can also update the controller's [MaterialStatesController.value]
  // however, this may only be done when it's safe to call
  // [State.setState], like in an event handler.
  //
  // The controller's [MaterialStatesController.value] represents the set of
  // states that a widget's visual properties, typically [MaterialStateProperty]
  // values, are resolved against. It is _not_ the intrinsic state of the widget.
  // The widget is responsible for ensuring that the controller's
  // [MaterialStatesController.value] tracks its intrinsic state. For example
  // one cannot request the keyboard focus for a widget by adding [MaterialState.focused]
  // to its controller. When the widget gains the or loses the focus it will
  // [MaterialStatesController.update] its controller's [MaterialStatesController.value]
  // and notify listeners of the change.
  MaterialMaterialStatesControllerType states_controller = 18;
  // {@macro flutter.widgets.editableText.obscuringCharacter}
  string obscuring_character = 19;
  // {@macro flutter.widgets.editableText.obscureText}
  bool obscure_text = 20;
  // {@macro flutter.widgets.editableText.autocorrect}
  bool autocorrect = 21;
  FlutterSmartDashesTypeType.Enum smart_dashes_type = 22;
  FlutterSmartQuotesTypeType.Enum smart_quotes_type = 23;
  // {@macro flutter.services.TextInputConfiguration.enableSuggestions}
  bool enable_suggestions = 24;
  // {@macro flutter.widgets.editableText.maxLines}
  //  * [expands], which determines whether the field should fill the height of
  //    its parent.
  int32 max_lines = 25;
  // {@macro flutter.widgets.editableText.minLines}
  //  * [expands], which determines whether the field should fill the height of
  //    its parent.
  int32 min_lines = 26;
  // {@macro flutter.widgets.editableText.expands}
  bool expands = 27;
  // The maximum number of characters (Unicode grapheme clusters) to allow in
  // the text field.
  //
  // If set, a character counter will be displayed below the
  // field showing how many characters have been entered. If set to a number
  // greater than 0, it will also display the maximum number allowed. If set
  // to [TextField.noMaxLength] then only the current character count is displayed.
  //
  // After [maxLength] characters have been input, additional input
  // is ignored, unless [maxLengthEnforcement] is set to
  // [MaxLengthEnforcement.none].
  //
  // The text field enforces the length with a [LengthLimitingTextInputFormatter],
  // which is evaluated after the supplied [inputFormatters], if any.
  //
  // This value must be either null, [TextField.noMaxLength], or greater than 0.
  // If null (the default) then there is no limit to the number of characters
  // that can be entered. If set to [TextField.noMaxLength], then no limit will
  // be enforced, but the number of characters entered will still be displayed.
  //
  // Whitespace characters (e.g. newline, space, tab) are included in the
  // character count.
  //
  // If [maxLengthEnforcement] is [MaxLengthEnforcement.none], then more than
  // [maxLength] characters may be entered, but the error counter and divider
  // will switch to the [decoration]'s [InputDecoration.errorStyle] when the
  // limit is exceeded.
  //
  // {@macro flutter.services.lengthLimitingTextInputFormatter.maxLength}
  int32 max_length = 28;
  // Determines how the [maxLength] limit should be enforced.
  //
  // {@macro flutter.services.textFormatter.effectiveMaxLengthEnforcement}
  //
  // {@macro flutter.services.textFormatter.maxLengthEnforcement}
  FlutterMaxLengthEnforcementType.Enum max_length_enforcement = 29;
  // {@macro flutter.widgets.editableText.inputFormatters}
  repeated FlutterTextInputFormatterType input_formatters = 34;
  // If false the text field is "disabled": it ignores taps and its
  // [decoration] is rendered in grey.
  //
  // If non-null this property overrides the [decoration]'s
  // [InputDecoration.enabled] property.
  bool enabled = 35;
  // {@macro flutter.widgets.editableText.cursorWidth}
  double cursor_width = 36;
  // {@macro flutter.widgets.editableText.cursorHeight}
  double cursor_height = 37;
  // {@macro flutter.widgets.editableText.cursorRadius}
  DartRadiusType cursor_radius = 38;
  // {@macro flutter.widgets.editableText.cursorOpacityAnimates}
  bool cursor_opacity_animates = 39;
  // The color of the cursor.
  //
  // The cursor indicates the current location of text insertion point in
  // the field.
  //
  // If this is null it will default to the ambient
  // [DefaultSelectionStyle.cursorColor]. If that is null, and the
  // [ThemeData.platform] is [TargetPlatform.iOS] or [TargetPlatform.macOS]
  // it will use [CupertinoThemeData.primaryColor]. Otherwise it will use
  // the value of [ColorScheme.primary] of [ThemeData.colorScheme].
  DartColorType cursor_color = 40;
  // The color of the cursor when the [InputDecorator] is showing an error.
  //
  // If this is null it will default to [TextStyle.color] of
  // [InputDecoration.errorStyle]. If that is null, it will use
  // [ColorScheme.error] of [ThemeData.colorScheme].
  DartColorType cursor_error_color = 41;
  // Controls how tall the selection highlight boxes are computed to be.
  //
  // See [ui.BoxHeightStyle] for details on available styles.
  DartBoxHeightStyleType.Enum selection_height_style = 42;
  // Controls how wide the selection highlight boxes are computed to be.
  //
  // See [ui.BoxWidthStyle] for details on available styles.
  DartBoxWidthStyleType.Enum selection_width_style = 43;
  // The appearance of the keyboard.
  //
  // This setting is only honored on iOS devices.
  //
  // If unset, defaults to [ThemeData.brightness].
  DartBrightnessType.Enum keyboard_appearance = 44;
  // {@macro flutter.widgets.editableText.scrollPadding}
  FlutterEdgeInsetsType scroll_padding = 45;
  // {@macro flutter.widgets.scrollable.dragStartBehavior}
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 46;
  bool enable_interactive_selection = 47;
  // {@macro flutter.widgets.editableText.selectionControls}
  FlutterTextSelectionControlsType selection_controls = 48;
  // Whether [onTap] should be called for every tap.
  //
  // Defaults to false, so [onTap] is only called for each distinct tap. When
  // enabled, [onTap] is called for every tap including consecutive taps.
  bool on_tap_always_called = 50;
  // {@macro flutter.widgets.editableText.scrollController}
  FlutterScrollControllerType scroll_controller = 54;
  // {@macro flutter.widgets.editableText.scrollPhysics}
  FlutterScrollPhysicsType scroll_physics = 55;
  // {@macro flutter.widgets.editableText.autofillHints}
  // {@macro flutter.services.AutofillConfiguration.autofillHints}
  repeated string autofill_hints = 56;
  // {@macro flutter.material.Material.clipBehavior}
  //
  // Defaults to [Clip.hardEdge].
  DartClipType.Enum clip_behavior = 58;
  // {@template flutter.material.textfield.restorationId}
  // Restoration ID to save and restore the state of the text field.
  //
  // If non-null, the text field will persist and restore its current scroll
  // offset and - if no [controller] has been provided - the content of the
  // text field. If a [controller] has been provided, it is the responsibility
  // of the owner of that controller to persist and restore it, e.g. by using
  // a [RestorableTextEditingController].
  //
  // The state of this widget is persisted in a [RestorationBucket] claimed
  // from the surrounding [RestorationScope] using the provided restoration ID.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  // {@endtemplate}
  string restoration_id = 59;
  // {@macro flutter.widgets.editableText.scribbleEnabled}
  bool scribble_enabled = 60;
  // {@macro flutter.services.TextInputConfiguration.enableIMEPersonalizedLearning}
  bool enable_i_m_e_personalized_learning = 61;
  // Determine whether this text field can request the primary focus.
  //
  // Defaults to true. If false, the text field will not request focus
  // when tapped, or when its context menu is displayed. If false it will not
  // be possible to move the focus to the text field with tab key.
  bool can_request_focus = 63;
  // {@macro flutter.widgets.EditableText.spellCheckConfiguration}
  //
  // If [SpellCheckConfiguration.misspelledTextStyle] is not specified in this
  // configuration, then [materialMisspelledTextStyle] is used by default.
  FlutterSpellCheckConfigurationType spell_check_configuration = 64;
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
  //
  // {@macro flutter.widgets.magnifier.intro}
  //
  // {@macro flutter.widgets.magnifier.TextMagnifierConfiguration.details}
  //
  // By default, builds a [CupertinoTextMagnifier] on iOS and [TextMagnifier]
  // on Android, and builds nothing on all other platforms. If it is desired to
  // suppress the magnifier, consider passing [TextMagnifierConfiguration.disabled].
  //
  // {@tool dartpad}
  // This sample demonstrates how to customize the magnifier that this text field uses.
  //
  // ** See code in examples/api/lib/widgets/text_magnifier/text_magnifier.0.dart **
  // {@end-tool}
  FlutterTextMagnifierConfigurationType magnifier_configuration = 65;
}

// package:flutter/src/material/text_form_field.dart
//
// Creates a [FormField] that contains a [TextField].
//
// When a [controller] is specified, [initialValue] must be null (the
// default). If [controller] is null, then a [TextEditingController]
// will be constructed automatically and its `text` will be initialized
// to [initialValue] or the empty string.
//
// For documentation about the various parameters, see the [TextField] class
// and [TextField.new], the constructor.
message MaterialTextFormField {
  FlutterKeyType key = 2;
  // Controls the text being edited.
  //
  // If null, this widget will create its own [TextEditingController] and
  // initialize its [TextEditingController.text] with [initialValue].
  FlutterTextEditingControllerType controller = 3;
  string initial_value = 4;
  FlutterFocusNodeType focus_node = 5;
  MaterialInputDecorationType decoration = 6;
  FlutterTextInputTypeType keyboard_type = 7;
  FlutterTextCapitalizationType.Enum text_capitalization = 8;
  FlutterTextInputActionType.Enum text_input_action = 9;
  FlutterTextStyleType style = 10;
  FlutterStrutStyleType strut_style = 11;
  DartTextDirectionType.Enum text_direction = 12;
  DartTextAlignType.Enum text_align = 13;
  FlutterTextAlignVerticalType text_align_vertical = 14;
  bool autofocus = 15;
  bool read_only = 16;
  bool show_cursor = 17;
  string obscuring_character = 18;
  bool obscure_text = 19;
  bool autocorrect = 20;
  FlutterSmartDashesTypeType.Enum smart_dashes_type = 21;
  FlutterSmartQuotesTypeType.Enum smart_quotes_type = 22;
  bool enable_suggestions = 23;
  FlutterMaxLengthEnforcementType.Enum max_length_enforcement = 24;
  int32 max_lines = 25;
  int32 min_lines = 26;
  bool expands = 27;
  int32 max_length = 28;
  bool on_tap_always_called = 31;
  repeated FlutterTextInputFormatterType input_formatters = 37;
  bool enabled = 38;
  double cursor_width = 39;
  double cursor_height = 40;
  DartRadiusType cursor_radius = 41;
  DartColorType cursor_color = 42;
  DartColorType cursor_error_color = 43;
  DartBrightnessType.Enum keyboard_appearance = 44;
  FlutterEdgeInsetsType scroll_padding = 45;
  bool enable_interactive_selection = 46;
  FlutterTextSelectionControlsType selection_controls = 47;
  FlutterScrollPhysicsType scroll_physics = 49;
  repeated string autofill_hints = 50;
  FlutterAutovalidateModeType.Enum autovalidate_mode = 51;
  FlutterScrollControllerType scroll_controller = 52;
  // Restoration ID to save and restore the state of the form field.
  //
  // Setting the restoration ID to a non-null value results in whether or not
  // the form field validation persists.
  //
  // The state of this widget is persisted in a [RestorationBucket] claimed
  // from the surrounding [RestorationScope] using the provided restoration ID.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  string restoration_id = 53;
  bool enable_i_m_e_personalized_learning = 54;
  FlutterSpellCheckConfigurationType spell_check_configuration = 57;
  FlutterTextMagnifierConfigurationType magnifier_configuration = 58;
  FlutterUndoHistoryControllerType undo_controller = 59;
  bool cursor_opacity_animates = 61;
  DartBoxHeightStyleType.Enum selection_height_style = 62;
  DartBoxWidthStyleType.Enum selection_width_style = 63;
  FlutterDragStartBehaviorType.Enum drag_start_behavior = 64;
  MaterialMaterialStatesControllerType states_controller = 66;
  DartClipType.Enum clip_behavior = 67;
  bool scribble_enabled = 68;
  bool can_request_focus = 69;
}

// package:flutter/src/material/text_selection_theme.dart
//
// Creates a text selection theme widget that specifies the text
// selection properties for all widgets below it in the widget tree.
message MaterialTextSelectionTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties for descendant [TextField] and [SelectableText] widgets.
  MaterialTextSelectionThemeDataType data = 3;
  WidgetType child = 4;
}

// package:flutter/src/material/text_selection_theme.dart
//
// Creates the set of properties used to configure [TextField]s.
message MaterialTextSelectionThemeData {
  // The color of the cursor in the text field.
  //
  // The cursor indicates the current location of text insertion point in
  // the field.
  DartColorType cursor_color = 2;
  // The background color of selected text.
  DartColorType selection_color = 3;
  // The color of the selection handles on the text field.
  //
  // Selection handles are used to indicate the bounds of the selected text,
  // or as a handle to drag the cursor to a new location in the text.
  //
  // On iOS [TextField] and [SelectableText] cannot access [selectionHandleColor].
  // To set the [selectionHandleColor] on iOS, you can change the
  // [CupertinoThemeData.primaryColor] in [ThemeData.cupertinoOverrideTheme].
  DartColorType selection_handle_color = 4;
}

// package:flutter/src/material/text_selection_toolbar.dart
//
// Creates an instance of TextSelectionToolbar.
message MaterialTextSelectionToolbar {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.material.TextSelectionToolbar.anchorAbove}
  // The focal point above which the toolbar attempts to position itself.
  //
  // If there is not enough room above before reaching the top of the screen,
  // then the toolbar will position itself below [anchorBelow].
  // {@endtemplate}
  DartOffsetType anchor_above = 3;
  // {@template flutter.material.TextSelectionToolbar.anchorBelow}
  // The focal point below which the toolbar attempts to position itself, if it
  // doesn't fit above [anchorAbove].
  // {@endtemplate}
  DartOffsetType anchor_below = 4;
  // {@template flutter.material.TextSelectionToolbar.children}
  // The children that will be displayed in the text selection toolbar.
  //
  // Typically these are buttons.
  //
  // Must not be empty.
  // {@endtemplate}
  //
  // See also:
  //   * [TextSelectionToolbarTextButton], which builds a default Material-
  //     style text selection toolbar text button.
  repeated WidgetType children = 6;
}

// package:flutter/src/material/text_selection_toolbar_text_button.dart
//
// Creates an instance of TextSelectionToolbarTextButton.
message MaterialTextSelectionToolbarTextButton {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // {@template flutter.material.TextSelectionToolbarTextButton.child}
  // The child of this button.
  //
  // Usually a [Text].
  // {@endtemplate}
  WidgetType child = 3;
  // The padding between the button's edge and its child.
  //
  // In a standard Material [TextSelectionToolbar], the padding depends on the
  // button's position within the toolbar.
  //
  // See also:
  //
  //  * [getPadding], which calculates the standard padding based on the
  //    button's position.
  //  * [ButtonStyle.padding], which is where this padding is applied.
  FlutterEdgeInsetsType padding = 4;
  // The alignment of the button's child.
  //
  // By default, this will be [Alignment.center].
  //
  // See also:
  //
  //  * [ButtonStyle.alignment], which is where this alignment is applied.
  FlutterAlignmentGeometryType alignment = 6;
}

// package:flutter/src/material/text_theme.dart
//
// Creates a text theme that uses the given values.
//
// Rather than creating a new text theme, consider using [Typography.black]
// or [Typography.white], which implement the typography styles in the
// Material Design specification:
//
// <https://material.io/design/typography/#type-scale>
//
// If you do decide to create your own text theme, consider using one of
// those predefined themes as a starting point for [copyWith] or [apply].
//
// The 2018 styles cannot be mixed with the 2021 styles. Only one or the
// other is allowed in this constructor. The 2018 styles are deprecated and
// will eventually be removed.
message MaterialTextTheme {
  FlutterTextStyleType display_large = 2;
  FlutterTextStyleType display_medium = 3;
  FlutterTextStyleType display_small = 4;
  // Largest of the headline styles.
  //
  // Headline styles are smaller than display styles. They're best-suited for
  // short, high-emphasis text on smaller screens.
  FlutterTextStyleType headline_large = 5;
  FlutterTextStyleType headline_medium = 6;
  FlutterTextStyleType headline_small = 7;
  FlutterTextStyleType title_large = 8;
  FlutterTextStyleType title_medium = 9;
  FlutterTextStyleType title_small = 10;
  FlutterTextStyleType body_large = 11;
  FlutterTextStyleType body_medium = 12;
  FlutterTextStyleType body_small = 13;
  FlutterTextStyleType label_large = 14;
  // Middle size of the label styles.
  //
  // Label styles are smaller, utilitarian styles, used for areas of the UI
  // such as text inside of components or very small supporting text in the
  // content body, like captions.
  FlutterTextStyleType label_medium = 15;
  FlutterTextStyleType label_small = 16;
}

// package:flutter/src/material/theme.dart
//
// Applies the given theme [data] to [child].
message MaterialTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the color and typography values for descendant widgets.
  MaterialThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/material/theme_data.dart
//
// Create a [ThemeData] that's used to configure a [Theme].
//
// The [colorScheme] and [textTheme] are used by the Material components to
// compute default values for visual properties. The API documentation for
// each component widget explains exactly how the defaults are computed.
//
// When providing a [ColorScheme], apps can either provide one directly
// with the [colorScheme] parameter, or have one generated for them by
// using the [colorSchemeSeed] and [brightness] parameters. A generated
// color scheme will be based on the tones of [colorSchemeSeed] and all of
// its contrasting color will meet accessibility guidelines for readability.
// (See [ColorScheme.fromSeed] for more details.)
//
// If the app wants to customize a generated color scheme, it can use
// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
// result to override any colors that need to be replaced. The result of
// this can be used as the [colorScheme] directly.
//
// For historical reasons, instead of using a [colorSchemeSeed] or
// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
// to construct the [colorScheme], but the results will not be as complete
// as when using generation from a seed color.
//
// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
// [primarySwatch] must all be null.
//
// The [textTheme] [TextStyle] colors are black if the color scheme's
// brightness is [Brightness.light], and white for [Brightness.dark].
//
// To override the appearance of specific components, provide
// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
// or [bottomNavigationBarTheme].
//
// See also:
//
//  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
//  * [ThemeData.light], which creates a light blue theme.
//  * [ThemeData.dark], which creates dark theme with a teal secondary [ColorScheme] color.
//  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
message MaterialThemeData {
  bool apply_elevation_overlay_color = 3;
  NoDefaultCupertinoThemeDataType cupertino_override_theme = 4;
  MaterialInputDecorationThemeType input_decoration_theme = 6;
  MaterialMaterialTapTargetSizeType.Enum material_tap_target_size = 7;
  MaterialPageTransitionsThemeType page_transitions_theme = 8;
  FlutterTargetPlatformType.Enum platform = 9;
  MaterialScrollbarThemeDataType scrollbar_theme = 10;
  bool use_material3 = 12;
  MaterialVisualDensityType visual_density = 13;
  DartBrightnessType.Enum brightness = 14;
  DartColorType canvas_color = 15;
  DartColorType card_color = 16;
  MaterialColorSchemeType color_scheme = 17;
  DartColorType color_scheme_seed = 18;
  DartColorType dialog_background_color = 19;
  DartColorType disabled_color = 20;
  DartColorType divider_color = 21;
  DartColorType focus_color = 22;
  DartColorType highlight_color = 23;
  DartColorType hint_color = 24;
  DartColorType hover_color = 25;
  DartColorType indicator_color = 26;
  DartColorType primary_color = 27;
  DartColorType primary_color_dark = 28;
  DartColorType primary_color_light = 29;
  DartColorType scaffold_background_color = 31;
  DartColorType secondary_header_color = 32;
  DartColorType shadow_color = 33;
  DartColorType splash_color = 34;
  DartColorType unselected_widget_color = 35;
  string font_family = 36;
  repeated string font_family_fallback = 37;
  string package = 38;
  FlutterIconThemeDataType icon_theme = 39;
  FlutterIconThemeDataType primary_icon_theme = 40;
  MaterialTextThemeType primary_text_theme = 41;
  MaterialTextThemeType text_theme = 42;
  MaterialTypographyType typography = 43;
  MaterialActionIconThemeDataType action_icon_theme = 44;
  MaterialAppBarThemeType app_bar_theme = 45;
  MaterialBadgeThemeDataType badge_theme = 46;
  MaterialMaterialBannerThemeDataType banner_theme = 47;
  MaterialBottomAppBarThemeType bottom_app_bar_theme = 48;
  MaterialBottomNavigationBarThemeDataType bottom_navigation_bar_theme = 49;
  MaterialBottomSheetThemeDataType bottom_sheet_theme = 50;
  MaterialButtonBarThemeDataType button_bar_theme = 51;
  MaterialButtonThemeDataType button_theme = 52;
  MaterialCardThemeType card_theme = 53;
  MaterialCheckboxThemeDataType checkbox_theme = 54;
  MaterialChipThemeDataType chip_theme = 55;
  MaterialDataTableThemeDataType data_table_theme = 56;
  MaterialDatePickerThemeDataType date_picker_theme = 57;
  MaterialDialogThemeType dialog_theme = 58;
  MaterialDividerThemeDataType divider_theme = 59;
  MaterialDrawerThemeDataType drawer_theme = 60;
  MaterialDropdownMenuThemeDataType dropdown_menu_theme = 61;
  MaterialElevatedButtonThemeDataType elevated_button_theme = 62;
  MaterialExpansionTileThemeDataType expansion_tile_theme = 63;
  MaterialFilledButtonThemeDataType filled_button_theme = 64;
  MaterialFloatingActionButtonThemeDataType floating_action_button_theme = 65;
  MaterialIconButtonThemeDataType icon_button_theme = 66;
  MaterialListTileThemeDataType list_tile_theme = 67;
  MaterialMenuBarThemeDataType menu_bar_theme = 68;
  MaterialMenuButtonThemeDataType menu_button_theme = 69;
  MaterialMenuThemeDataType menu_theme = 70;
  MaterialNavigationBarThemeDataType navigation_bar_theme = 71;
  MaterialNavigationDrawerThemeDataType navigation_drawer_theme = 72;
  MaterialNavigationRailThemeDataType navigation_rail_theme = 73;
  MaterialOutlinedButtonThemeDataType outlined_button_theme = 74;
  MaterialPopupMenuThemeDataType popup_menu_theme = 75;
  MaterialProgressIndicatorThemeDataType progress_indicator_theme = 76;
  MaterialRadioThemeDataType radio_theme = 77;
  MaterialSearchBarThemeDataType search_bar_theme = 78;
  MaterialSearchViewThemeDataType search_view_theme = 79;
  MaterialSegmentedButtonThemeDataType segmented_button_theme = 80;
  MaterialSliderThemeDataType slider_theme = 81;
  MaterialSnackBarThemeDataType snack_bar_theme = 82;
  MaterialSwitchThemeDataType switch_theme = 83;
  MaterialTabBarThemeType tab_bar_theme = 84;
  MaterialTextButtonThemeDataType text_button_theme = 85;
  MaterialTextSelectionThemeDataType text_selection_theme = 86;
  MaterialTimePickerThemeDataType time_picker_theme = 87;
  MaterialToggleButtonsThemeDataType toggle_buttons_theme = 88;
  MaterialTooltipThemeDataType tooltip_theme = 89;
}

// package:flutter/src/material/theme_data.dart
//
// A default dark theme.
//
// This theme does not contain text geometry. Instead, it is expected that
// this theme is localized using text geometry using [ThemeData.localize].
message MaterialThemeDataNamedDark {
  bool use_material3 = 2;
}

// package:flutter/src/material/theme_data.dart
//
// The default color theme. Same as [ThemeData.light].
//
// This is used by [Theme.of] when no theme has been specified.
//
// This theme does not contain text geometry. Instead, it is expected that
// this theme is localized using text geometry using [ThemeData.localize].
//
// Most applications would use [Theme.of], which provides correct localized
// text geometry.
message MaterialThemeDataNamedFallback {
  bool use_material3 = 2;
}

// package:flutter/src/material/theme_data.dart
//
// Create a [ThemeData] based on the colors in the given [colorScheme] and
// text styles of the optional [textTheme].
//
// If [colorScheme].brightness is [Brightness.dark] then
// [ThemeData.applyElevationOverlayColor] will be set to true to support
// the Material dark theme method for indicating elevation by applying
// a semi-transparent onSurface color on top of the surface color.
//
// This is the recommended method to theme your application. As we move
// forward we will be converting all the widget implementations to only use
// colors or colors derived from those in [ColorScheme].
//
// {@tool snippet}
// This example will set up an application to use the baseline Material
// Design light and dark themes.
//
// ```dart
// MaterialApp(
//   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
//   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
// )
// ```
// {@end-tool}
//
// See <https://material.io/design/color/> for
// more discussion on how to pick the right colors.
message MaterialThemeDataNamedFrom {
  MaterialColorSchemeType color_scheme = 2;
  MaterialTextThemeType text_theme = 3;
  bool use_material3 = 4;
}

// package:flutter/src/material/theme_data.dart
//
// A default light theme.
//
// This theme does not contain text geometry. Instead, it is expected that
// this theme is localized using text geometry using [ThemeData.localize].
message MaterialThemeDataNamedLight {
  bool use_material3 = 2;
}

// package:flutter/src/material/time.dart
//
// Creates a time of day.
//
// The [hour] argument must be between 0 and 23, inclusive. The [minute]
// argument must be between 0 and 59, inclusive.
message MaterialTimeOfDay {
  // The selected hour, in 24 hour time from 0..23.
  int32 hour = 2;
  // The selected minute.
  int32 minute = 3;
}

// package:flutter/src/material/time.dart
//
// Creates a time of day based on the given time.
//
// The [hour] is set to the time's hour and the [minute] is set to the time's
// minute in the timezone of the given [DateTime].
message MaterialTimeOfDayNamedFromDateTime {
  DartDateTimeType time = 2;
}

// package:flutter/src/material/time.dart
//
// Creates a time of day based on the current time.
//
// The [hour] is set to the current hour and the [minute] is set to the
// current minute in the local time zone.
message MaterialTimeOfDayNamedNow {
  
}

// package:flutter/src/material/time_picker.dart
//
// Creates a Material Design time picker.
message MaterialTimePickerDialog {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The time initially selected when the dialog is shown.
  MaterialTimeOfDayType initial_time = 3;
  // Optionally provide your own text for the cancel button.
  //
  // If null, the button uses [MaterialLocalizations.cancelButtonLabel].
  string cancel_text = 4;
  // Optionally provide your own text for the confirm button.
  //
  // If null, the button uses [MaterialLocalizations.okButtonLabel].
  string confirm_text = 5;
  // Optionally provide your own help text to the header of the time picker.
  string help_text = 6;
  // Optionally provide your own validation error text.
  string error_invalid_text = 7;
  // Optionally provide your own hour label text.
  string hour_label_text = 8;
  // Optionally provide your own minute label text.
  string minute_label_text = 9;
  // Restoration ID to save and restore the state of the [TimePickerDialog].
  //
  // If it is non-null, the time picker will persist and restore the
  // dialog's state.
  //
  // The state of this widget is persisted in a [RestorationBucket] claimed
  // from the surrounding [RestorationScope] using the provided restoration ID.
  //
  // See also:
  //
  //  * [RestorationManager], which explains how state restoration works in
  //    Flutter.
  string restoration_id = 10;
  // The entry mode for the picker. Whether it's text input or a dial.
  MaterialTimePickerEntryModeType.Enum initial_entry_mode = 11;
  // The optional [orientation] parameter sets the [Orientation] to use when
  // displaying the dialog.
  //
  // By default, the orientation is derived from the [MediaQueryData.size] of
  // the ambient [MediaQuery]. If the aspect of the size is tall, then
  // [Orientation.portrait] is used, if the size is wide, then
  // [Orientation.landscape] is used.
  //
  // Use this parameter to override the default and force the dialog to appear
  // in either portrait or landscape mode regardless of the aspect of the
  // [MediaQueryData.size].
  FlutterOrientationType.Enum orientation = 12;
}

// package:flutter/src/material/time_picker_theme.dart
//
// Creates a time picker theme that controls the configurations for
// time pickers displayed in its widget subtree.
message MaterialTimePickerTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties for descendant time picker widgets.
  MaterialTimePickerThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/time_picker_theme.dart
//
// Creates a theme that can be used for [TimePickerTheme] or
// [ThemeData.timePickerTheme].
message MaterialTimePickerThemeData {
  // The background color of a time picker.
  //
  // If this is null, the time picker defaults to the overall theme's
  // [ColorScheme.background].
  DartColorType background_color = 2;
  // The style of the cancel button of a [TimePickerDialog].
  MaterialButtonStyleType cancel_button_style = 3;
  // The style of the confirm (OK) button of a [TimePickerDialog].
  MaterialButtonStyleType confirm_button_style = 4;
  // The color and weight of the day period's outline.
  //
  // If this is null, the time picker defaults to:
  //
  // ```dart
  // BorderSide(
  //   color: Color.alphaBlend(
  //     Theme.of(context).colorScheme.onBackground.withOpacity(0.38),
  //     Theme.of(context).colorScheme.surface,
  //   ),
  // ),
  // ```
  FlutterBorderSideType day_period_border_side = 5;
  DartColorType day_period_color = 6;
  // The shape of the day period that the time picker uses.
  //
  // If this is null, the time picker defaults to:
  //
  // ```dart
  // const RoundedRectangleBorder(
  //   borderRadius: BorderRadius.all(Radius.circular(4.0)),
  //   side: BorderSide(),
  // )
  // ```
  FlutterOutlinedBorderType day_period_shape = 7;
  // The color of the day period text that represents AM/PM.
  //
  // If [dayPeriodTextColor] is a [MaterialStateColor], then the effective
  // text color can depend on the [MaterialState.selected] state, i.e. if the
  // text is selected or not.
  //
  // By default the overall theme's [ColorScheme.primary] color is used when
  // the text is selected and `ColorScheme.onSurface.withOpacity(0.60)` when
  // it's not selected.
  DartColorType day_period_text_color = 8;
  // Used to configure the [TextStyle]s for the day period control.
  //
  // If this is null, the time picker defaults to the overall theme's
  // [TextTheme.titleMedium].
  FlutterTextStyleType day_period_text_style = 9;
  // The background color of the time picker dial when the entry mode is
  // [TimePickerEntryMode.dial] or [TimePickerEntryMode.dialOnly].
  //
  // If this is null and [ThemeData.useMaterial3] is true, the time picker
  // dial background color defaults [ColorScheme.surfaceVariant] color.
  //
  // If this is null and [ThemeData.useMaterial3] is false, the time picker
  // dial background color defaults to [ColorScheme.onSurface] color with
  // an opacity of 0.08 when the overall theme's brightness is [Brightness.light]
  // and [ColorScheme.onSurface] color with an opacity of 0.12 when the overall
  // theme's brightness is [Brightness.dark].
  DartColorType dial_background_color = 10;
  // The color of the time picker dial's hand when the entry mode is
  // [TimePickerEntryMode.dial] or [TimePickerEntryMode.dialOnly].
  //
  // If this is null, the time picker defaults to the overall theme's
  // [ColorScheme.primary].
  DartColorType dial_hand_color = 11;
  // The color of the dial text that represents specific hours and minutes.
  //
  // If [dialTextColor] is a [MaterialStateColor], then the effective
  // text color can depend on the [MaterialState.selected] state, i.e. if the
  // text is selected or not.
  //
  // If this color is null then the dial's text colors are based on the
  // theme's [ThemeData.colorScheme].
  DartColorType dial_text_color = 12;
  // The [TextStyle] for the numbers on the time selection dial.
  //
  // If [dialTextStyle]'s [TextStyle.color] is a [MaterialStateColor], then the
  // effective text color can depend on the [MaterialState.selected] state,
  // i.e. if the text is selected or not.
  //
  // If this style is null then the dial's text style is based on the theme's
  // [ThemeData.textTheme].
  FlutterTextStyleType dial_text_style = 13;
  // The Material elevation for the time picker dialog.
  double elevation = 14;
  // The color of the entry mode [IconButton].
  //
  // If this is null, the time picker defaults to:
  //
  //
  // ```dart
  // Theme.of(context).colorScheme.onSurface.withOpacity(
  //   Theme.of(context).colorScheme.brightness == Brightness.dark ? 1.0 : 0.6,
  // )
  // ```
  DartColorType entry_mode_icon_color = 15;
  // Used to configure the [TextStyle]s for the helper text in the header.
  //
  // If this is null, the time picker defaults to the overall theme's
  // [TextTheme.labelSmall].
  FlutterTextStyleType help_text_style = 16;
  // The background color of the hour and minute header segments.
  //
  // If [hourMinuteColor] is a [MaterialStateColor], then the effective
  // background color can depend on the [MaterialState.selected] state, i.e.
  // if the segment is selected or not.
  //
  // By default, if the segment is selected, the overall theme's
  // `ColorScheme.primary.withOpacity(0.12)` is used when the overall theme's
  // brightness is [Brightness.light] and
  // `ColorScheme.primary.withOpacity(0.24)` is used when the overall theme's
  // brightness is [Brightness.dark].
  // If the segment is not selected, the overall theme's
  // `ColorScheme.onSurface.withOpacity(0.12)` is used.
  DartColorType hour_minute_color = 17;
  // The shape of the hour and minute controls that the time picker uses.
  //
  // If this is null, the time picker defaults to
  // `RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(4.0)))`.
  FlutterShapeBorderType hour_minute_shape = 18;
  // The color of the header text that represents hours and minutes.
  //
  // If [hourMinuteTextColor] is a [MaterialStateColor], then the effective
  // text color can depend on the [MaterialState.selected] state, i.e. if the
  // text is selected or not.
  //
  // By default the overall theme's [ColorScheme.primary] color is used when
  // the text is selected and [ColorScheme.onSurface] when it's not selected.
  DartColorType hour_minute_text_color = 19;
  // Used to configure the [TextStyle]s for the hour/minute controls.
  //
  // If this is null, the time picker defaults to the overall theme's
  // [TextTheme.headline3].
  FlutterTextStyleType hour_minute_text_style = 20;
  // The input decoration theme for the [TextField]s in the time picker.
  //
  // If this is null, the time picker provides its own defaults.
  MaterialInputDecorationThemeType input_decoration_theme = 21;
  // The padding around the time picker dialog when the entry mode is
  // [TimePickerEntryMode.dial] or [TimePickerEntryMode.dialOnly].
  FlutterEdgeInsetsGeometryType padding = 22;
  // The shape of the [Dialog] that the time picker is presented in.
  //
  // If this is null, the time picker defaults to
  // `RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(4.0)))`.
  FlutterShapeBorderType shape = 23;
}

// package:flutter/src/material/toggle_buttons.dart
//
// Creates a set of toggle buttons.
//
// It displays its widgets provided in a [List] of [children] along [direction].
// The state of each button is controlled by [isSelected], which is a list
// of bools that determine if a button is in an active, disabled, or
// selected state. They are both correlated by their index in the list.
// The length of [isSelected] has to match the length of the [children]
// list.
//
// Both [children] and [isSelected] properties arguments are required.
//
// The [focusNodes] argument must be null or a list of nodes. If [direction]
// is [Axis.vertical], [verticalDirection] must not be null.
message MaterialToggleButtons {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The toggle button widgets.
  //
  // These are typically [Icon] or [Text] widgets. The boolean selection
  // state of each widget is defined by the corresponding [isSelected]
  // list item.
  //
  // The length of children has to match the length of [isSelected]. If
  // [focusNodes] is not null, the length of children has to also match
  // the length of [focusNodes].
  repeated WidgetType children = 3;
  // The corresponding selection state of each toggle button.
  //
  // Each value in this list represents the selection state of the [children]
  // widget at the same index.
  //
  // The length of [isSelected] has to match the length of [children].
  repeated bool is_selected = 4;
  // Configures the minimum size of the area within which the buttons may
  // be pressed.
  //
  // If the [tapTargetSize] is larger than [constraints], the buttons will
  // include a transparent margin that responds to taps.
  //
  // Defaults to [ThemeData.materialTapTargetSize].
  MaterialMaterialTapTargetSizeType.Enum tap_target_size = 7;
  // The [TextStyle] to apply to any text in these toggle buttons.
  //
  // [TextStyle.color] will be ignored and substituted by [color],
  // [selectedColor] or [disabledColor] depending on whether the buttons
  // are active, selected, or disabled.
  FlutterTextStyleType text_style = 8;
  // Defines the button's size.
  //
  // Typically used to constrain the button's minimum size.
  //
  // If this property is null, then
  // BoxConstraints(minWidth: 48.0, minHeight: 48.0) is be used.
  FlutterBoxConstraintsType constraints = 9;
  // The color for descendant [Text] and [Icon] widgets if the button is
  // enabled and not selected.
  //
  // If [onPressed] is not null, this color will be used for values in
  // [isSelected] that are false.
  //
  // If this property is null, then ToggleButtonTheme.of(context).color
  // is used. If [ToggleButtonsThemeData.color] is also null, then
  // Theme.of(context).colorScheme.onSurface is used.
  DartColorType color = 10;
  // The color for descendant [Text] and [Icon] widgets if the button is
  // selected.
  //
  // If [onPressed] is not null, this color will be used for values in
  // [isSelected] that are true.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).selectedColor is used. If
  // [ToggleButtonsThemeData.selectedColor] is also null, then
  // Theme.of(context).colorScheme.primary is used.
  DartColorType selected_color = 11;
  // The color for descendant [Text] and [Icon] widgets if the button is
  // disabled.
  //
  // If [onPressed] is null, this color will be used.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).disabledColor is used. If
  // [ToggleButtonsThemeData.disabledColor] is also null, then
  // Theme.of(context).colorScheme.onSurface.withOpacity(0.38) is used.
  DartColorType disabled_color = 12;
  // The fill color for selected toggle buttons.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).fillColor is used. If
  // [ToggleButtonsThemeData.fillColor] is also null, then
  // the fill color is null.
  //
  // If fillColor is a [MaterialStateProperty<Color>], then [MaterialStateProperty.resolve]
  // is used for the following [MaterialState]s:
  //
  //  * [MaterialState.disabled]
  //  * [MaterialState.selected]
  //
  DartColorType fill_color = 13;
  // The color to use for filling the button when the button has input focus.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).focusColor is used. If
  // [ToggleButtonsThemeData.focusColor] is also null, then
  // Theme.of(context).focusColor is used.
  DartColorType focus_color = 14;
  // The highlight color for the button's [InkWell].
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).highlightColor is used. If
  // [ToggleButtonsThemeData.highlightColor] is also null, then
  // Theme.of(context).highlightColor is used.
  DartColorType highlight_color = 15;
  // The color to use for filling the button when the button has a pointer
  // hovering over it.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).hoverColor is used. If
  // [ToggleButtonsThemeData.hoverColor] is also null, then
  // Theme.of(context).hoverColor is used.
  DartColorType hover_color = 16;
  // The splash color for the button's [InkWell].
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).splashColor is used. If
  // [ToggleButtonsThemeData.splashColor] is also null, then
  // Theme.of(context).splashColor is used.
  DartColorType splash_color = 17;
  // The list of [FocusNode]s, corresponding to each toggle button.
  //
  // Focus is used to determine which widget should be affected by keyboard
  // events. The focus tree keeps track of which widget is currently focused
  // on by the user.
  //
  // If not null, the length of focusNodes has to match the length of
  // [children].
  //
  // See [FocusNode] for more information about how focus nodes are used.
  repeated FlutterFocusNodeType focus_nodes = 18;
  // Whether or not to render a border around each toggle button.
  //
  // When true, a border with [borderWidth], [borderRadius] and the
  // appropriate border color will render. Otherwise, no border will be
  // rendered.
  bool render_border = 19;
  // The border color to display when the toggle button is enabled and not
  // selected.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).borderColor is used. If
  // [ToggleButtonsThemeData.borderColor] is also null, then
  // Theme.of(context).colorScheme.onSurface is used.
  DartColorType border_color = 20;
  // The border color to display when the toggle button is selected.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).selectedBorderColor is used. If
  // [ToggleButtonsThemeData.selectedBorderColor] is also null, then
  // Theme.of(context).colorScheme.primary is used.
  DartColorType selected_border_color = 21;
  // The border color to display when the toggle button is disabled.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).disabledBorderColor is used. If
  // [ToggleButtonsThemeData.disabledBorderColor] is also null, then
  // Theme.of(context).disabledBorderColor is used.
  DartColorType disabled_border_color = 22;
  // The radii of the border's corners.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).borderRadius is used. If
  // [ToggleButtonsThemeData.borderRadius] is also null, then
  // the buttons default to non-rounded borders.
  FlutterBorderRadiusType border_radius = 23;
  // The width of the border surrounding each toggle button.
  //
  // This applies to both the greater surrounding border, as well as the
  // borders rendered between toggle buttons.
  //
  // To render a hairline border (one physical pixel), set borderWidth to 0.0.
  // See [BorderSide.width] for more details on hairline borders.
  //
  // To omit the border entirely, set [renderBorder] to false.
  //
  // If this property is null, then
  // ToggleButtonTheme.of(context).borderWidth is used. If
  // [ToggleButtonsThemeData.borderWidth] is also null, then
  // a width of 1.0 is used.
  double border_width = 24;
  // The direction along which the buttons are rendered.
  //
  // Defaults to [Axis.horizontal].
  FlutterAxisType.Enum direction = 25;
  // If [direction] is [Axis.vertical], this parameter determines whether to lay out
  // the buttons starting from the first or last child from top to bottom.
  FlutterVerticalDirectionType.Enum vertical_direction = 26;
}

// package:flutter/src/material/toggle_buttons_theme.dart
//
// Creates a toggle buttons theme that controls the color and border
// parameters for [ToggleButtons].
message MaterialToggleButtonsTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Specifies the color and border values for descendant [ToggleButtons] widgets.
  MaterialToggleButtonsThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/toggle_buttons_theme.dart
//
// Creates the set of color and border properties used to configure
// [ToggleButtons].
message MaterialToggleButtonsThemeData {
  // The default text style for [ToggleButtons.children].
  //
  // [TextStyle.color] will be ignored and substituted by [color],
  // [selectedColor] or [disabledColor] depending on whether the buttons
  // are active, selected, or disabled.
  FlutterTextStyleType text_style = 2;
  // Defines the button's size.
  //
  // Typically used to constrain the button's minimum size.
  FlutterBoxConstraintsType constraints = 3;
  // The color for descendant [Text] and [Icon] widgets if the toggle button
  // is enabled.
  DartColorType color = 4;
  // The color for descendant [Text] and [Icon] widgets if the toggle button
  // is selected.
  DartColorType selected_color = 5;
  // The color for descendant [Text] and [Icon] widgets if the toggle button
  // is disabled.
  DartColorType disabled_color = 6;
  // The fill color for selected toggle buttons.
  DartColorType fill_color = 7;
  // The color to use for filling the button when the button has input focus.
  DartColorType focus_color = 8;
  // The highlight color for the toggle button's [InkWell].
  DartColorType highlight_color = 9;
  // The color to use for filling the toggle button when the button has a
  // pointer hovering over it.
  DartColorType hover_color = 10;
  // The splash color for the toggle button's [InkWell].
  DartColorType splash_color = 11;
  // The border color to display when the toggle button is enabled.
  DartColorType border_color = 12;
  // The border color to display when the toggle button is selected.
  DartColorType selected_border_color = 13;
  // The border color to display when the toggle button is disabled.
  DartColorType disabled_border_color = 14;
  // The radii of the border's corners.
  FlutterBorderRadiusType border_radius = 15;
  // The width of the border surrounding each toggle button.
  //
  // This applies to both the greater surrounding border, as well as the
  // borders dividing each toggle button.
  //
  // To render a hairline border (one physical pixel), set borderWidth to 0.0.
  // See [BorderSide.width] for more details on hairline borders.
  double border_width = 16;
}

// package:flutter/src/material/tooltip.dart
//
// Creates a tooltip.
//
// By default, tooltips should adhere to the
// [Material specification](https://material.io/design/components/tooltips.html#spec).
// If the optional constructor parameters are not defined, the values
// provided by [TooltipTheme.of] will be used if a [TooltipTheme] is present
// or specified in [ThemeData].
//
// All parameters that are defined in the constructor will
// override the default values _and_ the values in [TooltipTheme.of].
//
// Only one of [message] and [richMessage] may be non-null.
message MaterialTooltip {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The text to display in the tooltip.
  //
  // Only one of [message] and [richMessage] may be non-null.
  string message = 3;
  // The rich text to display in the tooltip.
  //
  // Only one of [message] and [richMessage] may be non-null.
  FlutterInlineSpanType rich_message = 4;
  // The height of the tooltip's [child].
  //
  // If the [child] is null, then this is the tooltip's intrinsic height.
  double height = 5;
  // The amount of space by which to inset the tooltip's [child].
  //
  // On mobile, defaults to 16.0 logical pixels horizontally and 4.0 vertically.
  // On desktop, defaults to 8.0 logical pixels horizontally and 4.0 vertically.
  FlutterEdgeInsetsGeometryType padding = 6;
  // The empty space that surrounds the tooltip.
  //
  // Defines the tooltip's outer [Container.margin]. By default, a
  // long tooltip will span the width of its window. If long enough,
  // a tooltip might also span the window's height. This property allows
  // one to define how much space the tooltip must be inset from the edges
  // of their display window.
  //
  // If this property is null, then [TooltipThemeData.margin] is used.
  // If [TooltipThemeData.margin] is also null, the default margin is
  // 0.0 logical pixels on all sides.
  FlutterEdgeInsetsGeometryType margin = 7;
  // The vertical gap between the widget and the displayed tooltip.
  //
  // When [preferBelow] is set to true and tooltips have sufficient space to
  // display themselves, this property defines how much vertical space
  // tooltips will position themselves under their corresponding widgets.
  // Otherwise, tooltips will position themselves above their corresponding
  // widgets with the given offset.
  double vertical_offset = 8;
  // Whether the tooltip defaults to being displayed below the widget.
  //
  // If there is insufficient space to display the tooltip in
  // the preferred direction, the tooltip will be displayed in the opposite
  // direction.
  //
  // If this property is null, then [TooltipThemeData.preferBelow] is used.
  // If that is also null, the default value is true.
  //
  // Applying [TooltipThemeData.preferBelow]: `false` for the entire app
  // is recommended to avoid having a finger or cursor hide a tooltip.
  bool prefer_below = 9;
  // Whether the tooltip's [message] or [richMessage] should be excluded from
  // the semantics tree.
  //
  // Defaults to false. A tooltip will add a [Semantics] label that is set to
  // [Tooltip.message] if non-null, or the plain text value of
  // [Tooltip.richMessage] otherwise. Set this property to true if the app is
  // going to provide its own custom semantics label.
  bool exclude_from_semantics = 10;
  // Specifies the tooltip's shape and background color.
  //
  // The tooltip shape defaults to a rounded rectangle with a border radius of
  // 4.0. Tooltips will also default to an opacity of 90% and with the color
  // [Colors.grey]\[700\] if [ThemeData.brightness] is [Brightness.dark], and
  // [Colors.white] if it is [Brightness.light].
  FlutterDecorationType decoration = 11;
  // The style to use for the message of the tooltip.
  //
  // If null, the message's [TextStyle] will be determined based on
  // [ThemeData]. If [ThemeData.brightness] is set to [Brightness.dark],
  // [TextTheme.bodyMedium] of [ThemeData.textTheme] will be used with
  // [Colors.white]. Otherwise, if [ThemeData.brightness] is set to
  // [Brightness.light], [TextTheme.bodyMedium] of [ThemeData.textTheme] will be
  // used with [Colors.black].
  FlutterTextStyleType text_style = 12;
  // How the message of the tooltip is aligned horizontally.
  //
  // If this property is null, then [TooltipThemeData.textAlign] is used.
  // If [TooltipThemeData.textAlign] is also null, the default value is
  // [TextAlign.start].
  DartTextAlignType.Enum text_align = 13;
  // The length of time that a pointer must hover over a tooltip's widget
  // before the tooltip will be shown.
  //
  // Defaults to 0 milliseconds (tooltips are shown immediately upon hover).
  DartDurationType wait_duration = 14;
  // The length of time that the tooltip will be shown after a long press is
  // released (if triggerMode is [TooltipTriggerMode.longPress]) or a tap is
  // released (if triggerMode is [TooltipTriggerMode.tap]). This property
  // does not affect mouse pointer devices.
  //
  // Defaults to 1.5 seconds for long press and tap released
  //
  // See also:
  //
  //  * [exitDuration], which allows configuring the time untill a pointer
  // dissapears when hovering.
  DartDurationType show_duration = 15;
  // The length of time that a pointer must have stopped hovering over a
  // tooltip's widget before the tooltip will be hidden.
  //
  // Defaults to 100 milliseconds.
  //
  // See also:
  //
  //  * [showDuration], which allows configuring the length of time that a
  // tooltip will be visible after touch events are released.
  DartDurationType exit_duration = 16;
  // Whether the tooltip can be dismissed by tap.
  //
  // The default value is true.
  bool enable_tap_to_dismiss = 17;
  // The [TooltipTriggerMode] that will show the tooltip.
  //
  // If this property is null, then [TooltipThemeData.triggerMode] is used.
  // If [TooltipThemeData.triggerMode] is also null, the default mode is
  // [TooltipTriggerMode.longPress].
  //
  // This property does not affect mouse devices. Setting [triggerMode] to
  // [TooltipTriggerMode.manual] will not prevent the tooltip from showing when
  // the mouse cursor hovers over it.
  MaterialTooltipTriggerModeType.Enum trigger_mode = 18;
  // Whether the tooltip should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // When null, the default value is true.
  //
  // See also:
  //
  //  * [Feedback], for providing platform-specific feedback to certain actions.
  bool enable_feedback = 19;
  // The widget below this widget in the tree.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 21;
}

// package:flutter/src/material/tooltip.dart
message MaterialTooltipState {
  
}

// package:flutter/src/material/tooltip_theme.dart
//
// Creates a tooltip theme that controls the configurations for
// [Tooltip].
message MaterialTooltipTheme {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The properties for descendant [Tooltip] widgets.
  MaterialTooltipThemeDataType data = 3;
  // The widget below this widget in the tree.
  //
  // {@template flutter.widgets.ProxyWidget.child}
  // This widget can only have one child. To lay out multiple children, let this
  // widget's child be a widget such as [Row], [Column], or [Stack], which have a
  // `children` property, and then provide the children to that widget.
  // {@endtemplate}
  WidgetType child = 4;
}

// package:flutter/src/material/tooltip_theme.dart
//
// Creates the set of properties used to configure [Tooltip]s.
message MaterialTooltipThemeData {
  // The height of [Tooltip.child].
  double height = 2;
  // If provided, the amount of space by which to inset [Tooltip.child].
  FlutterEdgeInsetsGeometryType padding = 3;
  // If provided, the amount of empty space to surround the [Tooltip].
  FlutterEdgeInsetsGeometryType margin = 4;
  // The vertical gap between the widget and the displayed tooltip.
  //
  // When [preferBelow] is set to true and tooltips have sufficient space to
  // display themselves, this property defines how much vertical space
  // tooltips will position themselves under their corresponding widgets.
  // Otherwise, tooltips will position themselves above their corresponding
  // widgets with the given offset.
  double vertical_offset = 5;
  // Whether the tooltip is displayed below its widget by default.
  //
  // If there is insufficient space to display the tooltip in the preferred
  // direction, the tooltip will be displayed in the opposite direction.
  //
  // Applying `false` for the entire app is recommended
  // to avoid having a finger or cursor hide a tooltip.
  bool prefer_below = 6;
  // Whether the [Tooltip.message] should be excluded from the semantics
  // tree.
  //
  // By default, [Tooltip]s will add a [Semantics] label that is set to
  // [Tooltip.message]. Set this property to true if the app is going to
  // provide its own custom semantics label.
  bool exclude_from_semantics = 7;
  // The [Tooltip]'s shape and background color.
  FlutterDecorationType decoration = 8;
  // The style to use for the message of [Tooltip]s.
  FlutterTextStyleType text_style = 9;
  // The [TextAlign] to use for the message of [Tooltip]s.
  DartTextAlignType.Enum text_align = 10;
  // The length of time that a pointer must hover over a tooltip's widget
  // before the tooltip will be shown.
  DartDurationType wait_duration = 11;
  // The length of time that the tooltip will be shown once it has appeared.
  DartDurationType show_duration = 12;
  // The length of time that a pointer must have stopped hovering over a
  // tooltip's widget before the tooltip will be hidden.
  DartDurationType exit_duration = 13;
  // The [TooltipTriggerMode] that will show the tooltip.
  MaterialTooltipTriggerModeType.Enum trigger_mode = 14;
  // Whether the tooltip should provide acoustic and/or haptic feedback.
  //
  // For example, on Android a tap will produce a clicking sound and a
  // long-press will produce a short vibration, when feedback is enabled.
  //
  // This value is used if [Tooltip.enableFeedback] is null.
  // If this value is null, the default is true.
  //
  // See also:
  //
  //   * [Feedback], for providing platform-specific feedback to certain actions.
  bool enable_feedback = 15;
}

// package:flutter/src/material/tooltip_visibility.dart
//
// Creates a widget that configures the visibility of [Tooltip].
message MaterialTooltipVisibility {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // Determines the visibility of [Tooltip] widgets that inherit from this widget.
  bool visible = 3;
  // The widget below this widget in the tree.
  //
  // The entire app can be wrapped in this widget to globally control [Tooltip]
  // visibility.
  //
  // {@macro flutter.widgets.ProxyWidget.child}
  WidgetType child = 4;
}

// package:flutter/src/material/typography.dart
//
// Creates a typography instance.
//
// This constructor is identical to [Typography.material2018].
message MaterialTypography {
  FlutterTargetPlatformType.Enum platform = 2;
  MaterialTextThemeType black = 3;
  MaterialTextThemeType white = 4;
  MaterialTextThemeType english_like = 5;
  MaterialTextThemeType dense = 6;
  MaterialTextThemeType tall = 7;
}

// package:flutter/src/material/typography.dart
//
// Creates a typography instance using Material Design's 2014 defaults.
//
// If [platform] is [TargetPlatform.iOS] or [TargetPlatform.macOS], the
// default values for [black] and [white] are [blackCupertino] and
// [whiteCupertino] respectively. Otherwise they are [blackMountainView] and
// [whiteMountainView]. If [platform] is null then both [black] and [white]
// must be specified.
//
// The default values for [englishLike], [dense], and [tall] are
// [englishLike2014], [dense2014], and [tall2014].
message MaterialTypographyNamedMaterial2014 {
  FlutterTargetPlatformType.Enum platform = 2;
  MaterialTextThemeType black = 3;
  MaterialTextThemeType white = 4;
  MaterialTextThemeType english_like = 5;
  MaterialTextThemeType dense = 6;
  MaterialTextThemeType tall = 7;
}

// package:flutter/src/material/typography.dart
//
// Creates a typography instance using Material Design's 2018 defaults.
//
// If [platform] is [TargetPlatform.iOS] or [TargetPlatform.macOS], the
// default values for [black] and [white] are [blackCupertino] and
// [whiteCupertino] respectively. Otherwise they are [blackMountainView] and
// [whiteMountainView]. If [platform] is null then both [black] and [white]
// must be specified.
//
// The default values for [englishLike], [dense], and [tall] are
// [englishLike2018], [dense2018], and [tall2018].
message MaterialTypographyNamedMaterial2018 {
  FlutterTargetPlatformType.Enum platform = 2;
  MaterialTextThemeType black = 3;
  MaterialTextThemeType white = 4;
  MaterialTextThemeType english_like = 5;
  MaterialTextThemeType dense = 6;
  MaterialTextThemeType tall = 7;
}

// package:flutter/src/material/typography.dart
//
// Creates a typography instance using Material Design 3 2021 defaults.
//
// If [platform] is [TargetPlatform.iOS] or [TargetPlatform.macOS], the
// default values for [black] and [white] are [blackCupertino] and
// [whiteCupertino] respectively. Otherwise they are [blackMountainView] and
// [whiteMountainView]. If [platform] is null then both [black] and [white]
// must be specified.
//
// The default values for [englishLike], [dense], and [tall] are
// [englishLike2021], [dense2021], and [tall2021].
//
// See also:
//  * <https://m3.material.io/styles/typography>
message MaterialTypographyNamedMaterial2021 {
  FlutterTargetPlatformType.Enum platform = 2;
  MaterialColorSchemeType color_scheme = 3;
  MaterialTextThemeType black = 4;
  MaterialTextThemeType white = 5;
  MaterialTextThemeType english_like = 6;
  MaterialTextThemeType dense = 7;
  MaterialTextThemeType tall = 8;
}

// package:flutter/src/material/input_border.dart
//
// Creates an underline border for an [InputDecorator].
//
// The [borderSide] parameter defaults to [BorderSide.none] (it must not be
// null). Applications typically do not specify a [borderSide] parameter
// because the input decorator substitutes its own, using [copyWith], based
// on the current theme and [InputDecorator.isFocused].
//
// The [borderRadius] parameter defaults to a value where the top left
// and right corners have a circular radius of 4.0.
message MaterialUnderlineInputBorder {
  // Defines the border line's color and weight.
  //
  // The [InputDecorator] creates copies of its input border, using [copyWith],
  // based on the current theme and [InputDecorator.isFocused].
  FlutterBorderSideType border_side = 2;
  // The radii of the border's rounded rectangle corners.
  //
  // When this border is used with a filled input decorator, see
  // [InputDecoration.filled], the border radius defines the shape
  // of the background fill as well as the bottom left and right
  // edges of the underline itself.
  //
  // By default the top right and top left corners have a circular radius
  // of 4.0.
  FlutterBorderRadiusType border_radius = 3;
}

// package:flutter/src/material/tab_indicator.dart
//
// Create an underline style selected tab indicator.
message MaterialUnderlineTabIndicator {
  // The radius of the indicator's corners.
  //
  // If this value is non-null, rounded rectangular tab indicator is
  // drawn, otherwise rectangular tab indictor is drawn.
  FlutterBorderRadiusType border_radius = 2;
  // The color and weight of the horizontal line drawn below the selected tab.
  FlutterBorderSideType border_side = 3;
  // Locates the selected tab's underline relative to the tab's boundary.
  //
  // The [TabBar.indicatorSize] property can be used to define the tab
  // indicator's bounds in terms of its (centered) tab widget with
  // [TabBarIndicatorSize.label], or the entire tab with
  // [TabBarIndicatorSize.tab].
  FlutterEdgeInsetsGeometryType insets = 4;
}

// package:flutter/src/material/user_accounts_drawer_header.dart
//
// Creates a Material Design drawer header.
//
// Requires one of its ancestors to be a [Material] widget.
message MaterialUserAccountsDrawerHeader {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The header's background. If decoration is null then a [BoxDecoration]
  // with its background color set to the current theme's primaryColor is used.
  FlutterDecorationType decoration = 3;
  // The margin around the drawer header.
  FlutterEdgeInsetsGeometryType margin = 4;
  // A widget placed in the upper-left corner that represents the current
  // user's account. Normally a [CircleAvatar].
  WidgetType current_account_picture = 5;
  // A list of widgets that represent the current user's other accounts.
  // Up to three of these widgets will be arranged in a row in the header's
  // upper-right corner. Normally a list of [CircleAvatar] widgets.
  repeated WidgetType other_accounts_pictures = 6;
  // The size of the [currentAccountPicture].
  DartSizeType current_account_picture_size = 7;
  // The size of each widget in [otherAccountsPicturesSize].
  DartSizeType other_accounts_pictures_size = 8;
  // A widget that represents the user's current account name. It is
  // displayed on the left, below the [currentAccountPicture].
  WidgetType account_name = 9;
  // A widget that represents the email address of the user's current account.
  // It is displayed on the left, below the [accountName].
  WidgetType account_email = 10;
  // The [Color] of the arrow icon.
  DartColorType arrow_color = 12;
}

// package:flutter/src/material/divider.dart
//
// Creates a Material Design vertical divider.
//
// The [width], [thickness], [indent], and [endIndent] must be null or
// non-negative.
message MaterialVerticalDivider {
  // Controls how one widget replaces another widget in the tree.
  //
  // If the [runtimeType] and [key] properties of the two widgets are
  // [operator==], respectively, then the new widget replaces the old widget by
  // updating the underlying element (i.e., by calling [Element.update] with the
  // new widget). Otherwise, the old element is removed from the tree, the new
  // widget is inflated into an element, and the new element is inserted into the
  // tree.
  //
  // In addition, using a [GlobalKey] as the widget's [key] allows the element
  // to be moved around the tree (changing parent) without losing state. When a
  // new widget is found (its key and type do not match a previous widget in
  // the same location), but there was a widget with that same global key
  // elsewhere in the tree in the previous frame, then that widget's element is
  // moved to the new location.
  //
  // Generally, a widget that is the only child of another widget does not need
  // an explicit key.
  //
  // See also:
  //
  //  * The discussions at [Key] and [GlobalKey].
  FlutterKeyType key = 2;
  // The divider's width.
  //
  // The divider itself is always drawn as a vertical line that is centered
  // within the width specified by this value.
  //
  // If this is null, then the [DividerThemeData.space] is used. If that is
  // also null, then this defaults to 16.0.
  double width = 3;
  // The thickness of the line drawn within the divider.
  //
  // A divider with a [thickness] of 0.0 is always drawn as a line with a
  // width of exactly one device pixel.
  //
  // If this is null, then the [DividerThemeData.thickness] is used which
  // defaults to 0.0.
  double thickness = 4;
  // The amount of empty space on top of the divider.
  //
  // If this is null, then the [DividerThemeData.indent] is used. If that is
  // also null, then this defaults to 0.0.
  double indent = 5;
  // The amount of empty space under the divider.
  //
  // If this is null, then the [DividerThemeData.endIndent] is used. If that is
  // also null, then this defaults to 0.0.
  double end_indent = 6;
  // The color to use when painting the line.
  //
  // If this is null, then the [DividerThemeData.color] is used. If that is
  // also null, then [ThemeData.dividerColor] is used.
  //
  // {@tool snippet}
  //
  // ```dart
  // const Divider(
  //   color: Colors.deepOrange,
  // )
  // ```
  // {@end-tool}
  DartColorType color = 7;
}

// package:flutter/src/material/theme_data.dart
//
// A const constructor for [VisualDensity].
//
// The [horizontal] and [vertical] arguments must be in the interval between
// [minimumDensity] and [maximumDensity], inclusive.
message MaterialVisualDensity {
  // The horizontal visual density of UI components.
  //
  // This property affects only the horizontal spacing between and within
  // components, to allow for different UI visual densities. It does not affect
  // text sizes, icon sizes, or padding values. The default value is 0.0,
  // corresponding to the metrics specified in the Material Design
  // specification. The value can range from [minimumDensity] to
  // [maximumDensity], inclusive.
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], where this property is used to specify the base
  //    horizontal density of Material components.
  //  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  double horizontal = 2;
  // The vertical visual density of UI components.
  //
  // This property affects only the vertical spacing between and within
  // components, to allow for different UI visual densities. It does not affect
  // text sizes, icon sizes, or padding values. The default value is 0.0,
  // corresponding to the metrics specified in the Material Design
  // specification. The value can range from [minimumDensity] to
  // [maximumDensity], inclusive.
  //
  // See also:
  //
  //  * [ThemeData.visualDensity], where this property is used to specify the base
  //    vertical density of Material components.
  //  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  double vertical = 3;
}

// package:flutter/src/cupertino/theme.dart
//
// Creates a [NoDefaultCupertinoThemeData] styling specification.
//
// Unspecified properties default to null.
message NoDefaultCupertinoThemeData {
  // The brightness override for Cupertino descendants.
  //
  // Defaults to null. If a non-null [Brightness] is specified, the value will
  // take precedence over the ambient [MediaQueryData.platformBrightness], when
  // determining the brightness of descendant Cupertino widgets.
  //
  // If coming from a Material [Theme] and unspecified, [brightness] will be
  // derived from the Material [ThemeData]'s [brightness].
  //
  // See also:
  //
  //  * [MaterialBasedCupertinoThemeData], a [CupertinoThemeData] that defers
  //    [brightness] to its Material [Theme] parent if it's unspecified.
  //
  //  * [CupertinoTheme.brightnessOf], a method used to retrieve the overall
  //    [Brightness] from a [BuildContext], for Cupertino widgets.
  DartBrightnessType.Enum brightness = 2;
  // A color used on interactive elements of the theme.
  //
  // This color is generally used on text and icons in buttons and tappable
  // elements. Defaults to [CupertinoColors.activeBlue].
  //
  // If coming from a Material [Theme] and unspecified, [primaryColor] will be
  // derived from the Material [ThemeData]'s `colorScheme.primary`. However, in
  // iOS styling, the [primaryColor] is more sparsely used than in Material
  // Design where the [primaryColor] can appear on non-interactive surfaces like
  // the [AppBar] background, [TextField] borders etc.
  //
  // See also:
  //
  //  * [MaterialBasedCupertinoThemeData], a [CupertinoThemeData] that defers
  //    [primaryColor] to its Material [Theme] parent if it's unspecified.
  DartColorType primary_color = 3;
  // A color that must be easy to see when rendered on a [primaryColor] background.
  //
  // For example, this color is used for a [CupertinoButton]'s text and icons
  // when the button's background is [primaryColor].
  //
  // If coming from a Material [Theme] and unspecified, [primaryContrastingColor]
  // will be derived from the Material [ThemeData]'s `colorScheme.onPrimary`.
  //
  // See also:
  //
  //  * [MaterialBasedCupertinoThemeData], a [CupertinoThemeData] that defers
  //    [primaryContrastingColor] to its Material [Theme] parent if it's unspecified.
  DartColorType primary_contrasting_color = 4;
  // Text styles used by Cupertino widgets.
  //
  // Derived from [primaryColor] if unspecified.
  CupertinoTextThemeDataType text_theme = 5;
  // Background color of the top nav bar and bottom tab bar.
  //
  // Defaults to a light gray in light mode, or a dark translucent gray color in
  // dark mode.
  DartColorType bar_background_color = 6;
  // Background color of the scaffold.
  //
  // Defaults to [CupertinoColors.systemBackground].
  DartColorType scaffold_background_color = 7;
  // Flag to apply this theme to all descendant Cupertino widgets.
  //
  // Certain Cupertino widgets previously didn't use theming, matching past
  // versions of iOS. For example, [CupertinoSwitch]s always used
  // [CupertinoColors.systemGreen] when active.
  //
  // Today, however, these widgets can indeed be themed on iOS. Moreover on
  // macOS, the accent color is reflected in these widgets. Turning this flag
  // on ensures that descendant Cupertino widgets will be themed accordingly.
  //
  // This flag currently applies to the following widgets:
  // - [CupertinoSwitch] & [Switch.adaptive]
  //
  // Defaults to false.
  bool apply_theme_to_all = 8;
}

// package:vector_math/vector_math_64.dart
//
// New matrix with specified values.
message VectorMathMatrix3 {
  double arg0 = 2;
  double arg1 = 3;
  double arg2 = 4;
  double arg3 = 5;
  double arg4 = 6;
  double arg5 = 7;
  double arg6 = 8;
  double arg7 = 9;
  double arg8 = 10;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a new mat3 from columns.
message VectorMathMatrix3NamedColumns {
  VectorMathVector3Type arg0 = 2;
  VectorMathVector3Type arg1 = 3;
  VectorMathVector3Type arg2 = 4;
}

// package:vector_math/vector_math_64.dart
//
// Copes values from [other].
message VectorMathMatrix3NamedCopy {
  VectorMathMatrix3Type other = 2;
}

// package:vector_math/vector_math_64.dart
//
// New matrix from [values].
message VectorMathMatrix3NamedFromList {
  repeated double values = 2;
}

// package:vector_math/vector_math_64.dart
//
// Identity matrix.
message VectorMathMatrix3NamedIdentity {
  
}

// package:vector_math/vector_math_64.dart
//
// Outer product of [u] and [v].
message VectorMathMatrix3NamedOuter {
  VectorMathVector3Type u = 2;
  VectorMathVector3Type v = 3;
}

// package:vector_math/vector_math_64.dart
//
// Rotation of [radians] around X axis.
message VectorMathMatrix3NamedRotationX {
  double radians = 2;
}

// package:vector_math/vector_math_64.dart
//
// Rotation of [radians] around Y axis.
message VectorMathMatrix3NamedRotationY {
  double radians = 2;
}

// package:vector_math/vector_math_64.dart
//
// Rotation of [radians] around Z axis.
message VectorMathMatrix3NamedRotationZ {
  double radians = 2;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a new [Matrix3] filled with zeros.
message VectorMathMatrix3NamedZero {
  
}

// package:vector_math/vector_math_64.dart
//
// Constructs a new mat4.
message VectorMathMatrix4 {
  double arg0 = 2;
  double arg1 = 3;
  double arg2 = 4;
  double arg3 = 5;
  double arg4 = 6;
  double arg5 = 7;
  double arg6 = 8;
  double arg7 = 9;
  double arg8 = 10;
  double arg9 = 11;
  double arg10 = 12;
  double arg11 = 13;
  double arg12 = 14;
  double arg13 = 15;
  double arg14 = 16;
  double arg15 = 17;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a new mat4 from columns.
message VectorMathMatrix4NamedColumns {
  VectorMathVector4Type arg0 = 2;
  VectorMathVector4Type arg1 = 3;
  VectorMathVector4Type arg2 = 4;
  VectorMathVector4Type arg3 = 5;
}

// package:vector_math/vector_math_64.dart
//
// Constructs Matrix4 from [translation], [rotation] and [scale].
message VectorMathMatrix4NamedCompose {
  VectorMathVector3Type translation = 2;
  VectorMathQuaternionType rotation = 3;
  VectorMathVector3Type scale = 4;
}

// package:vector_math/vector_math_64.dart
//
// Copies values from [other].
message VectorMathMatrix4NamedCopy {
  VectorMathMatrix4Type other = 2;
}

// package:vector_math/vector_math_64.dart
//
// Scale matrix.
message VectorMathMatrix4NamedDiagonal3 {
  VectorMathVector3Type scale = 2;
}

// package:vector_math/vector_math_64.dart
//
// Scale matrix.
message VectorMathMatrix4NamedDiagonal3Values {
  double x = 2;
  double y = 3;
  double z = 4;
}

// package:vector_math/vector_math_64.dart
//
// Constructs Matrix4 with a [storage] that views given [buffer] starting at
// [offset]. [offset] has to be multiple of [Float64List.bytesPerElement].
message VectorMathMatrix4NamedFromBuffer {
  int32 offset = 3;
}

// package:vector_math/vector_math_64.dart
//
// Constructs Matrix4 with given [Float64List] as [storage].
message VectorMathMatrix4NamedFromFloat64List {
  DartFloat64ListType m4storage = 2;
}

// package:vector_math/vector_math_64.dart
//
// New matrix from [values].
message VectorMathMatrix4NamedFromList {
  repeated double values = 2;
}

// package:vector_math/vector_math_64.dart
//
// Identity matrix.
message VectorMathMatrix4NamedIdentity {
  
}

// package:vector_math/vector_math_64.dart
//
// Constructs a matrix that is the inverse of [other].
message VectorMathMatrix4NamedInverted {
  VectorMathMatrix4Type other = 2;
}

// package:vector_math/vector_math_64.dart
//
// Outer product of [u] and [v].
message VectorMathMatrix4NamedOuter {
  VectorMathVector4Type u = 2;
  VectorMathVector4Type v = 3;
}

// package:vector_math/vector_math_64.dart
//
// Rotation of [radians] around X.
message VectorMathMatrix4NamedRotationX {
  double radians = 2;
}

// package:vector_math/vector_math_64.dart
//
// Rotation of [radians] around Y.
message VectorMathMatrix4NamedRotationY {
  double radians = 2;
}

// package:vector_math/vector_math_64.dart
//
// Rotation of [radians] around Z.
message VectorMathMatrix4NamedRotationZ {
  double radians = 2;
}

// package:vector_math/vector_math_64.dart
//
// Skew matrix around X axis (alpha) and Y axis (beta).
message VectorMathMatrix4NamedSkew {
  double alpha = 2;
  double beta = 3;
}

// package:vector_math/vector_math_64.dart
//
// Skew matrix around X axis
message VectorMathMatrix4NamedSkewX {
  double alpha = 2;
}

// package:vector_math/vector_math_64.dart
//
// Skew matrix around Y axis.
message VectorMathMatrix4NamedSkewY {
  double beta = 2;
}

// package:vector_math/vector_math_64.dart
//
// Translation matrix.
message VectorMathMatrix4NamedTranslation {
  VectorMathVector3Type translation = 2;
}

// package:vector_math/vector_math_64.dart
//
// Translation matrix.
message VectorMathMatrix4NamedTranslationValues {
  double x = 2;
  double y = 3;
  double z = 4;
}

// package:vector_math/vector_math_64.dart
//
// Zero matrix.
message VectorMathMatrix4NamedZero {
  
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion using the raw values [x], [y], [z], and [w].
message VectorMathQuaternion {
  double x = 2;
  double y = 3;
  double z = 4;
  double w = 5;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion from a rotation of [angle] around [axis].
message VectorMathQuaternionNamedAxisAngle {
  VectorMathVector3Type axis = 2;
  double angle = 3;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion as a copy of [original].
message VectorMathQuaternionNamedCopy {
  VectorMathQuaternionType original = 2;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion from time derivative of [q] with angular
// velocity [omega].
message VectorMathQuaternionNamedDq {
  VectorMathQuaternionType q = 2;
  VectorMathVector3Type omega = 3;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion from [yaw], [pitch] and [roll].
message VectorMathQuaternionNamedEuler {
  double yaw = 2;
  double pitch = 3;
  double roll = 4;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion with a [storage] that views given [buffer]
// starting at [offset]. [offset] has to be multiple of
// [Float64List.bytesPerElement].
message VectorMathQuaternionNamedFromBuffer {
  int32 offset = 3;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion with given Float64List as [storage].
message VectorMathQuaternionNamedFromFloat64List {
  DartFloat64ListType q_storage = 2;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion from a rotation matrix [rotationMatrix].
message VectorMathQuaternionNamedFromRotation {
  VectorMathMatrix3Type rotation_matrix = 2;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion to be the rotation that rotates vector [a] to [b].
message VectorMathQuaternionNamedFromTwoVectors {
  VectorMathVector3Type a = 2;
  VectorMathVector3Type b = 3;
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion set to the identity quaternion.
message VectorMathQuaternionNamedIdentity {
  
}

// package:vector_math/vector_math_64.dart
//
// Constructs a quaternion with a random rotation. The random number
// generator [rn] is used to generate the random numbers for the rotation.
message VectorMathQuaternionNamedRandom {
  DartRandomType rn = 2;
}

// package:vector_math/vector_math_64.dart
//
// Construct a new vector with the specified values.
message VectorMathVector3 {
  double x = 2;
  double y = 3;
  double z = 4;
}

// package:vector_math/vector_math_64.dart
//
// Splat [value] into all lanes of the vector.
message VectorMathVector3NamedAll {
  double value = 2;
}

// package:vector_math/vector_math_64.dart
//
// Initialized with values from [array] starting at [offset].
message VectorMathVector3NamedArray {
  repeated double array = 2;
  int32 offset = 3;
}

// package:vector_math/vector_math_64.dart
//
// Copy of [other].
message VectorMathVector3NamedCopy {
  VectorMathVector3Type other = 2;
}

// package:vector_math/vector_math_64.dart
//
// Constructs Vector3 with a [storage] that views given [buffer] starting at
// [offset]. [offset] has to be multiple of [Float64List.bytesPerElement].
message VectorMathVector3NamedFromBuffer {
  int32 offset = 3;
}

// package:vector_math/vector_math_64.dart
//
// Constructs Vector3 with given Float64List as [storage].
message VectorMathVector3NamedFromFloat64List {
  DartFloat64ListType v3storage = 2;
}

// package:vector_math/vector_math_64.dart
//
// Generate random vector in the range (0, 0, 0) to (1, 1, 1). You can
// optionally pass your own random number generator.
message VectorMathVector3NamedRandom {
  DartRandomType rng = 2;
}

// package:vector_math/vector_math_64.dart
//
// Zero vector.
message VectorMathVector3NamedZero {
  
}

// package:vector_math/vector_math_64.dart
//
// Construct a new vector with the specified values.
message VectorMathVector4 {
  double x = 2;
  double y = 3;
  double z = 4;
  double w = 5;
}

// package:vector_math/vector_math_64.dart
//
// Splat [value] into all lanes of the vector.
message VectorMathVector4NamedAll {
  double value = 2;
}

// package:vector_math/vector_math_64.dart
//
// Initialized with values from [array] starting at [offset].
message VectorMathVector4NamedArray {
  repeated double array = 2;
  int32 offset = 3;
}

// package:vector_math/vector_math_64.dart
//
// Copy of [other].
message VectorMathVector4NamedCopy {
  VectorMathVector4Type other = 2;
}

// package:vector_math/vector_math_64.dart
//
// Constructs Vector4 with a [storage] that views given [buffer] starting at
// [offset]. [offset] has to be multiple of [Float64List.bytesPerElement].
message VectorMathVector4NamedFromBuffer {
  int32 offset = 3;
}

// package:vector_math/vector_math_64.dart
//
// Constructs Vector4 with given Float64List as [storage].
message VectorMathVector4NamedFromFloat64List {
  DartFloat64ListType v4storage = 2;
}

// package:vector_math/vector_math_64.dart
//
// Constructs the identity vector.
message VectorMathVector4NamedIdentity {
  
}

// package:vector_math/vector_math_64.dart
//
// Generate random vector in the range (0, 0, 0, 0) to (1, 1, 1, 1). You can
// optionally pass your own random number generator.
message VectorMathVector4NamedRandom {
  DartRandomType rng = 2;
}

// package:vector_math/vector_math_64.dart
//
// Zero vector.
message VectorMathVector4NamedZero {
  
}


// package:flutter/src/cupertino/text_theme.dart
//
// Cupertino typography theme in a [CupertinoThemeData].
message CupertinoTextThemeDataType {
  oneof constructor {
    CupertinoTextThemeData cupertino_text_theme_data = 2;
  }
}

// package:flutter/src/cupertino/theme.dart
//
// Styling specifications for a [CupertinoTheme].
//
// All constructor parameters can be null, in which case a
// [CupertinoColors.activeBlue] based default iOS theme styling is used.
//
// Parameters can also be partially specified, in which case some parameters
// will cascade down to other dependent parameters to create a cohesive
// visual effect. For instance, if a [primaryColor] is specified, it would
// cascade down to affect some fonts in [textTheme] if [textTheme] is not
// specified.
//
// See also:
//
//  * [CupertinoTheme], in which this [CupertinoThemeData] is inserted.
//  * [ThemeData], a Material equivalent that also configures Cupertino
//    styling via a [CupertinoThemeData] subclass [MaterialBasedCupertinoThemeData].
message CupertinoThemeDataType {
  oneof constructor {
    CupertinoThemeData cupertino_theme_data = 2;
    CupertinoThemeDataNamedRaw cupertino_theme_data_named_raw = 3;
    MaterialMaterialBasedCupertinoThemeData material_material_based_cupertino_theme_data = 4;
  }
}

// dart:ui
//
// A description of a color filter to apply when drawing a shape or compositing
// a layer with a particular [Paint]. A color filter is a function that takes
// two colors, and outputs one color. When applied during compositing, it is
// independently applied to each pixel of the layer being drawn before the
// entire layer is merged with the destination.
//
// Instances of this class are used with [Paint.colorFilter] on [Paint]
// objects.
message DartColorFilterType {
  oneof constructor {
    DartColorFilterNamedLinearToSrgbGamma dart_color_filter_named_linear_to_srgb_gamma = 2;
    DartColorFilterNamedMatrix dart_color_filter_named_matrix = 3;
    DartColorFilterNamedMode dart_color_filter_named_mode = 4;
    DartColorFilterNamedSrgbToLinearGamma dart_color_filter_named_srgb_to_linear_gamma = 5;
  }
}

// dart:ui
//
// An immutable 32 bit color value in ARGB format.
//
// Consider the light teal of the Flutter logo. It is fully opaque, with a red
// channel value of 0x42 (66), a green channel value of 0xA5 (165), and a blue
// channel value of 0xF5 (245). In the common "hash syntax" for color values,
// it would be described as `#42A5F5`.
//
// Here are some ways it could be constructed:
//
// ```dart
// Color c1 = const Color(0xFF42A5F5);
// Color c2 = const Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5);
// Color c3 = const Color.fromARGB(255, 66, 165, 245);
// Color c4 = const Color.fromRGBO(66, 165, 245, 1.0);
// ```
//
// If you are having a problem with `Color` wherein it seems your color is just
// not painting, check to make sure you are specifying the full 8 hexadecimal
// digits. If you only specify six, then the leading two digits are assumed to
// be zero, which means fully-transparent:
//
// ```dart
// Color c1 = const Color(0xFFFFFF); // fully transparent white (invisible)
// Color c2 = const Color(0xFFFFFFFF); // fully opaque white (visible)
// ```
//
// See also:
//
//  * [Colors](https://api.flutter.dev/flutter/material/Colors-class.html), which
//    defines the colors found in the Material Design specification.
message DartColorType {
  oneof constructor {
    CupertinoDynamicColor cupertino_dynamic_color = 2;
    CupertinoDynamicColorNamedWithBrightness cupertino_dynamic_color_named_with_brightness = 3;
    CupertinoDynamicColorNamedWithBrightnessAndContrast cupertino_dynamic_color_named_with_brightness_and_contrast = 4;
    DartColor dart_color = 5;
    DartColorNamedFromARGB dart_color_named_from_a_r_g_b = 6;
    DartColorNamedFromRGBO dart_color_named_from_r_g_b_o = 7;
  }
}

// dart:core
//
// An instant in time, such as July 20, 1969, 8:18pm GMT.
//
// DateTimes can represent time values that are at a distance of at most
// 100,000,000 days from epoch (1970-01-01 UTC): -271821-04-20 to 275760-09-13.
//
// Create a `DateTime` object by using one of the constructors
// or by parsing a correctly formatted string,
// which complies with a subset of ISO 8601.
// **Note:** hours are specified between 0 and 23,
// as in a 24-hour clock.
//
// For example:
// ```dart
// final now = DateTime.now();
// final berlinWallFell = DateTime.utc(1989, 11, 9);
// final moonLanding = DateTime.parse('1969-07-20 20:18:04Z'); // 8:18pm
// ```
//
// A `DateTime` object is anchored either in the UTC time zone
// or in the local time zone of the current computer
// when the object is created.
//
// Once created, neither the value nor the time zone
// of a `DateTime` object may be changed.
//
// You can use properties to get
// the individual units of a `DateTime` object.
// ```
// print(berlinWallFell.year); // 1989
// print(berlinWallFell.month); // 11
// print(berlinWallFell.day); // 9
// print(moonLanding.hour); // 20
// print(moonLanding.minute); // 18
// ```
// For convenience and readability,
// the `DateTime` class provides a constant for each `day` and `month`
// name - for example, [august] and [friday].
// You can use these constants to improve code readability:
// ```dart
// final berlinWallFell = DateTime.utc(1989, DateTime.november, 9);
// print(DateTime.november); // 11
// assert(berlinWallFell.month == DateTime.november);
// assert(berlinWallFell.weekday == DateTime.thursday);
// ```
//
// `Day` and `month` values begin at 1, and the week starts on `Monday`.
// That is, the constants [january] and [monday] are both 1.
//
// ## Working with UTC and local time
//
// A `DateTime` object is in the local time zone
// unless explicitly created in the UTC time zone.
// Use [isUtc] to determine whether a `DateTime` object is based in UTC.
//
// ```dart
// final dDay = DateTime.utc(1944, 6, 6);
// print(dDay.isUtc); // true
//
// final dDayLocal = DateTime(1944, 6, 6);
// print(dDayLocal.isUtc); // false
// ```
// Use the methods [toLocal] and [toUtc]
// to get the equivalent date/time value specified in the other time zone.
// ```
// final localDay = dDay.toLocal(); // e.g. 1944-06-06 02:00:00.000
// print(localDay.isUtc); // false
//
// final utcFromLocal = localDay.toUtc(); // 1944-06-06 00:00:00.000Z
// print(utcFromLocal.isUtc); // true
// ```
// Use [timeZoneName] to get an abbreviated name of the time zone
// for the `DateTime` object.
// ```
// print(dDay.timeZoneName); // UTC
// print(localDay.timeZoneName); // e.g. EET
// ```
// To find the difference
// between UTC and the time zone of a `DateTime` object
// call [timeZoneOffset].
// ```
// print(dDay.timeZoneOffset); // 0:00:00.000000
// print(localDay.timeZoneOffset); // e.g. 2:00:00.000000
// ```
//
// ## Comparing DateTime objects
//
// The `DateTime` class contains methods for comparing `DateTime`s
// chronologically, such as [isAfter], [isBefore], and [isAtSameMomentAs].
// ```
// print(berlinWallFell.isAfter(moonLanding)); // true
// print(berlinWallFell.isBefore(moonLanding)); // false
// print(dDay.isAtSameMomentAs(localDay)); // true
// ```
//
// ## Using DateTime with Duration
//
// Use the [add] and [subtract] methods with a [Duration] object
// to create a `DateTime` object based on another.
// For example, to find the point in time that is 36 hours after now,
// you can write:
// ```dart
// final now = DateTime.now();
// final later = now.add(const Duration(hours: 36));
// ```
//
// To find out how much time is between two `DateTime` objects use
// [difference], which returns a [Duration] object:
// ```
// final difference = berlinWallFell.difference(moonLanding);
// print(difference.inDays); // 7416
// ```
//
// The difference between two dates in different time zones
// is just the number of nanoseconds between the two points in time.
// It doesn't take calendar days into account.
// That means that the difference between two midnights in local time may be
// less than 24 hours times the number of days between them,
// if there is a daylight saving change in between.
// If the difference above is calculated using Australian local time, the
// difference is 7415 days and 23 hours, which is only 7415 whole days as
// reported by `inDays`.
//
// ## Other resources
//
//  * See [Duration] to represent a span of time.
//  * See [Stopwatch] to measure timespans.
//  * The `DateTime` class does not provide internationalization.
//  To internationalize your code, use
//  the [intl](https://pub.dev/packages/intl) package.
message DartDateTimeType {
  oneof constructor {
    DartDateTime dart_date_time = 2;
    DartDateTimeNamedFromMicrosecondsSinceEpoch dart_date_time_named_from_microseconds_since_epoch = 3;
    DartDateTimeNamedFromMillisecondsSinceEpoch dart_date_time_named_from_milliseconds_since_epoch = 4;
    DartDateTimeNamedNow dart_date_time_named_now = 5;
    DartDateTimeNamedTimestamp dart_date_time_named_timestamp = 6;
    DartDateTimeNamedUtc dart_date_time_named_utc = 7;
  }
}

// dart:ui
//
// Area of the display that may be obstructed by a hardware feature.
//
// This is populated only on Android.
//
// The [bounds] are measured in logical pixels. On devices with two screens the
// coordinate system starts with (0,0) in the top-left corner of the left or top screen
// and expands to include both screens and the visual space between them.
//
// The [type] describes the behaviour and if [DisplayFeature] obstructs the display.
// For example, [DisplayFeatureType.hinge] and [DisplayFeatureType.cutout] both obstruct the display,
// while [DisplayFeatureType.fold] does not.
//
// ![Device with a hinge display feature](https://flutter.github.io/assets-for-api-docs/assets/hardware/display_feature_hinge.png)
//
// ![Device with a fold display feature](https://flutter.github.io/assets-for-api-docs/assets/hardware/display_feature_fold.png)
//
// ![Device with a cutout display feature](https://flutter.github.io/assets-for-api-docs/assets/hardware/display_feature_cutout.png)
//
// The [state] contains information about the posture for foldable features
// ([DisplayFeatureType.hinge] and [DisplayFeatureType.fold]). The posture is
// the shape of the display, for example [DisplayFeatureState.postureFlat] or
// [DisplayFeatureState.postureHalfOpened]. For [DisplayFeatureType.cutout],
// the state is not used and has the [DisplayFeatureState.unknown] value.
message DartDisplayFeatureType {
  oneof constructor {
    DartDisplayFeature dart_display_feature = 2;
  }
}

// dart:core
//
// A span of time, such as 27 days, 4 hours, 12 minutes, and 3 seconds.
//
// A `Duration` represents a difference from one point in time to another. The
// duration may be "negative" if the difference is from a later time to an
// earlier.
//
// Durations are context independent. For example, a duration of 2 days is
// always 48 hours, even when it is added to a `DateTime` just when the
// time zone is about to make a daylight-savings switch. (See [DateTime.add]).
//
// Despite the same name, a `Duration` object does not implement "Durations"
// as specified by ISO 8601. In particular, a duration object does not keep
// track of the individually provided members (such as "days" or "hours"), but
// only uses these arguments to compute the length of the corresponding time
// interval.
//
// To create a new `Duration` object, use this class's single constructor
// giving the appropriate arguments:
// ```dart
// const fastestMarathon = Duration(hours: 2, minutes: 3, seconds: 2);
// ```
// The [Duration] represents a single number of microseconds,
// which is the sum of all the individual arguments to the constructor.
//
// Properties can access that single number in different ways.
// For example the [inMinutes] gives the number of whole minutes
// in the total duration, which includes the minutes that were provided
// as "hours" to the constructor, and can be larger than 59.
//
// ```dart
// const fastestMarathon = Duration(hours: 2, minutes: 3, seconds: 2);
// print(fastestMarathon.inDays); // 0
// print(fastestMarathon.inHours); // 2
// print(fastestMarathon.inMinutes); // 123
// print(fastestMarathon.inSeconds); // 7382
// print(fastestMarathon.inMilliseconds); // 7382000
// ```
// The duration can be negative, in which case
// all the properties derived from the duration are also non-positive.
// ```dart
// const overDayAgo = Duration(days: -1, hours: -10);
// print(overDayAgo.inDays); // -1
// print(overDayAgo.inHours); // -34
// print(overDayAgo.inMinutes); // -2040
// ```
// Use one of the properties, such as [inDays],
// to retrieve the integer value of the `Duration` in the specified time unit.
// Note that the returned value is rounded down.
// For example,
// ```dart
// const aLongWeekend = Duration(hours: 88);
// print(aLongWeekend.inDays); // 3
// ```
// This class provides a collection of arithmetic
// and comparison operators,
// plus a set of constants useful for converting time units.
// ```dart
// const firstHalf = Duration(minutes: 45); // 00:45:00.000000
// const secondHalf = Duration(minutes: 45); // 00:45:00.000000
// const overTime = Duration(minutes: 30); // 00:30:00.000000
// final maxGameTime = firstHalf + secondHalf + overTime;
// print(maxGameTime.inMinutes); // 120
//
// // The duration of the firstHalf and secondHalf is the same, returns 0.
// var result = firstHalf.compareTo(secondHalf);
// print(result); // 0
//
// // Duration of overTime is shorter than firstHalf, returns < 0.
// result = overTime.compareTo(firstHalf);
// print(result); // < 0
//
// // Duration of secondHalf is longer than overTime, returns > 0.
// result = secondHalf.compareTo(overTime);
// print(result); // > 0
// ```
//
// **See also:**
// * [DateTime] to represent a point in time.
// * [Stopwatch] to measure time-spans.
message DartDurationType {
  oneof constructor {
    DartDuration dart_duration = 2;
  }
}

// dart:io
//
// A reference to a file on the file system.
//
// A `File` holds a [path] on which operations can be performed.
// You can get the parent directory of the file using [parent],
// a property inherited from [FileSystemEntity].
//
// Create a new `File` object with a pathname to access the specified file on the
// file system from your program.
// ```dart
// var myFile = File('file.txt');
// ```
// The `File` class contains methods for manipulating files and their contents.
// Using methods in this class, you can open and close files, read to and write
// from them, create and delete them, and check for their existence.
//
// When reading or writing a file, you can use streams (with [openRead]),
// random access operations (with [open]),
// or convenience methods such as [readAsString],
//
// Most methods in this class occur in synchronous and asynchronous pairs,
// for example, [readAsString] and [readAsStringSync].
// Unless you have a specific reason for using the synchronous version
// of a method, prefer the asynchronous version to avoid blocking your program.
//
// ## If path is a link
//
// If [path] is a symbolic link, rather than a file,
// then the methods of `File` operate on the ultimate target of the
// link, except for [delete] and [deleteSync], which operate on
// the link.
//
// ## Read from a file
//
// The following code sample reads the entire contents from a file as a string
// using the asynchronous [readAsString] method:
// ```dart
// import 'dart:async';
// import 'dart:io';
//
// void main() {
//   File('file.txt').readAsString().then((String contents) {
//     print(contents);
//   });
// }
// ```
// A more flexible and useful way to read a file is with a [Stream].
// Open the file with [openRead], which returns a stream that
// provides the data in the file as chunks of bytes.
// Read the stream to process the file contents when available.
// You can use various transformers in succession to manipulate the
// file content into the required format, or to prepare it for output.
//
// You might want to use a stream to read large files,
// to manipulate the data with transformers,
// or for compatibility with another API, such as [WebSocket]s.
// ```dart
// import 'dart:io';
// import 'dart:convert';
// import 'dart:async';
//
// void main() async {
//   final file = File('file.txt');
//   Stream<String> lines = file.openRead()
//     .transform(utf8.decoder)       // Decode bytes to UTF-8.
//     .transform(LineSplitter());    // Convert stream to individual lines.
//   try {
//     await for (var line in lines) {
//       print('$line: ${line.length} characters');
//     }
//     print('File is now closed.');
//   } catch (e) {
//     print('Error: $e');
//   }
// }
// ```
// ## Write to a file
//
// To write a string to a file, use the [writeAsString] method:
// ```dart
// import 'dart:io';
//
// void main() async {
//   final filename = 'file.txt';
//   var file = await File(filename).writeAsString('some content');
//   // Do something with the file.
// }
// ```
// You can also write to a file using a [Stream]. Open the file with
// [openWrite], which returns an [IOSink] to which you can write data.
// Be sure to close the sink with the [IOSink.close] method.
// ```dart
// import 'dart:io';
//
// void main() {
//   var file = File('file.txt');
//   var sink = file.openWrite();
//   sink.write('FILE ACCESSED ${DateTime.now()}\n');
//
//   // Close the IOSink to free system resources.
//   sink.close();
// }
// ```
// ## The use of asynchronous methods
//
// To avoid unintentional blocking of the program,
// several methods are asynchronous and return a [Future]. For example,
// the [length] method, which gets the length of a file, returns a [Future].
// Wait for the future to get the result when it's ready.
// ```dart
// import 'dart:io';
//
// void main() async {
//   final file = File('file.txt');
//
//   var length = await file.length();
//   print(length);
// }
// ```
// In addition to length, the [exists], [lastModified], [stat], and
// other methods, are asynchronous.
//
// ## Other resources
//
// * The [Files and directories](https://dart.dev/guides/libraries/library-tour#files-and-directories)
//   section of the library tour.
//
// * [Write Command-Line Apps](https://dart.dev/tutorials/server/cmdline),
//   a tutorial about writing command-line apps, includes information about
//   files and directories.
message DartFileType {
  oneof constructor {
    DartFile dart_file = 2;
    DartFileNamedFromRawPath dart_file_named_from_raw_path = 3;
    DartFileNamedFromUri dart_file_named_from_uri = 4;
  }
}

// dart:typed_data
//
// A fixed-length list of IEEE 754 double-precision binary floating-point
// numbers  that is viewable as a [TypedData].
//
// For long lists, this
// implementation can be considerably more space- and time-efficient than
// the default [List] implementation.
//
// It is a compile-time error for a class to attempt to extend or implement
// Float64List.
message DartFloat64ListType {
  oneof constructor {
    DartFloat64List dart_float64_list = 2;
    DartFloat64ListNamedFromList dart_float64_list_named_from_list = 3;
    DartFloat64ListNamedSublistView dart_float64_list_named_sublist_view = 4;
    DartFloat64ListNamedView dart_float64_list_named_view = 5;
  }
}

// dart:ui
//
// A feature tag and value that affect the selection of glyphs in a font.
//
// Different fonts support different features. Consider using a tool
// such as <https://wakamaifondue.com/> to examine your fonts to
// determine what features are available.
//
// {@tool sample}
// This example shows usage of several OpenType font features,
// including Small Caps (selected manually using the "smcp" code),
// old-style figures, fractional ligatures, and stylistic sets.
//
// ** See code in examples/api/lib/ui/text/font_feature.0.dart **
// {@end-tool}
//
// Some fonts also support continuous font variations; see the [FontVariation]
// class.
//
// See also:
//
//  * <https://en.wikipedia.org/wiki/List_of_typographic_features>,
//    Wikipedia's description of these typographic features.
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags>,
//    Microsoft's registry of these features.
message DartFontFeatureType {
  oneof constructor {
    DartFontFeature dart_font_feature = 2;
    DartFontFeatureNamedAlternative dart_font_feature_named_alternative = 3;
    DartFontFeatureNamedAlternativeFractions dart_font_feature_named_alternative_fractions = 4;
    DartFontFeatureNamedCaseSensitiveForms dart_font_feature_named_case_sensitive_forms = 5;
    DartFontFeatureNamedCharacterVariant dart_font_feature_named_character_variant = 6;
    DartFontFeatureNamedContextualAlternates dart_font_feature_named_contextual_alternates = 7;
    DartFontFeatureNamedDenominator dart_font_feature_named_denominator = 8;
    DartFontFeatureNamedDisable dart_font_feature_named_disable = 9;
    DartFontFeatureNamedEnable dart_font_feature_named_enable = 10;
    DartFontFeatureNamedFractions dart_font_feature_named_fractions = 11;
    DartFontFeatureNamedHistoricalForms dart_font_feature_named_historical_forms = 12;
    DartFontFeatureNamedHistoricalLigatures dart_font_feature_named_historical_ligatures = 13;
    DartFontFeatureNamedLiningFigures dart_font_feature_named_lining_figures = 14;
    DartFontFeatureNamedLocaleAware dart_font_feature_named_locale_aware = 15;
    DartFontFeatureNamedNotationalForms dart_font_feature_named_notational_forms = 16;
    DartFontFeatureNamedNumerators dart_font_feature_named_numerators = 17;
    DartFontFeatureNamedOldstyleFigures dart_font_feature_named_oldstyle_figures = 18;
    DartFontFeatureNamedOrdinalForms dart_font_feature_named_ordinal_forms = 19;
    DartFontFeatureNamedProportionalFigures dart_font_feature_named_proportional_figures = 20;
    DartFontFeatureNamedRandomize dart_font_feature_named_randomize = 21;
    DartFontFeatureNamedScientificInferiors dart_font_feature_named_scientific_inferiors = 22;
    DartFontFeatureNamedSlashedZero dart_font_feature_named_slashed_zero = 23;
    DartFontFeatureNamedStylisticAlternates dart_font_feature_named_stylistic_alternates = 24;
    DartFontFeatureNamedStylisticSet dart_font_feature_named_stylistic_set = 25;
    DartFontFeatureNamedSubscripts dart_font_feature_named_subscripts = 26;
    DartFontFeatureNamedSuperscripts dart_font_feature_named_superscripts = 27;
    DartFontFeatureNamedSwash dart_font_feature_named_swash = 28;
    DartFontFeatureNamedTabularFigures dart_font_feature_named_tabular_figures = 29;
  }
}

// dart:ui
//
// An axis tag and value that can be used to customize variable fonts.
//
// Some fonts are variable fonts that can generate a range of different
// font faces by altering the values of the font's design axes.
//
// For example:
//
// ```dart
// const TextStyle(fontVariations: <ui.FontVariation>[ui.FontVariation('wght', 800.0)])
// ```
//
// Font variations are distinct from font features, as exposed by the
// [FontFeature] class. Where features can be enabled or disabled in a discrete
// manner, font variations provide a continuous axis of control.
//
// See also:
//
//  * <https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg#registered-axis-tags>,
//    which lists registered axis tags.
//
//  * <https://docs.microsoft.com/en-us/typography/opentype/spec/otvaroverview>,
//    an overview of the font variations technology.
message DartFontVariationType {
  oneof constructor {
    DartFontVariation dart_font_variation = 2;
    DartFontVariationNamedItalic dart_font_variation_named_italic = 3;
    DartFontVariationNamedOpticalSize dart_font_variation_named_optical_size = 4;
    DartFontVariationNamedSlant dart_font_variation_named_slant = 5;
    DartFontVariationNamedWeight dart_font_variation_named_weight = 6;
    DartFontVariationNamedWidth dart_font_variation_named_width = 7;
  }
}

// dart:ui
//
// A filter operation to apply to a raster image.
//
// See also:
//
//  * [BackdropFilter], a widget that applies [ImageFilter] to its rendering.
//  * [ImageFiltered], a widget that applies [ImageFilter] to its children.
//  * [SceneBuilder.pushBackdropFilter], which is the low-level API for using
//    this class as a backdrop filter.
//  * [SceneBuilder.pushImageFilter], which is the low-level API for using
//    this class as a child layer filter.
message DartImageFilterType {
  oneof constructor {
    DartColorFilterNamedLinearToSrgbGamma dart_color_filter_named_linear_to_srgb_gamma = 2;
    DartColorFilterNamedMatrix dart_color_filter_named_matrix = 3;
    DartColorFilterNamedMode dart_color_filter_named_mode = 4;
    DartColorFilterNamedSrgbToLinearGamma dart_color_filter_named_srgb_to_linear_gamma = 5;
    DartImageFilterNamedBlur dart_image_filter_named_blur = 6;
    DartImageFilterNamedCompose dart_image_filter_named_compose = 7;
    DartImageFilterNamedDilate dart_image_filter_named_dilate = 8;
    DartImageFilterNamedErode dart_image_filter_named_erode = 9;
    DartImageFilterNamedMatrix dart_image_filter_named_matrix = 10;
  }
}

// dart:ui
//
// An identifier used to select a user's language and formatting preferences.
//
// This represents a [Unicode Language
// Identifier](https://www.unicode.org/reports/tr35/#Unicode_language_identifier)
// (i.e. without Locale extensions), except variants are not supported.
//
// Locales are canonicalized according to the "preferred value" entries in the
// [IANA Language Subtag
// Registry](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry).
// For example, `const Locale('he')` and `const Locale('iw')` are equal and
// both have the [languageCode] `he`, because `iw` is a deprecated language
// subtag that was replaced by the subtag `he`.
//
// See also:
//
//  * [PlatformDispatcher.locale], which specifies the system's currently selected
//    [Locale].
message DartLocaleType {
  oneof constructor {
    DartLocale dart_locale = 2;
    DartLocaleNamedFromSubtags dart_locale_named_from_subtags = 3;
  }
}

// dart:ui
//
// An immutable 2D floating-point offset.
//
// Generally speaking, Offsets can be interpreted in two ways:
//
// 1. As representing a point in Cartesian space a specified distance from a
//    separately-maintained origin. For example, the top-left position of
//    children in the [RenderBox] protocol is typically represented as an
//    [Offset] from the top left of the parent box.
//
// 2. As a vector that can be applied to coordinates. For example, when
//    painting a [RenderObject], the parent is passed an [Offset] from the
//    screen's origin which it can add to the offsets of its children to find
//    the [Offset] from the screen's origin to each of the children.
//
// Because a particular [Offset] can be interpreted as one sense at one time
// then as the other sense at a later time, the same class is used for both
// senses.
//
// See also:
//
//  * [Size], which represents a vector describing the size of a rectangle.
message DartOffsetType {
  oneof constructor {
    DartOffset dart_offset = 2;
    DartOffsetNamedFromDirection dart_offset_named_from_direction = 3;
  }
}

// dart:ui
//
// A description of the style to use when drawing on a [Canvas].
//
// Most APIs on [Canvas] take a [Paint] object to describe the style
// to use for that operation.
message DartPaintType {
  oneof constructor {
    DartPaint dart_paint = 2;
  }
}

// dart:ui
//
// A complex, one-dimensional subset of a plane.
//
// A path consists of a number of sub-paths, and a _current point_.
//
// Sub-paths consist of segments of various types, such as lines,
// arcs, or beziers. Sub-paths can be open or closed, and can
// self-intersect.
//
// Closed sub-paths enclose a (possibly discontiguous) region of the
// plane based on the current [fillType].
//
// The _current point_ is initially at the origin. After each
// operation adding a segment to a sub-path, the current point is
// updated to the end of that segment.
//
// Paths can be drawn on canvases using [Canvas.drawPath], and can
// used to create clip regions using [Canvas.clipPath].
message DartPathType {
  oneof constructor {
    DartPath dart_path = 2;
    DartPathNamedFrom dart_path_named_from = 3;
  }
}

// dart:ui
//
// An immutable rounded rectangle with the custom radii for all four corners.
message DartRRectType {
  oneof constructor {
    DartRRectNamedFromLTRBAndCorners dart_r_rect_named_from_l_t_r_b_and_corners = 2;
    DartRRectNamedFromLTRBR dart_r_rect_named_from_l_t_r_b_r = 3;
    DartRRectNamedFromLTRBXY dart_r_rect_named_from_l_t_r_b_x_y = 4;
    DartRRectNamedFromRectAndCorners dart_r_rect_named_from_rect_and_corners = 5;
    DartRRectNamedFromRectAndRadius dart_r_rect_named_from_rect_and_radius = 6;
    DartRRectNamedFromRectXY dart_r_rect_named_from_rect_x_y = 7;
  }
}

// dart:ui
//
// A radius for either circular or elliptical shapes.
message DartRadiusType {
  oneof constructor {
    DartRadiusNamedCircular dart_radius_named_circular = 2;
    DartRadiusNamedElliptical dart_radius_named_elliptical = 3;
  }
}

// dart:math
//
// A generator of random bool, int, or double values.
//
// The default implementation supplies a stream of pseudo-random bits that are
// not suitable for cryptographic purposes.
//
// Use the [Random.secure] constructor for cryptographic purposes.
//
// To create a non-negative random integer uniformly distributed in the range
// from 0, inclusive, to max, exclusive, use [nextInt(int max)].
// ```dart
// var intValue = Random().nextInt(10); // Value is >= 0 and < 10.
// intValue = Random().nextInt(100) + 50; // Value is >= 50 and < 150.
// ```
// To create a non-negative random floating point value uniformly distributed
// in the range from 0.0, inclusive, to 1.0, exclusive, use [nextDouble].
// ```dart
// var doubleValue = Random().nextDouble(); // Value is >= 0.0 and < 1.0.
// doubleValue = Random().nextDouble() * 256; // Value is >= 0.0 and < 256.0.
// ```
// To create a random Boolean value, use [nextBool].
// ```dart
// var boolValue = Random().nextBool(); // true or false, with equal chance.
// ```
//
message DartRandomType {
  oneof constructor {
    DartRandom dart_random = 2;
    DartRandomNamedSecure dart_random_named_secure = 3;
  }
}

// dart:ui
//
// An immutable, 2D, axis-aligned, floating-point rectangle whose coordinates
// are relative to a given origin.
//
// A Rect can be created with one of its constructors or from an [Offset] and a
// [Size] using the `&` operator:
//
// ```dart
// Rect myRect = const Offset(1.0, 2.0) & const Size(3.0, 4.0);
// ```
message DartRectType {
  oneof constructor {
    DartRectNamedFromCenter dart_rect_named_from_center = 2;
    DartRectNamedFromCircle dart_rect_named_from_circle = 3;
    DartRectNamedFromLTRB dart_rect_named_from_l_t_r_b = 4;
    DartRectNamedFromLTWH dart_rect_named_from_l_t_w_h = 5;
    DartRectNamedFromPoints dart_rect_named_from_points = 6;
  }
}

// dart:ui
//
// Base class for objects such as [Gradient] and [ImageShader] which
// correspond to shaders as used by [Paint.shader].
message DartShaderType {
  oneof constructor {
    DartImageShader dart_image_shader = 2;
  }
}

// dart:ui
//
// A single shadow.
//
// Multiple shadows are stacked together in a [TextStyle].
message DartShadowType {
  oneof constructor {
    DartShadow dart_shadow = 2;
    FlutterBoxShadow flutter_box_shadow = 3;
  }
}

// dart:ui
//
// Holds a 2D floating-point size.
//
// You can think of this as an [Offset] from the origin.
message DartSizeType {
  oneof constructor {
    DartSize dart_size = 2;
    DartSizeNamedCopy dart_size_named_copy = 3;
    DartSizeNamedFromHeight dart_size_named_from_height = 4;
    DartSizeNamedFromRadius dart_size_named_from_radius = 5;
    DartSizeNamedFromWidth dart_size_named_from_width = 6;
    DartSizeNamedSquare dart_size_named_square = 7;
  }
}

// dart:core
//
// An interface implemented by all stack trace objects.
//
// A [StackTrace] is intended to convey information to the user about the call
// sequence that triggered an exception.
//
// These objects are created by the runtime, it is not possible to create
// them programmatically.
message DartStackTraceType {
  oneof constructor {
    DartStackTraceNamedFromString dart_stack_trace_named_from_string = 2;
  }
}

// dart:ui
//
// An abstract interface for string attributes that affects how assistive
// technologies, e.g. VoiceOver or TalkBack, treat the text.
//
// See also:
//
//  * [AttributedString], where the string attributes are used.
//  * [SpellOutStringAttribute], which causes the assistive technologies to
//    spell out the string character by character when announcing the string.
//  * [LocaleStringAttribute], which causes the assistive technologies to
//    treat the string in the specific language.
message DartStringAttributeType {
  oneof constructor {
    DartLocaleStringAttribute dart_locale_string_attribute = 2;
    DartSpellOutStringAttribute dart_spell_out_string_attribute = 3;
  }
}

// dart:ui
//
// A linear decoration to draw near the text.
message DartTextDecorationType {
  oneof constructor {
    DartTextDecorationNamedCombine dart_text_decoration_named_combine = 2;
  }
}

// dart:ui
//
// {@template dart.ui.textHeightBehavior}
// Defines how to apply [TextStyle.height] over and under text.
//
// [TextHeightBehavior.applyHeightToFirstAscent] and
// [TextHeightBehavior.applyHeightToLastDescent] represent whether the
// [TextStyle.height] modifier will be applied to the corresponding metric. By
// default both properties are true, and [TextStyle.height] is applied as
// normal. When set to false, the font's default ascent will be used.
//
// [TextHeightBehavior.leadingDistribution] determines how the
// leading is distributed over and under text. This
// property applies before [TextHeightBehavior.applyHeightToFirstAscent] and
// [TextHeightBehavior.applyHeightToLastDescent].
//
// {@endtemplate}
message DartTextHeightBehaviorType {
  oneof constructor {
    DartTextHeightBehavior dart_text_height_behavior = 2;
  }
}

// dart:ui
//
// A position in a string of text.
//
// A TextPosition can be used to describe a caret position in between
// characters. The [offset] points to the position between `offset - 1` and
// `offset` characters of the string, and the [affinity] is used to describe
// which character this position affiliates with.
//
// One use case is when rendered text is forced to wrap. In this case, the offset
// where the wrap occurs could visually appear either at the end of the first
// line or the beginning of the second line. The second way is with
// bidirectional text.  An offset at the interface between two different text
// directions could have one of two locations in the rendered text.
//
// See the documentation for [TextAffinity] for more information on how
// TextAffinity disambiguates situations like these.
message DartTextPositionType {
  oneof constructor {
    DartTextPosition dart_text_position = 2;
  }
}

// dart:ui
//
// A range of characters in a string of text.
message DartTextRangeType {
  oneof constructor {
    DartTextRange dart_text_range = 2;
    DartTextRangeNamedCollapsed dart_text_range_named_collapsed = 3;
    FlutterTextSelection flutter_text_selection = 4;
    FlutterTextSelectionNamedCollapsed flutter_text_selection_named_collapsed = 5;
    FlutterTextSelectionNamedFromPosition flutter_text_selection_named_from_position = 6;
  }
}

// dart:typed_data
//
// A typed view of a sequence of bytes.
//
// It is a compile-time error for a class to attempt to extend or implement
// TypedData.
message DartTypedDataType {
  oneof constructor {
    DartByteData dart_byte_data = 2;
    DartByteDataNamedSublistView dart_byte_data_named_sublist_view = 3;
    DartByteDataNamedView dart_byte_data_named_view = 4;
    DartFloat32List dart_float32_list = 5;
    DartFloat32ListNamedFromList dart_float32_list_named_from_list = 6;
    DartFloat32ListNamedSublistView dart_float32_list_named_sublist_view = 7;
    DartFloat32ListNamedView dart_float32_list_named_view = 8;
    DartFloat64List dart_float64_list = 9;
    DartFloat64ListNamedFromList dart_float64_list_named_from_list = 10;
    DartFloat64ListNamedSublistView dart_float64_list_named_sublist_view = 11;
    DartFloat64ListNamedView dart_float64_list_named_view = 12;
    DartInt32List dart_int32_list = 13;
    DartInt32ListNamedFromList dart_int32_list_named_from_list = 14;
    DartInt32ListNamedSublistView dart_int32_list_named_sublist_view = 15;
    DartInt32ListNamedView dart_int32_list_named_view = 16;
    DartInt64List dart_int64_list = 17;
    DartInt64ListNamedFromList dart_int64_list_named_from_list = 18;
    DartInt64ListNamedSublistView dart_int64_list_named_sublist_view = 19;
    DartInt64ListNamedView dart_int64_list_named_view = 20;
    DartUint8List dart_uint8_list = 21;
    DartUint8ListNamedFromList dart_uint8_list_named_from_list = 22;
    DartUint8ListNamedSublistView dart_uint8_list_named_sublist_view = 23;
    DartUint8ListNamedView dart_uint8_list_named_view = 24;
  }
}

// dart:typed_data
//
// A fixed-length list of 8-bit unsigned integers.
//
// For long lists, this implementation can be considerably
// more space- and time-efficient than the default [List] implementation.
//
// Integers stored in the list are truncated to their low eight bits,
// interpreted as an unsigned 8-bit integer with values in the
// range 0 to 255.
//
// It is a compile-time error for a class to attempt to extend or implement
// Uint8List.
message DartUint8ListType {
  oneof constructor {
    DartUint8List dart_uint8_list = 2;
    DartUint8ListNamedFromList dart_uint8_list_named_from_list = 3;
    DartUint8ListNamedSublistView dart_uint8_list_named_sublist_view = 4;
    DartUint8ListNamedView dart_uint8_list_named_view = 5;
  }
}

// dart:core
//
// A parsed URI, such as a URL.
//
// To create a URI with specific components, use [Uri.new]:
// ```dart
// var httpsUri = Uri(
//     scheme: 'https',
//     host: 'dart.dev',
//     path: '/guides/libraries/library-tour',
//     fragment: 'numbers');
// print(httpsUri); // https://dart.dev/guides/libraries/library-tour#numbers
//
// httpsUri = Uri(
//     scheme: 'https',
//     host: 'example.com',
//     path: '/page/',
//     queryParameters: {'search': 'blue', 'limit': '10'});
// print(httpsUri); // https://example.com/page/?search=blue&limit=10
//
// final mailtoUri = Uri(
//     scheme: 'mailto',
//     path: 'John.Doe@example.com',
//     queryParameters: {'subject': 'Example'});
// print(mailtoUri); // mailto:John.Doe@example.com?subject=Example
// ```
//
// ## HTTP and HTTPS URI
// To create a URI with https scheme, use [Uri.https] or [Uri.http]:
// ```dart
// final httpsUri = Uri.https('example.com', 'api/fetch', {'limit': '10'});
// print(httpsUri); // https://example.com/api/fetch?limit=10
// ```
// ## File URI
// To create a URI from file path, use [Uri.file]:
// ```dart
// final fileUriUnix =
//     Uri.file(r'/home/myself/images/image.png', windows: false);
// print(fileUriUnix); // file:///home/myself/images/image.png
//
// final fileUriWindows =
//     Uri.file(r'C:\Users\myself\Documents\image.png', windows: true);
// print(fileUriWindows); // file:///C:/Users/myself/Documents/image.png
// ```
// If the URI is not a file URI, calling this throws [UnsupportedError].
//
// ## Directory URI
// Like [Uri.file] except that a non-empty URI path ends in a slash.
// ```dart
// final fileDirectory =
//     Uri.directory('/home/myself/data/image', windows: false);
// print(fileDirectory); // file:///home/myself/data/image/
//
// final fileDirectoryWindows = Uri.directory('/data/images', windows: true);
// print(fileDirectoryWindows); //  file:///data/images/
// ```
//
// ## URI from string
// To create a URI from string, use [Uri.parse] or [Uri.tryParse]:
// ```dart
// final uri = Uri.parse(
//     'https://dart.dev/guides/libraries/library-tour#utility-classes');
// print(uri); // https://dart.dev
// print(uri.isScheme('https')); // true
// print(uri.origin); // https://dart.dev
// print(uri.host); // dart.dev
// print(uri.authority); // dart.dev
// print(uri.port); // 443
// print(uri.path); // guides/libraries/library-tour
// print(uri.pathSegments); // [guides, libraries, library-tour]
// print(uri.fragment); // utility-classes
// print(uri.hasQuery); // false
// print(uri.data); // null
// ```
//
// **See also:**
// * [URIs][uris] in the [library tour][libtour]
// * [RFC-3986](https://tools.ietf.org/html/rfc3986)
// * [RFC-2396](https://tools.ietf.org/html/rfc2396)
// * [RFC-2045](https://tools.ietf.org/html/rfc2045)
//
// [uris]: https://dart.dev/guides/libraries/library-tour#uris
// [libtour]: https://dart.dev/guides/libraries/library-tour
message DartUriType {
  oneof constructor {
    DartUri dart_uri = 2;
    DartUriNamedDataFromBytes dart_uri_named_data_from_bytes = 3;
    DartUriNamedDataFromString dart_uri_named_data_from_string = 4;
    DartUriNamedDirectory dart_uri_named_directory = 5;
    DartUriNamedFile dart_uri_named_file = 6;
    DartUriNamedHttp dart_uri_named_http = 7;
    DartUriNamedHttps dart_uri_named_https = 8;
  }
}

// package:flutter/src/painting/alignment.dart
//
// An offset that's expressed as a fraction of a [Size], but whose horizontal
// component is dependent on the writing direction.
//
// This can be used to indicate an offset from the left in [TextDirection.ltr]
// text and an offset from the right in [TextDirection.rtl] text without having
// to be aware of the current text direction.
//
// See also:
//
//  * [Alignment], a variant that is defined in physical terms (i.e.
//    whose horizontal component does not depend on the text direction).
message FlutterAlignmentDirectionalType {
  oneof constructor {
    FlutterAlignmentDirectional flutter_alignment_directional = 2;
  }
}

// package:flutter/src/painting/alignment.dart
//
// Base class for [Alignment] that allows for text-direction aware
// resolution.
//
// A property or argument of this type accepts classes created either with [
// Alignment] and its variants, or [AlignmentDirectional.new].
//
// To convert an [AlignmentGeometry] object of indeterminate type into an
// [Alignment] object, call the [resolve] method.
message FlutterAlignmentGeometryType {
  oneof constructor {
    FlutterAlignment flutter_alignment = 2;
    FlutterAlignmentDirectional flutter_alignment_directional = 3;
    FlutterFractionalOffset flutter_fractional_offset = 4;
    FlutterFractionalOffsetNamedFromOffsetAndRect flutter_fractional_offset_named_from_offset_and_rect = 5;
    FlutterFractionalOffsetNamedFromOffsetAndSize flutter_fractional_offset_named_from_offset_and_size = 6;
  }
}

// package:flutter/src/painting/alignment.dart
//
// A point within a rectangle.
//
// `Alignment(0.0, 0.0)` represents the center of the rectangle. The distance
// from -1.0 to +1.0 is the distance from one side of the rectangle to the
// other side of the rectangle. Therefore, 2.0 units horizontally (or
// vertically) is equivalent to the width (or height) of the rectangle.
//
// `Alignment(-1.0, -1.0)` represents the top left of the rectangle.
//
// `Alignment(1.0, 1.0)` represents the bottom right of the rectangle.
//
// `Alignment(0.0, 3.0)` represents a point that is horizontally centered with
// respect to the rectangle and vertically below the bottom of the rectangle by
// the height of the rectangle.
//
// `Alignment(0.0, -0.5)` represents a point that is horizontally centered with
// respect to the rectangle and vertically half way between the top edge and
// the center.
//
// `Alignment(x, y)` in a rectangle with height h and width w describes
// the point (x * w/2 + w/2, y * h/2 + h/2) in the coordinate system of the
// rectangle.
//
// [Alignment] uses visual coordinates, which means increasing [x] moves the
// point from left to right. To support layouts with a right-to-left
// [TextDirection], consider using [AlignmentDirectional], in which the
// direction the point moves when increasing the horizontal value depends on
// the [TextDirection].
//
// A variety of widgets use [Alignment] in their configuration, most
// notably:
//
//  * [Align] positions a child according to an [Alignment].
//
// See also:
//
//  * [AlignmentDirectional], which has a horizontal coordinate orientation
//    that depends on the [TextDirection].
//  * [AlignmentGeometry], which is an abstract type that is agnostic as to
//    whether the horizontal direction depends on the [TextDirection].
message FlutterAlignmentType {
  oneof constructor {
    FlutterAlignment flutter_alignment = 2;
    FlutterFractionalOffset flutter_fractional_offset = 3;
    FlutterFractionalOffsetNamedFromOffsetAndRect flutter_fractional_offset_named_from_offset_and_rect = 4;
    FlutterFractionalOffsetNamedFromOffsetAndSize flutter_fractional_offset_named_from_offset_and_size = 5;
  }
}

// package:flutter/src/services/asset_bundle.dart
//
// A collection of resources used by the application.
//
// Asset bundles contain resources, such as images and strings, that can be
// used by an application. Access to these resources is asynchronous so that
// they can be transparently loaded over a network (e.g., from a
// [NetworkAssetBundle]) or from the local file system without blocking the
// application's user interface.
//
// Applications have a [rootBundle], which contains the resources that were
// packaged with the application when it was built. To add resources to the
// [rootBundle] for your application, add them to the `assets` subsection of
// the `flutter` section of your application's `pubspec.yaml` manifest.
//
// For example:
//
// ```yaml
// name: my_awesome_application
// flutter:
//   assets:
//    - images/hamilton.jpeg
//    - images/lafayette.jpeg
// ```
//
// Rather than accessing the [rootBundle] global static directly, consider
// obtaining the [AssetBundle] for the current [BuildContext] using
// [DefaultAssetBundle.of]. This layer of indirection lets ancestor widgets
// substitute a different [AssetBundle] (e.g., for testing or localization) at
// runtime rather than directly replying upon the [rootBundle] created at build
// time. For convenience, the [WidgetsApp] or [MaterialApp] widget at the top
// of the widget hierarchy configures the [DefaultAssetBundle] to be the
// [rootBundle].
//
// See also:
//
//  * [DefaultAssetBundle]
//  * [NetworkAssetBundle]
//  * [rootBundle]
message FlutterAssetBundleType {
  oneof constructor {
    FlutterNetworkAssetBundle flutter_network_asset_bundle = 2;
    FlutterPlatformAssetBundle flutter_platform_asset_bundle = 3;
  }
}

// package:flutter/src/services/autofill.dart
//
// An object that represents an autofillable input field in the autofill workflow.
//
// An [AutofillClient] provides autofill-related information of the input field
// it represents to the platform, and consumes autofill inputs from the platform.
message FlutterAutofillClientType {
  oneof constructor {
    FlutterEditableTextState flutter_editable_text_state = 2;
  }
}

// package:flutter/src/widgets/router.dart
//
// Report to a [Router] when the user taps the back button on platforms that
// support back buttons (such as Android).
//
// When [Router] widgets are nested, consider using a
// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],
// so that the back button requests get dispatched to the appropriate [Router].
// To make this work properly, it's important that whenever a [Router] thinks
// it should get the back button messages (e.g. after the user taps inside it),
// it calls [takePriority] on its [BackButtonDispatcher] (or
// [ChildBackButtonDispatcher]) instance.
//
// The class takes a single callback, which must return a [Future<bool>]. The
// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,
// the callback should return a future that completes to true if it can handle
// the pop request, and a future that completes to false otherwise.
message FlutterBackButtonDispatcherType {
  oneof constructor {
    FlutterChildBackButtonDispatcher flutter_child_back_button_dispatcher = 2;
    FlutterRootBackButtonDispatcher flutter_root_back_button_dispatcher = 3;
  }
}

// package:flutter/src/painting/border_radius.dart
//
// Base class for [BorderRadius] that allows for text-direction aware resolution.
//
// A property or argument of this type accepts classes created either with [
// BorderRadius.only] and its variants, or [BorderRadiusDirectional.only]
// and its variants.
//
// To convert a [BorderRadiusGeometry] object of indeterminate type into a
// [BorderRadius] object, call the [resolve] method.
message FlutterBorderRadiusGeometryType {
  oneof constructor {
    FlutterBorderRadiusDirectionalNamedAll flutter_border_radius_directional_named_all = 2;
    FlutterBorderRadiusDirectionalNamedCircular flutter_border_radius_directional_named_circular = 3;
    FlutterBorderRadiusDirectionalNamedHorizontal flutter_border_radius_directional_named_horizontal = 4;
    FlutterBorderRadiusDirectionalNamedOnly flutter_border_radius_directional_named_only = 5;
    FlutterBorderRadiusDirectionalNamedVertical flutter_border_radius_directional_named_vertical = 6;
    FlutterBorderRadiusNamedAll flutter_border_radius_named_all = 7;
    FlutterBorderRadiusNamedCircular flutter_border_radius_named_circular = 8;
    FlutterBorderRadiusNamedHorizontal flutter_border_radius_named_horizontal = 9;
    FlutterBorderRadiusNamedOnly flutter_border_radius_named_only = 10;
    FlutterBorderRadiusNamedVertical flutter_border_radius_named_vertical = 11;
  }
}

// package:flutter/src/painting/border_radius.dart
//
// An immutable set of radii for each corner of a rectangle.
//
// Used by [BoxDecoration] when the shape is a [BoxShape.rectangle].
//
// The [BorderRadius] class specifies offsets in terms of visual corners, e.g.
// [topLeft]. These values are not affected by the [TextDirection]. To support
// both left-to-right and right-to-left layouts, consider using
// [BorderRadiusDirectional], which is expressed in terms that are relative to
// a [TextDirection] (typically obtained from the ambient [Directionality]).
message FlutterBorderRadiusType {
  oneof constructor {
    FlutterBorderRadiusNamedAll flutter_border_radius_named_all = 2;
    FlutterBorderRadiusNamedCircular flutter_border_radius_named_circular = 3;
    FlutterBorderRadiusNamedHorizontal flutter_border_radius_named_horizontal = 4;
    FlutterBorderRadiusNamedOnly flutter_border_radius_named_only = 5;
    FlutterBorderRadiusNamedVertical flutter_border_radius_named_vertical = 6;
  }
}

// package:flutter/src/painting/borders.dart
//
// A side of a border of a box.
//
// A [Border] consists of four [BorderSide] objects: [Border.top],
// [Border.left], [Border.right], and [Border.bottom].
//
// Setting [BorderSide.width] to 0.0 will result in hairline rendering; see
// [BorderSide.width] for a more involved explanation.
//
// {@tool snippet}
// This sample shows how [BorderSide] objects can be used in a [Container], via
// a [BoxDecoration] and a [Border], to decorate some [Text]. In this example,
// the text has a thick bar above it that is light blue, and a thick bar below
// it that is a darker shade of blue.
//
// ```dart
// Container(
//   padding: const EdgeInsets.all(8.0),
//   decoration: BoxDecoration(
//     border: Border(
//       top: BorderSide(width: 16.0, color: Colors.lightBlue.shade50),
//       bottom: BorderSide(width: 16.0, color: Colors.lightBlue.shade900),
//     ),
//   ),
//   child: const Text('Flutter in the sky', textAlign: TextAlign.center),
// )
// ```
// {@end-tool}
//
// See also:
//
//  * [Border], which uses [BorderSide] objects to represent its sides.
//  * [BoxDecoration], which optionally takes a [Border] object.
//  * [TableBorder], which is similar to [Border] but has two more sides
//    ([TableBorder.horizontalInside] and [TableBorder.verticalInside]), both
//    of which are also [BorderSide] objects.
message FlutterBorderSideType {
  oneof constructor {
    FlutterBorderSide flutter_border_side = 2;
  }
}

// package:flutter/src/painting/box_border.dart
//
// A border of a box, comprised of four sides: top, right, bottom, left.
//
// The sides are represented by [BorderSide] objects.
//
// {@tool snippet}
//
// All four borders the same, two-pixel wide solid white:
//
// ```dart
// Border.all(width: 2.0, color: const Color(0xFFFFFFFF))
// ```
// {@end-tool}
// {@tool snippet}
//
// The border for a Material Design divider:
//
// ```dart
// Border(bottom: BorderSide(color: Theme.of(context).dividerColor))
// ```
// {@end-tool}
// {@tool snippet}
//
// A 1990s-era "OK" button:
//
// ```dart
// Container(
//   decoration: const BoxDecoration(
//     border: Border(
//       top: BorderSide(color: Color(0xFFFFFFFF)),
//       left: BorderSide(color: Color(0xFFFFFFFF)),
//       right: BorderSide(),
//       bottom: BorderSide(),
//     ),
//   ),
//   child: Container(
//     padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 2.0),
//     decoration: const BoxDecoration(
//       border: Border(
//         top: BorderSide(color: Color(0xFFDFDFDF)),
//         left: BorderSide(color: Color(0xFFDFDFDF)),
//         right: BorderSide(color: Color(0xFF7F7F7F)),
//         bottom: BorderSide(color: Color(0xFF7F7F7F)),
//       ),
//       color: Color(0xFFBFBFBF),
//     ),
//     child: const Text(
//       'OK',
//       textAlign: TextAlign.center,
//       style: TextStyle(color: Color(0xFF000000))
//     ),
//   ),
// )
// ```
// {@end-tool}
//
// See also:
//
//  * [BoxDecoration], which uses this class to describe its edge decoration.
//  * [BorderSide], which is used to describe each side of the box.
//  * [Theme], from the material layer, which can be queried to obtain appropriate colors
//    to use for borders in a [MaterialApp], as shown in the "divider" sample above.
//  * [paint], which explains the behavior of [BoxDecoration] parameters.
//  * <https://pub.dev/packages/non_uniform_border>, a package that implements
//    a Non-Uniform Border on ShapeBorder, which is used by Material Design
//    buttons and other widgets, under the "shape" field.
message FlutterBorderType {
  oneof constructor {
    FlutterBorder flutter_border = 2;
    FlutterBorderNamedAll flutter_border_named_all = 3;
    FlutterBorderNamedFromBorderSide flutter_border_named_from_border_side = 4;
    FlutterBorderNamedSymmetric flutter_border_named_symmetric = 5;
  }
}

// package:flutter/src/widgets/bottom_navigation_bar_item.dart
//
// An interactive button within either material's [BottomNavigationBar]
// or the iOS themed [CupertinoTabBar] with an icon and title.
//
// This class is rarely used in isolation. It is typically embedded in one of
// the bottom navigation widgets above.
//
// See also:
//
//  * [BottomNavigationBar]
//  * <https://material.io/design/components/bottom-navigation.html>
//  * [CupertinoTabBar]
//  * <https://developer.apple.com/ios/human-interface-guidelines/bars/tab-bars>
message FlutterBottomNavigationBarItemType {
  oneof constructor {
    FlutterBottomNavigationBarItem flutter_bottom_navigation_bar_item = 2;
  }
}

// package:flutter/src/painting/box_border.dart
//
// Base class for box borders that can paint as rectangles, circles, or rounded
// rectangles.
//
// This class is extended by [Border] and [BorderDirectional] to provide
// concrete versions of four-sided borders using different conventions for
// specifying the sides.
//
// The only API difference that this class introduces over [ShapeBorder] is
// that its [paint] method takes additional arguments.
//
// See also:
//
//  * [BorderSide], which is used to describe each side of the box.
//  * [RoundedRectangleBorder], another way of describing a box's border.
//  * [CircleBorder], another way of describing a circle border.
//  * [BoxDecoration], which uses a [BoxBorder] to describe its borders.
message FlutterBoxBorderType {
  oneof constructor {
    FlutterBorder flutter_border = 2;
    FlutterBorderDirectional flutter_border_directional = 3;
    FlutterBorderNamedAll flutter_border_named_all = 4;
    FlutterBorderNamedFromBorderSide flutter_border_named_from_border_side = 5;
    FlutterBorderNamedSymmetric flutter_border_named_symmetric = 6;
  }
}

// package:flutter/src/rendering/box.dart
//
// Immutable layout constraints for [RenderBox] layout.
//
// A [Size] respects a [BoxConstraints] if, and only if, all of the following
// relations hold:
//
// * [minWidth] <= [Size.width] <= [maxWidth]
// * [minHeight] <= [Size.height] <= [maxHeight]
//
// The constraints themselves must satisfy these relations:
//
// * 0.0 <= [minWidth] <= [maxWidth] <= [double.infinity]
// * 0.0 <= [minHeight] <= [maxHeight] <= [double.infinity]
//
// [double.infinity] is a legal value for each constraint.
//
// ## The box layout model
//
// Render objects in the Flutter framework are laid out by a one-pass layout
// model which walks down the render tree passing constraints, then walks back
// up the render tree passing concrete geometry.
//
// For boxes, the constraints are [BoxConstraints], which, as described herein,
// consist of four numbers: a minimum width [minWidth], a maximum width
// [maxWidth], a minimum height [minHeight], and a maximum height [maxHeight].
//
// The geometry for boxes consists of a [Size], which must satisfy the
// constraints described above.
//
// Each [RenderBox] (the objects that provide the layout models for box
// widgets) receives [BoxConstraints] from its parent, then lays out each of
// its children, then picks a [Size] that satisfies the [BoxConstraints].
//
// Render objects position their children independently of laying them out.
// Frequently, the parent will use the children's sizes to determine their
// position. A child does not know its position and will not necessarily be
// laid out again, or repainted, if its position changes.
//
// ## Terminology
//
// When the minimum constraints and the maximum constraint in an axis are the
// same, that axis is _tightly_ constrained. See: [
// BoxConstraints.tightFor], [BoxConstraints.tightForFinite], [tighten],
// [hasTightWidth], [hasTightHeight], [isTight].
//
// An axis with a minimum constraint of 0.0 is _loose_ (regardless of the
// maximum constraint; if it is also 0.0, then the axis is simultaneously tight
// and loose!). See: [BoxConstraints.loose], [loosen].
//
// An axis whose maximum constraint is not infinite is _bounded_. See:
// [hasBoundedWidth], [hasBoundedHeight].
//
// An axis whose maximum constraint is infinite is _unbounded_. An axis is
// _expanding_ if it is tightly infinite (its minimum and maximum constraints
// are both infinite). See: [BoxConstraints.expand].
//
// An axis whose _minimum_ constraint is infinite is just said to be _infinite_
// (since by definition the maximum constraint must also be infinite in that
// case). See: [hasInfiniteWidth], [hasInfiniteHeight].
//
// A size is _constrained_ when it satisfies a [BoxConstraints] description.
// See: [constrain], [constrainWidth], [constrainHeight],
// [constrainDimensions], [constrainSizeAndAttemptToPreserveAspectRatio],
// [isSatisfiedBy].
message FlutterBoxConstraintsType {
  oneof constructor {
    FlutterBoxConstraints flutter_box_constraints = 2;
    FlutterBoxConstraintsNamedExpand flutter_box_constraints_named_expand = 3;
    FlutterBoxConstraintsNamedLoose flutter_box_constraints_named_loose = 4;
    FlutterBoxConstraintsNamedTight flutter_box_constraints_named_tight = 5;
    FlutterBoxConstraintsNamedTightFor flutter_box_constraints_named_tight_for = 6;
    FlutterBoxConstraintsNamedTightForFinite flutter_box_constraints_named_tight_for_finite = 7;
  }
}

// package:flutter/src/painting/box_decoration.dart
//
// An immutable description of how to paint a box.
//
// The [BoxDecoration] class provides a variety of ways to draw a box.
//
// The box has a [border], a body, and may cast a [boxShadow].
//
// The [shape] of the box can be a circle or a rectangle. If it is a rectangle,
// then the [borderRadius] property controls the roundness of the corners.
//
// The body of the box is painted in layers. The bottom-most layer is the
// [color], which fills the box. Above that is the [gradient], which also fills
// the box. Finally there is the [image], the precise alignment of which is
// controlled by the [DecorationImage] class.
//
// The [border] paints over the body; the [boxShadow], naturally, paints below it.
//
// {@tool snippet}
//
// The following applies a [BoxDecoration] to a [Container] widget to draw an
// [image] of an owl with a thick black [border] and rounded corners.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/painting/box_decoration.png)
//
// ```dart
// Container(
//   decoration: BoxDecoration(
//     color: const Color(0xff7c94b6),
//     image: const DecorationImage(
//       image: NetworkImage('https://flutter.github.io/assets-for-api-docs/assets/widgets/owl-2.jpg'),
//       fit: BoxFit.cover,
//     ),
//     border: Border.all(
//       width: 8,
//     ),
//     borderRadius: BorderRadius.circular(12),
//   ),
// )
// ```
// {@end-tool}
//
// {@template flutter.painting.BoxDecoration.clip}
// The [shape] or the [borderRadius] won't clip the children of the
// decorated [Container]. If the clip is required, insert a clip widget
// (e.g., [ClipRect], [ClipRRect], [ClipPath]) as the child of the [Container].
// Be aware that clipping may be costly in terms of performance.
// {@endtemplate}
//
// See also:
//
//  * [DecoratedBox] and [Container], widgets that can be configured with
//    [BoxDecoration] objects.
//  * [DecoratedSliver], a widget that can be configured with a [BoxDecoration]
//   that is converted to render with slivers.
//  * [CustomPaint], a widget that lets you draw arbitrary graphics.
//  * [Decoration], the base class which lets you define other decorations.
message FlutterBoxDecorationType {
  oneof constructor {
    FlutterBoxDecoration flutter_box_decoration = 2;
  }
}

// package:flutter/src/painting/box_shadow.dart
//
// A shadow cast by a box.
//
// [BoxShadow] can cast non-rectangular shadows if the box is non-rectangular
// (e.g., has a border radius or a circular shape).
//
// This class is similar to CSS box-shadow.
//
// See also:
//
//  * [Canvas.drawShadow], which is a more efficient way to draw shadows.
//  * [PhysicalModel], a widget for showing shadows.
//  * [kElevationToShadow], for some predefined shadows used in Material
//    Design.
//  * [Shadow], which is the parent class that lacks [spreadRadius].
message FlutterBoxShadowType {
  oneof constructor {
    FlutterBoxShadow flutter_box_shadow = 2;
  }
}

// package:flutter/src/widgets/framework.dart
//
// A handle to the location of a widget in the widget tree.
//
// This class presents a set of methods that can be used from
// [StatelessWidget.build] methods and from methods on [State] objects.
//
// [BuildContext] objects are passed to [WidgetBuilder] functions (such as
// [StatelessWidget.build]), and are available from the [State.context] member.
// Some static functions (e.g. [showDialog], [Theme.of], and so forth) also
// take build contexts so that they can act on behalf of the calling widget, or
// obtain data specifically for the given context.
//
// Each widget has its own [BuildContext], which becomes the parent of the
// widget returned by the [StatelessWidget.build] or [State.build] function.
// (And similarly, the parent of any children for [RenderObjectWidget]s.)
//
// In particular, this means that within a build method, the build context of
// the widget of the build method is not the same as the build context of the
// widgets returned by that build method. This can lead to some tricky cases.
// For example, [Theme.of(context)] looks for the nearest enclosing [Theme] of
// the given build context. If a build method for a widget Q includes a [Theme]
// within its returned widget tree, and attempts to use [Theme.of] passing its
// own context, the build method for Q will not find that [Theme] object. It
// will instead find whatever [Theme] was an ancestor to the widget Q. If the
// build context for a subpart of the returned tree is needed, a [Builder]
// widget can be used: the build context passed to the [Builder.builder]
// callback will be that of the [Builder] itself.
//
// For example, in the following snippet, the [ScaffoldState.showBottomSheet]
// method is called on the [Scaffold] widget that the build method itself
// creates. If a [Builder] had not been used, and instead the `context`
// argument of the build method itself had been used, no [Scaffold] would have
// been found, and the [Scaffold.of] function would have returned null.
//
// ```dart
// @override
// Widget build(BuildContext context) {
//   // here, Scaffold.of(context) returns null
//   return Scaffold(
//     appBar: AppBar(title: const Text('Demo')),
//     body: Builder(
//       builder: (BuildContext context) {
//         return TextButton(
//           child: const Text('BUTTON'),
//           onPressed: () {
//             Scaffold.of(context).showBottomSheet(
//               (BuildContext context) {
//                 return Container(
//                   alignment: Alignment.center,
//                   height: 200,
//                   color: Colors.amber,
//                   child: Center(
//                     child: Column(
//                       mainAxisSize: MainAxisSize.min,
//                       children: <Widget>[
//                         const Text('BottomSheet'),
//                         ElevatedButton(
//                           child: const Text('Close BottomSheet'),
//                           onPressed: () {
//                             Navigator.pop(context);
//                           },
//                         )
//                       ],
//                     ),
//                   ),
//                 );
//               },
//             );
//           },
//         );
//       },
//     )
//   );
// }
// ```
//
// The [BuildContext] for a particular widget can change location over time as
// the widget is moved around the tree. Because of this, values returned from
// the methods on this class should not be cached beyond the execution of a
// single synchronous function.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=rIaaH87z1-g}
//
// Avoid storing instances of [BuildContext]s because they may become invalid
// if the widget they are associated with is unmounted from the widget tree.
// {@template flutter.widgets.BuildContext.asynchronous_gap}
// If a [BuildContext] is used across an asynchronous gap (i.e. after performing
// an asynchronous operation), consider checking [mounted] to determine whether
// the context is still valid before interacting with it:
//
// ```dart
//   @override
//   Widget build(BuildContext context) {
//     return OutlinedButton(
//       onPressed: () async {
//         await Future<void>.delayed(const Duration(seconds: 1));
//         if (context.mounted) {
//           Navigator.of(context).pop();
//         }
//       },
//       child: const Text('Delayed pop'),
//     );
//   }
// ```
// {@endtemplate}
//
// [BuildContext] objects are actually [Element] objects. The [BuildContext]
// interface is used to discourage direct manipulation of [Element] objects.
message FlutterBuildContextType {
  oneof constructor {
    FlutterInheritedElement flutter_inherited_element = 2;
    FlutterLeafRenderObjectElement flutter_leaf_render_object_element = 3;
    FlutterListWheelElement flutter_list_wheel_element = 4;
    FlutterMultiChildRenderObjectElement flutter_multi_child_render_object_element = 5;
    FlutterRootElement flutter_root_element = 6;
    FlutterSingleChildRenderObjectElement flutter_single_child_render_object_element = 7;
    FlutterSliverMultiBoxAdaptorElement flutter_sliver_multi_box_adaptor_element = 8;
    FlutterStatefulElement flutter_stateful_element = 9;
    FlutterStatelessElement flutter_stateless_element = 10;
  }
}

// package:flutter/src/widgets/context_menu_button_item.dart
//
// The type and callback for a context menu button.
//
// See also:
//
//  * [AdaptiveTextSelectionToolbar], which can take a list of
//    ContextMenuButtonItems and create a platform-specific context menu with
//    the indicated buttons.
message FlutterContextMenuButtonItemType {
  oneof constructor {
    FlutterContextMenuButtonItem flutter_context_menu_button_item = 2;
  }
}

// package:flutter/src/rendering/custom_paint.dart
//
// The interface used by [CustomPaint] (in the widgets library) and
// [RenderCustomPaint] (in the rendering library).
//
// To implement a custom painter, either subclass or implement this interface
// to define your custom paint delegate. [CustomPainter] subclasses must
// implement the [paint] and [shouldRepaint] methods, and may optionally also
// implement the [hitTest] and [shouldRebuildSemantics] methods, and the
// [semanticsBuilder] getter.
//
// The [paint] method is called whenever the custom object needs to be repainted.
//
// The [shouldRepaint] method is called when a new instance of the class
// is provided, to check if the new instance actually represents different
// information.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=vvI_NUXK00s}
//
// The most efficient way to trigger a repaint is to either:
//
// * Extend this class and supply a `repaint` argument to the constructor of
//   the [CustomPainter], where that object notifies its listeners when it is
//   time to repaint.
// * Extend [Listenable] (e.g. via [ChangeNotifier]) and implement
//   [CustomPainter], so that the object itself provides the notifications
//   directly.
//
// In either case, the [CustomPaint] widget or [RenderCustomPaint]
// render object will listen to the [Listenable] and repaint whenever the
// animation ticks, avoiding both the build and layout phases of the pipeline.
//
// The [hitTest] method is called when the user interacts with the underlying
// render object, to determine if the user hit the object or missed it.
//
// The [semanticsBuilder] is called whenever the custom object needs to rebuild
// its semantics information.
//
// The [shouldRebuildSemantics] method is called when a new instance of the
// class is provided, to check if the new instance contains different
// information that affects the semantics tree.
//
// {@tool snippet}
//
// This sample extends the same code shown for [RadialGradient] to create a
// custom painter that paints a sky.
//
// ```dart
// class Sky extends CustomPainter {
//   @override
//   void paint(Canvas canvas, Size size) {
//     final Rect rect = Offset.zero & size;
//     const RadialGradient gradient = RadialGradient(
//       center: Alignment(0.7, -0.6),
//       radius: 0.2,
//       colors: <Color>[Color(0xFFFFFF00), Color(0xFF0099FF)],
//       stops: <double>[0.4, 1.0],
//     );
//     canvas.drawRect(
//       rect,
//       Paint()..shader = gradient.createShader(rect),
//     );
//   }
//
//   @override
//   SemanticsBuilderCallback get semanticsBuilder {
//     return (Size size) {
//       // Annotate a rectangle containing the picture of the sun
//       // with the label "Sun". When text to speech feature is enabled on the
//       // device, a user will be able to locate the sun on this picture by
//       // touch.
//       Rect rect = Offset.zero & size;
//       final double width = size.shortestSide * 0.4;
//       rect = const Alignment(0.8, -0.9).inscribe(Size(width, width), rect);
//       return <CustomPainterSemantics>[
//         CustomPainterSemantics(
//           rect: rect,
//           properties: const SemanticsProperties(
//             label: 'Sun',
//             textDirection: TextDirection.ltr,
//           ),
//         ),
//       ];
//     };
//   }
//
//   // Since this Sky painter has no fields, it always paints
//   // the same thing and semantics information is the same.
//   // Therefore we return false here. If we had fields (set
//   // from the constructor) then we would return true if any
//   // of them differed from the same fields on the oldDelegate.
//   @override
//   bool shouldRepaint(Sky oldDelegate) => false;
//   @override
//   bool shouldRebuildSemantics(Sky oldDelegate) => false;
// }
// ```
// {@end-tool}
//
// ## Composition and the sharing of canvases
//
// Widgets (or rather, render objects) are composited together using a minimum
// number of [Canvas]es, for performance reasons. As a result, a
// [CustomPainter]'s [Canvas] may be the same as that used by other widgets
// (including other [CustomPaint] widgets).
//
// This is mostly unnoticeable, except when using unusual [BlendMode]s. For
// example, trying to use [BlendMode.dstOut] to "punch a hole" through a
// previously-drawn image may erase more than was intended, because previous
// widgets will have been painted onto the same canvas.
//
// To avoid this issue, consider using [Canvas.saveLayer] and
// [Canvas.restore] when using such blend modes. Creating new layers is
// relatively expensive, however, and should be done sparingly to avoid
// introducing jank.
//
// See also:
//
//  * [Canvas], the class that a custom painter uses to paint.
//  * [CustomPaint], the widget that uses [CustomPainter], and whose sample
//    code shows how to use the above `Sky` class.
//  * [RadialGradient], whose sample code section shows a different take
//    on the sample code above.
message FlutterCustomPainterType {
  oneof constructor {
    FlutterBannerPainter flutter_banner_painter = 2;
  }
}

// package:flutter/src/painting/decoration.dart
//
// A description of a box decoration (a decoration applied to a [Rect]).
//
// This class presents the abstract interface for all decorations.
// See [BoxDecoration] for a concrete example.
//
// To actually paint a [Decoration], use the [createBoxPainter]
// method to obtain a [BoxPainter]. [Decoration] objects can be
// shared between boxes; [BoxPainter] objects can cache resources to
// make painting on a particular surface faster.
message FlutterDecorationType {
  oneof constructor {
    FlutterBoxDecoration flutter_box_decoration = 2;
    FlutterFlutterLogoDecoration flutter_flutter_logo_decoration = 3;
    FlutterMagnifierDecoration flutter_magnifier_decoration = 4;
    FlutterShapeDecoration flutter_shape_decoration = 5;
    FlutterShapeDecorationNamedFromBoxDecoration flutter_shape_decoration_named_from_box_decoration = 6;
    MaterialUnderlineTabIndicator material_underline_tab_indicator = 7;
  }
}

// package:flutter/src/gestures/gesture_settings.dart
//
// The device specific gesture settings scaled into logical pixels.
//
// This configuration can be retrieved from the window, or more commonly from a
// [MediaQuery] widget.
//
// See also:
//
//  * [ui.GestureSettings], the configuration that this is derived from.
message FlutterDeviceGestureSettingsType {
  oneof constructor {
    FlutterDeviceGestureSettings flutter_device_gesture_settings = 2;
    FlutterDeviceGestureSettingsNamedFromView flutter_device_gesture_settings_named_from_view = 3;
  }
}

// package:flutter/src/foundation/diagnostics.dart
//
// A base class for providing string and [DiagnosticsNode] debug
// representations describing the properties and children of an object.
//
// The string debug representation is generated from the intermediate
// [DiagnosticsNode] representation. The [DiagnosticsNode] representation is
// also used by debugging tools displaying interactive trees of objects and
// properties.
//
// See also:
//
//  * [DiagnosticableTreeMixin], a mixin that implements this class.
//  * [Diagnosticable], which should be used instead of this class to
//    provide diagnostics for objects without children.
message FlutterDiagnosticableTreeType {
  oneof constructor {
    CupertinoActionSheet cupertino_action_sheet = 2;
    CupertinoActivityIndicator cupertino_activity_indicator = 3;
    CupertinoActivityIndicatorNamedPartiallyRevealed cupertino_activity_indicator_named_partially_revealed = 4;
    CupertinoAdaptiveTextSelectionToolbar cupertino_adaptive_text_selection_toolbar = 5;
    CupertinoAdaptiveTextSelectionToolbarNamedButtonItems cupertino_adaptive_text_selection_toolbar_named_button_items = 6;
    CupertinoAdaptiveTextSelectionToolbarNamedEditable cupertino_adaptive_text_selection_toolbar_named_editable = 7;
    CupertinoAdaptiveTextSelectionToolbarNamedEditableText cupertino_adaptive_text_selection_toolbar_named_editable_text = 8;
    CupertinoAlertDialog cupertino_alert_dialog = 9;
    CupertinoApp cupertino_app = 10;
    CupertinoAppNamedRouter cupertino_app_named_router = 11;
    CupertinoButton cupertino_button = 12;
    CupertinoButtonNamedFilled cupertino_button_named_filled = 13;
    CupertinoCheckbox cupertino_checkbox = 14;
    CupertinoContextMenu cupertino_context_menu = 15;
    CupertinoContextMenuAction cupertino_context_menu_action = 16;
    CupertinoDesktopTextSelectionToolbar cupertino_desktop_text_selection_toolbar = 17;
    CupertinoDesktopTextSelectionToolbarButton cupertino_desktop_text_selection_toolbar_button = 18;
    CupertinoDesktopTextSelectionToolbarButtonNamedButtonItem cupertino_desktop_text_selection_toolbar_button_named_button_item = 19;
    CupertinoDesktopTextSelectionToolbarButtonNamedText cupertino_desktop_text_selection_toolbar_button_named_text = 20;
    CupertinoDialogAction cupertino_dialog_action = 21;
    CupertinoFormRow cupertino_form_row = 22;
    CupertinoFormSection cupertino_form_section = 23;
    CupertinoFormSectionNamedInsetGrouped cupertino_form_section_named_inset_grouped = 24;
    CupertinoListSection cupertino_list_section = 25;
    CupertinoListSectionNamedInsetGrouped cupertino_list_section_named_inset_grouped = 26;
    CupertinoListTile cupertino_list_tile = 27;
    CupertinoListTileChevron cupertino_list_tile_chevron = 28;
    CupertinoListTileNamedNotched cupertino_list_tile_named_notched = 29;
    CupertinoMagnifier cupertino_magnifier = 30;
    CupertinoNavigationBar cupertino_navigation_bar = 31;
    CupertinoNavigationBarBackButton cupertino_navigation_bar_back_button = 32;
    CupertinoPageScaffold cupertino_page_scaffold = 33;
    CupertinoPicker cupertino_picker = 34;
    CupertinoPickerDefaultSelectionOverlay cupertino_picker_default_selection_overlay = 35;
    CupertinoPopupSurface cupertino_popup_surface = 36;
    CupertinoScrollbar cupertino_scrollbar = 37;
    CupertinoSearchTextField cupertino_search_text_field = 38;
    CupertinoSlider cupertino_slider = 39;
    CupertinoSliverNavigationBar cupertino_sliver_navigation_bar = 40;
    CupertinoSliverRefreshControl cupertino_sliver_refresh_control = 41;
    CupertinoSpellCheckSuggestionsToolbar cupertino_spell_check_suggestions_toolbar = 42;
    CupertinoSpellCheckSuggestionsToolbarNamedEditableText cupertino_spell_check_suggestions_toolbar_named_editable_text = 43;
    CupertinoSwitch cupertino_switch = 44;
    CupertinoTabBar cupertino_tab_bar = 45;
    CupertinoTabView cupertino_tab_view = 46;
    CupertinoTextField cupertino_text_field = 47;
    CupertinoTextFieldNamedBorderless cupertino_text_field_named_borderless = 48;
    CupertinoTextFormFieldRow cupertino_text_form_field_row = 49;
    CupertinoTextSelectionToolbar cupertino_text_selection_toolbar = 50;
    CupertinoTextSelectionToolbarButton cupertino_text_selection_toolbar_button = 51;
    CupertinoTextSelectionToolbarButtonNamedButtonItem cupertino_text_selection_toolbar_button_named_button_item = 52;
    CupertinoTextSelectionToolbarButtonNamedText cupertino_text_selection_toolbar_button_named_text = 53;
    CupertinoTheme cupertino_theme = 54;
    CupertinoUserInterfaceLevel cupertino_user_interface_level = 55;
    FlutterAbsorbPointer flutter_absorb_pointer = 56;
    FlutterAlign flutter_align = 57;
    FlutterAndroidView flutter_android_view = 58;
    FlutterAnimatedAlign flutter_animated_align = 59;
    FlutterAnimatedContainer flutter_animated_container = 60;
    FlutterAnimatedCrossFade flutter_animated_cross_fade = 61;
    FlutterAnimatedDefaultTextStyle flutter_animated_default_text_style = 62;
    FlutterAnimatedFractionallySizedBox flutter_animated_fractionally_sized_box = 63;
    FlutterAnimatedOpacity flutter_animated_opacity = 64;
    FlutterAnimatedPadding flutter_animated_padding = 65;
    FlutterAnimatedPhysicalModel flutter_animated_physical_model = 66;
    FlutterAnimatedPositioned flutter_animated_positioned = 67;
    FlutterAnimatedPositionedDirectional flutter_animated_positioned_directional = 68;
    FlutterAnimatedPositionedNamedFromRect flutter_animated_positioned_named_from_rect = 69;
    FlutterAnimatedRotation flutter_animated_rotation = 70;
    FlutterAnimatedScale flutter_animated_scale = 71;
    FlutterAnimatedSize flutter_animated_size = 72;
    FlutterAnimatedSlide flutter_animated_slide = 73;
    FlutterAnimatedSwitcher flutter_animated_switcher = 74;
    FlutterAppKitView flutter_app_kit_view = 75;
    FlutterAspectRatio flutter_aspect_ratio = 76;
    FlutterAutofillGroup flutter_autofill_group = 77;
    FlutterAutomaticKeepAlive flutter_automatic_keep_alive = 78;
    FlutterBackdropFilter flutter_backdrop_filter = 79;
    FlutterBackdropFilterLayer flutter_backdrop_filter_layer = 80;
    FlutterBanner flutter_banner = 81;
    FlutterBaseline flutter_baseline = 82;
    FlutterBlockSemantics flutter_block_semantics = 83;
    FlutterCenter flutter_center = 84;
    FlutterCheckedModeBanner flutter_checked_mode_banner = 85;
    FlutterClipOval flutter_clip_oval = 86;
    FlutterClipPath flutter_clip_path = 87;
    FlutterClipPathLayer flutter_clip_path_layer = 88;
    FlutterClipRRect flutter_clip_r_rect = 89;
    FlutterClipRRectLayer flutter_clip_r_rect_layer = 90;
    FlutterClipRect flutter_clip_rect = 91;
    FlutterClipRectLayer flutter_clip_rect_layer = 92;
    FlutterColorFilterLayer flutter_color_filter_layer = 93;
    FlutterColorFiltered flutter_color_filtered = 94;
    FlutterColoredBox flutter_colored_box = 95;
    FlutterColumn flutter_column = 96;
    FlutterCompositedTransformFollower flutter_composited_transform_follower = 97;
    FlutterCompositedTransformTarget flutter_composited_transform_target = 98;
    FlutterConstrainedBox flutter_constrained_box = 99;
    FlutterContainer flutter_container = 100;
    FlutterContainerLayer flutter_container_layer = 101;
    FlutterCustomMultiChildLayout flutter_custom_multi_child_layout = 102;
    FlutterCustomPaint flutter_custom_paint = 103;
    FlutterCustomScrollView flutter_custom_scroll_view = 104;
    FlutterCustomSingleChildLayout flutter_custom_single_child_layout = 105;
    FlutterDecoratedBox flutter_decorated_box = 106;
    FlutterDecoratedSliver flutter_decorated_sliver = 107;
    FlutterDefaultAssetBundle flutter_default_asset_bundle = 108;
    FlutterDefaultSelectionStyle flutter_default_selection_style = 109;
    FlutterDefaultSelectionStyleNamedFallback flutter_default_selection_style_named_fallback = 110;
    FlutterDefaultTextEditingShortcuts flutter_default_text_editing_shortcuts = 111;
    FlutterDefaultTextHeightBehavior flutter_default_text_height_behavior = 112;
    FlutterDefaultTextStyle flutter_default_text_style = 113;
    FlutterDefaultTextStyleNamedFallback flutter_default_text_style_named_fallback = 114;
    FlutterDelayedMultiDragGestureRecognizer flutter_delayed_multi_drag_gesture_recognizer = 115;
    FlutterDirectionality flutter_directionality = 116;
    FlutterDismissible flutter_dismissible = 117;
    FlutterDisplayFeatureSubScreen flutter_display_feature_sub_screen = 118;
    FlutterDoubleTapGestureRecognizer flutter_double_tap_gesture_recognizer = 119;
    FlutterDraggable flutter_draggable = 120;
    FlutterDraggableScrollableActuator flutter_draggable_scrollable_actuator = 121;
    FlutterEagerGestureRecognizer flutter_eager_gesture_recognizer = 122;
    FlutterEditableText flutter_editable_text = 123;
    FlutterErrorWidgetNamedWithDetails flutter_error_widget_named_with_details = 124;
    FlutterExcludeFocus flutter_exclude_focus = 125;
    FlutterExcludeFocusTraversal flutter_exclude_focus_traversal = 126;
    FlutterExcludeSemantics flutter_exclude_semantics = 127;
    FlutterExpanded flutter_expanded = 128;
    FlutterFadeInImageNamedAssetNetwork flutter_fade_in_image_named_asset_network = 129;
    FlutterFadeInImageNamedMemoryNetwork flutter_fade_in_image_named_memory_network = 130;
    FlutterFittedBox flutter_fitted_box = 131;
    FlutterFlex flutter_flex = 132;
    FlutterFlexible flutter_flexible = 133;
    FlutterFlow flutter_flow = 134;
    FlutterFlowNamedUnwrapped flutter_flow_named_unwrapped = 135;
    FlutterFlutterError flutter_flutter_error = 136;
    FlutterFlutterErrorNamedFromParts flutter_flutter_error_named_from_parts = 137;
    FlutterFocus flutter_focus = 138;
    FlutterFocusManager flutter_focus_manager = 139;
    FlutterFocusNamedWithExternalFocusNode flutter_focus_named_with_external_focus_node = 140;
    FlutterFocusNode flutter_focus_node = 141;
    FlutterFocusScope flutter_focus_scope = 142;
    FlutterFocusScopeNamedWithExternalFocusNode flutter_focus_scope_named_with_external_focus_node = 143;
    FlutterFocusScopeNode flutter_focus_scope_node = 144;
    FlutterFocusTraversalGroup flutter_focus_traversal_group = 145;
    FlutterFocusTraversalOrder flutter_focus_traversal_order = 146;
    FlutterFocusableActionDetector flutter_focusable_action_detector = 147;
    FlutterFollowerLayer flutter_follower_layer = 148;
    FlutterForcePressGestureRecognizer flutter_force_press_gesture_recognizer = 149;
    FlutterForm flutter_form = 150;
    FlutterFractionalTranslation flutter_fractional_translation = 151;
    FlutterFractionallySizedBox flutter_fractionally_sized_box = 152;
    FlutterGestureDetector flutter_gesture_detector = 153;
    FlutterGlowingOverscrollIndicator flutter_glowing_overscroll_indicator = 154;
    FlutterGridPaper flutter_grid_paper = 155;
    FlutterGridView flutter_grid_view = 156;
    FlutterGridViewNamedCount flutter_grid_view_named_count = 157;
    FlutterGridViewNamedCustom flutter_grid_view_named_custom = 158;
    FlutterGridViewNamedExtent flutter_grid_view_named_extent = 159;
    FlutterHeroControllerScope flutter_hero_controller_scope = 160;
    FlutterHeroControllerScopeNamedNone flutter_hero_controller_scope_named_none = 161;
    FlutterHeroMode flutter_hero_mode = 162;
    FlutterHorizontalDragGestureRecognizer flutter_horizontal_drag_gesture_recognizer = 163;
    FlutterHorizontalMultiDragGestureRecognizer flutter_horizontal_multi_drag_gesture_recognizer = 164;
    FlutterHtmlElementView flutter_html_element_view = 165;
    FlutterHtmlElementViewNamedFromTagName flutter_html_element_view_named_from_tag_name = 166;
    FlutterIcon flutter_icon = 167;
    FlutterIconTheme flutter_icon_theme = 168;
    FlutterIgnoreBaseline flutter_ignore_baseline = 169;
    FlutterIgnorePointer flutter_ignore_pointer = 170;
    FlutterImageFilterLayer flutter_image_filter_layer = 171;
    FlutterImageFiltered flutter_image_filtered = 172;
    FlutterImageIcon flutter_image_icon = 173;
    FlutterImageNamedAsset flutter_image_named_asset = 174;
    FlutterImageNamedFile flutter_image_named_file = 175;
    FlutterImageNamedMemory flutter_image_named_memory = 176;
    FlutterImageNamedNetwork flutter_image_named_network = 177;
    FlutterImmediateMultiDragGestureRecognizer flutter_immediate_multi_drag_gesture_recognizer = 178;
    FlutterIndexedSemantics flutter_indexed_semantics = 179;
    FlutterIndexedStack flutter_indexed_stack = 180;
    FlutterInheritedElement flutter_inherited_element = 181;
    FlutterInteractiveViewer flutter_interactive_viewer = 182;
    FlutterIntrinsicHeight flutter_intrinsic_height = 183;
    FlutterIntrinsicWidth flutter_intrinsic_width = 184;
    FlutterKeepAlive flutter_keep_alive = 185;
    FlutterKeyboardListener flutter_keyboard_listener = 186;
    FlutterKeyedSubtree flutter_keyed_subtree = 187;
    FlutterKeyedSubtreeNamedWrap flutter_keyed_subtree_named_wrap = 188;
    FlutterLeaderLayer flutter_leader_layer = 189;
    FlutterLeafRenderObjectElement flutter_leaf_render_object_element = 190;
    FlutterLimitedBox flutter_limited_box = 191;
    FlutterListBody flutter_list_body = 192;
    FlutterListView flutter_list_view = 193;
    FlutterListViewNamedCustom flutter_list_view_named_custom = 194;
    FlutterListWheelElement flutter_list_wheel_element = 195;
    FlutterListWheelScrollView flutter_list_wheel_scroll_view = 196;
    FlutterListWheelScrollViewNamedUseDelegate flutter_list_wheel_scroll_view_named_use_delegate = 197;
    FlutterListWheelViewport flutter_list_wheel_viewport = 198;
    FlutterListener flutter_listener = 199;
    FlutterLocalizationsNamedOverride flutter_localizations_named_override = 200;
    FlutterLongPressDraggable flutter_long_press_draggable = 201;
    FlutterLongPressGestureRecognizer flutter_long_press_gesture_recognizer = 202;
    FlutterLookupBoundary flutter_lookup_boundary = 203;
    FlutterMediaQuery flutter_media_query = 204;
    FlutterMediaQueryNamedRemovePadding flutter_media_query_named_remove_padding = 205;
    FlutterMediaQueryNamedRemoveViewInsets flutter_media_query_named_remove_view_insets = 206;
    FlutterMediaQueryNamedRemoveViewPadding flutter_media_query_named_remove_view_padding = 207;
    FlutterMergeSemantics flutter_merge_semantics = 208;
    FlutterMetaData flutter_meta_data = 209;
    FlutterModalBarrier flutter_modal_barrier = 210;
    FlutterMouseRegion flutter_mouse_region = 211;
    FlutterMultiChildRenderObjectElement flutter_multi_child_render_object_element = 212;
    FlutterMultiTapGestureRecognizer flutter_multi_tap_gesture_recognizer = 213;
    FlutterNavigationToolbar flutter_navigation_toolbar = 214;
    FlutterNavigator flutter_navigator = 215;
    FlutterNavigatorPopHandler flutter_navigator_pop_handler = 216;
    FlutterNestedScrollViewViewport flutter_nested_scroll_view_viewport = 217;
    FlutterNotificationListener flutter_notification_listener = 218;
    FlutterOffsetLayer flutter_offset_layer = 219;
    FlutterOffstage flutter_offstage = 220;
    FlutterOpacity flutter_opacity = 221;
    FlutterOpacityLayer flutter_opacity_layer = 222;
    FlutterOverflowBar flutter_overflow_bar = 223;
    FlutterOverflowBox flutter_overflow_box = 224;
    FlutterOverlay flutter_overlay = 225;
    FlutterPadding flutter_padding = 226;
    FlutterPageStorage flutter_page_storage = 227;
    FlutterPageView flutter_page_view = 228;
    FlutterPageViewNamedCustom flutter_page_view_named_custom = 229;
    FlutterPanGestureRecognizer flutter_pan_gesture_recognizer = 230;
    FlutterPerformanceOverlay flutter_performance_overlay = 231;
    FlutterPerformanceOverlayLayer flutter_performance_overlay_layer = 232;
    FlutterPerformanceOverlayNamedAllEnabled flutter_performance_overlay_named_all_enabled = 233;
    FlutterPhysicalModel flutter_physical_model = 234;
    FlutterPictureLayer flutter_picture_layer = 235;
    FlutterPipelineOwner flutter_pipeline_owner = 236;
    FlutterPlaceholder flutter_placeholder = 237;
    FlutterPlatformMenu flutter_platform_menu = 238;
    FlutterPlatformMenuBar flutter_platform_menu_bar = 239;
    FlutterPlatformSelectableRegionContextMenu flutter_platform_selectable_region_context_menu = 240;
    FlutterPlatformViewLayer flutter_platform_view_layer = 241;
    FlutterPopScope flutter_pop_scope = 242;
    FlutterPositioned flutter_positioned = 243;
    FlutterPositionedDirectional flutter_positioned_directional = 244;
    FlutterPositionedNamedDirectional flutter_positioned_named_directional = 245;
    FlutterPositionedNamedFill flutter_positioned_named_fill = 246;
    FlutterPositionedNamedFromRect flutter_positioned_named_from_rect = 247;
    FlutterPositionedNamedFromRelativeRect flutter_positioned_named_from_relative_rect = 248;
    FlutterPreferredSize flutter_preferred_size = 249;
    FlutterPrimaryScrollController flutter_primary_scroll_controller = 250;
    FlutterPrimaryScrollControllerNamedNone flutter_primary_scroll_controller_named_none = 251;
    FlutterProjectMyApp flutter_project_my_app = 252;
    FlutterProjectMyHomePage flutter_project_my_home_page = 253;
    FlutterRawGestureDetector flutter_raw_gesture_detector = 254;
    FlutterRawImage flutter_raw_image = 255;
    FlutterRawMagnifier flutter_raw_magnifier = 256;
    FlutterRawScrollbar flutter_raw_scrollbar = 257;
    FlutterRenderAbsorbPointer flutter_render_absorb_pointer = 258;
    FlutterRenderAnimatedSize flutter_render_animated_size = 259;
    FlutterRenderAspectRatio flutter_render_aspect_ratio = 260;
    FlutterRenderBackdropFilter flutter_render_backdrop_filter = 261;
    FlutterRenderBaseline flutter_render_baseline = 262;
    FlutterRenderBlockSemantics flutter_render_block_semantics = 263;
    FlutterRenderClipOval flutter_render_clip_oval = 264;
    FlutterRenderClipPath flutter_render_clip_path = 265;
    FlutterRenderClipRRect flutter_render_clip_r_rect = 266;
    FlutterRenderClipRect flutter_render_clip_rect = 267;
    FlutterRenderConstrainedBox flutter_render_constrained_box = 268;
    FlutterRenderConstrainedOverflowBox flutter_render_constrained_overflow_box = 269;
    FlutterRenderCustomMultiChildLayoutBox flutter_render_custom_multi_child_layout_box = 270;
    FlutterRenderCustomPaint flutter_render_custom_paint = 271;
    FlutterRenderCustomSingleChildLayoutBox flutter_render_custom_single_child_layout_box = 272;
    FlutterRenderDecoratedBox flutter_render_decorated_box = 273;
    FlutterRenderDecoratedSliver flutter_render_decorated_sliver = 274;
    FlutterRenderErrorBox flutter_render_error_box = 275;
    FlutterRenderExcludeSemantics flutter_render_exclude_semantics = 276;
    FlutterRenderFittedBox flutter_render_fitted_box = 277;
    FlutterRenderFlex flutter_render_flex = 278;
    FlutterRenderFlow flutter_render_flow = 279;
    FlutterRenderFollowerLayer flutter_render_follower_layer = 280;
    FlutterRenderFractionalTranslation flutter_render_fractional_translation = 281;
    FlutterRenderFractionallySizedOverflowBox flutter_render_fractionally_sized_overflow_box = 282;
    FlutterRenderIgnoreBaseline flutter_render_ignore_baseline = 283;
    FlutterRenderIgnorePointer flutter_render_ignore_pointer = 284;
    FlutterRenderImage flutter_render_image = 285;
    FlutterRenderIndexedSemantics flutter_render_indexed_semantics = 286;
    FlutterRenderIndexedStack flutter_render_indexed_stack = 287;
    FlutterRenderIntrinsicHeight flutter_render_intrinsic_height = 288;
    FlutterRenderIntrinsicWidth flutter_render_intrinsic_width = 289;
    FlutterRenderLeaderLayer flutter_render_leader_layer = 290;
    FlutterRenderLimitedBox flutter_render_limited_box = 291;
    FlutterRenderListBody flutter_render_list_body = 292;
    FlutterRenderListWheelViewport flutter_render_list_wheel_viewport = 293;
    FlutterRenderMergeSemantics flutter_render_merge_semantics = 294;
    FlutterRenderMetaData flutter_render_meta_data = 295;
    FlutterRenderMouseRegion flutter_render_mouse_region = 296;
    FlutterRenderNestedScrollViewViewport flutter_render_nested_scroll_view_viewport = 297;
    FlutterRenderOffstage flutter_render_offstage = 298;
    FlutterRenderOpacity flutter_render_opacity = 299;
    FlutterRenderPadding flutter_render_padding = 300;
    FlutterRenderParagraph flutter_render_paragraph = 301;
    FlutterRenderPerformanceOverlay flutter_render_performance_overlay = 302;
    FlutterRenderPhysicalModel flutter_render_physical_model = 303;
    FlutterRenderPointerListener flutter_render_pointer_listener = 304;
    FlutterRenderPositionedBox flutter_render_positioned_box = 305;
    FlutterRenderProxyBox flutter_render_proxy_box = 306;
    FlutterRenderRepaintBoundary flutter_render_repaint_boundary = 307;
    FlutterRenderRotatedBox flutter_render_rotated_box = 308;
    FlutterRenderSemanticsAnnotations flutter_render_semantics_annotations = 309;
    FlutterRenderSemanticsGestureHandler flutter_render_semantics_gesture_handler = 310;
    FlutterRenderShrinkWrappingViewport flutter_render_shrink_wrapping_viewport = 311;
    FlutterRenderSizedOverflowBox flutter_render_sized_overflow_box = 312;
    FlutterRenderSliverConstrainedCrossAxis flutter_render_sliver_constrained_cross_axis = 313;
    FlutterRenderSliverCrossAxisGroup flutter_render_sliver_cross_axis_group = 314;
    FlutterRenderSliverFillRemaining flutter_render_sliver_fill_remaining = 315;
    FlutterRenderSliverFillRemainingAndOverscroll flutter_render_sliver_fill_remaining_and_overscroll = 316;
    FlutterRenderSliverFillRemainingWithScrollable flutter_render_sliver_fill_remaining_with_scrollable = 317;
    FlutterRenderSliverFillViewport flutter_render_sliver_fill_viewport = 318;
    FlutterRenderSliverFixedExtentList flutter_render_sliver_fixed_extent_list = 319;
    FlutterRenderSliverGrid flutter_render_sliver_grid = 320;
    FlutterRenderSliverIgnorePointer flutter_render_sliver_ignore_pointer = 321;
    FlutterRenderSliverList flutter_render_sliver_list = 322;
    FlutterRenderSliverMainAxisGroup flutter_render_sliver_main_axis_group = 323;
    FlutterRenderSliverOffstage flutter_render_sliver_offstage = 324;
    FlutterRenderSliverOpacity flutter_render_sliver_opacity = 325;
    FlutterRenderSliverOverlapAbsorber flutter_render_sliver_overlap_absorber = 326;
    FlutterRenderSliverOverlapInjector flutter_render_sliver_overlap_injector = 327;
    FlutterRenderSliverPadding flutter_render_sliver_padding = 328;
    FlutterRenderSliverToBoxAdapter flutter_render_sliver_to_box_adapter = 329;
    FlutterRenderStack flutter_render_stack = 330;
    FlutterRenderTable flutter_render_table = 331;
    FlutterRenderTapRegion flutter_render_tap_region = 332;
    FlutterRenderTapRegionSurface flutter_render_tap_region_surface = 333;
    FlutterRenderTransform flutter_render_transform = 334;
    FlutterRenderView flutter_render_view = 335;
    FlutterRenderViewport flutter_render_viewport = 336;
    FlutterRenderWrap flutter_render_wrap = 337;
    FlutterReorderableDelayedDragStartListener flutter_reorderable_delayed_drag_start_listener = 338;
    FlutterReorderableDragStartListener flutter_reorderable_drag_start_listener = 339;
    FlutterRepaintBoundary flutter_repaint_boundary = 340;
    FlutterRepaintBoundaryNamedWrap flutter_repaint_boundary_named_wrap = 341;
    FlutterRestorationScope flutter_restoration_scope = 342;
    FlutterRichText flutter_rich_text = 343;
    FlutterRootElement flutter_root_element = 344;
    FlutterRootRestorationScope flutter_root_restoration_scope = 345;
    FlutterRootWidget flutter_root_widget = 346;
    FlutterRotatedBox flutter_rotated_box = 347;
    FlutterRow flutter_row = 348;
    FlutterSafeArea flutter_safe_area = 349;
    FlutterScaleGestureRecognizer flutter_scale_gesture_recognizer = 350;
    FlutterScrollConfiguration flutter_scroll_configuration = 351;
    FlutterScrollNotificationObserver flutter_scroll_notification_observer = 352;
    FlutterSelectableRegion flutter_selectable_region = 353;
    FlutterSelectionContainer flutter_selection_container = 354;
    FlutterSelectionContainerNamedDisabled flutter_selection_container_named_disabled = 355;
    FlutterSelectionRegistrarScope flutter_selection_registrar_scope = 356;
    FlutterSemantics flutter_semantics = 357;
    FlutterSemanticsDebugger flutter_semantics_debugger = 358;
    FlutterSemanticsNamedFromProperties flutter_semantics_named_from_properties = 359;
    FlutterSerialTapGestureRecognizer flutter_serial_tap_gesture_recognizer = 360;
    FlutterShaderMaskLayer flutter_shader_mask_layer = 361;
    FlutterSharedAppData flutter_shared_app_data = 362;
    FlutterShortcutRegistrar flutter_shortcut_registrar = 363;
    FlutterShortcutsNamedManager flutter_shortcuts_named_manager = 364;
    FlutterShrinkWrappingViewport flutter_shrink_wrapping_viewport = 365;
    FlutterSingleChildRenderObjectElement flutter_single_child_render_object_element = 366;
    FlutterSingleChildScrollView flutter_single_child_scroll_view = 367;
    FlutterSizeChangedLayoutNotifier flutter_size_changed_layout_notifier = 368;
    FlutterSizedBox flutter_sized_box = 369;
    FlutterSizedBoxNamedExpand flutter_sized_box_named_expand = 370;
    FlutterSizedBoxNamedFromSize flutter_sized_box_named_from_size = 371;
    FlutterSizedBoxNamedShrink flutter_sized_box_named_shrink = 372;
    FlutterSizedBoxNamedSquare flutter_sized_box_named_square = 373;
    FlutterSizedOverflowBox flutter_sized_overflow_box = 374;
    FlutterSliverAnimatedOpacity flutter_sliver_animated_opacity = 375;
    FlutterSliverConstrainedCrossAxis flutter_sliver_constrained_cross_axis = 376;
    FlutterSliverCrossAxisExpanded flutter_sliver_cross_axis_expanded = 377;
    FlutterSliverCrossAxisGroup flutter_sliver_cross_axis_group = 378;
    FlutterSliverFillRemaining flutter_sliver_fill_remaining = 379;
    FlutterSliverFillViewport flutter_sliver_fill_viewport = 380;
    FlutterSliverFixedExtentList flutter_sliver_fixed_extent_list = 381;
    FlutterSliverFixedExtentListNamedList flutter_sliver_fixed_extent_list_named_list = 382;
    FlutterSliverGrid flutter_sliver_grid = 383;
    FlutterSliverGridNamedCount flutter_sliver_grid_named_count = 384;
    FlutterSliverGridNamedExtent flutter_sliver_grid_named_extent = 385;
    FlutterSliverIgnorePointer flutter_sliver_ignore_pointer = 386;
    FlutterSliverList flutter_sliver_list = 387;
    FlutterSliverListNamedList flutter_sliver_list_named_list = 388;
    FlutterSliverMainAxisGroup flutter_sliver_main_axis_group = 389;
    FlutterSliverMultiBoxAdaptorElement flutter_sliver_multi_box_adaptor_element = 390;
    FlutterSliverOffstage flutter_sliver_offstage = 391;
    FlutterSliverOpacity flutter_sliver_opacity = 392;
    FlutterSliverOverlapAbsorber flutter_sliver_overlap_absorber = 393;
    FlutterSliverOverlapInjector flutter_sliver_overlap_injector = 394;
    FlutterSliverPadding flutter_sliver_padding = 395;
    FlutterSliverPersistentHeader flutter_sliver_persistent_header = 396;
    FlutterSliverPrototypeExtentList flutter_sliver_prototype_extent_list = 397;
    FlutterSliverPrototypeExtentListNamedList flutter_sliver_prototype_extent_list_named_list = 398;
    FlutterSliverSafeArea flutter_sliver_safe_area = 399;
    FlutterSliverToBoxAdapter flutter_sliver_to_box_adapter = 400;
    FlutterSliverVisibility flutter_sliver_visibility = 401;
    FlutterSliverVisibilityNamedMaintain flutter_sliver_visibility_named_maintain = 402;
    FlutterSnapshotWidget flutter_snapshot_widget = 403;
    FlutterSpacer flutter_spacer = 404;
    FlutterSrcSemanticsSemanticsHintOverrides flutter_src_semantics_semantics_hint_overrides = 405;
    FlutterSrcSemanticsSemanticsNode flutter_src_semantics_semantics_node = 406;
    FlutterSrcSemanticsSemanticsNodeNamedRoot flutter_src_semantics_semantics_node_named_root = 407;
    FlutterSrcSemanticsSemanticsProperties flutter_src_semantics_semantics_properties = 408;
    FlutterStack flutter_stack = 409;
    FlutterStatefulElement flutter_stateful_element = 410;
    FlutterStatelessElement flutter_stateless_element = 411;
    FlutterStretchingOverscrollIndicator flutter_stretching_overscroll_indicator = 412;
    FlutterTable flutter_table = 413;
    FlutterTableCell flutter_table_cell = 414;
    FlutterTapAndHorizontalDragGestureRecognizer flutter_tap_and_horizontal_drag_gesture_recognizer = 415;
    FlutterTapAndPanGestureRecognizer flutter_tap_and_pan_gesture_recognizer = 416;
    FlutterTapGestureRecognizer flutter_tap_gesture_recognizer = 417;
    FlutterTapRegion flutter_tap_region = 418;
    FlutterTapRegionSurface flutter_tap_region_surface = 419;
    FlutterText flutter_text = 420;
    FlutterTextFieldTapRegion flutter_text_field_tap_region = 421;
    FlutterTextNamedRich flutter_text_named_rich = 422;
    FlutterTextSelectionGestureDetector flutter_text_selection_gesture_detector = 423;
    FlutterTextSpan flutter_text_span = 424;
    FlutterTexture flutter_texture = 425;
    FlutterTextureBox flutter_texture_box = 426;
    FlutterTextureLayer flutter_texture_layer = 427;
    FlutterTickerMode flutter_ticker_mode = 428;
    FlutterTitle flutter_title = 429;
    FlutterTransform flutter_transform = 430;
    FlutterTransformLayer flutter_transform_layer = 431;
    FlutterTransformNamedFlip flutter_transform_named_flip = 432;
    FlutterTransformNamedRotate flutter_transform_named_rotate = 433;
    FlutterTransformNamedScale flutter_transform_named_scale = 434;
    FlutterTransformNamedTranslate flutter_transform_named_translate = 435;
    FlutterUiKitView flutter_ui_kit_view = 436;
    FlutterUnconstrainedBox flutter_unconstrained_box = 437;
    FlutterUnmanagedRestorationScope flutter_unmanaged_restoration_scope = 438;
    FlutterVerticalDragGestureRecognizer flutter_vertical_drag_gesture_recognizer = 439;
    FlutterVerticalMultiDragGestureRecognizer flutter_vertical_multi_drag_gesture_recognizer = 440;
    FlutterView flutter_view = 441;
    FlutterViewAnchor flutter_view_anchor = 442;
    FlutterViewCollection flutter_view_collection = 443;
    FlutterViewport flutter_viewport = 444;
    FlutterVisibility flutter_visibility = 445;
    FlutterVisibilityNamedMaintain flutter_visibility_named_maintain = 446;
    FlutterWidgetInspector flutter_widget_inspector = 447;
    FlutterWidgetSpan flutter_widget_span = 448;
    FlutterWidgetToRenderBoxAdapter flutter_widget_to_render_box_adapter = 449;
    FlutterWidgetsApp flutter_widgets_app = 450;
    FlutterWidgetsAppNamedRouter flutter_widgets_app_named_router = 451;
    FlutterWrap flutter_wrap = 452;
    MaterialAboutDialog material_about_dialog = 453;
    MaterialAboutListTile material_about_list_tile = 454;
    MaterialActionChip material_action_chip = 455;
    MaterialActionChipNamedElevated material_action_chip_named_elevated = 456;
    MaterialActionIconTheme material_action_icon_theme = 457;
    MaterialAdaptiveTextSelectionToolbar material_adaptive_text_selection_toolbar = 458;
    MaterialAdaptiveTextSelectionToolbarNamedButtonItems material_adaptive_text_selection_toolbar_named_button_items = 459;
    MaterialAdaptiveTextSelectionToolbarNamedEditable material_adaptive_text_selection_toolbar_named_editable = 460;
    MaterialAdaptiveTextSelectionToolbarNamedEditableText material_adaptive_text_selection_toolbar_named_editable_text = 461;
    MaterialAdaptiveTextSelectionToolbarNamedSelectableRegion material_adaptive_text_selection_toolbar_named_selectable_region = 462;
    MaterialAlertDialog material_alert_dialog = 463;
    MaterialAlertDialogNamedAdaptive material_alert_dialog_named_adaptive = 464;
    MaterialAnimatedTheme material_animated_theme = 465;
    MaterialAppBar material_app_bar = 466;
    MaterialBackButton material_back_button = 467;
    MaterialBackButtonIcon material_back_button_icon = 468;
    MaterialBadge material_badge = 469;
    MaterialBadgeNamedCount material_badge_named_count = 470;
    MaterialBadgeTheme material_badge_theme = 471;
    MaterialBottomAppBar material_bottom_app_bar = 472;
    MaterialBottomNavigationBar material_bottom_navigation_bar = 473;
    MaterialBottomNavigationBarTheme material_bottom_navigation_bar_theme = 474;
    MaterialButtonBar material_button_bar = 475;
    MaterialButtonBarTheme material_button_bar_theme = 476;
    MaterialButtonTheme material_button_theme = 477;
    MaterialButtonThemeNamedFromButtonThemeData material_button_theme_named_from_button_theme_data = 478;
    MaterialCard material_card = 479;
    MaterialCardNamedFilled material_card_named_filled = 480;
    MaterialCardNamedOutlined material_card_named_outlined = 481;
    MaterialCheckbox material_checkbox = 482;
    MaterialCheckboxListTile material_checkbox_list_tile = 483;
    MaterialCheckboxListTileNamedAdaptive material_checkbox_list_tile_named_adaptive = 484;
    MaterialCheckboxMenuButton material_checkbox_menu_button = 485;
    MaterialCheckboxNamedAdaptive material_checkbox_named_adaptive = 486;
    MaterialCheckboxTheme material_checkbox_theme = 487;
    MaterialCheckedPopupMenuItem material_checked_popup_menu_item = 488;
    MaterialChip material_chip = 489;
    MaterialChipTheme material_chip_theme = 490;
    MaterialChoiceChip material_choice_chip = 491;
    MaterialChoiceChipNamedElevated material_choice_chip_named_elevated = 492;
    MaterialCircleAvatar material_circle_avatar = 493;
    MaterialCircularProgressIndicator material_circular_progress_indicator = 494;
    MaterialCircularProgressIndicatorNamedAdaptive material_circular_progress_indicator_named_adaptive = 495;
    MaterialCloseButton material_close_button = 496;
    MaterialCloseButtonIcon material_close_button_icon = 497;
    MaterialDataTable material_data_table = 498;
    MaterialDataTableTheme material_data_table_theme = 499;
    MaterialDatePickerDialog material_date_picker_dialog = 500;
    MaterialDatePickerTheme material_date_picker_theme = 501;
    MaterialDateRangePickerDialog material_date_range_picker_dialog = 502;
    MaterialDefaultTabController material_default_tab_controller = 503;
    MaterialDesktopTextSelectionToolbar material_desktop_text_selection_toolbar = 504;
    MaterialDesktopTextSelectionToolbarButton material_desktop_text_selection_toolbar_button = 505;
    MaterialDesktopTextSelectionToolbarButtonNamedText material_desktop_text_selection_toolbar_button_named_text = 506;
    MaterialDialog material_dialog = 507;
    MaterialDialogNamedFullscreen material_dialog_named_fullscreen = 508;
    MaterialDivider material_divider = 509;
    MaterialDividerTheme material_divider_theme = 510;
    MaterialDrawer material_drawer = 511;
    MaterialDrawerButton material_drawer_button = 512;
    MaterialDrawerButtonIcon material_drawer_button_icon = 513;
    MaterialDrawerController material_drawer_controller = 514;
    MaterialDrawerHeader material_drawer_header = 515;
    MaterialDrawerTheme material_drawer_theme = 516;
    MaterialDropdownButton material_dropdown_button = 517;
    MaterialDropdownButtonFormField material_dropdown_button_form_field = 518;
    MaterialDropdownButtonHideUnderline material_dropdown_button_hide_underline = 519;
    MaterialDropdownMenuItem material_dropdown_menu_item = 520;
    MaterialDropdownMenuTheme material_dropdown_menu_theme = 521;
    MaterialElevatedButton material_elevated_button = 522;
    MaterialElevatedButtonNamedIcon material_elevated_button_named_icon = 523;
    MaterialElevatedButtonTheme material_elevated_button_theme = 524;
    MaterialEndDrawerButton material_end_drawer_button = 525;
    MaterialEndDrawerButtonIcon material_end_drawer_button_icon = 526;
    MaterialExpandIcon material_expand_icon = 527;
    MaterialExpansionPanelList material_expansion_panel_list = 528;
    MaterialExpansionPanelListNamedRadio material_expansion_panel_list_named_radio = 529;
    MaterialExpansionTile material_expansion_tile = 530;
    MaterialExpansionTileTheme material_expansion_tile_theme = 531;
    MaterialFilledButton material_filled_button = 532;
    MaterialFilledButtonNamedIcon material_filled_button_named_icon = 533;
    MaterialFilledButtonNamedTonal material_filled_button_named_tonal = 534;
    MaterialFilledButtonNamedTonalIcon material_filled_button_named_tonal_icon = 535;
    MaterialFilledButtonTheme material_filled_button_theme = 536;
    MaterialFilterChip material_filter_chip = 537;
    MaterialFilterChipNamedElevated material_filter_chip_named_elevated = 538;
    MaterialFlexibleSpaceBar material_flexible_space_bar = 539;
    MaterialFlexibleSpaceBarSettings material_flexible_space_bar_settings = 540;
    MaterialFloatingActionButton material_floating_action_button = 541;
    MaterialFloatingActionButtonNamedExtended material_floating_action_button_named_extended = 542;
    MaterialFloatingActionButtonNamedLarge material_floating_action_button_named_large = 543;
    MaterialFloatingActionButtonNamedSmall material_floating_action_button_named_small = 544;
    MaterialFlutterLogo material_flutter_logo = 545;
    MaterialGridTile material_grid_tile = 546;
    MaterialGridTileBar material_grid_tile_bar = 547;
    MaterialIconButton material_icon_button = 548;
    MaterialIconButtonNamedFilled material_icon_button_named_filled = 549;
    MaterialIconButtonNamedFilledTonal material_icon_button_named_filled_tonal = 550;
    MaterialIconButtonNamedOutlined material_icon_button_named_outlined = 551;
    MaterialIconButtonTheme material_icon_button_theme = 552;
    MaterialInk material_ink = 553;
    MaterialInkResponse material_ink_response = 554;
    MaterialInkWell material_ink_well = 555;
    MaterialInputChip material_input_chip = 556;
    MaterialInputDatePickerFormField material_input_date_picker_form_field = 557;
    MaterialInputDecorator material_input_decorator = 558;
    MaterialLicensePage material_license_page = 559;
    MaterialLinearProgressIndicator material_linear_progress_indicator = 560;
    MaterialListTile material_list_tile = 561;
    MaterialListTileTheme material_list_tile_theme = 562;
    MaterialMagnifier material_magnifier = 563;
    MaterialMaterial material_material = 564;
    MaterialMaterialApp material_material_app = 565;
    MaterialMaterialAppNamedRouter material_material_app_named_router = 566;
    MaterialMaterialBanner material_material_banner = 567;
    MaterialMaterialBannerTheme material_material_banner_theme = 568;
    MaterialMaterialButton material_material_button = 569;
    MaterialMenuAcceleratorCallbackBinding material_menu_accelerator_callback_binding = 570;
    MaterialMenuAcceleratorLabel material_menu_accelerator_label = 571;
    MaterialMenuAnchor material_menu_anchor = 572;
    MaterialMenuBar material_menu_bar = 573;
    MaterialMenuBarTheme material_menu_bar_theme = 574;
    MaterialMenuButtonTheme material_menu_button_theme = 575;
    MaterialMenuItemButton material_menu_item_button = 576;
    MaterialMenuTheme material_menu_theme = 577;
    MaterialMergeableMaterial material_mergeable_material = 578;
    MaterialNavigationBar material_navigation_bar = 579;
    MaterialNavigationBarTheme material_navigation_bar_theme = 580;
    MaterialNavigationDestination material_navigation_destination = 581;
    MaterialNavigationDrawer material_navigation_drawer = 582;
    MaterialNavigationDrawerDestination material_navigation_drawer_destination = 583;
    MaterialNavigationDrawerTheme material_navigation_drawer_theme = 584;
    MaterialNavigationRail material_navigation_rail = 585;
    MaterialNavigationRailTheme material_navigation_rail_theme = 586;
    MaterialOutlinedButton material_outlined_button = 587;
    MaterialOutlinedButtonNamedIcon material_outlined_button_named_icon = 588;
    MaterialOutlinedButtonTheme material_outlined_button_theme = 589;
    MaterialPaginatedDataTable material_paginated_data_table = 590;
    MaterialPopupMenuDivider material_popup_menu_divider = 591;
    MaterialPopupMenuItem material_popup_menu_item = 592;
    MaterialPopupMenuTheme material_popup_menu_theme = 593;
    MaterialProgressIndicatorTheme material_progress_indicator_theme = 594;
    MaterialRadioTheme material_radio_theme = 595;
    MaterialRangeSlider material_range_slider = 596;
    MaterialRawChip material_raw_chip = 597;
    MaterialRawMaterialButton material_raw_material_button = 598;
    MaterialRefreshProgressIndicator material_refresh_progress_indicator = 599;
    MaterialScaffold material_scaffold = 600;
    MaterialScaffoldMessenger material_scaffold_messenger = 601;
    MaterialScrollbar material_scrollbar = 602;
    MaterialScrollbarTheme material_scrollbar_theme = 603;
    MaterialSearchBar material_search_bar = 604;
    MaterialSearchBarTheme material_search_bar_theme = 605;
    MaterialSearchViewTheme material_search_view_theme = 606;
    MaterialSegmentedButtonTheme material_segmented_button_theme = 607;
    MaterialSelectableText material_selectable_text = 608;
    MaterialSelectableTextNamedRich material_selectable_text_named_rich = 609;
    MaterialSelectionArea material_selection_area = 610;
    MaterialSimpleDialog material_simple_dialog = 611;
    MaterialSimpleDialogOption material_simple_dialog_option = 612;
    MaterialSlider material_slider = 613;
    MaterialSliderNamedAdaptive material_slider_named_adaptive = 614;
    MaterialSliderTheme material_slider_theme = 615;
    MaterialSliverAppBar material_sliver_app_bar = 616;
    MaterialSliverAppBarNamedLarge material_sliver_app_bar_named_large = 617;
    MaterialSliverAppBarNamedMedium material_sliver_app_bar_named_medium = 618;
    MaterialSnackBar material_snack_bar = 619;
    MaterialSpellCheckSuggestionsToolbar material_spell_check_suggestions_toolbar = 620;
    MaterialSpellCheckSuggestionsToolbarNamedEditableText material_spell_check_suggestions_toolbar_named_editable_text = 621;
    MaterialStepper material_stepper = 622;
    MaterialSubmenuButton material_submenu_button = 623;
    MaterialSwitch material_switch = 624;
    MaterialSwitchListTile material_switch_list_tile = 625;
    MaterialSwitchListTileNamedAdaptive material_switch_list_tile_named_adaptive = 626;
    MaterialSwitchNamedAdaptive material_switch_named_adaptive = 627;
    MaterialSwitchTheme material_switch_theme = 628;
    MaterialTab material_tab = 629;
    MaterialTabBar material_tab_bar = 630;
    MaterialTabBarNamedSecondary material_tab_bar_named_secondary = 631;
    MaterialTabBarView material_tab_bar_view = 632;
    MaterialTabPageSelector material_tab_page_selector = 633;
    MaterialTabPageSelectorIndicator material_tab_page_selector_indicator = 634;
    MaterialTableRowInkWell material_table_row_ink_well = 635;
    MaterialTextButton material_text_button = 636;
    MaterialTextButtonNamedIcon material_text_button_named_icon = 637;
    MaterialTextButtonTheme material_text_button_theme = 638;
    MaterialTextField material_text_field = 639;
    MaterialTextFormField material_text_form_field = 640;
    MaterialTextSelectionTheme material_text_selection_theme = 641;
    MaterialTextSelectionToolbar material_text_selection_toolbar = 642;
    MaterialTextSelectionToolbarTextButton material_text_selection_toolbar_text_button = 643;
    MaterialTheme material_theme = 644;
    MaterialTimePickerDialog material_time_picker_dialog = 645;
    MaterialTimePickerTheme material_time_picker_theme = 646;
    MaterialToggleButtons material_toggle_buttons = 647;
    MaterialToggleButtonsTheme material_toggle_buttons_theme = 648;
    MaterialTooltip material_tooltip = 649;
    MaterialTooltipTheme material_tooltip_theme = 650;
    MaterialTooltipVisibility material_tooltip_visibility = 651;
    MaterialUserAccountsDrawerHeader material_user_accounts_drawer_header = 652;
    MaterialVerticalDivider material_vertical_divider = 653;
  }
}

// package:flutter/src/foundation/diagnostics.dart
//
// Defines diagnostics data for a [value].
//
// For debug and profile modes, [DiagnosticsNode] provides a high quality
// multiline string dump via [toStringDeep]. The core members are the [name],
// [toDescription], [getProperties], [value], and [getChildren]. All other
// members exist typically to provide hints for how [toStringDeep] and
// debugging tools should format output.
//
// In release mode, far less information is retained and some information may
// not print at all.
message FlutterDiagnosticsNodeType {
  oneof constructor {
    FlutterColorProperty flutter_color_property = 2;
    FlutterDevToolsDeepLinkProperty flutter_dev_tools_deep_link_property = 3;
    FlutterDiagnosticableTreeNode flutter_diagnosticable_tree_node = 4;
    FlutterDiagnosticsBlock flutter_diagnostics_block = 5;
    FlutterDiagnosticsNodeNamedMessage flutter_diagnostics_node_named_message = 6;
    FlutterDiagnosticsStackTrace flutter_diagnostics_stack_trace = 7;
    FlutterDiagnosticsStackTraceNamedSingleFrame flutter_diagnostics_stack_trace_named_single_frame = 8;
    FlutterDoubleProperty flutter_double_property = 9;
    FlutterErrorDescription flutter_error_description = 10;
    FlutterErrorHint flutter_error_hint = 11;
    FlutterErrorSpacer flutter_error_spacer = 12;
    FlutterErrorSummary flutter_error_summary = 13;
    FlutterFlagProperty flutter_flag_property = 14;
    FlutterIconDataProperty flutter_icon_data_property = 15;
    FlutterIntProperty flutter_int_property = 16;
    FlutterIterableProperty flutter_iterable_property = 17;
    FlutterMessageProperty flutter_message_property = 18;
    FlutterPercentProperty flutter_percent_property = 19;
    FlutterSrcSemanticsAttributedStringProperty flutter_src_semantics_attributed_string_property = 20;
    FlutterStringProperty flutter_string_property = 21;
    FlutterTransformProperty flutter_transform_property = 22;
  }
}

// package:flutter/src/painting/edge_insets.dart
//
// An immutable set of offsets in each of the four cardinal directions, but
// whose horizontal components are dependent on the writing direction.
//
// This can be used to indicate padding from the left in [TextDirection.ltr]
// text and padding from the right in [TextDirection.rtl] text without having
// to be aware of the current text direction.
//
// See also:
//
//  * [EdgeInsets], a variant that uses physical labels (left and right instead
//    of start and end).
message FlutterEdgeInsetsDirectionalType {
  oneof constructor {
    FlutterEdgeInsetsDirectionalNamedAll flutter_edge_insets_directional_named_all = 2;
    FlutterEdgeInsetsDirectionalNamedFromSTEB flutter_edge_insets_directional_named_from_s_t_e_b = 3;
    FlutterEdgeInsetsDirectionalNamedOnly flutter_edge_insets_directional_named_only = 4;
    FlutterEdgeInsetsDirectionalNamedSymmetric flutter_edge_insets_directional_named_symmetric = 5;
  }
}

// package:flutter/src/painting/edge_insets.dart
//
// Base class for [EdgeInsets] that allows for text-direction aware
// resolution.
//
// A property or argument of this type accepts classes created either with [
// EdgeInsets.fromLTRB] and its variants, or [
// EdgeInsetsDirectional.fromSTEB] and its variants.
//
// To convert an [EdgeInsetsGeometry] object of indeterminate type into a
// [EdgeInsets] object, call the [resolve] method.
//
// See also:
//
//  * [Padding], a widget that describes margins using [EdgeInsetsGeometry].
message FlutterEdgeInsetsGeometryType {
  oneof constructor {
    FlutterEdgeInsetsDirectionalNamedAll flutter_edge_insets_directional_named_all = 2;
    FlutterEdgeInsetsDirectionalNamedFromSTEB flutter_edge_insets_directional_named_from_s_t_e_b = 3;
    FlutterEdgeInsetsDirectionalNamedOnly flutter_edge_insets_directional_named_only = 4;
    FlutterEdgeInsetsDirectionalNamedSymmetric flutter_edge_insets_directional_named_symmetric = 5;
    FlutterEdgeInsetsNamedAll flutter_edge_insets_named_all = 6;
    FlutterEdgeInsetsNamedFromLTRB flutter_edge_insets_named_from_l_t_r_b = 7;
    FlutterEdgeInsetsNamedFromViewPadding flutter_edge_insets_named_from_view_padding = 8;
    FlutterEdgeInsetsNamedOnly flutter_edge_insets_named_only = 9;
    FlutterEdgeInsetsNamedSymmetric flutter_edge_insets_named_symmetric = 10;
  }
}

// package:flutter/src/painting/edge_insets.dart
//
// An immutable set of offsets in each of the four cardinal directions.
//
// Typically used for an offset from each of the four sides of a box. For
// example, the padding inside a box can be represented using this class.
//
// The [EdgeInsets] class specifies offsets in terms of visual edges, left,
// top, right, and bottom. These values are not affected by the
// [TextDirection]. To support both left-to-right and right-to-left layouts,
// consider using [EdgeInsetsDirectional], which is expressed in terms of
// _start_, top, _end_, and bottom, where start and end are resolved in terms
// of a [TextDirection] (typically obtained from the ambient [Directionality]).
//
// {@tool snippet}
//
// Here are some examples of how to create [EdgeInsets] instances:
//
// Typical eight-pixel margin on all sides:
//
// ```dart
// const EdgeInsets.all(8.0)
// ```
// {@end-tool}
// {@tool snippet}
//
// Eight pixel margin above and below, no horizontal margins:
//
// ```dart
// const EdgeInsets.symmetric(vertical: 8.0)
// ```
// {@end-tool}
// {@tool snippet}
//
// Left margin indent of 40 pixels:
//
// ```dart
// const EdgeInsets.only(left: 40.0)
// ```
// {@end-tool}
//
// See also:
//
//  * [Padding], a widget that accepts [EdgeInsets] to describe its margins.
//  * [EdgeInsetsDirectional], which (for properties and arguments that accept
//    the type [EdgeInsetsGeometry]) allows the horizontal insets to be
//    specified in a [TextDirection]-aware manner.
message FlutterEdgeInsetsType {
  oneof constructor {
    FlutterEdgeInsetsNamedAll flutter_edge_insets_named_all = 2;
    FlutterEdgeInsetsNamedFromLTRB flutter_edge_insets_named_from_l_t_r_b = 3;
    FlutterEdgeInsetsNamedFromViewPadding flutter_edge_insets_named_from_view_padding = 4;
    FlutterEdgeInsetsNamedOnly flutter_edge_insets_named_only = 5;
    FlutterEdgeInsetsNamedSymmetric flutter_edge_insets_named_symmetric = 6;
  }
}

// package:flutter/src/widgets/editable_text.dart
//
// State for a [EditableText].
message FlutterEditableTextStateType {
  oneof constructor {
    FlutterEditableTextState flutter_editable_text_state = 2;
  }
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// A controller for scroll views whose items have the same size.
//
// Similar to a standard [ScrollController] but with the added convenience
// mechanisms to read and go to item indices rather than a raw pixel scroll
// offset.
//
// See also:
//
//  * [ListWheelScrollView], a scrollable view widget with fixed size items
//    that this widget controls.
//  * [FixedExtentMetrics], the `metrics` property exposed by
//    [ScrollNotification] from [ListWheelScrollView] which can be used
//    to listen to the current item index on a push basis rather than polling
//    the [FixedExtentScrollController].
message FlutterFixedExtentScrollControllerType {
  oneof constructor {
    FlutterFixedExtentScrollController flutter_fixed_extent_scroll_controller = 2;
  }
}

// package:flutter/src/foundation/assertions.dart
//
// Error class used to report Flutter-specific assertion failures and
// contract violations.
//
// See also:
//
//  * <https://flutter.dev/docs/testing/errors>, more information about error
//    handling in Flutter.
message FlutterFlutterErrorType {
  oneof constructor {
    FlutterFlutterError flutter_flutter_error = 2;
    FlutterFlutterErrorNamedFromParts flutter_flutter_error_named_from_parts = 3;
  }
}

// package:flutter/src/widgets/focus_manager.dart
//
// An object that can be used by a stateful widget to obtain the keyboard focus
// and to handle keyboard events.
//
// _Please see the [Focus] and [FocusScope] widgets, which are utility widgets
// that manage their own [FocusNode]s and [FocusScopeNode]s, respectively. If
// they aren't appropriate, [FocusNode]s can be managed directly, but doing this
// is rare._
//
// [FocusNode]s are persistent objects that form a _focus tree_ that is a
// representation of the widgets in the hierarchy that are interested in focus.
// A focus node might need to be created if it is passed in from an ancestor of
// a [Focus] widget to control the focus of the children from the ancestor, or
// a widget might need to host one if the widget subsystem is not being used,
// or if the [Focus] and [FocusScope] widgets provide insufficient control.
//
// [FocusNode]s are organized into _scopes_ (see [FocusScopeNode]), which form
// sub-trees of nodes that restrict traversal to a group of nodes. Within a
// scope, the most recent nodes to have focus are remembered, and if a node is
// focused and then unfocused, the previous node receives focus again.
//
// The focus node hierarchy can be traversed using the [parent], [children],
// [ancestors] and [descendants] accessors.
//
// [FocusNode]s are [ChangeNotifier]s, so a listener can be registered to
// receive a notification when the focus changes. Listeners will also be
// notified when [skipTraversal], [canRequestFocus], [descendantsAreFocusable],
// and [descendantsAreTraversable] properties are updated. If the [Focus] and
// [FocusScope] widgets are being used to manage the nodes, consider
// establishing an [InheritedWidget] dependency on them by calling [Focus.of]
// or [FocusScope.of] instead. [FocusNode.hasFocus] can also be used to
// establish a similar dependency, especially if all that is needed is to
// determine whether or not the widget is focused at build time.
//
// To see the focus tree in the debug console, call [debugDumpFocusTree]. To
// get the focus tree as a string, call [debugDescribeFocusTree].
//
// {@template flutter.widgets.FocusNode.lifecycle}
// ## Lifecycle
//
// There are several actors involved in the lifecycle of a
// [FocusNode]/[FocusScopeNode]. They are created and disposed by their
// _owner_, attached, detached, and re-parented using a [FocusAttachment] by
// their _host_ (which must be owned by the [State] of a [StatefulWidget]), and
// they are managed by the [FocusManager]. Different parts of the [FocusNode]
// API are intended for these different actors.
//
// [FocusNode]s (and hence [FocusScopeNode]s) are persistent objects that form
// part of a _focus tree_ that is a sparse representation of the widgets in the
// hierarchy that are interested in receiving keyboard events. They must be
// managed like other persistent state, which is typically done by a
// [StatefulWidget] that owns the node. A stateful widget that owns a focus
// scope node must call [dispose] from its [State.dispose] method.
//
// Once created, a [FocusNode] must be attached to the widget tree via a
// [FocusAttachment] object. This attachment is created by calling [attach],
// usually from the [State.initState] method. If the hosting widget is updated
// to have a different focus node, then the updated node needs to be attached
// in [State.didUpdateWidget], after calling [FocusAttachment.detach] on the
// previous [FocusAttachment].
//
// Because [FocusNode]s form a sparse representation of the widget tree, they
// must be updated whenever the widget tree is rebuilt. This is done by calling
// [FocusAttachment.reparent], usually from the [State.build] or
// [State.didChangeDependencies] methods of the widget that represents the
// focused region, so that the [BuildContext] assigned to the [FocusScopeNode]
// can be tracked (the context is used to obtain the [RenderObject], from which
// the geometry of focused regions can be determined).
//
// Creating a [FocusNode] each time [State.build] is invoked will cause the
// focus to be lost each time the widget is built, which is usually not desired
// behavior (call [unfocus] if losing focus is desired).
//
// If, as is common, the hosting [StatefulWidget] is also the owner of the
// focus node, then it will also call [dispose] from its [State.dispose] (in
// which case the [FocusAttachment.detach] may be skipped, since dispose will
// automatically detach). If another object owns the focus node, then it must
// call [dispose] when the node is done being used.
// {@endtemplate}
//
// {@template flutter.widgets.FocusNode.keyEvents}
// ## Key Event Propagation
//
// The [FocusManager] receives key events from [HardwareKeyboard] and will pass
// them to the focused nodes. It starts with the node with the primary focus,
// and will call the [onKeyEvent] callback for that node. If the callback
// returns [KeyEventResult.ignored], indicating that it did not handle the
// event, the [FocusManager] will move to the parent of that node and call its
// [onKeyEvent]. If that [onKeyEvent] returns [KeyEventResult.handled], then it
// will stop propagating the event. If it reaches the root [FocusScopeNode],
// [FocusManager.rootScope], the event is discarded.
// {@endtemplate}
//
// ## Focus Traversal
//
// The term _traversal_, sometimes called _tab traversal_, refers to moving the
// focus from one widget to the next in a particular order (also sometimes
// referred to as the _tab order_, since the TAB key is often bound to the
// action to move to the next widget).
//
// To give focus to the logical _next_ or _previous_ widget in the UI, call the
// [nextFocus] or [previousFocus] methods. To give the focus to a widget in a
// particular direction, call the [focusInDirection] method.
//
// The policy for what the _next_ or _previous_ widget is, or the widget in a
// particular direction, is determined by the [FocusTraversalPolicy] in force.
//
// The ambient policy is determined by looking up the widget hierarchy for a
// [FocusTraversalGroup] widget, and obtaining the focus traversal policy from
// it. Different focus nodes can inherit difference policies, so part of the
// app can go in a predefined order (using [OrderedTraversalPolicy]), and part
// can go in reading order (using [ReadingOrderTraversalPolicy]), depending
// upon the use case.
//
// Predefined policies include [WidgetOrderTraversalPolicy],
// [ReadingOrderTraversalPolicy], [OrderedTraversalPolicy], and
// [DirectionalFocusTraversalPolicyMixin], but custom policies can be built
// based upon these policies. See [FocusTraversalPolicy] for more information.
//
// {@tool dartpad}
// This example shows how a FocusNode should be managed if not using the
// [Focus] or [FocusScope] widgets. See the [Focus] widget for a similar
// example using [Focus] and [FocusScope] widgets.
//
// ** See code in examples/api/lib/widgets/focus_manager/focus_node.0.dart **
// {@end-tool}
//
// See also:
//
// * [Focus], a widget that manages a [FocusNode] and provides access to focus
//   information and actions to its descendant widgets.
// * [FocusTraversalGroup], a widget used to group together and configure the
//   focus traversal policy for a widget subtree.
// * [FocusManager], a singleton that manages the primary focus and distributes
//   key events to focused nodes.
// * [FocusTraversalPolicy], a class used to determine how to move the focus to
//   other nodes.
message FlutterFocusNodeType {
  oneof constructor {
    FlutterFocusNode flutter_focus_node = 2;
    FlutterFocusScopeNode flutter_focus_scope_node = 3;
  }
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Base class for all sort orders for [OrderedTraversalPolicy] traversal.
//
// {@template flutter.widgets.FocusOrder.comparable}
// Only orders of the same type are comparable. If a set of widgets in the same
// [FocusTraversalGroup] contains orders that are not comparable with each
// other, it will assert, since the ordering between such keys is undefined. To
// avoid collisions, use a [FocusTraversalGroup] to group similarly ordered
// widgets together.
//
// When overriding, [FocusOrder.doCompare] must be overridden instead of
// [FocusOrder.compareTo], which calls [FocusOrder.doCompare] to do the actual
// comparison.
// {@endtemplate}
//
// See also:
//
// * [FocusTraversalGroup], a widget that groups together and imposes a
//   traversal policy on the [Focus] nodes below it in the widget hierarchy.
// * [FocusTraversalOrder], a widget that assigns an order to a widget subtree
//   for the [OrderedTraversalPolicy] to use.
// * [NumericFocusOrder], for a focus order that describes its order with a
//   `double`.
// * [LexicalFocusOrder], a focus order that assigns a string-based lexical
//   traversal order to a [FocusTraversalOrder] widget.
message FlutterFocusOrderType {
  oneof constructor {
    FlutterLexicalFocusOrder flutter_lexical_focus_order = 2;
    FlutterNumericFocusOrder flutter_numeric_focus_order = 3;
  }
}

// package:flutter/src/widgets/focus_manager.dart
//
// A subclass of [FocusNode] that acts as a scope for its descendants,
// maintaining information about which descendant is currently or was last
// focused.
//
// _Please see the [FocusScope] and [Focus] widgets, which are utility widgets
// that manage their own [FocusScopeNode]s and [FocusNode]s, respectively. If
// they aren't appropriate, [FocusScopeNode]s can be managed directly._
//
// [FocusScopeNode] organizes [FocusNode]s into _scopes_. Scopes form sub-trees
// of nodes that can be traversed as a group. Within a scope, the most recent
// nodes to have focus are remembered, and if a node is focused and then
// removed, the original node receives focus again.
//
// From a [FocusScopeNode], calling [setFirstFocus], sets the given focus scope
// as the [focusedChild] of this node, adopting if it isn't already part of the
// focus tree.
//
// {@macro flutter.widgets.FocusNode.lifecycle}
// {@macro flutter.widgets.FocusNode.keyEvents}
//
// See also:
//
//  * [Focus], a widget that manages a [FocusNode] and provides access to focus
//    information and actions to its descendant widgets.
//  * [FocusManager], a singleton that manages the primary focus and
//    distributes key events to focused nodes.
message FlutterFocusScopeNodeType {
  oneof constructor {
    FlutterFocusScopeNode flutter_focus_scope_node = 2;
  }
}

// package:flutter/src/widgets/focus_traversal.dart
//
// Determines how focusable widgets are traversed within a [FocusTraversalGroup].
//
// The focus traversal policy is what determines which widget is "next",
// "previous", or in a direction from the widget associated with the currently
// focused [FocusNode] (usually a [Focus] widget).
//
// One of the pre-defined subclasses may be used, or define a custom policy to
// create a unique focus order.
//
// When defining your own, your subclass should implement [sortDescendants] to
// provide the order in which you would like the descendants to be traversed.
//
// See also:
//
//  * [FocusNode], for a description of the focus system.
//  * [FocusTraversalGroup], a widget that groups together and imposes a
//    traversal policy on the [Focus] nodes below it in the widget hierarchy.
//  * [FocusNode], which is affected by the traversal policy.
//  * [WidgetOrderTraversalPolicy], a policy that relies on the widget
//    creation order to describe the order of traversal.
//  * [ReadingOrderTraversalPolicy], a policy that describes the order as the
//    natural "reading order" for the current [Directionality].
//  * [OrderedTraversalPolicy], a policy that describes the order
//    explicitly using [FocusTraversalOrder] widgets.
//  * [DirectionalFocusTraversalPolicyMixin] a mixin class that implements
//    focus traversal in a direction.
message FlutterFocusTraversalPolicyType {
  oneof constructor {
    FlutterOrderedTraversalPolicy flutter_ordered_traversal_policy = 2;
    FlutterReadingOrderTraversalPolicy flutter_reading_order_traversal_policy = 3;
    FlutterWidgetOrderTraversalPolicy flutter_widget_order_traversal_policy = 4;
  }
}

// package:flutter/src/gestures/recognizer.dart
//
// The base class that all gesture recognizers inherit from.
//
// Provides a basic API that can be used by classes that work with
// gesture recognizers but don't care about the specific details of
// the gestures recognizers themselves.
//
// See also:
//
//  * [GestureDetector], the widget that is used to detect built-in gestures.
//  * [RawGestureDetector], the widget that is used to detect custom gestures.
//  * [debugPrintRecognizerCallbacksTrace], a flag that can be set to help
//    debug issues with gesture recognizers.
message FlutterGestureRecognizerType {
  oneof constructor {
    FlutterDelayedMultiDragGestureRecognizer flutter_delayed_multi_drag_gesture_recognizer = 2;
    FlutterDoubleTapGestureRecognizer flutter_double_tap_gesture_recognizer = 3;
    FlutterEagerGestureRecognizer flutter_eager_gesture_recognizer = 4;
    FlutterForcePressGestureRecognizer flutter_force_press_gesture_recognizer = 5;
    FlutterHorizontalDragGestureRecognizer flutter_horizontal_drag_gesture_recognizer = 6;
    FlutterHorizontalMultiDragGestureRecognizer flutter_horizontal_multi_drag_gesture_recognizer = 7;
    FlutterImmediateMultiDragGestureRecognizer flutter_immediate_multi_drag_gesture_recognizer = 8;
    FlutterLongPressGestureRecognizer flutter_long_press_gesture_recognizer = 9;
    FlutterMultiTapGestureRecognizer flutter_multi_tap_gesture_recognizer = 10;
    FlutterPanGestureRecognizer flutter_pan_gesture_recognizer = 11;
    FlutterScaleGestureRecognizer flutter_scale_gesture_recognizer = 12;
    FlutterSerialTapGestureRecognizer flutter_serial_tap_gesture_recognizer = 13;
    FlutterTapAndHorizontalDragGestureRecognizer flutter_tap_and_horizontal_drag_gesture_recognizer = 14;
    FlutterTapAndPanGestureRecognizer flutter_tap_and_pan_gesture_recognizer = 15;
    FlutterTapGestureRecognizer flutter_tap_gesture_recognizer = 16;
    FlutterVerticalDragGestureRecognizer flutter_vertical_drag_gesture_recognizer = 17;
    FlutterVerticalMultiDragGestureRecognizer flutter_vertical_multi_drag_gesture_recognizer = 18;
  }
}

// package:flutter/src/painting/gradient.dart
//
// Base class for transforming gradient shaders without applying the same
// transform to the entire canvas.
//
// For example, a [SweepGradient] normally starts its gradation at 3 o'clock
// and draws clockwise. To have the sweep appear to start at 6 o'clock, supply
// a [GradientRotation] of `pi/4` radians (i.e. 45 degrees).
message FlutterGradientTransformType {
  oneof constructor {
    FlutterGradientRotation flutter_gradient_rotation = 2;
  }
}

// package:flutter/src/painting/gradient.dart
//
// A 2D gradient.
//
// This is an interface that allows [LinearGradient], [RadialGradient], and
// [SweepGradient] classes to be used interchangeably in [BoxDecoration]s.
//
// See also:
//
//  * [Gradient](dart-ui/Gradient-class.html), the class in the [dart:ui] library.
//
message FlutterGradientType {
  oneof constructor {
    FlutterLinearGradient flutter_linear_gradient = 2;
    FlutterRadialGradient flutter_radial_gradient = 3;
    FlutterSweepGradient flutter_sweep_gradient = 4;
  }
}

// package:flutter/src/widgets/heroes.dart
//
// A [Navigator] observer that manages [Hero] transitions.
//
// An instance of [HeroController] should be used in [Navigator.observers].
// This is done automatically by [MaterialApp].
message FlutterHeroControllerType {
  oneof constructor {
    FlutterHeroController flutter_hero_controller = 2;
  }
}

// package:flutter/src/widgets/icon_data.dart
//
// A description of an icon fulfilled by a font glyph.
//
// See [Icons] for a number of predefined icons available for material
// design applications.
//
// In release builds, the Flutter tool will tree shake out of bundled fonts
// the code points (or instances of [IconData]) which are not referenced from
// Dart app code. See the [staticIconProvider] annotation for more details.
message FlutterIconDataType {
  oneof constructor {
    FlutterIconData flutter_icon_data = 2;
  }
}

// package:flutter/src/widgets/icon_theme_data.dart
//
// Defines the size, font variations, color, opacity, and shadows of icons.
//
// Used by [IconTheme] to control those properties in a widget subtree.
//
// To obtain the current icon theme, use [IconTheme.of]. To convert an icon
// theme to a version with all the fields filled in, use
// [IconThemeData.fallback].
message FlutterIconThemeDataType {
  oneof constructor {
    CupertinoIconThemeData cupertino_icon_theme_data = 2;
    FlutterIconThemeData flutter_icon_theme_data = 3;
    FlutterIconThemeDataNamedFallback flutter_icon_theme_data_named_fallback = 4;
  }
}

// package:flutter/src/widgets/icon.dart
//
// A graphical icon widget drawn with a glyph from a font described in
// an [IconData] such as material's predefined [IconData]s in [Icons].
//
// Icons are not interactive. For an interactive icon, consider material's
// [IconButton].
//
// There must be an ambient [Directionality] widget when using [Icon].
// Typically this is introduced automatically by the [WidgetsApp] or
// [MaterialApp].
//
// This widget assumes that the rendered icon is squared. Non-squared icons may
// render incorrectly.
//
// {@tool snippet}
//
// This example shows how to create a [Row] of [Icon]s in different colors and
// sizes. The first [Icon] uses a [semanticLabel] to announce in accessibility
// modes like TalkBack and VoiceOver.
//
// ![The following code snippet would generate a row of icons consisting of a pink heart, a green musical note, and a blue umbrella, each progressively bigger than the last.](https://flutter.github.io/assets-for-api-docs/assets/widgets/icon.png)
//
// ```dart
// const Row(
//   mainAxisAlignment: MainAxisAlignment.spaceAround,
//   children: <Widget>[
//     Icon(
//       Icons.favorite,
//       color: Colors.pink,
//       size: 24.0,
//       semanticLabel: 'Text to announce in accessibility modes',
//     ),
//     Icon(
//       Icons.audiotrack,
//       color: Colors.green,
//       size: 30.0,
//     ),
//     Icon(
//       Icons.beach_access,
//       color: Colors.blue,
//       size: 36.0,
//     ),
//   ],
// )
// ```
// {@end-tool}
//
// See also:
//
//  * [IconButton], for interactive icons.
//  * [Icons], for the list of available Material Icons for use with this class.
//  * [IconTheme], which provides ambient configuration for icons.
//  * [ImageIcon], for showing icons from [AssetImage]s or other [ImageProvider]s.
message FlutterIconType {
  oneof constructor {
    FlutterIcon flutter_icon = 2;
  }
}

// package:flutter/src/painting/image_provider.dart
//
// Configuration information passed to the [ImageProvider.resolve] method to
// select a specific image.
//
// See also:
//
//  * [createLocalImageConfiguration], which creates an [ImageConfiguration]
//    based on ambient configuration in a [Widget] environment.
//  * [ImageProvider], which uses [ImageConfiguration] objects to determine
//    which image to obtain.
message FlutterImageConfigurationType {
  oneof constructor {
    FlutterImageConfiguration flutter_image_configuration = 2;
  }
}

// package:flutter/src/widgets/framework.dart
//
// Base class for widgets that efficiently propagate information down the tree.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=og-vJqLzg2c}
//
// To obtain the nearest instance of a particular type of inherited widget from
// a build context, use [BuildContext.dependOnInheritedWidgetOfExactType].
//
// Inherited widgets, when referenced in this way, will cause the consumer to
// rebuild when the inherited widget itself changes state.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=Zbm3hjPjQMk}
//
// {@tool snippet}
//
// The following is a skeleton of an inherited widget called `FrogColor`:
//
// ```dart
// class FrogColor extends InheritedWidget {
//   const FrogColor({
//     super.key,
//     required this.color,
//     required super.child,
//   });
//
//   final Color color;
//
//   static FrogColor? maybeOf(BuildContext context) {
//     return context.dependOnInheritedWidgetOfExactType<FrogColor>();
//   }
//
//   static FrogColor of(BuildContext context) {
//     final FrogColor? result = maybeOf(context);
//     assert(result != null, 'No FrogColor found in context');
//     return result!;
//   }
//
//   @override
//   bool updateShouldNotify(FrogColor oldWidget) => color != oldWidget.color;
// }
// ```
// {@end-tool}
//
// ## Implementing the `of` and `maybeOf` methods
//
// The convention is to provide two static methods, `of` and `maybeOf`, on the
// [InheritedWidget] which call
// [BuildContext.dependOnInheritedWidgetOfExactType]. This allows the class to
// define its own fallback logic in case there isn't a widget in scope.
//
// The `of` method typically returns a non-nullable instance and asserts if the
// [InheritedWidget] isn't found, and the `maybeOf` method returns a nullable
// instance, and returns null if the [InheritedWidget] isn't found. The `of`
// method is typically implemented by calling `maybeOf` internally.
//
// Sometimes, the `of` and `maybeOf` methods return some data rather than the
// inherited widget itself; for example, in this case it could have returned a
// [Color] instead of the `FrogColor` widget.
//
// Occasionally, the inherited widget is an implementation detail of another
// class, and is therefore private. The `of` and `maybeOf` methods in that case
// are typically implemented on the public class instead. For example, [Theme]
// is implemented as a [StatelessWidget] that builds a private inherited
// widget; [Theme.of] looks for that private inherited widget using
// [BuildContext.dependOnInheritedWidgetOfExactType] and then returns the
// [ThemeData] inside it.
//
// ## Calling the `of` or `maybeOf` methods
//
// When using the `of` or `maybeOf` methods, the `context` must be a descendant
// of the [InheritedWidget], meaning it must be "below" the [InheritedWidget]
// in the tree.
//
// {@tool snippet}
//
// In this example, the `context` used is the one from the [Builder], which is
// a child of the `FrogColor` widget, so this works.
//
// ```dart
// // continuing from previous example...
// class MyPage extends StatelessWidget {
//   const MyPage({super.key});
//
//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       body: FrogColor(
//         color: Colors.green,
//         child: Builder(
//           builder: (BuildContext innerContext) {
//             return Text(
//               'Hello Frog',
//               style: TextStyle(color: FrogColor.of(innerContext).color),
//             );
//           },
//         ),
//       ),
//     );
//   }
// }
// ```
// {@end-tool}
//
// {@tool snippet}
//
// In this example, the `context` used is the one from the `MyOtherPage`
// widget, which is a parent of the `FrogColor` widget, so this does not work,
// and will assert when `FrogColor.of` is called.
//
// ```dart
// // continuing from previous example...
//
// class MyOtherPage extends StatelessWidget {
//   const MyOtherPage({super.key});
//
//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       body: FrogColor(
//         color: Colors.green,
//         child: Text(
//           'Hello Frog',
//           style: TextStyle(color: FrogColor.of(context).color),
//         ),
//       ),
//     );
//   }
// }
// ```
// {@end-tool} {@youtube 560 315 https://www.youtube.com/watch?v=1t-8rBCGBYw}
//
// See also:
//
// * [StatefulWidget] and [State], for widgets that can build differently
//   several times over their lifetime.
// * [StatelessWidget], for widgets that always build the same way given a
//   particular configuration and ambient state.
// * [Widget], for an overview of widgets in general.
// * [InheritedNotifier], an inherited widget whose value can be a
//   [Listenable], and which will notify dependents whenever the value sends
//   notifications.
// * [InheritedModel], an inherited widget that allows clients to subscribe to
//   changes for subparts of the value.
message FlutterInheritedWidgetType {
  oneof constructor {
    CupertinoUserInterfaceLevel cupertino_user_interface_level = 2;
    FlutterDefaultAssetBundle flutter_default_asset_bundle = 3;
    FlutterDefaultSelectionStyle flutter_default_selection_style = 4;
    FlutterDefaultSelectionStyleNamedFallback flutter_default_selection_style_named_fallback = 5;
    FlutterDefaultTextHeightBehavior flutter_default_text_height_behavior = 6;
    FlutterDefaultTextStyle flutter_default_text_style = 7;
    FlutterDefaultTextStyleNamedFallback flutter_default_text_style_named_fallback = 8;
    FlutterDirectionality flutter_directionality = 9;
    FlutterFocusTraversalOrder flutter_focus_traversal_order = 10;
    FlutterHeroControllerScope flutter_hero_controller_scope = 11;
    FlutterHeroControllerScopeNamedNone flutter_hero_controller_scope_named_none = 12;
    FlutterIconTheme flutter_icon_theme = 13;
    FlutterLookupBoundary flutter_lookup_boundary = 14;
    FlutterMediaQuery flutter_media_query = 15;
    FlutterMediaQueryNamedRemovePadding flutter_media_query_named_remove_padding = 16;
    FlutterMediaQueryNamedRemoveViewInsets flutter_media_query_named_remove_view_insets = 17;
    FlutterMediaQueryNamedRemoveViewPadding flutter_media_query_named_remove_view_padding = 18;
    FlutterPrimaryScrollController flutter_primary_scroll_controller = 19;
    FlutterPrimaryScrollControllerNamedNone flutter_primary_scroll_controller_named_none = 20;
    FlutterScrollConfiguration flutter_scroll_configuration = 21;
    FlutterSelectionRegistrarScope flutter_selection_registrar_scope = 22;
    FlutterUnmanagedRestorationScope flutter_unmanaged_restoration_scope = 23;
    MaterialActionIconTheme material_action_icon_theme = 24;
    MaterialBadgeTheme material_badge_theme = 25;
    MaterialBottomNavigationBarTheme material_bottom_navigation_bar_theme = 26;
    MaterialButtonBarTheme material_button_bar_theme = 27;
    MaterialButtonTheme material_button_theme = 28;
    MaterialButtonThemeNamedFromButtonThemeData material_button_theme_named_from_button_theme_data = 29;
    MaterialCheckboxTheme material_checkbox_theme = 30;
    MaterialChipTheme material_chip_theme = 31;
    MaterialDataTableTheme material_data_table_theme = 32;
    MaterialDatePickerTheme material_date_picker_theme = 33;
    MaterialDividerTheme material_divider_theme = 34;
    MaterialDrawerTheme material_drawer_theme = 35;
    MaterialDropdownButtonHideUnderline material_dropdown_button_hide_underline = 36;
    MaterialDropdownMenuTheme material_dropdown_menu_theme = 37;
    MaterialElevatedButtonTheme material_elevated_button_theme = 38;
    MaterialExpansionTileTheme material_expansion_tile_theme = 39;
    MaterialFilledButtonTheme material_filled_button_theme = 40;
    MaterialFlexibleSpaceBarSettings material_flexible_space_bar_settings = 41;
    MaterialIconButtonTheme material_icon_button_theme = 42;
    MaterialListTileTheme material_list_tile_theme = 43;
    MaterialMaterialBannerTheme material_material_banner_theme = 44;
    MaterialMenuAcceleratorCallbackBinding material_menu_accelerator_callback_binding = 45;
    MaterialMenuBarTheme material_menu_bar_theme = 46;
    MaterialMenuButtonTheme material_menu_button_theme = 47;
    MaterialMenuTheme material_menu_theme = 48;
    MaterialNavigationBarTheme material_navigation_bar_theme = 49;
    MaterialNavigationDrawerTheme material_navigation_drawer_theme = 50;
    MaterialNavigationRailTheme material_navigation_rail_theme = 51;
    MaterialOutlinedButtonTheme material_outlined_button_theme = 52;
    MaterialPopupMenuTheme material_popup_menu_theme = 53;
    MaterialProgressIndicatorTheme material_progress_indicator_theme = 54;
    MaterialRadioTheme material_radio_theme = 55;
    MaterialScrollbarTheme material_scrollbar_theme = 56;
    MaterialSearchBarTheme material_search_bar_theme = 57;
    MaterialSearchViewTheme material_search_view_theme = 58;
    MaterialSegmentedButtonTheme material_segmented_button_theme = 59;
    MaterialSliderTheme material_slider_theme = 60;
    MaterialSwitchTheme material_switch_theme = 61;
    MaterialTextButtonTheme material_text_button_theme = 62;
    MaterialTextSelectionTheme material_text_selection_theme = 63;
    MaterialTimePickerTheme material_time_picker_theme = 64;
    MaterialToggleButtonsTheme material_toggle_buttons_theme = 65;
    MaterialTooltipTheme material_tooltip_theme = 66;
  }
}

// package:flutter/src/painting/inline_span.dart
//
// An immutable span of inline content which forms part of a paragraph.
//
//  * The subclass [TextSpan] specifies text and may contain child [InlineSpan]s.
//  * The subclass [PlaceholderSpan] represents a placeholder that may be
//    filled with non-text content. [PlaceholderSpan] itself defines a
//    [ui.PlaceholderAlignment] and a [TextBaseline]. To be useful,
//    [PlaceholderSpan] must be extended to define content. An instance of
//    this is the [WidgetSpan] class in the widgets library.
//  * The subclass [WidgetSpan] specifies embedded inline widgets.
//
// {@tool snippet}
//
// This example shows a tree of [InlineSpan]s that make a query asking for a
// name with a [TextField] embedded inline.
//
// ```dart
// Text.rich(
//   TextSpan(
//     text: 'My name is ',
//     style: const TextStyle(color: Colors.black),
//     children: <InlineSpan>[
//       WidgetSpan(
//         alignment: PlaceholderAlignment.baseline,
//         baseline: TextBaseline.alphabetic,
//         child: ConstrainedBox(
//           constraints: const BoxConstraints(maxWidth: 100),
//           child: const TextField(),
//         )
//       ),
//       const TextSpan(
//         text: '.',
//       ),
//     ],
//   ),
// )
// ```
// {@end-tool}
//
// See also:
//
//  * [Text], a widget for showing uniformly-styled text.
//  * [RichText], a widget for finer control of text rendering.
//  * [TextPainter], a class for painting [InlineSpan] objects on a [Canvas].
message FlutterInlineSpanType {
  oneof constructor {
    FlutterTextSpan flutter_text_span = 2;
    FlutterWidgetSpan flutter_widget_span = 3;
  }
}

// package:flutter/src/widgets/actions.dart
//
// An abstract class representing a particular configuration of an [Action].
//
// This class is what the [Shortcuts.shortcuts] map has as values, and is used
// by an [ActionDispatcher] to look up an action and invoke it, giving it this
// object to extract configuration information from.
//
// See also:
//
//  * [Shortcuts], a widget used to bind key combinations to [Intent]s.
//  * [Actions], a widget used to map [Intent]s to [Action]s.
//  * [Actions.invoke], which invokes the action associated with a specified
//    [Intent] using the [Actions] widget that most tightly encloses the given
//    [BuildContext].
message FlutterIntentType {
  oneof constructor {
    FlutterActivateIntent flutter_activate_intent = 2;
    FlutterAutocompleteNextOptionIntent flutter_autocomplete_next_option_intent = 3;
    FlutterAutocompletePreviousOptionIntent flutter_autocomplete_previous_option_intent = 4;
    FlutterButtonActivateIntent flutter_button_activate_intent = 5;
    FlutterCopySelectionTextIntentNamedCut flutter_copy_selection_text_intent_named_cut = 6;
    FlutterDeleteCharacterIntent flutter_delete_character_intent = 7;
    FlutterDeleteToLineBreakIntent flutter_delete_to_line_break_intent = 8;
    FlutterDeleteToNextWordBoundaryIntent flutter_delete_to_next_word_boundary_intent = 9;
    FlutterDirectionalFocusIntent flutter_directional_focus_intent = 10;
    FlutterDismissIntent flutter_dismiss_intent = 11;
    FlutterDoNothingAndStopPropagationIntent flutter_do_nothing_and_stop_propagation_intent = 12;
    FlutterDoNothingAndStopPropagationTextIntent flutter_do_nothing_and_stop_propagation_text_intent = 13;
    FlutterDoNothingIntent flutter_do_nothing_intent = 14;
    FlutterExpandSelectionToDocumentBoundaryIntent flutter_expand_selection_to_document_boundary_intent = 15;
    FlutterExpandSelectionToLineBreakIntent flutter_expand_selection_to_line_break_intent = 16;
    FlutterExtendSelectionByCharacterIntent flutter_extend_selection_by_character_intent = 17;
    FlutterExtendSelectionByPageIntent flutter_extend_selection_by_page_intent = 18;
    FlutterExtendSelectionToDocumentBoundaryIntent flutter_extend_selection_to_document_boundary_intent = 19;
    FlutterExtendSelectionToLineBreakIntent flutter_extend_selection_to_line_break_intent = 20;
    FlutterExtendSelectionToNextParagraphBoundaryIntent flutter_extend_selection_to_next_paragraph_boundary_intent = 21;
    FlutterExtendSelectionToNextParagraphBoundaryOrCaretLocationIntent flutter_extend_selection_to_next_paragraph_boundary_or_caret_location_intent = 22;
    FlutterExtendSelectionToNextWordBoundaryIntent flutter_extend_selection_to_next_word_boundary_intent = 23;
    FlutterExtendSelectionToNextWordBoundaryOrCaretLocationIntent flutter_extend_selection_to_next_word_boundary_or_caret_location_intent = 24;
    FlutterExtendSelectionVerticallyToAdjacentLineIntent flutter_extend_selection_vertically_to_adjacent_line_intent = 25;
    FlutterExtendSelectionVerticallyToAdjacentPageIntent flutter_extend_selection_vertically_to_adjacent_page_intent = 26;
    FlutterNextFocusIntent flutter_next_focus_intent = 27;
    FlutterPasteTextIntent flutter_paste_text_intent = 28;
    FlutterPreviousFocusIntent flutter_previous_focus_intent = 29;
    FlutterPrioritizedIntents flutter_prioritized_intents = 30;
    FlutterRedoTextIntent flutter_redo_text_intent = 31;
    FlutterReplaceTextIntent flutter_replace_text_intent = 32;
    FlutterRequestFocusIntent flutter_request_focus_intent = 33;
    FlutterScrollIntent flutter_scroll_intent = 34;
    FlutterScrollToDocumentBoundaryIntent flutter_scroll_to_document_boundary_intent = 35;
    FlutterSelectAllTextIntent flutter_select_all_text_intent = 36;
    FlutterSelectIntent flutter_select_intent = 37;
    FlutterTransposeCharactersIntent flutter_transpose_characters_intent = 38;
    FlutterUndoTextIntent flutter_undo_text_intent = 39;
    FlutterUpdateSelectionIntent flutter_update_selection_intent = 40;
  }
}

// package:flutter/src/foundation/key.dart
//
// A [Key] is an identifier for [Widget]s, [Element]s and [SemanticsNode]s.
//
// A new widget will only be used to update an existing element if its key is
// the same as the key of the current widget associated with the element.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=kn0EOS-ZiIc}
//
// Keys must be unique amongst the [Element]s with the same parent.
//
// Subclasses of [Key] should either subclass [LocalKey] or [GlobalKey].
//
// See also:
//
//  * [Widget.key], which discusses how widgets use keys.
message FlutterKeyType {
  oneof constructor {
    FlutterGlobalKey flutter_global_key = 2;
    FlutterKey flutter_key = 3;
    FlutterLabeledGlobalKey flutter_labeled_global_key = 4;
    FlutterObjectKey flutter_object_key = 5;
    FlutterUniqueKey flutter_unique_key = 6;
  }
}

// package:flutter/src/rendering/layer.dart
//
// An object that a [LeaderLayer] can register with.
//
// An instance of this class should be provided as the [LeaderLayer.link] and
// the [FollowerLayer.link] properties to cause the [FollowerLayer] to follow
// the [LeaderLayer].
//
// See also:
//
//  * [CompositedTransformTarget], the widget that creates a [LeaderLayer].
//  * [CompositedTransformFollower], the widget that creates a [FollowerLayer].
//  * [RenderLeaderLayer] and [RenderFollowerLayer], the corresponding
//    render objects.
message FlutterLayerLinkType {
  oneof constructor {
    FlutterLayerLink flutter_layer_link = 2;
  }
}

// package:flutter/src/widgets/framework.dart
//
// A superclass for [RenderObjectWidget]s that configure [RenderObject] subclasses
// that have no children.
//
// Subclasses must implement [createRenderObject] and [updateRenderObject].
message FlutterLeafRenderObjectWidgetType {
  oneof constructor {
    FlutterErrorWidgetNamedWithDetails flutter_error_widget_named_with_details = 2;
    FlutterPerformanceOverlay flutter_performance_overlay = 3;
    FlutterPerformanceOverlayNamedAllEnabled flutter_performance_overlay_named_all_enabled = 4;
    FlutterRawImage flutter_raw_image = 5;
    FlutterTexture flutter_texture = 6;
    FlutterWidgetToRenderBoxAdapter flutter_widget_to_render_box_adapter = 7;
  }
}

// package:flutter/src/painting/linear_border.dart
//
// Defines the relative size and alignment of one <LinearBorder> edge.
//
// A [LinearBorder] defines a box outline as zero to four edges, each
// of which is rendered as a single line. The width and color of the
// lines is defined by [LinearBorder.side].
//
// Each line's length is defined by [size], a value between 0.0 and 1.0
// (the default) which defines the length as a percentage of the
// length of a box edge.
//
// When [size] is less than 1.0, the line is aligned within the
// available space according to [alignment], a value between -1.0 and
// 1.0.  The default is 0.0, which means centered, -1.0 means align on the
// "start" side, and 1.0 means align on the "end" side. The meaning of
// start and end depend on the current [TextDirection], see
// [Directionality].
message FlutterLinearBorderEdgeType {
  oneof constructor {
    FlutterLinearBorderEdge flutter_linear_border_edge = 2;
  }
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// A delegate that supplies children for [ListWheelScrollView].
//
// [ListWheelScrollView] lazily constructs its children during layout to avoid
// creating more children than are visible through the [Viewport]. This
// delegate is responsible for providing children to [ListWheelScrollView]
// during that stage.
//
// See also:
//
//  * [ListWheelChildListDelegate], a delegate that supplies children using an
//    explicit list.
//  * [ListWheelChildLoopingListDelegate], a delegate that supplies infinite
//    children by looping an explicit list.
//  * [ListWheelChildBuilderDelegate], a delegate that supplies children using
//    a builder callback.
message FlutterListWheelChildDelegateType {
  oneof constructor {
    FlutterListWheelChildListDelegate flutter_list_wheel_child_list_delegate = 2;
    FlutterListWheelChildLoopingListDelegate flutter_list_wheel_child_looping_list_delegate = 3;
  }
}

// package:flutter/src/rendering/list_wheel_viewport.dart
//
// A delegate used by [RenderListWheelViewport] to manage its children.
//
// [RenderListWheelViewport] during layout will ask the delegate to create
// children that are visible in the viewport and remove those that are not.
message FlutterListWheelChildManagerType {
  oneof constructor {
    FlutterListWheelElement flutter_list_wheel_element = 2;
  }
}

// package:flutter/src/widgets/list_wheel_scroll_view.dart
//
// A viewport showing a subset of children on a wheel.
//
// Typically used with [ListWheelScrollView], this viewport is similar to
// [Viewport] in that it shows a subset of children in a scrollable based
// on the scrolling offset and the children's dimensions. But uses
// [RenderListWheelViewport] to display the children on a wheel.
//
// See also:
//
//  * [ListWheelScrollView], widget that combines this viewport with a scrollable.
//  * [RenderListWheelViewport], the render object that renders the children
//    on a wheel.
message FlutterListWheelViewportType {
  oneof constructor {
    FlutterListWheelViewport flutter_list_wheel_viewport = 2;
  }
}

// package:flutter/src/foundation/key.dart
//
// A key that is not a [GlobalKey].
//
// Keys must be unique amongst the [Element]s with the same parent. By
// contrast, [GlobalKey]s must be unique across the entire app.
//
// See also:
//
//  * [Widget.key], which discusses how widgets use keys.
message FlutterLocalKeyType {
  oneof constructor {
    FlutterObjectKey flutter_object_key = 2;
    FlutterUniqueKey flutter_unique_key = 3;
  }
}

// package:flutter/src/widgets/magnifier.dart
//
// A decoration for a [RawMagnifier].
//
// [MagnifierDecoration] does not expose [ShapeDecoration.color], [ShapeDecoration.image],
// or [ShapeDecoration.gradient], since they will be covered by the [RawMagnifier]'s lens.
//
// Also takes an [opacity] (see https://github.com/flutter/engine/pull/34435).
message FlutterMagnifierDecorationType {
  oneof constructor {
    FlutterMagnifierDecoration flutter_magnifier_decoration = 2;
  }
}

// package:flutter/src/widgets/media_query.dart
//
// Information about a piece of media (e.g., a window).
//
// For example, the [MediaQueryData.size] property contains the width and
// height of the current window.
//
// To obtain individual attributes in a [MediaQueryData], prefer to use the
// attribute-specific functions of [MediaQuery] over obtaining the entire
// [MediaQueryData] and accessing its members.
// {@macro flutter.widgets.media_query.MediaQuery.useSpecific}
//
// To obtain the entire current [MediaQueryData] for a given [BuildContext],
// use the [MediaQuery.of] function. This can be useful if you are going to use
// [copyWith] to replace the [MediaQueryData] with one with an updated
// property.
//
// ## Insets and Padding
//
// ![A diagram of padding, viewInsets, and viewPadding in correlation with each
// other](https://flutter.github.io/assets-for-api-docs/assets/widgets/media_query.png)
//
// This diagram illustrates how [padding] relates to [viewPadding] and
// [viewInsets], shown here in its simplest configuration, as the difference
// between the two. In cases when the viewInsets exceed the viewPadding, like
// when a software keyboard is shown below, padding goes to zero rather than a
// negative value. Therefore, padding is calculated by taking
// `max(0.0, viewPadding - viewInsets)`.
//
// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/widgets/window_padding.mp4}
//
// In this diagram, the black areas represent system UI that the app cannot
// draw over. The red area represents view padding that the application may not
// be able to detect gestures in and may not want to draw in. The grey area
// represents the system keyboard, which can cover over the bottom view padding
// when visible.
//
// MediaQueryData includes three [EdgeInsets] values:
// [padding], [viewPadding], and [viewInsets]. These values reflect the
// configuration of the device and are used and optionally consumed by widgets
// that position content within these insets. The padding value defines areas
// that might not be completely visible, like the display "notch" on the iPhone
// X. The viewInsets value defines areas that aren't visible at all, typically
// because they're obscured by the device's keyboard. Similar to viewInsets,
// viewPadding does not differentiate padding in areas that may be obscured.
// For example, by using the viewPadding property, padding would defer to the
// iPhone "safe area" regardless of whether a keyboard is showing.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=ceCo8U0XHqw}
//
// The viewInsets and viewPadding are independent values, they're
// measured from the edges of the MediaQuery widget's bounds. Together they
// inform the [padding] property. The bounds of the top level MediaQuery
// created by [WidgetsApp] are the same as the window that contains the app.
//
// Widgets whose layouts consume space defined by [viewInsets], [viewPadding],
// or [padding] should enclose their children in secondary MediaQuery
// widgets that reduce those properties by the same amount.
// The [removePadding], [removeViewPadding], and [removeViewInsets] methods are
// useful for this.
//
// See also:
//
//  * [Scaffold], [SafeArea], [CupertinoTabScaffold], and
//    [CupertinoPageScaffold], all of which are informed by [padding],
//    [viewPadding], and [viewInsets].
message FlutterMediaQueryDataType {
  oneof constructor {
    FlutterMediaQueryData flutter_media_query_data = 2;
    FlutterMediaQueryDataNamedFromView flutter_media_query_data_named_from_view = 3;
  }
}

// package:flutter/src/widgets/framework.dart
//
// A superclass for [RenderObjectWidget]s that configure [RenderObject] subclasses
// that have a single list of children. (This superclass only provides the
// storage for that child list, it doesn't actually provide the updating
// logic.)
//
// Subclasses must use a [RenderObject] that mixes in
// [ContainerRenderObjectMixin], which provides the necessary functionality to
// visit the children of the container render object (the render object
// belonging to the [children] widgets). Typically, subclasses will use a
// [RenderBox] that mixes in both [ContainerRenderObjectMixin] and
// [RenderBoxContainerDefaultsMixin].
//
// Subclasses must implement [createRenderObject] and [updateRenderObject].
//
// See also:
//
//  * [Stack], which uses [MultiChildRenderObjectWidget].
//  * [RenderStack], for an example implementation of the associated render
//    object.
//  * [SlottedMultiChildRenderObjectWidget], which configures a
//    [RenderObject] that instead of having a single list of children organizes
//    its children in named slots.
message FlutterMultiChildRenderObjectWidgetType {
  oneof constructor {
    FlutterColumn flutter_column = 2;
    FlutterCustomMultiChildLayout flutter_custom_multi_child_layout = 3;
    FlutterFlex flutter_flex = 4;
    FlutterFlow flutter_flow = 5;
    FlutterFlowNamedUnwrapped flutter_flow_named_unwrapped = 6;
    FlutterListBody flutter_list_body = 7;
    FlutterNestedScrollViewViewport flutter_nested_scroll_view_viewport = 8;
    FlutterOverflowBar flutter_overflow_bar = 9;
    FlutterRichText flutter_rich_text = 10;
    FlutterRow flutter_row = 11;
    FlutterShrinkWrappingViewport flutter_shrink_wrapping_viewport = 12;
    FlutterSliverCrossAxisGroup flutter_sliver_cross_axis_group = 13;
    FlutterSliverMainAxisGroup flutter_sliver_main_axis_group = 14;
    FlutterStack flutter_stack = 15;
    FlutterViewport flutter_viewport = 16;
    FlutterWrap flutter_wrap = 17;
  }
}

// package:flutter/src/widgets/navigator.dart
//
// An interface for observing the behavior of a [Navigator].
message FlutterNavigatorObserverType {
  oneof constructor {
    FlutterHeroController flutter_hero_controller = 2;
    FlutterNavigatorObserver flutter_navigator_observer = 3;
    FlutterRouteObserver flutter_route_observer = 4;
  }
}

// package:flutter/src/painting/notched_shapes.dart
//
// A shape with a notch in its outline.
//
// Typically used as the outline of a 'host' widget to make a notch that
// accommodates a 'guest' widget. e.g the [BottomAppBar] may have a notch to
// accommodate the [FloatingActionButton].
//
// See also:
//
//  * [ShapeBorder], which defines a shaped border without a dynamic notch.
//  * [AutomaticNotchedShape], an adapter from [ShapeBorder] to [NotchedShape].
message FlutterNotchedShapeType {
  oneof constructor {
    FlutterAutomaticNotchedShape flutter_automatic_notched_shape = 2;
    FlutterCircularNotchedRectangle flutter_circular_notched_rectangle = 3;
  }
}

// package:flutter/src/painting/borders.dart
//
// A ShapeBorder that draws an outline with the width and color specified
// by [side].
message FlutterOutlinedBorderType {
  oneof constructor {
    FlutterBeveledRectangleBorder flutter_beveled_rectangle_border = 2;
    FlutterCircleBorder flutter_circle_border = 3;
    FlutterContinuousRectangleBorder flutter_continuous_rectangle_border = 4;
    FlutterLinearBorder flutter_linear_border = 5;
    FlutterLinearBorderNamedBottom flutter_linear_border_named_bottom = 6;
    FlutterLinearBorderNamedEnd flutter_linear_border_named_end = 7;
    FlutterLinearBorderNamedStart flutter_linear_border_named_start = 8;
    FlutterLinearBorderNamedTop flutter_linear_border_named_top = 9;
    FlutterOvalBorder flutter_oval_border = 10;
    FlutterRoundedRectangleBorder flutter_rounded_rectangle_border = 11;
    FlutterStadiumBorder flutter_stadium_border = 12;
    FlutterStarBorder flutter_star_border = 13;
    FlutterStarBorderNamedPolygon flutter_star_border_named_polygon = 14;
  }
}

// package:flutter/src/widgets/page_view.dart
//
// A controller for [PageView].
//
// A page controller lets you manipulate which page is visible in a [PageView].
// In addition to being able to control the pixel offset of the content inside
// the [PageView], a [PageController] also lets you control the offset in terms
// of pages, which are increments of the viewport size.
//
// See also:
//
//  * [PageView], which is the widget this object controls.
//
// {@tool snippet}
//
// This widget introduces a [MaterialApp], [Scaffold] and [PageView] with two pages
// using the default constructor. Both pages contain an [ElevatedButton] allowing you
// to animate the [PageView] using a [PageController].
//
// ```dart
// class MyPageView extends StatefulWidget {
//   const MyPageView({super.key});
//
//   @override
//   State<MyPageView> createState() => _MyPageViewState();
// }
//
// class _MyPageViewState extends State<MyPageView> {
//   final PageController _pageController = PageController();
//
//   @override
//   void dispose() {
//     _pageController.dispose();
//     super.dispose();
//   }
//
//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       home: Scaffold(
//         body: PageView(
//           controller: _pageController,
//           children: <Widget>[
//             ColoredBox(
//               color: Colors.red,
//               child: Center(
//                 child: ElevatedButton(
//                   onPressed: () {
//                     if (_pageController.hasClients) {
//                       _pageController.animateToPage(
//                         1,
//                         duration: const Duration(milliseconds: 400),
//                         curve: Curves.easeInOut,
//                       );
//                     }
//                   },
//                   child: const Text('Next'),
//                 ),
//               ),
//             ),
//             ColoredBox(
//               color: Colors.blue,
//               child: Center(
//                 child: ElevatedButton(
//                   onPressed: () {
//                     if (_pageController.hasClients) {
//                       _pageController.animateToPage(
//                         0,
//                         duration: const Duration(milliseconds: 400),
//                         curve: Curves.easeInOut,
//                       );
//                     }
//                   },
//                   child: const Text('Previous'),
//                 ),
//               ),
//             ),
//           ],
//         ),
//       ),
//     );
//   }
// }
// ```
// {@end-tool}
message FlutterPageControllerType {
  oneof constructor {
    FlutterPageController flutter_page_controller = 2;
  }
}

// package:flutter/src/widgets/page_storage.dart
//
// A storage bucket associated with a page in an app.
//
// Useful for storing per-page state that persists across navigations from one
// page to another.
message FlutterPageStorageBucketType {
  oneof constructor {
    FlutterPageStorageBucket flutter_page_storage_bucket = 2;
  }
}

// package:flutter/src/widgets/platform_menu_bar.dart
//
// A class for [PlatformMenuItem]s that do not have submenus (as a [PlatformMenu]
// would), but can be selected.
//
// These [PlatformMenuItem]s are the leaves of the menu item tree, and [onSelected]
// will be called when they are selected by clicking on them, or via an
// optional keyboard [shortcut].
//
// See also:
//
//  * [PlatformMenu], a menu item that opens a submenu.
message FlutterPlatformMenuItemType {
  oneof constructor {
    FlutterPlatformMenu flutter_platform_menu = 2;
    FlutterPlatformMenuItem flutter_platform_menu_item = 3;
    FlutterPlatformMenuItemGroup flutter_platform_menu_item_group = 4;
    FlutterPlatformProvidedMenuItem flutter_platform_provided_menu_item = 5;
  }
}

// package:flutter/src/widgets/preferred_size.dart
//
// An interface for widgets that can return the size this widget would prefer
// if it were otherwise unconstrained.
//
// There are a few cases, notably [AppBar] and [TabBar], where it would be
// undesirable for the widget to constrain its own size but where the widget
// needs to expose a preferred or "default" size. For example a primary
// [Scaffold] sets its app bar height to the app bar's preferred height
// plus the height of the system status bar.
//
// Widgets that need to know the preferred size of their child can require
// that their child implement this interface by using this class rather
// than [Widget] as the type of their `child` property.
//
// Use [PreferredSize] to give a preferred size to an arbitrary widget.
message FlutterPreferredSizeWidgetType {
  oneof constructor {
    CupertinoNavigationBar cupertino_navigation_bar = 2;
    CupertinoTabBar cupertino_tab_bar = 3;
    FlutterPreferredSize flutter_preferred_size = 4;
    MaterialAppBar material_app_bar = 5;
    MaterialTab material_tab = 6;
    MaterialTabBar material_tab_bar = 7;
    MaterialTabBarNamedSecondary material_tab_bar_named_secondary = 8;
  }
}

// package:flutter/src/rendering/stack.dart
//
// An immutable 2D, axis-aligned, floating-point rectangle whose coordinates
// are given relative to another rectangle's edges, known as the container.
// Since the dimensions of the rectangle are relative to those of the
// container, this class has no width and height members. To determine the
// width or height of the rectangle, convert it to a [Rect] using [toRect()]
// (passing the container's own Rect), and then examine that object.
message FlutterRelativeRectType {
  oneof constructor {
    FlutterRelativeRectNamedFromDirectional flutter_relative_rect_named_from_directional = 2;
    FlutterRelativeRectNamedFromLTRB flutter_relative_rect_named_from_l_t_r_b = 3;
    FlutterRelativeRectNamedFromRect flutter_relative_rect_named_from_rect = 4;
    FlutterRelativeRectNamedFromSize flutter_relative_rect_named_from_size = 5;
  }
}

// package:flutter/src/rendering/box.dart
//
// A render object in a 2D Cartesian coordinate system.
//
// The [size] of each box is expressed as a width and a height. Each box has
// its own coordinate system in which its upper left corner is placed at (0,
// 0). The lower right corner of the box is therefore at (width, height). The
// box contains all the points including the upper left corner and extending
// to, but not including, the lower right corner.
//
// Box layout is performed by passing a [BoxConstraints] object down the tree.
// The box constraints establish a min and max value for the child's width and
// height. In determining its size, the child must respect the constraints
// given to it by its parent.
//
// This protocol is sufficient for expressing a number of common box layout
// data flows. For example, to implement a width-in-height-out data flow, call
// your child's [layout] function with a set of box constraints with a tight
// width value (and pass true for parentUsesSize). After the child determines
// its height, use the child's height to determine your size.
//
// ## Writing a RenderBox subclass
//
// One would implement a new [RenderBox] subclass to describe a new layout
// model, new paint model, new hit-testing model, or new semantics model, while
// remaining in the Cartesian space defined by the [RenderBox] protocol.
//
// To create a new protocol, consider subclassing [RenderObject] instead.
//
// ### Constructors and properties of a new RenderBox subclass
//
// The constructor will typically take a named argument for each property of
// the class. The value is then passed to a private field of the class and the
// constructor asserts its correctness (e.g. if it should not be null, it
// asserts it's not null).
//
// Properties have the form of a getter/setter/field group like the following:
//
// ```dart
// AxisDirection get axis => _axis;
// AxisDirection _axis = AxisDirection.down; // or initialized in constructor
// set axis(AxisDirection value) {
//   if (value == _axis) {
//     return;
//   }
//   _axis = value;
//   markNeedsLayout();
// }
// ```
//
// The setter will typically finish with either a call to [markNeedsLayout], if
// the layout uses this property, or [markNeedsPaint], if only the painter
// function does. (No need to call both, [markNeedsLayout] implies
// [markNeedsPaint].)
//
// Consider layout and paint to be expensive; be conservative about calling
// [markNeedsLayout] or [markNeedsPaint]. They should only be called if the
// layout (or paint, respectively) has actually changed.
//
// ### Children
//
// If a render object is a leaf, that is, it cannot have any children, then
// ignore this section. (Examples of leaf render objects are [RenderImage] and
// [RenderParagraph].)
//
// For render objects with children, there are four possible scenarios:
//
// * A single [RenderBox] child. In this scenario, consider inheriting from
//   [RenderProxyBox] (if the render object sizes itself to match the child) or
//   [RenderShiftedBox] (if the child will be smaller than the box and the box
//   will align the child inside itself).
//
// * A single child, but it isn't a [RenderBox]. Use the
//   [RenderObjectWithChildMixin] mixin.
//
// * A single list of children. Use the [ContainerRenderObjectMixin] mixin.
//
// * A more complicated child model.
//
// #### Using RenderProxyBox
//
// By default, a [RenderProxyBox] render object sizes itself to fit its child, or
// to be as small as possible if there is no child; it passes all hit testing
// and painting on to the child, and intrinsic dimensions and baseline
// measurements similarly are proxied to the child.
//
// A subclass of [RenderProxyBox] just needs to override the parts of the
// [RenderBox] protocol that matter. For example, [RenderOpacity] just
// overrides the paint method (and [alwaysNeedsCompositing] to reflect what the
// paint method does, and the [visitChildrenForSemantics] method so that the
// child is hidden from accessibility tools when it's invisible), and adds an
// [RenderOpacity.opacity] field.
//
// [RenderProxyBox] assumes that the child is the size of the parent and
// positioned at 0,0. If this is not true, then use [RenderShiftedBox] instead.
//
// See
// [proxy_box.dart](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/proxy_box.dart)
// for examples of inheriting from [RenderProxyBox].
//
// #### Using RenderShiftedBox
//
// By default, a [RenderShiftedBox] acts much like a [RenderProxyBox] but
// without assuming that the child is positioned at 0,0 (the actual position
// recorded in the child's [parentData] field is used), and without providing a
// default layout algorithm.
//
// See
// [shifted_box.dart](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/shifted_box.dart)
// for examples of inheriting from [RenderShiftedBox].
//
// #### Kinds of children and child-specific data
//
// A [RenderBox] doesn't have to have [RenderBox] children. One can use another
// subclass of [RenderObject] for a [RenderBox]'s children. See the discussion
// at [RenderObject].
//
// Children can have additional data owned by the parent but stored on the
// child using the [parentData] field. The class used for that data must
// inherit from [ParentData]. The [setupParentData] method is used to
// initialize the [parentData] field of a child when the child is attached.
//
// By convention, [RenderBox] objects that have [RenderBox] children use the
// [BoxParentData] class, which has a [BoxParentData.offset] field to store the
// position of the child relative to the parent. ([RenderProxyBox] does not
// need this offset and therefore is an exception to this rule.)
//
// #### Using RenderObjectWithChildMixin
//
// If a render object has a single child but it isn't a [RenderBox], then the
// [RenderObjectWithChildMixin] class, which is a mixin that will handle the
// boilerplate of managing a child, will be useful.
//
// It's a generic class with one type argument, the type of the child. For
// example, if you are building a `RenderFoo` class which takes a single
// `RenderBar` child, you would use the mixin as follows:
//
// ```dart
// class RenderFoo extends RenderBox
//   with RenderObjectWithChildMixin<RenderBar> {
//   // ...
// }
// ```
//
// Since the `RenderFoo` class itself is still a [RenderBox] in this case, you
// still have to implement the [RenderBox] layout algorithm, as well as
// features like intrinsics and baselines, painting, and hit testing.
//
// #### Using ContainerRenderObjectMixin
//
// If a render box can have multiple children, then the
// [ContainerRenderObjectMixin] mixin can be used to handle the boilerplate. It
// uses a linked list to model the children in a manner that is easy to mutate
// dynamically and that can be walked efficiently. Random access is not
// efficient in this model; if you need random access to the children consider
// the next section on more complicated child models.
//
// The [ContainerRenderObjectMixin] class has two type arguments. The first is
// the type of the child objects. The second is the type for their
// [parentData]. The class used for [parentData] must itself have the
// [ContainerParentDataMixin] class mixed into it; this is where
// [ContainerRenderObjectMixin] stores the linked list. A [ParentData] class
// can extend [ContainerBoxParentData]; this is essentially
// [BoxParentData] mixed with [ContainerParentDataMixin]. For example, if a
// `RenderFoo` class wanted to have a linked list of [RenderBox] children, one
// might create a `FooParentData` class as follows:
//
// ```dart
// class FooParentData extends ContainerBoxParentData<RenderBox> {
//   // (any fields you might need for these children)
// }
// ```
//
// When using [ContainerRenderObjectMixin] in a [RenderBox], consider mixing in
// [RenderBoxContainerDefaultsMixin], which provides a collection of utility
// methods that implement common parts of the [RenderBox] protocol (such as
// painting the children).
//
// The declaration of the `RenderFoo` class itself would thus look like this:
//
// ```dart
// // continuing from previous example...
// class RenderFoo extends RenderBox with
//   ContainerRenderObjectMixin<RenderBox, FooParentData>,
//   RenderBoxContainerDefaultsMixin<RenderBox, FooParentData> {
//   // ...
// }
// ```
//
// When walking the children (e.g. during layout), the following pattern is
// commonly used (in this case assuming that the children are all [RenderBox]
// objects and that this render object uses `FooParentData` objects for its
// children's [parentData] fields):
//
// ```dart
// // continuing from previous example...
// RenderBox? child = firstChild;
// while (child != null) {
//   final FooParentData childParentData = child.parentData! as FooParentData;
//   // ...operate on child and childParentData...
//   assert(child.parentData == childParentData);
//   child = childParentData.nextSibling;
// }
// ```
//
// #### More complicated child models
//
// Render objects can have more complicated models, for example a map of
// children keyed on an enum, or a 2D grid of efficiently randomly-accessible
// children, or multiple lists of children, etc. If a render object has a model
// that can't be handled by the mixins above, it must implement the
// [RenderObject] child protocol, as follows:
//
// * Any time a child is removed, call [dropChild] with the child.
//
// * Any time a child is added, call [adoptChild] with the child.
//
// * Implement the [attach] method such that it calls [attach] on each child.
//
// * Implement the [detach] method such that it calls [detach] on each child.
//
// * Implement the [redepthChildren] method such that it calls [redepthChild]
//   on each child.
//
// * Implement the [visitChildren] method such that it calls its argument for
//   each child, typically in paint order (back-most to front-most).
//
// * Implement [debugDescribeChildren] such that it outputs a [DiagnosticsNode]
//   for each child.
//
// Implementing these seven bullet points is essentially all that the two
// aforementioned mixins do.
//
// ### Layout
//
// [RenderBox] classes implement a layout algorithm. They have a set of
// constraints provided to them, and they size themselves based on those
// constraints and whatever other inputs they may have (for example, their
// children or properties).
//
// When implementing a [RenderBox] subclass, one must make a choice. Does it
// size itself exclusively based on the constraints, or does it use any other
// information in sizing itself? An example of sizing purely based on the
// constraints would be growing to fit the parent.
//
// Sizing purely based on the constraints allows the system to make some
// significant optimizations. Classes that use this approach should override
// [sizedByParent] to return true, and then override [computeDryLayout] to
// compute the [Size] using nothing but the constraints, e.g.:
//
// ```dart
// @override
// bool get sizedByParent => true;
//
// @override
// Size computeDryLayout(BoxConstraints constraints) {
//   return constraints.smallest;
// }
// ```
//
// Otherwise, the size is set in the [performLayout] function.
//
// The [performLayout] function is where render boxes decide, if they are not
// [sizedByParent], what [size] they should be, and also where they decide
// where their children should be.
//
// #### Layout of RenderBox children
//
// The [performLayout] function should call the [layout] function of each (box)
// child, passing it a [BoxConstraints] object describing the constraints
// within which the child can render. Passing tight constraints (see
// [BoxConstraints.isTight]) to the child will allow the rendering library to
// apply some optimizations, as it knows that if the constraints are tight, the
// child's dimensions cannot change even if the layout of the child itself
// changes.
//
// If the [performLayout] function will use the child's size to affect other
// aspects of the layout, for example if the render box sizes itself around the
// child, or positions several children based on the size of those children,
// then it must specify the `parentUsesSize` argument to the child's [layout]
// function, setting it to true.
//
// This flag turns off some optimizations; algorithms that do not rely on the
// children's sizes will be more efficient. (In particular, relying on the
// child's [size] means that if the child is marked dirty for layout, the
// parent will probably also be marked dirty for layout, unless the
// [constraints] given by the parent to the child were tight constraints.)
//
// For [RenderBox] classes that do not inherit from [RenderProxyBox], once they
// have laid out their children, they should also position them, by setting the
// [BoxParentData.offset] field of each child's [parentData] object.
//
// #### Layout of non-RenderBox children
//
// The children of a [RenderBox] do not have to be [RenderBox]es themselves. If
// they use another protocol (as discussed at [RenderObject]), then instead of
// [BoxConstraints], the parent would pass in the appropriate [Constraints]
// subclass, and instead of reading the child's size, the parent would read
// whatever the output of [layout] is for that layout protocol. The
// `parentUsesSize` flag is still used to indicate whether the parent is going
// to read that output, and optimizations still kick in if the child has tight
// constraints (as defined by [Constraints.isTight]).
//
// ### Painting
//
// To describe how a render box paints, implement the [paint] method. It is
// given a [PaintingContext] object and an [Offset]. The painting context
// provides methods to affect the layer tree as well as a
// [PaintingContext.canvas] which can be used to add drawing commands. The
// canvas object should not be cached across calls to the [PaintingContext]'s
// methods; every time a method on [PaintingContext] is called, there is a
// chance that the canvas will change identity. The offset specifies the
// position of the top left corner of the box in the coordinate system of the
// [PaintingContext.canvas].
//
// To draw text on a canvas, use a [TextPainter].
//
// To draw an image to a canvas, use the [paintImage] method.
//
// A [RenderBox] that uses methods on [PaintingContext] that introduce new
// layers should override the [alwaysNeedsCompositing] getter and set it to
// true. If the object sometimes does and sometimes does not, it can have that
// getter return true in some cases and false in others. In that case, whenever
// the return value would change, call [markNeedsCompositingBitsUpdate]. (This
// is done automatically when a child is added or removed, so you don't have to
// call it explicitly if the [alwaysNeedsCompositing] getter only changes value
// based on the presence or absence of children.)
//
// Anytime anything changes on the object that would cause the [paint] method
// to paint something different (but would not cause the layout to change),
// the object should call [markNeedsPaint].
//
// #### Painting children
//
// The [paint] method's `context` argument has a [PaintingContext.paintChild]
// method, which should be called for each child that is to be painted. It
// should be given a reference to the child, and an [Offset] giving the
// position of the child relative to the parent.
//
// If the [paint] method applies a transform to the painting context before
// painting children (or generally applies an additional offset beyond the
// offset it was itself given as an argument), then the [applyPaintTransform]
// method should also be overridden. That method must adjust the matrix that it
// is given in the same manner as it transformed the painting context and
// offset before painting the given child. This is used by the [globalToLocal]
// and [localToGlobal] methods.
//
// #### Hit Tests
//
// Hit testing for render boxes is implemented by the [hitTest] method. The
// default implementation of this method defers to [hitTestSelf] and
// [hitTestChildren]. When implementing hit testing, you can either override
// these latter two methods, or ignore them and just override [hitTest].
//
// The [hitTest] method itself is given an [Offset], and must return true if the
// object or one of its children has absorbed the hit (preventing objects below
// this one from being hit), or false if the hit can continue to other objects
// below this one.
//
// For each child [RenderBox], the [hitTest] method on the child should be
// called with the same [HitTestResult] argument and with the point transformed
// into the child's coordinate space (in the same manner that the
// [applyPaintTransform] method would). The default implementation defers to
// [hitTestChildren] to call the children. [RenderBoxContainerDefaultsMixin]
// provides a [RenderBoxContainerDefaultsMixin.defaultHitTestChildren] method
// that does this assuming that the children are axis-aligned, not transformed,
// and positioned according to the [BoxParentData.offset] field of the
// [parentData]; more elaborate boxes can override [hitTestChildren]
// accordingly.
//
// If the object is hit, then it should also add itself to the [HitTestResult]
// object that is given as an argument to the [hitTest] method, using
// [HitTestResult.add]. The default implementation defers to [hitTestSelf] to
// determine if the box is hit. If the object adds itself before the children
// can add themselves, then it will be as if the object was above the children.
// If it adds itself after the children, then it will be as if it was below the
// children. Entries added to the [HitTestResult] object should use the
// [BoxHitTestEntry] class. The entries are subsequently walked by the system
// in the order they were added, and for each entry, the target's [handleEvent]
// method is called, passing in the [HitTestEntry] object.
//
// Hit testing cannot rely on painting having happened.
//
// ### Semantics
//
// For a render box to be accessible, implement the
// [describeApproximatePaintClip], [visitChildrenForSemantics], and
// [describeSemanticsConfiguration] methods. The default implementations are
// sufficient for objects that only affect layout, but nodes that represent
// interactive components or information (diagrams, text, images, etc) should
// provide more complete implementations. For more information, see the
// documentation for these members.
//
// ### Intrinsics and Baselines
//
// The layout, painting, hit testing, and semantics protocols are common to all
// render objects. [RenderBox] objects must implement two additional protocols:
// intrinsic sizing and baseline measurements.
//
// There are four methods to implement for intrinsic sizing, to compute the
// minimum and maximum intrinsic width and height of the box. The documentation
// for these methods discusses the protocol in detail:
// [computeMinIntrinsicWidth], [computeMaxIntrinsicWidth],
// [computeMinIntrinsicHeight], [computeMaxIntrinsicHeight].
//
// Be sure to set [debugCheckIntrinsicSizes] to true in your unit tests if you
// do override any of these methods, which will add additional checks to
// help validate your implementation.
//
// In addition, if the box has any children, it must implement
// [computeDistanceToActualBaseline]. [RenderProxyBox] provides a simple
// implementation that forwards to the child; [RenderShiftedBox] provides an
// implementation that offsets the child's baseline information by the position
// of the child relative to the parent. If you do not inherited from either of
// these classes, however, you must implement the algorithm yourself.
message FlutterRenderBoxType {
  oneof constructor {
    FlutterRenderAbsorbPointer flutter_render_absorb_pointer = 2;
    FlutterRenderAnimatedSize flutter_render_animated_size = 3;
    FlutterRenderAspectRatio flutter_render_aspect_ratio = 4;
    FlutterRenderBackdropFilter flutter_render_backdrop_filter = 5;
    FlutterRenderBaseline flutter_render_baseline = 6;
    FlutterRenderBlockSemantics flutter_render_block_semantics = 7;
    FlutterRenderClipOval flutter_render_clip_oval = 8;
    FlutterRenderClipPath flutter_render_clip_path = 9;
    FlutterRenderClipRRect flutter_render_clip_r_rect = 10;
    FlutterRenderClipRect flutter_render_clip_rect = 11;
    FlutterRenderConstrainedBox flutter_render_constrained_box = 12;
    FlutterRenderConstrainedOverflowBox flutter_render_constrained_overflow_box = 13;
    FlutterRenderCustomMultiChildLayoutBox flutter_render_custom_multi_child_layout_box = 14;
    FlutterRenderCustomPaint flutter_render_custom_paint = 15;
    FlutterRenderCustomSingleChildLayoutBox flutter_render_custom_single_child_layout_box = 16;
    FlutterRenderDecoratedBox flutter_render_decorated_box = 17;
    FlutterRenderErrorBox flutter_render_error_box = 18;
    FlutterRenderExcludeSemantics flutter_render_exclude_semantics = 19;
    FlutterRenderFittedBox flutter_render_fitted_box = 20;
    FlutterRenderFlex flutter_render_flex = 21;
    FlutterRenderFlow flutter_render_flow = 22;
    FlutterRenderFollowerLayer flutter_render_follower_layer = 23;
    FlutterRenderFractionalTranslation flutter_render_fractional_translation = 24;
    FlutterRenderFractionallySizedOverflowBox flutter_render_fractionally_sized_overflow_box = 25;
    FlutterRenderIgnoreBaseline flutter_render_ignore_baseline = 26;
    FlutterRenderIgnorePointer flutter_render_ignore_pointer = 27;
    FlutterRenderImage flutter_render_image = 28;
    FlutterRenderIndexedSemantics flutter_render_indexed_semantics = 29;
    FlutterRenderIndexedStack flutter_render_indexed_stack = 30;
    FlutterRenderIntrinsicHeight flutter_render_intrinsic_height = 31;
    FlutterRenderIntrinsicWidth flutter_render_intrinsic_width = 32;
    FlutterRenderLeaderLayer flutter_render_leader_layer = 33;
    FlutterRenderLimitedBox flutter_render_limited_box = 34;
    FlutterRenderListBody flutter_render_list_body = 35;
    FlutterRenderListWheelViewport flutter_render_list_wheel_viewport = 36;
    FlutterRenderMergeSemantics flutter_render_merge_semantics = 37;
    FlutterRenderMetaData flutter_render_meta_data = 38;
    FlutterRenderMouseRegion flutter_render_mouse_region = 39;
    FlutterRenderNestedScrollViewViewport flutter_render_nested_scroll_view_viewport = 40;
    FlutterRenderOffstage flutter_render_offstage = 41;
    FlutterRenderOpacity flutter_render_opacity = 42;
    FlutterRenderPadding flutter_render_padding = 43;
    FlutterRenderParagraph flutter_render_paragraph = 44;
    FlutterRenderPerformanceOverlay flutter_render_performance_overlay = 45;
    FlutterRenderPhysicalModel flutter_render_physical_model = 46;
    FlutterRenderPointerListener flutter_render_pointer_listener = 47;
    FlutterRenderPositionedBox flutter_render_positioned_box = 48;
    FlutterRenderProxyBox flutter_render_proxy_box = 49;
    FlutterRenderRepaintBoundary flutter_render_repaint_boundary = 50;
    FlutterRenderRotatedBox flutter_render_rotated_box = 51;
    FlutterRenderSemanticsAnnotations flutter_render_semantics_annotations = 52;
    FlutterRenderSemanticsGestureHandler flutter_render_semantics_gesture_handler = 53;
    FlutterRenderShrinkWrappingViewport flutter_render_shrink_wrapping_viewport = 54;
    FlutterRenderSizedOverflowBox flutter_render_sized_overflow_box = 55;
    FlutterRenderStack flutter_render_stack = 56;
    FlutterRenderTable flutter_render_table = 57;
    FlutterRenderTapRegion flutter_render_tap_region = 58;
    FlutterRenderTapRegionSurface flutter_render_tap_region_surface = 59;
    FlutterRenderTransform flutter_render_transform = 60;
    FlutterRenderViewport flutter_render_viewport = 61;
    FlutterRenderWrap flutter_render_wrap = 62;
    FlutterTextureBox flutter_texture_box = 63;
  }
}

// package:flutter/src/rendering/sliver_multi_box_adaptor.dart
//
// A delegate used by [RenderSliverMultiBoxAdaptor] to manage its children.
//
// [RenderSliverMultiBoxAdaptor] objects reify their children lazily to avoid
// spending resources on children that are not visible in the viewport. This
// delegate lets these objects create and remove children as well as estimate
// the total scroll offset extent occupied by the full child list.
message FlutterRenderSliverBoxChildManagerType {
  oneof constructor {
    FlutterSliverMultiBoxAdaptorElement flutter_sliver_multi_box_adaptor_element = 2;
  }
}

// package:flutter/src/rendering/sliver.dart
//
// Base class for the render objects that implement scroll effects in viewports.
//
// A [RenderViewport] has a list of child slivers. Each sliver  literally a
// slice of the viewport's contents  is laid out in turn, covering the
// viewport in the process. (Every sliver is laid out each time, including
// those that have zero extent because they are "scrolled off" or are beyond
// the end of the viewport.)
//
// Slivers participate in the _sliver protocol_, wherein during [layout] each
// sliver receives a [SliverConstraints] object and computes a corresponding
// [SliverGeometry] that describes where it fits in the viewport. This is
// analogous to the box protocol used by [RenderBox], which gets a
// [BoxConstraints] as input and computes a [Size].
//
// Slivers have a leading edge, which is where the position described by
// [SliverConstraints.scrollOffset] for this sliver begins. Slivers have
// several dimensions, the primary of which is [SliverGeometry.paintExtent],
// which describes the extent of the sliver along the main axis, starting from
// the leading edge, reaching either the end of the viewport or the end of the
// sliver, whichever comes first.
//
// Slivers can change dimensions based on the changing constraints in a
// non-linear fashion, to achieve various scroll effects. For example, the
// various [RenderSliverPersistentHeader] subclasses, on which [SliverAppBar]
// is based, achieve effects such as staying visible despite the scroll offset,
// or reappearing at different offsets based on the user's scroll direction
// ([SliverConstraints.userScrollDirection]).
//
// {@youtube 560 315 https://www.youtube.com/watch?v=Mz3kHQxBjGg}
//
// ## Writing a RenderSliver subclass
//
// Slivers can have sliver children, or children from another coordinate
// system, typically box children. (For details on the box protocol, see
// [RenderBox].) Slivers can also have different child models, typically having
// either one child, or a list of children.
//
// ### Examples of slivers
//
// A good example of a sliver with a single child that is also itself a sliver
// is [RenderSliverPadding], which indents its child. A sliver-to-sliver render
// object such as this must construct a [SliverConstraints] object for its
// child, then must take its child's [SliverGeometry] and use it to form its
// own [geometry].
//
// The other common kind of one-child sliver is a sliver that has a single
// [RenderBox] child. An example of that would be [RenderSliverToBoxAdapter],
// which lays out a single box and sizes itself around the box. Such a sliver
// must use its [SliverConstraints] to create a [BoxConstraints] for the
// child, lay the child out (using the child's [layout] method), and then use
// the child's [RenderBox.size] to generate the sliver's [SliverGeometry].
//
// The most common kind of sliver though is one with multiple children. The
// most straight-forward example of this is [RenderSliverList], which arranges
// its children one after the other in the main axis direction. As with the
// one-box-child sliver case, it uses its [constraints] to create a
// [BoxConstraints] for the children, and then it uses the aggregate
// information from all its children to generate its [geometry]. Unlike the
// one-child cases, however, it is judicious in which children it actually lays
// out (and later paints). If the scroll offset is 1000 pixels, and it
// previously determined that the first three children are each 400 pixels
// tall, then it will skip the first two and start the layout with its third
// child.
//
// ### Layout
//
// As they are laid out, slivers decide their [geometry], which includes their
// size ([SliverGeometry.paintExtent]) and the position of the next sliver
// ([SliverGeometry.layoutExtent]), as well as the position of each of their
// children, based on the input [constraints] from the viewport such as the
// scroll offset ([SliverConstraints.scrollOffset]).
//
// For example, a sliver that just paints a box 100 pixels high would say its
// [SliverGeometry.paintExtent] was 100 pixels when the scroll offset was zero,
// but would say its [SliverGeometry.paintExtent] was 25 pixels when the scroll
// offset was 75 pixels, and would say it was zero when the scroll offset was
// 100 pixels or more. (This is assuming that
// [SliverConstraints.remainingPaintExtent] was more than 100 pixels.)
//
// The various dimensions that are provided as input to this system are in the
// [constraints]. They are described in detail in the documentation for the
// [SliverConstraints] class.
//
// The [performLayout] function must take these [constraints] and create a
// [SliverGeometry] object that it must then assign to the [geometry] property.
// The different dimensions of the geometry that can be configured are
// described in detail in the documentation for the [SliverGeometry] class.
//
// ### Painting
//
// In addition to implementing layout, a sliver must also implement painting.
// This is achieved by overriding the [paint] method.
//
// The [paint] method is called with an [Offset] from the [Canvas] origin to
// the top-left corner of the sliver, _regardless of the axis direction_.
//
// Subclasses should also override [applyPaintTransform] to provide the
// [Matrix4] describing the position of each child relative to the sliver.
// (This is used by, among other things, the accessibility layer, to determine
// the bounds of the child.)
//
// ### Hit testing
//
// To implement hit testing, either override the [hitTestSelf] and
// [hitTestChildren] methods, or, for more complex cases, instead override the
// [hitTest] method directly.
//
// To actually react to pointer events, the [handleEvent] method may be
// implemented. By default it does nothing. (Typically gestures are handled by
// widgets in the box protocol, not by slivers directly.)
//
// ### Helper methods
//
// There are a number of methods that a sliver should implement which will make
// the other methods easier to implement. Each method listed below has detailed
// documentation. In addition, the [RenderSliverHelpers] class can be used to
// mix in some helpful methods.
//
// #### childScrollOffset
//
// If the subclass positions children anywhere other than at scroll offset
// zero, it should override [childScrollOffset]. For example,
// [RenderSliverList] and [RenderSliverGrid] override this method, but
// [RenderSliverToBoxAdapter] does not.
//
// This is used by, among other things, [Scrollable.ensureVisible].
//
// #### childMainAxisPosition
//
// Subclasses should implement [childMainAxisPosition] to describe where their
// children are positioned.
//
// #### childCrossAxisPosition
//
// If the subclass positions children in the cross-axis at a position other
// than zero, then it should override [childCrossAxisPosition]. For example
// [RenderSliverGrid] overrides this method.
message FlutterRenderSliverType {
  oneof constructor {
    FlutterRenderDecoratedSliver flutter_render_decorated_sliver = 2;
    FlutterRenderSliverConstrainedCrossAxis flutter_render_sliver_constrained_cross_axis = 3;
    FlutterRenderSliverCrossAxisGroup flutter_render_sliver_cross_axis_group = 4;
    FlutterRenderSliverFillRemaining flutter_render_sliver_fill_remaining = 5;
    FlutterRenderSliverFillRemainingAndOverscroll flutter_render_sliver_fill_remaining_and_overscroll = 6;
    FlutterRenderSliverFillRemainingWithScrollable flutter_render_sliver_fill_remaining_with_scrollable = 7;
    FlutterRenderSliverFillViewport flutter_render_sliver_fill_viewport = 8;
    FlutterRenderSliverFixedExtentList flutter_render_sliver_fixed_extent_list = 9;
    FlutterRenderSliverGrid flutter_render_sliver_grid = 10;
    FlutterRenderSliverIgnorePointer flutter_render_sliver_ignore_pointer = 11;
    FlutterRenderSliverList flutter_render_sliver_list = 12;
    FlutterRenderSliverMainAxisGroup flutter_render_sliver_main_axis_group = 13;
    FlutterRenderSliverOffstage flutter_render_sliver_offstage = 14;
    FlutterRenderSliverOpacity flutter_render_sliver_opacity = 15;
    FlutterRenderSliverOverlapAbsorber flutter_render_sliver_overlap_absorber = 16;
    FlutterRenderSliverOverlapInjector flutter_render_sliver_overlap_injector = 17;
    FlutterRenderSliverPadding flutter_render_sliver_padding = 18;
    FlutterRenderSliverToBoxAdapter flutter_render_sliver_to_box_adapter = 19;
  }
}

// package:flutter/src/services/restoration.dart
//
// A [RestorationBucket] holds pieces of the restoration data that a part of
// the application needs to restore its state.
//
// For a general overview of how state restoration works in Flutter, see the
// [RestorationManager].
//
// [RestorationBucket]s are organized in a tree that is rooted in
// [RestorationManager.rootBucket] and managed by a [RestorationManager]. The
// tree is serializable and must contain all the data an application needs to
// restore its current state at a later point in time.
//
// A [RestorationBucket] stores restoration data as key-value pairs. The key is
// a [String] representing a restoration ID that identifies a piece of data
// uniquely within a bucket. The value can be anything that is serializable via
// the [StandardMessageCodec]. Furthermore, a [RestorationBucket] may have
// child buckets, which are identified within their parent via a unique
// restoration ID as well.
//
// During state restoration, the data previously stored in the
// [RestorationBucket] hierarchy will be made available again to the
// application to restore it to the state it had when the data was collected.
// State restoration to a previous state may happen when the app is launched
// (e.g. after it has been terminated gracefully while running in the
// background) or after the app has already been running for a while.
//
// ## Lifecycle
//
// A [RestorationBucket] is rarely instantiated directly via its constructors.
// Instead, when an entity wants to store data in or retrieve data from a
// restoration bucket, it typically obtains a child bucket from a parent by
// calling [claimChild]. If no parent is available,
// [RestorationManager.rootBucket] may be used as a parent. When claiming a
// child, the claimer must provide the restoration ID of the child it would
// like to own. A child bucket with a given restoration ID can at most have
// one owner. If another owner tries to claim a bucket with the same ID from
// the same parent, an exception is thrown (see discussion in [claimChild]).
// The restoration IDs that a given owner uses to claim a child (and to store
// data in that child, see below) must be stable across app launches to ensure
// that after the app restarts the owner can retrieve the same data again that
// it stored during a previous run.
//
// Per convention, the owner of the bucket has exclusive access to the values
// stored in the bucket. It can read, add, modify, and remove values via the
// [read], [write], and [remove] methods. In general, the owner should store
// all the data in the bucket that it needs to restore its current state. If
// its current state changes, the data in the bucket must be updated. At the
// same time, the data in the bucket should be kept to a minimum. For example,
// for data that can be retrieved from other sources (like a database or
// web service) only enough information (e.g. an ID or resource locator) to
// re-obtain that data should be stored in the bucket. In addition to managing
// the data in a bucket, an owner may also make the bucket available to other
// entities so they can claim child buckets from it via [claimChild] for their
// own restoration needs.
//
// The bucket returned by [claimChild] may either contain state information
// that the owner had previously (e.g. during a previous run of the
// application) stored in it or it may be empty. If the bucket contains data,
// the owner is expected to restore its state with the information previously
// stored in the bucket. If the bucket is empty, it may initialize itself to
// default values.
//
// When the data stored in a bucket is no longer needed to restore the
// application to its current state (e.g. because the owner of the bucket is no
// longer shown on screen), the bucket must be [dispose]d. This will remove all
// information stored in the bucket from the app's restoration data and that
// information will not be available again when the application is restored to
// this state in the future.
message FlutterRestorationBucketType {
  oneof constructor {
    FlutterRestorationBucketNamedChild flutter_restoration_bucket_named_child = 2;
    FlutterRestorationBucketNamedEmpty flutter_restoration_bucket_named_empty = 3;
    FlutterRestorationBucketNamedRoot flutter_restoration_bucket_named_root = 4;
  }
}

// package:flutter/src/services/restoration.dart
//
// Manages the restoration data in the framework and synchronizes it with the
// engine.
//
// Restoration data can be serialized out and - at a later point in time - be
// used to restore the application to the previous state described by the
// serialized data. Mobile operating systems use the concept of state
// restoration to provide the illusion that apps continue to run in the
// background forever: after an app has been backgrounded, the user can always
// return to it and find it in the same state. In practice, the operating
// system may, however, terminate the app to free resources for other apps
// running in the foreground. Before that happens, the app gets a chance to
// serialize out its restoration data. When the user navigates back to the
// backgrounded app, it is restarted and the serialized restoration data is
// provided to it again. Ideally, the app will use that data to restore itself
// to the same state it was in when the user backgrounded the app.
//
// In Flutter, restoration data is organized in a tree of [RestorationBucket]s
// which is rooted in the [rootBucket]. All information that the application
// needs to restore its current state must be stored in a bucket in this
// hierarchy. To store data in the hierarchy, entities (e.g. [Widget]s) must
// claim ownership of a child bucket from a parent bucket (which may be the
// [rootBucket] provided by this [RestorationManager]). The owner of a bucket
// may store arbitrary values in the bucket as long as they can be serialized
// with the [StandardMessageCodec]. The values are stored in the bucket under a
// given restoration ID as key. A restoration ID is a [String] that must be
// unique within a given bucket. To access the stored value again during state
// restoration, the same restoration ID must be provided again. The owner of
// the bucket may also make the bucket available to other entities so that they
// can claim child buckets from it for their own restoration needs. Within a
// bucket, child buckets are also identified by unique restoration IDs. The
// restoration ID must be provided when claiming a child bucket.
//
// When restoration data is provided to the [RestorationManager] (e.g. after
// the application relaunched when foregrounded again), the bucket hierarchy
// with all the data stored in it is restored. Entities can retrieve the data
// again by using the same restoration IDs that they originally used to store
// the data.
//
// In addition to providing restoration data when the app is launched,
// restoration data may also be provided to a running app to restore it to a
// previous state (e.g. when the user hits the back/forward button in the web
// browser). When this happens, the [RestorationManager] notifies its listeners
// (added via [addListener]) that a new [rootBucket] is available. In response
// to the notification, listeners must stop using the old bucket and restore
// their state from the information in the new [rootBucket].
//
// Some platforms restrict the size of the restoration data. Therefore, the
// data stored in the buckets should be as small as possible while still
// allowing the app to restore its current state from it. Data that can be
// retrieved from other services (e.g. a database or a web server) should not
// be included in the restoration data. Instead, a small identifier (e.g. a
// UUID, database record number, or resource locator) should be stored that can
// be used to retrieve the data again from its original source during state
// restoration.
//
// The [RestorationManager] sends a serialized version of the bucket hierarchy
// over to the engine at the end of a frame in which the data in the hierarchy
// or its shape has changed. The engine caches the data until the operating
// system needs it. The application is responsible for keeping the data in the
// bucket always up-to-date to reflect its current state.
//
// ## Discussion
//
// Due to Flutter's threading model and restrictions in the APIs of the
// platforms Flutter runs on, restoration data must be stored in the buckets
// proactively as described above. When the operating system asks for the
// restoration data, it will do so on the platform thread expecting a
// synchronous response. To avoid the risk of deadlocks, the platform thread
// cannot block and call into the UI thread (where the dart code is running) to
// retrieve the restoration data. For this reason, the [RestorationManager]
// always sends the latest copy of the restoration data from the UI thread over
// to the platform thread whenever it changes. That way, the restoration data
// is always ready to go on the platform thread when the operating system needs
// it.
//
// ## State Restoration on iOS
//
// To enable state restoration on iOS, a restoration identifier has to be
// assigned to the [FlutterViewController](/ios-embedder/interface_flutter_view_controller.html).
// If the standard embedding (produced by `flutter create`) is used, this can
// be accomplished with the following steps:
//
//  1. In the app's directory, open `ios/Runner.xcodeproj` with Xcode.
//  2. Select `Main.storyboard` under `Runner/Runner` in the Project Navigator
//     on the left.
//  3. Select the `Flutter View Controller` under
//     `Flutter View Controller Scene` in the view hierarchy.
//  4. Navigate to the Identity Inspector in the panel on the right.
//  5. Enter a unique restoration ID in the provided field.
//  6. Save the project.
//
// ## Development with hot restart and hot reload
//
// Changes applied to your app with hot reload and hot restart are not
// persisted on the device. They are lost when the app is fully terminated and
// restarted, e.g. by the operating system. Therefore, your app may not restore
// correctly during development if you have made changes and applied them with
// hot restart or hot reload. To test state restoration, always make sure to
// fully re-compile your application (e.g. by re-executing `flutter run`) after
// making a change.
//
// ## Testing State Restoration
//
// {@template flutter.widgets.RestorationManager}
// To test state restoration on Android:
//   1. Turn on "Don't keep activities", which destroys the Android activity
//      as soon as the user leaves it. This option should become available
//      when Developer Options are turned on for the device.
//   2. Run the code sample on an Android device.
//   3. Create some in-memory state in the app on the phone,
//      e.g. by navigating to a different screen.
//   4. Background the Flutter app, then return to it. It will restart
//      and restore its state.
//
// To test state restoration on iOS:
//   1. Open `ios/Runner.xcworkspace/` in Xcode.
//   2. (iOS 14+ only): Switch to build in profile or release mode, as
//      launching an app from the home screen is not supported in debug
//      mode.
//   2. Press the Play button in Xcode to build and run the app.
//   3. Create some in-memory state in the app on the phone,
//      e.g. by navigating to a different screen.
//   4. Background the app on the phone, e.g. by going back to the home screen.
//   5. Press the Stop button in Xcode to terminate the app while running in
//      the background.
//   6. Open the app again on the phone (not via Xcode). It will restart
//      and restore its state.
// {@endtemplate}
//
// See also:
//
//  * [ServicesBinding.restorationManager], which holds the singleton instance
//    of the [RestorationManager] for the currently running application.
//  * [RestorationBucket], which make up the restoration data hierarchy.
//  * [RestorationMixin], which uses [RestorationBucket]s behind the scenes
//    to make [State] objects of [StatefulWidget]s restorable.
message FlutterRestorationManagerType {
  oneof constructor {
    FlutterRestorationManager flutter_restoration_manager = 2;
  }
}

// package:flutter/src/widgets/binding.dart
//
// A widget for the root of the widget tree.
//
// Exposes an [attach] method to attach the widget tree to a [BuildOwner]. That
// method also bootstraps the element tree.
//
// Used by [WidgetsBinding.attachRootWidget] (which is indirectly called by
// [runApp]) to bootstrap applications.
message FlutterRootWidgetType {
  oneof constructor {
    FlutterRootWidget flutter_root_widget = 2;
  }
}

// package:flutter/src/widgets/router.dart
//
// A route information provider that provides route information for the
// [Router] widget
//
// This provider is responsible for handing the route information through [value]
// getter and notifies listeners, typically the [Router] widget, when a new
// route information is available.
//
// When the router opts for route information reporting (by overriding the
// [RouterDelegate.currentConfiguration] to return non-null), override the
// [routerReportsNewRouteInformation] method to process the route information.
//
// See also:
//
//  * [PlatformRouteInformationProvider], which wires up the itself with the
//    [WidgetsBindingObserver.didPushRoute] to propagate platform push route
//    intent to the [Router] widget, as well as reports new route information
//    from the [Router] back to the engine by overriding the
//    [routerReportsNewRouteInformation].
message FlutterRouteInformationProviderType {
  oneof constructor {
    FlutterPlatformRouteInformationProvider flutter_platform_route_information_provider = 2;
  }
}

// package:flutter/src/widgets/router.dart
//
// A piece of routing information.
//
// The route information consists of a location string of the application and
// a state object that configures the application in that location.
//
// This information flows two ways, from the [RouteInformationProvider] to the
// [Router] or from the [Router] to [RouteInformationProvider].
//
// In the former case, the [RouteInformationProvider] notifies the [Router]
// widget when a new [RouteInformation] is available. The [Router] widget takes
// these information and navigates accordingly.
//
// The latter case happens in web application where the [Router] reports route
// changes back to the web engine.
//
// The current [RouteInformation] of an application is also used for state
// restoration purposes. Before an application is killed, the [Router] converts
// its current configurations into a [RouteInformation] object utilizing the
// [RouteInformationProvider]. The [RouteInformation] object is then serialized
// out and persisted. During state restoration, the object is deserialized and
// passed back to the [RouteInformationProvider], which turns it into a
// configuration for the [Router] again to restore its state from.
message FlutterRouteInformationType {
  oneof constructor {
    FlutterRouteInformation flutter_route_information = 2;
  }
}

// package:flutter/src/widgets/scroll_configuration.dart
//
// Describes how [Scrollable] widgets should behave.
//
// {@template flutter.widgets.scrollBehavior}
// Used by [ScrollConfiguration] to configure the [Scrollable] widgets in a
// subtree.
//
// This class can be extended to further customize a [ScrollBehavior] for a
// subtree. For example, overriding [ScrollBehavior.getScrollPhysics] sets the
// default [ScrollPhysics] for [Scrollable]s that inherit this [ScrollConfiguration].
// Overriding [ScrollBehavior.buildOverscrollIndicator] can be used to add or change
// the default [GlowingOverscrollIndicator] decoration, while
// [ScrollBehavior.buildScrollbar] can be changed to modify the default [Scrollbar].
//
// When looking to easily toggle the default decorations, you can use
// [ScrollBehavior.copyWith] instead of creating your own [ScrollBehavior] class.
// The `scrollbar` and `overscrollIndicator` flags can turn these decorations off.
// {@endtemplate}
//
// See also:
//
//   * [ScrollConfiguration], the inherited widget that controls how
//     [Scrollable] widgets behave in a subtree.
message FlutterScrollBehaviorType {
  oneof constructor {
    CupertinoScrollBehavior cupertino_scroll_behavior = 2;
    FlutterScrollBehavior flutter_scroll_behavior = 3;
    MaterialMaterialScrollBehavior material_material_scroll_behavior = 4;
  }
}

// package:flutter/src/widgets/scroll_context.dart
//
// An interface that [Scrollable] widgets implement in order to use
// [ScrollPosition].
//
// See also:
//
//  * [ScrollableState], which is the most common implementation of this
//    interface.
//  * [ScrollPosition], which uses this interface to communicate with the
//    scrollable widget.
message FlutterScrollContextType {
  oneof constructor {
    FlutterScrollableState flutter_scrollable_state = 2;
  }
}

// package:flutter/src/widgets/scroll_controller.dart
//
// Controls a scrollable widget.
//
// Scroll controllers are typically stored as member variables in [State]
// objects and are reused in each [State.build]. A single scroll controller can
// be used to control multiple scrollable widgets, but some operations, such
// as reading the scroll [offset], require the controller to be used with a
// single scrollable widget.
//
// A scroll controller creates a [ScrollPosition] to manage the state specific
// to an individual [Scrollable] widget. To use a custom [ScrollPosition],
// subclass [ScrollController] and override [createScrollPosition].
//
// {@macro flutter.widgets.scrollPosition.listening}
//
// Typically used with [ListView], [GridView], [CustomScrollView].
//
// See also:
//
//  * [ListView], [GridView], [CustomScrollView], which can be controlled by a
//    [ScrollController].
//  * [Scrollable], which is the lower-level widget that creates and associates
//    [ScrollPosition] objects with [ScrollController] objects.
//  * [PageController], which is an analogous object for controlling a
//    [PageView].
//  * [ScrollPosition], which manages the scroll offset for an individual
//    scrolling widget.
//  * [ScrollNotification] and [NotificationListener], which can be used to
//    listen to scrolling occur without using a [ScrollController].
message FlutterScrollControllerType {
  oneof constructor {
    FlutterFixedExtentScrollController flutter_fixed_extent_scroll_controller = 2;
    FlutterPageController flutter_page_controller = 3;
    FlutterScrollController flutter_scroll_controller = 4;
    FlutterTrackingScrollController flutter_tracking_scroll_controller = 5;
  }
}

// package:flutter/src/widgets/scroll_physics.dart
//
// Determines the physics of a [Scrollable] widget.
//
// For example, determines how the [Scrollable] will behave when the user
// reaches the maximum scroll extent or when the user stops scrolling.
//
// When starting a physics [Simulation], the current scroll position and
// velocity are used as the initial conditions for the particle in the
// simulation. The movement of the particle in the simulation is then used to
// determine the scroll position for the widget.
//
// Instead of creating your own subclasses, [parent] can be used to combine
// [ScrollPhysics] objects of different types to get the desired scroll physics.
// For example:
//
// ```dart
// const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics())
// ```
//
// You can also use `applyTo`, which is useful when you already have
// an instance of [ScrollPhysics]:
//
// ```dart
// ScrollPhysics physics = const BouncingScrollPhysics();
// // ...
// final ScrollPhysics mergedPhysics = physics.applyTo(const AlwaysScrollableScrollPhysics());
// ```
//
// When implementing a subclass, you must override [applyTo] so that it returns
// an appropriate instance of your subclass.  Otherwise, classes like
// [Scrollable] that inform a [ScrollPosition] will combine them with
// the default [ScrollPhysics] object instead of your custom subclass.
message FlutterScrollPhysicsType {
  oneof constructor {
    FlutterAlwaysScrollableScrollPhysics flutter_always_scrollable_scroll_physics = 2;
    FlutterBouncingScrollPhysics flutter_bouncing_scroll_physics = 3;
    FlutterClampingScrollPhysics flutter_clamping_scroll_physics = 4;
    FlutterFixedExtentScrollPhysics flutter_fixed_extent_scroll_physics = 5;
    FlutterNeverScrollableScrollPhysics flutter_never_scrollable_scroll_physics = 6;
    FlutterPageScrollPhysics flutter_page_scroll_physics = 7;
    FlutterRangeMaintainingScrollPhysics flutter_range_maintaining_scroll_physics = 8;
    FlutterScrollPhysics flutter_scroll_physics = 9;
  }
}

// package:flutter/src/widgets/scroll_position.dart
//
// Determines which portion of the content is visible in a scroll view.
//
// The [pixels] value determines the scroll offset that the scroll view uses to
// select which part of its content to display. As the user scrolls the
// viewport, this value changes, which changes the content that is displayed.
//
// The [ScrollPosition] applies [physics] to scrolling, and stores the
// [minScrollExtent] and [maxScrollExtent].
//
// Scrolling is controlled by the current [activity], which is set by
// [beginActivity]. [ScrollPosition] itself does not start any activities.
// Instead, concrete subclasses, such as [ScrollPositionWithSingleContext],
// typically start activities in response to user input or instructions from a
// [ScrollController].
//
// This object is a [Listenable] that notifies its listeners when [pixels]
// changes.
//
// {@template flutter.widgets.scrollPosition.listening}
// ### Accessing Scrolling Information
//
// There are several ways to acquire information about scrolling and
// scrollable widgets, but each provides different types of information about
// the scrolling activity, the position, and the dimensions of the [Viewport].
//
// A [ScrollController] is a [Listenable]. It notifies its listeners whenever
// any of the attached [ScrollPosition]s notify _their_ listeners, such as when
// scrolling occurs. This is very similar to using a [NotificationListener] of
// type [ScrollNotification] to listen to changes in the scroll position, with
// the difference being that a notification listener will provide information
// about the scrolling activity. A notification listener can further listen to
// specific subclasses of [ScrollNotification], like [UserScrollNotification].
//
// {@tool dartpad}
// This sample shows the difference between using a [ScrollController] or a
// [NotificationListener] of type [ScrollNotification] to listen to scrolling
// activities. Toggling the [Radio] button switches between the two.
// Using a [ScrollNotification] will provide details about the scrolling
// activity, along with the metrics of the [ScrollPosition], but not the scroll
// position object itself. By listening with a [ScrollController], the position
// object is directly accessible.
// Both of these types of notifications are only triggered by scrolling.
//
// ** See code in examples/api/lib/widgets/scroll_position/scroll_controller_notification.0.dart **
// {@end-tool}
//
// [ScrollController] does not notify its listeners when the list of
// [ScrollPosition]s attached to the scroll controller changes. To listen to
// the attaching and detaching of scroll positions to the controller, use the
// [ScrollController.onAttach] and [ScrollController.onDetach] methods. This is
// also useful for adding a listener to the
// [ScrollPosition.isScrollingNotifier] when the position is created during the
// build method of the [Scrollable].
//
// At the time that a scroll position is attached, the [ScrollMetrics], such as
// the [ScrollMetrics.maxScrollExtent], are not yet available. These are not
// determined until the [Scrollable] has finished laying out its contents and
// computing things like the full extent of that content.
// [ScrollPosition.hasContentDimensions] can be used to know when the
// metrics are available, or a [ScrollMetricsNotification] can be used,
// discussed further below.
//
// {@tool dartpad}
// This sample shows how to apply a listener to the
// [ScrollPosition.isScrollingNotifier] using [ScrollController.onAttach].
// This is used to change the [AppBar]'s color when scrolling is occurring.
//
// ** See code in examples/api/lib/widgets/scroll_position/scroll_controller_on_attach.0.dart **
// {@end-tool}
//
// #### From a different context
//
// When needing to access scrolling information from a context that is within
// the scrolling widget itself, use [Scrollable.of] to access the
// [ScrollableState] and the [ScrollableState.position]. This would be the same
// [ScrollPosition] attached to a [ScrollController].
//
// When needing to access scrolling information from a context that is not an
// ancestor of the scrolling widget, use [ScrollNotificationObserver]. This is
// used by [AppBar] to create the scrolled under effect. Since [Scaffold.appBar]
// is a separate subtree from the [Scaffold.body], scroll notifications would
// not bubble up to the app bar. Use
// [ScrollNotificationObserverState.addListener] to listen to scroll
// notifications happening outside of the current context.
//
// #### Dimension changes
//
// Lastly, listening to a [ScrollController] or a [ScrollPosition] will
// _not_ notify when the [ScrollMetrics] of a given scroll position changes,
// such as when the window is resized, changing the dimensions of the
// [Viewport] and the previously mentioned extents of the scrollable. In order
// to listen to changes in scroll metrics, use a [NotificationListener] of type
// [ScrollMetricsNotification]. This type of notification differs from
// [ScrollNotification], as it is not associated with the activity of
// scrolling, but rather the dimensions of the scrollable area, such as the
// window size.
//
// {@tool dartpad}
// This sample shows how a [ScrollMetricsNotification] is dispatched when
// the `windowSize` is changed. Press the floating action button to increase
// the scrollable window's size.
//
// ** See code in examples/api/lib/widgets/scroll_position/scroll_metrics_notification.0.dart **
// {@end-tool}
// {@endtemplate}
//
// ## Subclassing ScrollPosition
//
// Over time, a [Scrollable] might have many different [ScrollPosition]
// objects. For example, if [Scrollable.physics] changes type, [Scrollable]
// creates a new [ScrollPosition] with the new physics. To transfer state from
// the old instance to the new instance, subclasses implement [absorb]. See
// [absorb] for more details.
//
// Subclasses also need to call [didUpdateScrollDirection] whenever
// [userScrollDirection] changes values.
//
// See also:
//
//  * [Scrollable], which uses a [ScrollPosition] to determine which portion of
//    its content to display.
//  * [ScrollController], which can be used with [ListView], [GridView] and
//    other scrollable widgets to control a [ScrollPosition].
//  * [ScrollPositionWithSingleContext], which is the most commonly used
//    concrete subclass of [ScrollPosition].
//  * [ScrollNotification] and [NotificationListener], which can be used to watch
//    the scroll position without using a [ScrollController].
message FlutterScrollPositionType {
  oneof constructor {
    FlutterScrollPositionWithSingleContext flutter_scroll_position_with_single_context = 2;
  }
}

// package:flutter/src/widgets/selectable_region.dart
//
// State for a [SelectableRegion].
message FlutterSelectableRegionStateType {
  oneof constructor {
    FlutterSelectableRegionState flutter_selectable_region_state = 2;
  }
}

// package:flutter/src/rendering/selection.dart
//
// A registrar that keeps track of [Selectable]s in the subtree.
//
// A [Selectable] is only included in the [SelectableRegion] if they are
// registered with a [SelectionRegistrar]. Once a [Selectable] is registered,
// it will receive [SelectionEvent]s in
// [SelectionHandler.dispatchSelectionEvent].
//
// Use [SelectionContainer.maybeOf] to get the immediate [SelectionRegistrar]
// in the ancestor chain above the build context.
//
// See also:
//  * [SelectableRegion], which provides an overview of the selection system.
//  * [SelectionRegistrarScope], which hosts the [SelectionRegistrar] for the
//    subtree.
//  * [SelectionRegistrant], which auto registers the object with the mixin to
//    [SelectionRegistrar].
message FlutterSelectionRegistrarType {
  oneof constructor {
    FlutterSelectableRegionState flutter_selectable_region_state = 2;
  }
}

// package:flutter/src/painting/borders.dart
//
// Base class for shape outlines.
//
// This class handles how to add multiple borders together. Subclasses define
// various shapes, like circles ([CircleBorder]), rounded rectangles
// ([RoundedRectangleBorder]), continuous rectangles
// ([ContinuousRectangleBorder]), or beveled rectangles
// ([BeveledRectangleBorder]).
//
// See also:
//
//  * [ShapeDecoration], which can be used with [DecoratedBox] to show a shape.
//  * [Material] (and many other widgets in the Material library), which takes
//    a [ShapeBorder] to define its shape.
//  * [NotchedShape], which describes a shape with a hole in it.
message FlutterShapeBorderType {
  oneof constructor {
    FlutterBeveledRectangleBorder flutter_beveled_rectangle_border = 2;
    FlutterBorder flutter_border = 3;
    FlutterBorderDirectional flutter_border_directional = 4;
    FlutterBorderNamedAll flutter_border_named_all = 5;
    FlutterBorderNamedFromBorderSide flutter_border_named_from_border_side = 6;
    FlutterBorderNamedSymmetric flutter_border_named_symmetric = 7;
    FlutterCircleBorder flutter_circle_border = 8;
    FlutterContinuousRectangleBorder flutter_continuous_rectangle_border = 9;
    FlutterLinearBorder flutter_linear_border = 10;
    FlutterLinearBorderNamedBottom flutter_linear_border_named_bottom = 11;
    FlutterLinearBorderNamedEnd flutter_linear_border_named_end = 12;
    FlutterLinearBorderNamedStart flutter_linear_border_named_start = 13;
    FlutterLinearBorderNamedTop flutter_linear_border_named_top = 14;
    FlutterOvalBorder flutter_oval_border = 15;
    FlutterRoundedRectangleBorder flutter_rounded_rectangle_border = 16;
    FlutterStadiumBorder flutter_stadium_border = 17;
    FlutterStarBorder flutter_star_border = 18;
    FlutterStarBorderNamedPolygon flutter_star_border_named_polygon = 19;
    MaterialOutlineInputBorder material_outline_input_border = 20;
    MaterialUnderlineInputBorder material_underline_input_border = 21;
  }
}

// package:flutter/src/widgets/shortcuts.dart
//
// A manager of keyboard shortcut bindings used by [Shortcuts] to handle key
// events.
//
// The manager may be listened to (with [addListener]/[removeListener]) for
// change notifications when the shortcuts change.
//
// Typically, a [Shortcuts] widget supplies its own manager, but in uncommon
// cases where overriding the usual shortcut manager behavior is desired, a
// subclassed [ShortcutManager] may be supplied.
message FlutterShortcutManagerType {
  oneof constructor {
    FlutterShortcutManager flutter_shortcut_manager = 2;
  }
}

// package:flutter/src/rendering/shifted_box.dart
//
// A delegate for computing the layout of a render object with a single child.
//
// Used by [CustomSingleChildLayout] (in the widgets library) and
// [RenderCustomSingleChildLayoutBox] (in the rendering library).
//
// When asked to layout, [CustomSingleChildLayout] first calls [getSize] with
// its incoming constraints to determine its size. It then calls
// [getConstraintsForChild] to determine the constraints to apply to the child.
// After the child completes its layout, [RenderCustomSingleChildLayoutBox]
// calls [getPositionForChild] to determine the child's position.
//
// The [shouldRelayout] method is called when a new instance of the class
// is provided, to check if the new instance actually represents different
// information.
//
// The most efficient way to trigger a relayout is to supply a `relayout`
// argument to the constructor of the [SingleChildLayoutDelegate]. The custom
// layout will listen to this value and relayout whenever the Listenable
// notifies its listeners, such as when an [Animation] ticks. This allows
// the custom layout to avoid the build phase of the pipeline.
//
// See also:
//
//  * [CustomSingleChildLayout], the widget that uses this delegate.
//  * [RenderCustomSingleChildLayoutBox], render object that uses this
//    delegate.
message FlutterSingleChildLayoutDelegateType {
  oneof constructor {
    FlutterDesktopTextSelectionToolbarLayoutDelegate flutter_desktop_text_selection_toolbar_layout_delegate = 2;
    FlutterTextSelectionToolbarLayoutDelegate flutter_text_selection_toolbar_layout_delegate = 3;
    MaterialSpellCheckSuggestionsToolbarLayoutDelegate material_spell_check_suggestions_toolbar_layout_delegate = 4;
  }
}

// package:flutter/src/widgets/framework.dart
//
// A superclass for [RenderObjectWidget]s that configure [RenderObject] subclasses
// that have a single child slot.
//
// The render object assigned to this widget should make use of
// [RenderObjectWithChildMixin] to implement a single-child model. The mixin
// exposes a [RenderObjectWithChildMixin.child] property that allows retrieving
// the render object belonging to the [child] widget.
//
// Subclasses must implement [createRenderObject] and [updateRenderObject].
message FlutterSingleChildRenderObjectWidgetType {
  oneof constructor {
    FlutterAbsorbPointer flutter_absorb_pointer = 2;
    FlutterAlign flutter_align = 3;
    FlutterAspectRatio flutter_aspect_ratio = 4;
    FlutterBackdropFilter flutter_backdrop_filter = 5;
    FlutterBaseline flutter_baseline = 6;
    FlutterBlockSemantics flutter_block_semantics = 7;
    FlutterCenter flutter_center = 8;
    FlutterClipOval flutter_clip_oval = 9;
    FlutterClipPath flutter_clip_path = 10;
    FlutterClipRRect flutter_clip_r_rect = 11;
    FlutterClipRect flutter_clip_rect = 12;
    FlutterColorFiltered flutter_color_filtered = 13;
    FlutterColoredBox flutter_colored_box = 14;
    FlutterCompositedTransformFollower flutter_composited_transform_follower = 15;
    FlutterCompositedTransformTarget flutter_composited_transform_target = 16;
    FlutterConstrainedBox flutter_constrained_box = 17;
    FlutterCustomPaint flutter_custom_paint = 18;
    FlutterCustomSingleChildLayout flutter_custom_single_child_layout = 19;
    FlutterDecoratedBox flutter_decorated_box = 20;
    FlutterDecoratedSliver flutter_decorated_sliver = 21;
    FlutterExcludeSemantics flutter_exclude_semantics = 22;
    FlutterFittedBox flutter_fitted_box = 23;
    FlutterFractionalTranslation flutter_fractional_translation = 24;
    FlutterFractionallySizedBox flutter_fractionally_sized_box = 25;
    FlutterIgnoreBaseline flutter_ignore_baseline = 26;
    FlutterIgnorePointer flutter_ignore_pointer = 27;
    FlutterImageFiltered flutter_image_filtered = 28;
    FlutterIndexedSemantics flutter_indexed_semantics = 29;
    FlutterIntrinsicHeight flutter_intrinsic_height = 30;
    FlutterIntrinsicWidth flutter_intrinsic_width = 31;
    FlutterLimitedBox flutter_limited_box = 32;
    FlutterListener flutter_listener = 33;
    FlutterMergeSemantics flutter_merge_semantics = 34;
    FlutterMetaData flutter_meta_data = 35;
    FlutterMouseRegion flutter_mouse_region = 36;
    FlutterOffstage flutter_offstage = 37;
    FlutterOpacity flutter_opacity = 38;
    FlutterOverflowBox flutter_overflow_box = 39;
    FlutterPadding flutter_padding = 40;
    FlutterPhysicalModel flutter_physical_model = 41;
    FlutterRepaintBoundary flutter_repaint_boundary = 42;
    FlutterRepaintBoundaryNamedWrap flutter_repaint_boundary_named_wrap = 43;
    FlutterRotatedBox flutter_rotated_box = 44;
    FlutterSemantics flutter_semantics = 45;
    FlutterSemanticsNamedFromProperties flutter_semantics_named_from_properties = 46;
    FlutterSizeChangedLayoutNotifier flutter_size_changed_layout_notifier = 47;
    FlutterSizedBox flutter_sized_box = 48;
    FlutterSizedBoxNamedExpand flutter_sized_box_named_expand = 49;
    FlutterSizedBoxNamedFromSize flutter_sized_box_named_from_size = 50;
    FlutterSizedBoxNamedShrink flutter_sized_box_named_shrink = 51;
    FlutterSizedBoxNamedSquare flutter_sized_box_named_square = 52;
    FlutterSizedOverflowBox flutter_sized_overflow_box = 53;
    FlutterSliverIgnorePointer flutter_sliver_ignore_pointer = 54;
    FlutterSliverOffstage flutter_sliver_offstage = 55;
    FlutterSliverOpacity flutter_sliver_opacity = 56;
    FlutterSliverOverlapAbsorber flutter_sliver_overlap_absorber = 57;
    FlutterSliverOverlapInjector flutter_sliver_overlap_injector = 58;
    FlutterSliverPadding flutter_sliver_padding = 59;
    FlutterSliverToBoxAdapter flutter_sliver_to_box_adapter = 60;
    FlutterSnapshotWidget flutter_snapshot_widget = 61;
    FlutterTapRegion flutter_tap_region = 62;
    FlutterTapRegionSurface flutter_tap_region_surface = 63;
    FlutterTextFieldTapRegion flutter_text_field_tap_region = 64;
    FlutterTransform flutter_transform = 65;
    FlutterTransformNamedFlip flutter_transform_named_flip = 66;
    FlutterTransformNamedRotate flutter_transform_named_rotate = 67;
    FlutterTransformNamedScale flutter_transform_named_scale = 68;
    FlutterTransformNamedTranslate flutter_transform_named_translate = 69;
  }
}

// package:flutter/src/widgets/scroll_delegate.dart
//
// A delegate that supplies children for slivers.
//
// Many slivers lazily construct their box children to avoid creating more
// children than are visible through the [Viewport]. Rather than receiving
// their children as an explicit [List], they receive their children using a
// [SliverChildDelegate].
//
// It's uncommon to subclass [SliverChildDelegate]. Instead, consider using one
// of the existing subclasses that provide adaptors to builder callbacks or
// explicit child lists.
//
// {@template flutter.widgets.SliverChildDelegate.lifecycle}
// ## Child elements' lifecycle
//
// ### Creation
//
// While laying out the list, visible children's elements, states and render
// objects will be created lazily based on existing widgets (such as in the
// case of [SliverChildListDelegate]) or lazily provided ones (such as in the
// case of [SliverChildBuilderDelegate]).
//
// ### Destruction
//
// When a child is scrolled out of view, the associated element subtree, states
// and render objects are destroyed. A new child at the same position in the
// sliver will be lazily recreated along with new elements, states and render
// objects when it is scrolled back.
//
// ### Destruction mitigation
//
// In order to preserve state as child elements are scrolled in and out of
// view, the following options are possible:
//
//  * Moving the ownership of non-trivial UI-state-driving business logic
//    out of the sliver child subtree. For instance, if a list contains posts
//    with their number of upvotes coming from a cached network response, store
//    the list of posts and upvote number in a data model outside the list. Let
//    the sliver child UI subtree be easily recreate-able from the
//    source-of-truth model object. Use [StatefulWidget]s in the child widget
//    subtree to store instantaneous UI state only.
//
//  * Letting [KeepAlive] be the root widget of the sliver child widget subtree
//    that needs to be preserved. The [KeepAlive] widget marks the child
//    subtree's top render object child for keepalive. When the associated top
//    render object is scrolled out of view, the sliver keeps the child's
//    render object (and by extension, its associated elements and states) in a
//    cache list instead of destroying them. When scrolled back into view, the
//    render object is repainted as-is (if it wasn't marked dirty in the
//    interim).
//
//    This only works if the [SliverChildDelegate] subclasses don't wrap the
//    child widget subtree with other widgets such as [AutomaticKeepAlive] and
//    [RepaintBoundary] via `addAutomaticKeepAlives` and
//    `addRepaintBoundaries`.
//
//  * Using [AutomaticKeepAlive] widgets (inserted by default in
//    [SliverChildListDelegate] or [SliverChildListDelegate]).
//    [AutomaticKeepAlive] allows descendant widgets to control whether the
//    subtree is actually kept alive or not. This behavior is in contrast with
//    [KeepAlive], which will unconditionally keep the subtree alive.
//
//    As an example, the [EditableText] widget signals its sliver child element
//    subtree to stay alive while its text field has input focus. If it doesn't
//    have focus and no other descendants signaled for keepalive via a
//    [KeepAliveNotification], the sliver child element subtree will be
//    destroyed when scrolled away.
//
//    [AutomaticKeepAlive] descendants typically signal it to be kept alive by
//    using the [AutomaticKeepAliveClientMixin], then implementing the
//    [AutomaticKeepAliveClientMixin.wantKeepAlive] getter and calling
//    [AutomaticKeepAliveClientMixin.updateKeepAlive].
//
// ## Using more than one delegate in a [Viewport]
//
// If multiple delegates are used in a single scroll view, the first child of
// each delegate will always be laid out, even if it extends beyond the
// currently viewable area. This is because at least one child is required in
// order to [estimateMaxScrollOffset] for the whole scroll view, as it uses the
// currently built children to estimate the remaining children's extent.
// {@endtemplate}
//
// See also:
//
//  * [SliverChildBuilderDelegate], which is a delegate that uses a builder
//    callback to construct the children.
//  * [SliverChildListDelegate], which is a delegate that has an explicit list
//    of children.
message FlutterSliverChildDelegateType {
  oneof constructor {
    FlutterSliverChildListDelegate flutter_sliver_child_list_delegate = 2;
    FlutterSliverChildListDelegateNamedFixed flutter_sliver_child_list_delegate_named_fixed = 3;
  }
}

// package:flutter/src/rendering/sliver_grid.dart
//
// Controls the layout of tiles in a grid.
//
// Given the current constraints on the grid, a [SliverGridDelegate] computes
// the layout for the tiles in the grid. The tiles can be placed arbitrarily,
// but it is more efficient to place tiles roughly in order by scroll offset
// because grids reify a contiguous sequence of children.
//
// {@tool dartpad}
// This example shows how a [SliverGridDelegate] returns a [SliverGridLayout]
// configured based on the provided [SliverConstraints] in [getLayout].
//
// ** See code in examples/api/lib/widgets/scroll_view/grid_view.0.dart **
// {@end-tool}
//
// See also:
//
//  * [SliverGridDelegateWithFixedCrossAxisCount], which creates a layout with
//    a fixed number of tiles in the cross axis.
//  * [SliverGridDelegateWithMaxCrossAxisExtent], which creates a layout with
//    tiles that have a maximum cross-axis extent.
//  * [GridView], which uses this delegate to control the layout of its tiles.
//  * [SliverGrid], which uses this delegate to control the layout of its
//    tiles.
//  * [RenderSliverGrid], which uses this delegate to control the layout of its
//    tiles.
message FlutterSliverGridDelegateType {
  oneof constructor {
    FlutterSliverGridDelegateWithFixedCrossAxisCount flutter_sliver_grid_delegate_with_fixed_cross_axis_count = 2;
    FlutterSliverGridDelegateWithMaxCrossAxisExtent flutter_sliver_grid_delegate_with_max_cross_axis_extent = 3;
  }
}

// package:flutter/src/widgets/sliver.dart
//
// A base class for slivers that have multiple box children.
//
// Helps subclasses build their children lazily using a [SliverChildDelegate].
//
// The widgets returned by the [delegate] are cached and the delegate is only
// consulted again if it changes and the new delegate's
// [SliverChildDelegate.shouldRebuild] method returns true.
message FlutterSliverMultiBoxAdaptorWidgetType {
  oneof constructor {
    FlutterSliverFixedExtentList flutter_sliver_fixed_extent_list = 2;
    FlutterSliverFixedExtentListNamedList flutter_sliver_fixed_extent_list_named_list = 3;
    FlutterSliverGrid flutter_sliver_grid = 4;
    FlutterSliverGridNamedCount flutter_sliver_grid_named_count = 5;
    FlutterSliverGridNamedExtent flutter_sliver_grid_named_extent = 6;
    FlutterSliverList flutter_sliver_list = 7;
    FlutterSliverListNamedList flutter_sliver_list_named_list = 8;
    FlutterSliverPrototypeExtentList flutter_sliver_prototype_extent_list = 9;
    FlutterSliverPrototypeExtentListNamedList flutter_sliver_prototype_extent_list_named_list = 10;
  }
}

// package:flutter/src/widgets/nested_scroll_view.dart
//
// Handle to provide to a [SliverOverlapAbsorber], a [SliverOverlapInjector],
// and an [NestedScrollViewViewport], to shift overlap in a [NestedScrollView].
//
// A particular [SliverOverlapAbsorberHandle] can only be assigned to a single
// [SliverOverlapAbsorber] at a time. It can also be (and normally is) assigned
// to one or more [SliverOverlapInjector]s, which must be later descendants of
// the same [NestedScrollViewViewport] as the [SliverOverlapAbsorber]. The
// [SliverOverlapAbsorber] must be a direct descendant of the
// [NestedScrollViewViewport], taking part in the same sliver layout. (The
// [SliverOverlapInjector] can be a descendant that takes part in a nested
// scroll view's sliver layout.)
//
// Whenever the [NestedScrollViewViewport] is marked dirty for layout, it will
// cause its assigned [SliverOverlapAbsorberHandle] to fire notifications. It
// is the responsibility of the [SliverOverlapInjector]s (and any other
// clients) to mark themselves dirty when this happens, in case the geometry
// subsequently changes during layout.
//
// See also:
//
//  * [NestedScrollView], which uses a [NestedScrollViewViewport] and a
//    [SliverOverlapAbsorber] to align its children, and which shows sample
//    usage for this class.
message FlutterSliverOverlapAbsorberHandleType {
  oneof constructor {
    FlutterSliverOverlapAbsorberHandle flutter_sliver_overlap_absorber_handle = 2;
  }
}

// package:flutter/src/widgets/snapshot_widget.dart
//
// A controller for the [SnapshotWidget] that controls when the child image is displayed
// and when to regenerated the child image.
//
// When the value of [allowSnapshotting] is true, the [SnapshotWidget] will paint the child
// widgets based on the [SnapshotMode] of the snapshot widget.
//
// The controller notifies its listeners when the value of [allowSnapshotting] changes
// or when [clear] is called.
//
// To force [SnapshotWidget] to recreate the child image, call [clear].
message FlutterSnapshotControllerType {
  oneof constructor {
    FlutterSnapshotController flutter_snapshot_controller = 2;
  }
}

// package:flutter/src/widgets/spell_check.dart
//
// Controls how spell check is performed for text input.
//
// This configuration determines the [SpellCheckService] used to fetch the
// [List<SuggestionSpan>] spell check results and the [TextStyle] used to
// mark misspelled words within text input.
message FlutterSpellCheckConfigurationType {
  oneof constructor {
    FlutterSpellCheckConfiguration flutter_spell_check_configuration = 2;
    FlutterSpellCheckConfigurationNamedDisabled flutter_spell_check_configuration_named_disabled = 3;
  }
}

// package:flutter/src/services/spell_check.dart
//
// Determines how spell check results are received for text input.
message FlutterSpellCheckServiceType {
  oneof constructor {
    FlutterDefaultSpellCheckService flutter_default_spell_check_service = 2;
  }
}

// package:flutter/src/animation/animation_style.dart
//
// Used to override the default parameters of an animation.
//
// Currently, this class is used by the following widgets:
// - [ExpansionTile]
// - [MaterialApp]
// - [PopupMenuButton]
//
// If [duration] and [reverseDuration] are set to [Duration.zero], the
// corresponding animation will be disabled.
//
// All of the parameters are optional. If no parameters are specified,
// the default animation will be used.
message FlutterSrcAnimationAnimationStyleType {
  oneof constructor {
    FlutterSrcAnimationAnimationStyle flutter_src_animation_animation_style = 2;
  }
}

// package:flutter/src/animation/curves.dart
//
// An parametric animation easing curve, i.e. a mapping of the unit interval to
// the unit interval.
//
// Easing curves are used to adjust the rate of change of an animation over
// time, allowing them to speed up and slow down, rather than moving at a
// constant rate.
//
// A [Curve] must map t=0.0 to 0.0 and t=1.0 to 1.0.
//
// See also:
//
//  * [Curves], a collection of common animation easing curves.
//  * [CurveTween], which can be used to apply a [Curve] to an [Animation].
//  * [Canvas.drawArc], which draws an arc, and has nothing to do with easing
//    curves.
//  * [Animatable], for a more flexible interface that maps fractions to
//    arbitrary values.
message FlutterSrcAnimationCurveType {
  oneof constructor {
    FlutterSrcAnimationCatmullRomCurve flutter_src_animation_catmull_rom_curve = 2;
    FlutterSrcAnimationCatmullRomCurveNamedPrecompute flutter_src_animation_catmull_rom_curve_named_precompute = 3;
    FlutterSrcAnimationCubic flutter_src_animation_cubic = 4;
    FlutterSrcAnimationElasticInCurve flutter_src_animation_elastic_in_curve = 5;
    FlutterSrcAnimationElasticInOutCurve flutter_src_animation_elastic_in_out_curve = 6;
    FlutterSrcAnimationElasticOutCurve flutter_src_animation_elastic_out_curve = 7;
    FlutterSrcAnimationFlippedCurve flutter_src_animation_flipped_curve = 8;
    FlutterSrcAnimationInterval flutter_src_animation_interval = 9;
    FlutterSrcAnimationSawTooth flutter_src_animation_saw_tooth = 10;
    FlutterSrcAnimationThreePointCubic flutter_src_animation_three_point_cubic = 11;
    FlutterSrcAnimationThreshold flutter_src_animation_threshold = 12;
  }
}

// package:flutter/src/scheduler/ticker.dart
//
// An interface implemented by classes that can vend [Ticker] objects.
//
// Tickers can be used by any object that wants to be notified whenever a frame
// triggers, but are most commonly used indirectly via an
// [AnimationController]. [AnimationController]s need a [TickerProvider] to
// obtain their [Ticker]. If you are creating an [AnimationController] from a
// [State], then you can use the [TickerProviderStateMixin] and
// [SingleTickerProviderStateMixin] classes to obtain a suitable
// [TickerProvider]. The widget test framework [WidgetTester] object can be
// used as a ticker provider in the context of tests. In other contexts, you
// will have to either pass a [TickerProvider] from a higher level (e.g.
// indirectly from a [State] that mixes in [TickerProviderStateMixin]), or
// create a custom [TickerProvider] subclass.
message FlutterSrcSchedulerTickerProviderType {
  oneof constructor {
    FlutterAnimatedGridState flutter_animated_grid_state = 2;
    FlutterAnimatedListState flutter_animated_list_state = 3;
    FlutterEditableTextState flutter_editable_text_state = 4;
    FlutterNavigatorState flutter_navigator_state = 5;
    FlutterOverlayState flutter_overlay_state = 6;
    FlutterRawScrollbarState flutter_raw_scrollbar_state = 7;
    FlutterScrollableState flutter_scrollable_state = 8;
    FlutterSliverAnimatedGridState flutter_sliver_animated_grid_state = 9;
    FlutterSliverAnimatedListState flutter_sliver_animated_list_state = 10;
    FlutterSliverReorderableListState flutter_sliver_reorderable_list_state = 11;
    MaterialDrawerControllerState material_drawer_controller_state = 12;
    MaterialRefreshIndicatorState material_refresh_indicator_state = 13;
    MaterialScaffoldMessengerState material_scaffold_messenger_state = 14;
    MaterialScaffoldState material_scaffold_state = 15;
    MaterialTooltipState material_tooltip_state = 16;
  }
}

// package:flutter/src/semantics/semantics.dart
//
// A string that carries a list of [StringAttribute]s.
message FlutterSrcSemanticsAttributedStringType {
  oneof constructor {
    FlutterSrcSemanticsAttributedString flutter_src_semantics_attributed_string = 2;
  }
}

// package:flutter/src/semantics/semantics.dart
//
// Provides hint values which override the default hints on supported
// platforms.
//
// On iOS, these values are always ignored.
message FlutterSrcSemanticsSemanticsHintOverridesType {
  oneof constructor {
    FlutterSrcSemanticsSemanticsHintOverrides flutter_src_semantics_semantics_hint_overrides = 2;
  }
}

// package:flutter/src/semantics/semantics.dart
//
// Contains properties used by assistive technologies to make the application
// more accessible.
//
// The properties of this class are used to generate a [SemanticsNode]s in the
// semantics tree.
message FlutterSrcSemanticsSemanticsPropertiesType {
  oneof constructor {
    FlutterSrcSemanticsSemanticsProperties flutter_src_semantics_semantics_properties = 2;
  }
}

// package:flutter/src/semantics/semantics.dart
//
// Base class for all sort keys for [SemanticsProperties.sortKey] accessibility
// traversal order sorting.
//
// Sort keys are sorted by [name], then by the comparison that the subclass
// implements. If [SemanticsProperties.sortKey] is specified, sort keys within
// the same semantic group must all be of the same type.
//
// Keys with no [name] are compared to other keys with no [name], and will
// be traversed before those with a [name].
//
// If no sort key is applied to a semantics node, then it will be ordered using
// a platform dependent default algorithm.
//
// See also:
//
//  * [OrdinalSortKey] for a sort key that sorts using an ordinal.
message FlutterSrcSemanticsSemanticsSortKeyType {
  oneof constructor {
    FlutterSrcSemanticsOrdinalSortKey flutter_src_semantics_ordinal_sort_key = 2;
  }
}

// package:flutter/src/semantics/semantics.dart
//
// A tag for a [SemanticsNode].
//
// Tags can be interpreted by the parent of a [SemanticsNode]
// and depending on the presence of a tag the parent can for example decide
// how to add the tagged node as a child. Tags are not sent to the engine.
//
// As an example, the [RenderSemanticsGestureHandler] uses tags to determine
// if a child node should be excluded from the scrollable area for semantic
// purposes.
//
// The provided [name] is only used for debugging. Two tags created with the
// same [name] and the `new` operator are not considered identical. However,
// two tags created with the same [name] and the `const` operator are always
// identical.
message FlutterSrcSemanticsSemanticsTagType {
  oneof constructor {
    FlutterPlaceholderSpanIndexSemanticsTag flutter_placeholder_span_index_semantics_tag = 2;
    FlutterSrcSemanticsSemanticsTag flutter_src_semantics_semantics_tag = 3;
  }
}

// package:flutter/src/widgets/framework.dart
//
// A widget that has mutable state.
//
// State is information that (1) can be read synchronously when the widget is
// built and (2) might change during the lifetime of the widget. It is the
// responsibility of the widget implementer to ensure that the [State] is
// promptly notified when such state changes, using [State.setState].
//
// A stateful widget is a widget that describes part of the user interface by
// building a constellation of other widgets that describe the user interface
// more concretely. The building process continues recursively until the
// description of the user interface is fully concrete (e.g., consists
// entirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s).
//
// Stateful widgets are useful when the part of the user interface you are
// describing can change dynamically, e.g. due to having an internal
// clock-driven state, or depending on some system state. For compositions that
// depend only on the configuration information in the object itself and the
// [BuildContext] in which the widget is inflated, consider using
// [StatelessWidget].
//
// {@youtube 560 315 https://www.youtube.com/watch?v=AqCMFXEmf3w}
//
// [StatefulWidget] instances themselves are immutable and store their mutable
// state either in separate [State] objects that are created by the
// [createState] method, or in objects to which that [State] subscribes, for
// example [Stream] or [ChangeNotifier] objects, to which references are stored
// in final fields on the [StatefulWidget] itself.
//
// The framework calls [createState] whenever it inflates a
// [StatefulWidget], which means that multiple [State] objects might be
// associated with the same [StatefulWidget] if that widget has been inserted
// into the tree in multiple places. Similarly, if a [StatefulWidget] is
// removed from the tree and later inserted in to the tree again, the framework
// will call [createState] again to create a fresh [State] object, simplifying
// the lifecycle of [State] objects.
//
// A [StatefulWidget] keeps the same [State] object when moving from one
// location in the tree to another if its creator used a [GlobalKey] for its
// [key]. Because a widget with a [GlobalKey] can be used in at most one
// location in the tree, a widget that uses a [GlobalKey] has at most one
// associated element. The framework takes advantage of this property when
// moving a widget with a global key from one location in the tree to another
// by grafting the (unique) subtree associated with that widget from the old
// location to the new location (instead of recreating the subtree at the new
// location). The [State] objects associated with [StatefulWidget] are grafted
// along with the rest of the subtree, which means the [State] object is reused
// (instead of being recreated) in the new location. However, in order to be
// eligible for grafting, the widget must be inserted into the new location in
// the same animation frame in which it was removed from the old location.
//
// ## Performance considerations
//
// There are two primary categories of [StatefulWidget]s.
//
// The first is one which allocates resources in [State.initState] and disposes
// of them in [State.dispose], but which does not depend on [InheritedWidget]s
// or call [State.setState]. Such widgets are commonly used at the root of an
// application or page, and communicate with subwidgets via [ChangeNotifier]s,
// [Stream]s, or other such objects. Stateful widgets following such a pattern
// are relatively cheap (in terms of CPU and GPU cycles), because they are
// built once then never update. They can, therefore, have somewhat complicated
// and deep build methods.
//
// The second category is widgets that use [State.setState] or depend on
// [InheritedWidget]s. These will typically rebuild many times during the
// application's lifetime, and it is therefore important to minimize the impact
// of rebuilding such a widget. (They may also use [State.initState] or
// [State.didChangeDependencies] and allocate resources, but the important part
// is that they rebuild.)
//
// There are several techniques one can use to minimize the impact of
// rebuilding a stateful widget:
//
//  * Push the state to the leaves. For example, if your page has a ticking
//    clock, rather than putting the state at the top of the page and
//    rebuilding the entire page each time the clock ticks, create a dedicated
//    clock widget that only updates itself.
//
//  * Minimize the number of nodes transitively created by the build method and
//    any widgets it creates. Ideally, a stateful widget would only create a
//    single widget, and that widget would be a [RenderObjectWidget].
//    (Obviously this isn't always practical, but the closer a widget gets to
//    this ideal, the more efficient it will be.)
//
//  * If a subtree does not change, cache the widget that represents that
//    subtree and re-use it each time it can be used. To do this, assign
//    a widget to a `final` state variable and re-use it in the build method. It
//    is massively more efficient for a widget to be re-used than for a new (but
//    identically-configured) widget to be created. Another caching strategy
//    consists in extracting the mutable part of the widget into a [StatefulWidget]
//    which accepts a child parameter.
//
//  * Use `const` widgets where possible. (This is equivalent to caching a
//    widget and re-using it.)
//
//  * Avoid changing the depth of any created subtrees or changing the type of
//    any widgets in the subtree. For example, rather than returning either the
//    child or the child wrapped in an [IgnorePointer], always wrap the child
//    widget in an [IgnorePointer] and control the [IgnorePointer.ignoring]
//    property. This is because changing the depth of the subtree requires
//    rebuilding, laying out, and painting the entire subtree, whereas just
//    changing the property will require the least possible change to the
//    render tree (in the case of [IgnorePointer], for example, no layout or
//    repaint is necessary at all).
//
//  * If the depth must be changed for some reason, consider wrapping the
//    common parts of the subtrees in widgets that have a [GlobalKey] that
//    remains consistent for the life of the stateful widget. (The
//    [KeyedSubtree] widget may be useful for this purpose if no other widget
//    can conveniently be assigned the key.)
//
// {@macro flutter.flutter.widgets.framework.prefer_const_over_helper}
//
// This video gives more explanations on why `const` constructors are important
// and why a [Widget] is better than a helper method.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=IOyq-eTRhvo}
//
// For more details on the mechanics of rebuilding a widget, see
// the discussion at [Element.rebuild].
//
// {@tool snippet}
//
// This is a skeleton of a stateful widget subclass called `YellowBird`.
//
// In this example, the [State] has no actual state. State is normally
// represented as private member fields. Also, normally widgets have more
// constructor arguments, each of which corresponds to a `final` property.
//
// ```dart
// class YellowBird extends StatefulWidget {
//   const YellowBird({ super.key });
//
//   @override
//   State<YellowBird> createState() => _YellowBirdState();
// }
//
// class _YellowBirdState extends State<YellowBird> {
//   @override
//   Widget build(BuildContext context) {
//     return Container(color: const Color(0xFFFFE306));
//   }
// }
// ```
// {@end-tool}
// {@tool snippet}
//
// This example shows the more generic widget `Bird` which can be given a
// color and a child, and which has some internal state with a method that
// can be called to mutate it:
//
// ```dart
// class Bird extends StatefulWidget {
//   const Bird({
//     super.key,
//     this.color = const Color(0xFFFFE306),
//     this.child,
//   });
//
//   final Color color;
//   final Widget? child;
//
//   @override
//   State<Bird> createState() => _BirdState();
// }
//
// class _BirdState extends State<Bird> {
//   double _size = 1.0;
//
//   void grow() {
//     setState(() { _size += 0.1; });
//   }
//
//   @override
//   Widget build(BuildContext context) {
//     return Container(
//       color: widget.color,
//       transform: Matrix4.diagonal3Values(_size, _size, 1.0),
//       child: widget.child,
//     );
//   }
// }
// ```
// {@end-tool}
//
// By convention, widget constructors only use named arguments. Also by
// convention, the first argument is [key], and the last argument is `child`,
// `children`, or the equivalent.
//
// See also:
//
//  * [State], where the logic behind a [StatefulWidget] is hosted.
//  * [StatelessWidget], for widgets that always build the same way given a
//    particular configuration and ambient state.
//  * [InheritedWidget], for widgets that introduce ambient state that can
//    be read by descendant widgets.
message FlutterStatefulWidgetType {
  oneof constructor {
    CupertinoActionSheet cupertino_action_sheet = 2;
    CupertinoActivityIndicator cupertino_activity_indicator = 3;
    CupertinoActivityIndicatorNamedPartiallyRevealed cupertino_activity_indicator_named_partially_revealed = 4;
    CupertinoAlertDialog cupertino_alert_dialog = 5;
    CupertinoApp cupertino_app = 6;
    CupertinoAppNamedRouter cupertino_app_named_router = 7;
    CupertinoButton cupertino_button = 8;
    CupertinoButtonNamedFilled cupertino_button_named_filled = 9;
    CupertinoCheckbox cupertino_checkbox = 10;
    CupertinoContextMenu cupertino_context_menu = 11;
    CupertinoContextMenuAction cupertino_context_menu_action = 12;
    CupertinoDesktopTextSelectionToolbarButton cupertino_desktop_text_selection_toolbar_button = 13;
    CupertinoDesktopTextSelectionToolbarButtonNamedButtonItem cupertino_desktop_text_selection_toolbar_button_named_button_item = 14;
    CupertinoDesktopTextSelectionToolbarButtonNamedText cupertino_desktop_text_selection_toolbar_button_named_text = 15;
    CupertinoListTile cupertino_list_tile = 16;
    CupertinoListTileNamedNotched cupertino_list_tile_named_notched = 17;
    CupertinoNavigationBar cupertino_navigation_bar = 18;
    CupertinoPageScaffold cupertino_page_scaffold = 19;
    CupertinoPicker cupertino_picker = 20;
    CupertinoScrollbar cupertino_scrollbar = 21;
    CupertinoSearchTextField cupertino_search_text_field = 22;
    CupertinoSlider cupertino_slider = 23;
    CupertinoSliverNavigationBar cupertino_sliver_navigation_bar = 24;
    CupertinoSliverRefreshControl cupertino_sliver_refresh_control = 25;
    CupertinoSwitch cupertino_switch = 26;
    CupertinoTabView cupertino_tab_view = 27;
    CupertinoTextField cupertino_text_field = 28;
    CupertinoTextFieldNamedBorderless cupertino_text_field_named_borderless = 29;
    CupertinoTextFormFieldRow cupertino_text_form_field_row = 30;
    CupertinoTextSelectionToolbarButton cupertino_text_selection_toolbar_button = 31;
    CupertinoTextSelectionToolbarButtonNamedButtonItem cupertino_text_selection_toolbar_button_named_button_item = 32;
    CupertinoTextSelectionToolbarButtonNamedText cupertino_text_selection_toolbar_button_named_text = 33;
    FlutterAndroidView flutter_android_view = 34;
    FlutterAnimatedAlign flutter_animated_align = 35;
    FlutterAnimatedContainer flutter_animated_container = 36;
    FlutterAnimatedCrossFade flutter_animated_cross_fade = 37;
    FlutterAnimatedDefaultTextStyle flutter_animated_default_text_style = 38;
    FlutterAnimatedFractionallySizedBox flutter_animated_fractionally_sized_box = 39;
    FlutterAnimatedOpacity flutter_animated_opacity = 40;
    FlutterAnimatedPadding flutter_animated_padding = 41;
    FlutterAnimatedPhysicalModel flutter_animated_physical_model = 42;
    FlutterAnimatedPositioned flutter_animated_positioned = 43;
    FlutterAnimatedPositionedDirectional flutter_animated_positioned_directional = 44;
    FlutterAnimatedPositionedNamedFromRect flutter_animated_positioned_named_from_rect = 45;
    FlutterAnimatedRotation flutter_animated_rotation = 46;
    FlutterAnimatedScale flutter_animated_scale = 47;
    FlutterAnimatedSize flutter_animated_size = 48;
    FlutterAnimatedSlide flutter_animated_slide = 49;
    FlutterAnimatedSwitcher flutter_animated_switcher = 50;
    FlutterAppKitView flutter_app_kit_view = 51;
    FlutterAutofillGroup flutter_autofill_group = 52;
    FlutterAutomaticKeepAlive flutter_automatic_keep_alive = 53;
    FlutterBanner flutter_banner = 54;
    FlutterDismissible flutter_dismissible = 55;
    FlutterDraggable flutter_draggable = 56;
    FlutterDraggableScrollableActuator flutter_draggable_scrollable_actuator = 57;
    FlutterEditableText flutter_editable_text = 58;
    FlutterFadeInImageNamedAssetNetwork flutter_fade_in_image_named_asset_network = 59;
    FlutterFadeInImageNamedMemoryNetwork flutter_fade_in_image_named_memory_network = 60;
    FlutterFocus flutter_focus = 61;
    FlutterFocusNamedWithExternalFocusNode flutter_focus_named_with_external_focus_node = 62;
    FlutterFocusScope flutter_focus_scope = 63;
    FlutterFocusScopeNamedWithExternalFocusNode flutter_focus_scope_named_with_external_focus_node = 64;
    FlutterFocusTraversalGroup flutter_focus_traversal_group = 65;
    FlutterFocusableActionDetector flutter_focusable_action_detector = 66;
    FlutterForm flutter_form = 67;
    FlutterGlowingOverscrollIndicator flutter_glowing_overscroll_indicator = 68;
    FlutterImageNamedAsset flutter_image_named_asset = 69;
    FlutterImageNamedFile flutter_image_named_file = 70;
    FlutterImageNamedMemory flutter_image_named_memory = 71;
    FlutterImageNamedNetwork flutter_image_named_network = 72;
    FlutterInteractiveViewer flutter_interactive_viewer = 73;
    FlutterListWheelScrollView flutter_list_wheel_scroll_view = 74;
    FlutterListWheelScrollViewNamedUseDelegate flutter_list_wheel_scroll_view_named_use_delegate = 75;
    FlutterLocalizationsNamedOverride flutter_localizations_named_override = 76;
    FlutterLongPressDraggable flutter_long_press_draggable = 77;
    FlutterNavigator flutter_navigator = 78;
    FlutterNavigatorPopHandler flutter_navigator_pop_handler = 79;
    FlutterOverlay flutter_overlay = 80;
    FlutterPageView flutter_page_view = 81;
    FlutterPageViewNamedCustom flutter_page_view_named_custom = 82;
    FlutterPlatformMenuBar flutter_platform_menu_bar = 83;
    FlutterPopScope flutter_pop_scope = 84;
    FlutterProjectMyHomePage flutter_project_my_home_page = 85;
    FlutterRawGestureDetector flutter_raw_gesture_detector = 86;
    FlutterRawScrollbar flutter_raw_scrollbar = 87;
    FlutterRestorationScope flutter_restoration_scope = 88;
    FlutterRootRestorationScope flutter_root_restoration_scope = 89;
    FlutterScrollNotificationObserver flutter_scroll_notification_observer = 90;
    FlutterSelectableRegion flutter_selectable_region = 91;
    FlutterSelectionContainer flutter_selection_container = 92;
    FlutterSelectionContainerNamedDisabled flutter_selection_container_named_disabled = 93;
    FlutterSemanticsDebugger flutter_semantics_debugger = 94;
    FlutterSharedAppData flutter_shared_app_data = 95;
    FlutterShortcutRegistrar flutter_shortcut_registrar = 96;
    FlutterShortcutsNamedManager flutter_shortcuts_named_manager = 97;
    FlutterSliverAnimatedOpacity flutter_sliver_animated_opacity = 98;
    FlutterStretchingOverscrollIndicator flutter_stretching_overscroll_indicator = 99;
    FlutterTextSelectionGestureDetector flutter_text_selection_gesture_detector = 100;
    FlutterTickerMode flutter_ticker_mode = 101;
    FlutterUiKitView flutter_ui_kit_view = 102;
    FlutterWidgetInspector flutter_widget_inspector = 103;
    FlutterWidgetsApp flutter_widgets_app = 104;
    FlutterWidgetsAppNamedRouter flutter_widgets_app_named_router = 105;
    MaterialAnimatedTheme material_animated_theme = 106;
    MaterialAppBar material_app_bar = 107;
    MaterialBottomAppBar material_bottom_app_bar = 108;
    MaterialBottomNavigationBar material_bottom_navigation_bar = 109;
    MaterialCheckbox material_checkbox = 110;
    MaterialCheckboxNamedAdaptive material_checkbox_named_adaptive = 111;
    MaterialCheckedPopupMenuItem material_checked_popup_menu_item = 112;
    MaterialCircularProgressIndicator material_circular_progress_indicator = 113;
    MaterialCircularProgressIndicatorNamedAdaptive material_circular_progress_indicator_named_adaptive = 114;
    MaterialDatePickerDialog material_date_picker_dialog = 115;
    MaterialDateRangePickerDialog material_date_range_picker_dialog = 116;
    MaterialDefaultTabController material_default_tab_controller = 117;
    MaterialDrawerController material_drawer_controller = 118;
    MaterialDropdownButton material_dropdown_button = 119;
    MaterialDropdownButtonFormField material_dropdown_button_form_field = 120;
    MaterialElevatedButton material_elevated_button = 121;
    MaterialElevatedButtonNamedIcon material_elevated_button_named_icon = 122;
    MaterialExpandIcon material_expand_icon = 123;
    MaterialExpansionPanelList material_expansion_panel_list = 124;
    MaterialExpansionPanelListNamedRadio material_expansion_panel_list_named_radio = 125;
    MaterialExpansionTile material_expansion_tile = 126;
    MaterialFilledButton material_filled_button = 127;
    MaterialFilledButtonNamedIcon material_filled_button_named_icon = 128;
    MaterialFilledButtonNamedTonal material_filled_button_named_tonal = 129;
    MaterialFilledButtonNamedTonalIcon material_filled_button_named_tonal_icon = 130;
    MaterialFlexibleSpaceBar material_flexible_space_bar = 131;
    MaterialInk material_ink = 132;
    MaterialInputDatePickerFormField material_input_date_picker_form_field = 133;
    MaterialInputDecorator material_input_decorator = 134;
    MaterialLicensePage material_license_page = 135;
    MaterialLinearProgressIndicator material_linear_progress_indicator = 136;
    MaterialMaterial material_material = 137;
    MaterialMaterialApp material_material_app = 138;
    MaterialMaterialAppNamedRouter material_material_app_named_router = 139;
    MaterialMaterialBanner material_material_banner = 140;
    MaterialMenuAcceleratorLabel material_menu_accelerator_label = 141;
    MaterialMenuAnchor material_menu_anchor = 142;
    MaterialMenuItemButton material_menu_item_button = 143;
    MaterialMergeableMaterial material_mergeable_material = 144;
    MaterialNavigationRail material_navigation_rail = 145;
    MaterialOutlinedButton material_outlined_button = 146;
    MaterialOutlinedButtonNamedIcon material_outlined_button_named_icon = 147;
    MaterialPaginatedDataTable material_paginated_data_table = 148;
    MaterialPopupMenuDivider material_popup_menu_divider = 149;
    MaterialPopupMenuItem material_popup_menu_item = 150;
    MaterialRangeSlider material_range_slider = 151;
    MaterialRawChip material_raw_chip = 152;
    MaterialRawMaterialButton material_raw_material_button = 153;
    MaterialRefreshProgressIndicator material_refresh_progress_indicator = 154;
    MaterialScaffold material_scaffold = 155;
    MaterialScaffoldMessenger material_scaffold_messenger = 156;
    MaterialSearchBar material_search_bar = 157;
    MaterialSelectableText material_selectable_text = 158;
    MaterialSelectableTextNamedRich material_selectable_text_named_rich = 159;
    MaterialSelectionArea material_selection_area = 160;
    MaterialSlider material_slider = 161;
    MaterialSliderNamedAdaptive material_slider_named_adaptive = 162;
    MaterialSliverAppBar material_sliver_app_bar = 163;
    MaterialSliverAppBarNamedLarge material_sliver_app_bar_named_large = 164;
    MaterialSliverAppBarNamedMedium material_sliver_app_bar_named_medium = 165;
    MaterialSnackBar material_snack_bar = 166;
    MaterialStepper material_stepper = 167;
    MaterialSubmenuButton material_submenu_button = 168;
    MaterialTabBar material_tab_bar = 169;
    MaterialTabBarNamedSecondary material_tab_bar_named_secondary = 170;
    MaterialTabBarView material_tab_bar_view = 171;
    MaterialTextButton material_text_button = 172;
    MaterialTextButtonNamedIcon material_text_button_named_icon = 173;
    MaterialTextField material_text_field = 174;
    MaterialTextFormField material_text_form_field = 175;
    MaterialTimePickerDialog material_time_picker_dialog = 176;
    MaterialTooltip material_tooltip = 177;
    MaterialUserAccountsDrawerHeader material_user_accounts_drawer_header = 178;
  }
}

// package:flutter/src/widgets/framework.dart
//
// A widget that does not require mutable state.
//
// A stateless widget is a widget that describes part of the user interface by
// building a constellation of other widgets that describe the user interface
// more concretely. The building process continues recursively until the
// description of the user interface is fully concrete (e.g., consists
// entirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s).
//
// {@youtube 560 315 https://www.youtube.com/watch?v=wE7khGHVkYY}
//
// Stateless widget are useful when the part of the user interface you are
// describing does not depend on anything other than the configuration
// information in the object itself and the [BuildContext] in which the widget
// is inflated. For compositions that can change dynamically, e.g. due to
// having an internal clock-driven state, or depending on some system state,
// consider using [StatefulWidget].
//
// ## Performance considerations
//
// The [build] method of a stateless widget is typically only called in three
// situations: the first time the widget is inserted in the tree, when the
// widget's parent changes its configuration (see [Element.rebuild]), and when
// an [InheritedWidget] it depends on changes.
//
// If a widget's parent will regularly change the widget's configuration, or if
// it depends on inherited widgets that frequently change, then it is important
// to optimize the performance of the [build] method to maintain a fluid
// rendering performance.
//
// There are several techniques one can use to minimize the impact of
// rebuilding a stateless widget:
//
//  * Minimize the number of nodes transitively created by the build method and
//    any widgets it creates. For example, instead of an elaborate arrangement
//    of [Row]s, [Column]s, [Padding]s, and [SizedBox]es to position a single
//    child in a particularly fancy manner, consider using just an [Align] or a
//    [CustomSingleChildLayout]. Instead of an intricate layering of multiple
//    [Container]s and with [Decoration]s to draw just the right graphical
//    effect, consider a single [CustomPaint] widget.
//
//  * Use `const` widgets where possible, and provide a `const` constructor for
//    the widget so that users of the widget can also do so.
//
//  * Consider refactoring the stateless widget into a stateful widget so that
//    it can use some of the techniques described at [StatefulWidget], such as
//    caching common parts of subtrees and using [GlobalKey]s when changing the
//    tree structure.
//
//  * If the widget is likely to get rebuilt frequently due to the use of
//    [InheritedWidget]s, consider refactoring the stateless widget into
//    multiple widgets, with the parts of the tree that change being pushed to
//    the leaves. For example instead of building a tree with four widgets, the
//    inner-most widget depending on the [Theme], consider factoring out the
//    part of the build function that builds the inner-most widget into its own
//    widget, so that only the inner-most widget needs to be rebuilt when the
//    theme changes.
// {@template flutter.flutter.widgets.framework.prefer_const_over_helper}
//  * When trying to create a reusable piece of UI, prefer using a widget
//    rather than a helper method. For example, if there was a function used to
//    build a widget, a [State.setState] call would require Flutter to entirely
//    rebuild the returned wrapping widget. If a [Widget] was used instead,
//    Flutter would be able to efficiently re-render only those parts that
//    really need to be updated. Even better, if the created widget is `const`,
//    Flutter would short-circuit most of the rebuild work.
// {@endtemplate}
//
// This video gives more explanations on why `const` constructors are important
// and why a [Widget] is better than a helper method.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=IOyq-eTRhvo}
//
// {@tool snippet}
//
// The following is a skeleton of a stateless widget subclass called `GreenFrog`.
//
// Normally, widgets have more constructor arguments, each of which corresponds
// to a `final` property.
//
// ```dart
// class GreenFrog extends StatelessWidget {
//   const GreenFrog({ super.key });
//
//   @override
//   Widget build(BuildContext context) {
//     return Container(color: const Color(0xFF2DBD3A));
//   }
// }
// ```
// {@end-tool}
//
// {@tool snippet}
//
// This next example shows the more generic widget `Frog` which can be given
// a color and a child:
//
// ```dart
// class Frog extends StatelessWidget {
//   const Frog({
//     super.key,
//     this.color = const Color(0xFF2DBD3A),
//     this.child,
//   });
//
//   final Color color;
//   final Widget? child;
//
//   @override
//   Widget build(BuildContext context) {
//     return ColoredBox(color: color, child: child);
//   }
// }
// ```
// {@end-tool}
//
// By convention, widget constructors only use named arguments. Also by
// convention, the first argument is [key], and the last argument is `child`,
// `children`, or the equivalent.
//
// See also:
//
//  * [StatefulWidget] and [State], for widgets that can build differently
//    several times over their lifetime.
//  * [InheritedWidget], for widgets that introduce ambient state that can
//    be read by descendant widgets.
message FlutterStatelessWidgetType {
  oneof constructor {
    CupertinoAdaptiveTextSelectionToolbar cupertino_adaptive_text_selection_toolbar = 2;
    CupertinoAdaptiveTextSelectionToolbarNamedButtonItems cupertino_adaptive_text_selection_toolbar_named_button_items = 3;
    CupertinoAdaptiveTextSelectionToolbarNamedEditable cupertino_adaptive_text_selection_toolbar_named_editable = 4;
    CupertinoAdaptiveTextSelectionToolbarNamedEditableText cupertino_adaptive_text_selection_toolbar_named_editable_text = 5;
    CupertinoDesktopTextSelectionToolbar cupertino_desktop_text_selection_toolbar = 6;
    CupertinoDialogAction cupertino_dialog_action = 7;
    CupertinoFormRow cupertino_form_row = 8;
    CupertinoFormSection cupertino_form_section = 9;
    CupertinoFormSectionNamedInsetGrouped cupertino_form_section_named_inset_grouped = 10;
    CupertinoListSection cupertino_list_section = 11;
    CupertinoListSectionNamedInsetGrouped cupertino_list_section_named_inset_grouped = 12;
    CupertinoListTileChevron cupertino_list_tile_chevron = 13;
    CupertinoMagnifier cupertino_magnifier = 14;
    CupertinoNavigationBarBackButton cupertino_navigation_bar_back_button = 15;
    CupertinoPickerDefaultSelectionOverlay cupertino_picker_default_selection_overlay = 16;
    CupertinoPopupSurface cupertino_popup_surface = 17;
    CupertinoSpellCheckSuggestionsToolbar cupertino_spell_check_suggestions_toolbar = 18;
    CupertinoSpellCheckSuggestionsToolbarNamedEditableText cupertino_spell_check_suggestions_toolbar_named_editable_text = 19;
    CupertinoTabBar cupertino_tab_bar = 20;
    CupertinoTextSelectionToolbar cupertino_text_selection_toolbar = 21;
    CupertinoTheme cupertino_theme = 22;
    FlutterCheckedModeBanner flutter_checked_mode_banner = 23;
    FlutterContainer flutter_container = 24;
    FlutterCustomScrollView flutter_custom_scroll_view = 25;
    FlutterDefaultTextEditingShortcuts flutter_default_text_editing_shortcuts = 26;
    FlutterDisplayFeatureSubScreen flutter_display_feature_sub_screen = 27;
    FlutterExcludeFocus flutter_exclude_focus = 28;
    FlutterExcludeFocusTraversal flutter_exclude_focus_traversal = 29;
    FlutterGestureDetector flutter_gesture_detector = 30;
    FlutterGridPaper flutter_grid_paper = 31;
    FlutterGridView flutter_grid_view = 32;
    FlutterGridViewNamedCount flutter_grid_view_named_count = 33;
    FlutterGridViewNamedCustom flutter_grid_view_named_custom = 34;
    FlutterGridViewNamedExtent flutter_grid_view_named_extent = 35;
    FlutterHeroMode flutter_hero_mode = 36;
    FlutterHtmlElementView flutter_html_element_view = 37;
    FlutterHtmlElementViewNamedFromTagName flutter_html_element_view_named_from_tag_name = 38;
    FlutterIcon flutter_icon = 39;
    FlutterImageIcon flutter_image_icon = 40;
    FlutterIndexedStack flutter_indexed_stack = 41;
    FlutterKeyboardListener flutter_keyboard_listener = 42;
    FlutterKeyedSubtree flutter_keyed_subtree = 43;
    FlutterKeyedSubtreeNamedWrap flutter_keyed_subtree_named_wrap = 44;
    FlutterListView flutter_list_view = 45;
    FlutterListViewNamedCustom flutter_list_view_named_custom = 46;
    FlutterModalBarrier flutter_modal_barrier = 47;
    FlutterNavigationToolbar flutter_navigation_toolbar = 48;
    FlutterPageStorage flutter_page_storage = 49;
    FlutterPlaceholder flutter_placeholder = 50;
    FlutterPlatformSelectableRegionContextMenu flutter_platform_selectable_region_context_menu = 51;
    FlutterPositionedDirectional flutter_positioned_directional = 52;
    FlutterPreferredSize flutter_preferred_size = 53;
    FlutterProjectMyApp flutter_project_my_app = 54;
    FlutterRawMagnifier flutter_raw_magnifier = 55;
    FlutterReorderableDelayedDragStartListener flutter_reorderable_delayed_drag_start_listener = 56;
    FlutterReorderableDragStartListener flutter_reorderable_drag_start_listener = 57;
    FlutterSafeArea flutter_safe_area = 58;
    FlutterSingleChildScrollView flutter_single_child_scroll_view = 59;
    FlutterSliverConstrainedCrossAxis flutter_sliver_constrained_cross_axis = 60;
    FlutterSliverFillRemaining flutter_sliver_fill_remaining = 61;
    FlutterSliverFillViewport flutter_sliver_fill_viewport = 62;
    FlutterSliverPersistentHeader flutter_sliver_persistent_header = 63;
    FlutterSliverSafeArea flutter_sliver_safe_area = 64;
    FlutterSliverVisibility flutter_sliver_visibility = 65;
    FlutterSliverVisibilityNamedMaintain flutter_sliver_visibility_named_maintain = 66;
    FlutterSpacer flutter_spacer = 67;
    FlutterText flutter_text = 68;
    FlutterTextNamedRich flutter_text_named_rich = 69;
    FlutterTitle flutter_title = 70;
    FlutterUnconstrainedBox flutter_unconstrained_box = 71;
    FlutterView flutter_view = 72;
    FlutterViewAnchor flutter_view_anchor = 73;
    FlutterVisibility flutter_visibility = 74;
    FlutterVisibilityNamedMaintain flutter_visibility_named_maintain = 75;
    MaterialAboutDialog material_about_dialog = 76;
    MaterialAboutListTile material_about_list_tile = 77;
    MaterialActionChip material_action_chip = 78;
    MaterialActionChipNamedElevated material_action_chip_named_elevated = 79;
    MaterialAdaptiveTextSelectionToolbar material_adaptive_text_selection_toolbar = 80;
    MaterialAdaptiveTextSelectionToolbarNamedButtonItems material_adaptive_text_selection_toolbar_named_button_items = 81;
    MaterialAdaptiveTextSelectionToolbarNamedEditable material_adaptive_text_selection_toolbar_named_editable = 82;
    MaterialAdaptiveTextSelectionToolbarNamedEditableText material_adaptive_text_selection_toolbar_named_editable_text = 83;
    MaterialAdaptiveTextSelectionToolbarNamedSelectableRegion material_adaptive_text_selection_toolbar_named_selectable_region = 84;
    MaterialAlertDialog material_alert_dialog = 85;
    MaterialAlertDialogNamedAdaptive material_alert_dialog_named_adaptive = 86;
    MaterialBackButton material_back_button = 87;
    MaterialBackButtonIcon material_back_button_icon = 88;
    MaterialBadge material_badge = 89;
    MaterialBadgeNamedCount material_badge_named_count = 90;
    MaterialButtonBar material_button_bar = 91;
    MaterialCard material_card = 92;
    MaterialCardNamedFilled material_card_named_filled = 93;
    MaterialCardNamedOutlined material_card_named_outlined = 94;
    MaterialCheckboxListTile material_checkbox_list_tile = 95;
    MaterialCheckboxListTileNamedAdaptive material_checkbox_list_tile_named_adaptive = 96;
    MaterialCheckboxMenuButton material_checkbox_menu_button = 97;
    MaterialChip material_chip = 98;
    MaterialChoiceChip material_choice_chip = 99;
    MaterialChoiceChipNamedElevated material_choice_chip_named_elevated = 100;
    MaterialCircleAvatar material_circle_avatar = 101;
    MaterialCloseButton material_close_button = 102;
    MaterialCloseButtonIcon material_close_button_icon = 103;
    MaterialDataTable material_data_table = 104;
    MaterialDesktopTextSelectionToolbar material_desktop_text_selection_toolbar = 105;
    MaterialDesktopTextSelectionToolbarButton material_desktop_text_selection_toolbar_button = 106;
    MaterialDesktopTextSelectionToolbarButtonNamedText material_desktop_text_selection_toolbar_button_named_text = 107;
    MaterialDialog material_dialog = 108;
    MaterialDialogNamedFullscreen material_dialog_named_fullscreen = 109;
    MaterialDivider material_divider = 110;
    MaterialDrawer material_drawer = 111;
    MaterialDrawerButton material_drawer_button = 112;
    MaterialDrawerButtonIcon material_drawer_button_icon = 113;
    MaterialDrawerHeader material_drawer_header = 114;
    MaterialDropdownMenuItem material_dropdown_menu_item = 115;
    MaterialEndDrawerButton material_end_drawer_button = 116;
    MaterialEndDrawerButtonIcon material_end_drawer_button_icon = 117;
    MaterialFilterChip material_filter_chip = 118;
    MaterialFilterChipNamedElevated material_filter_chip_named_elevated = 119;
    MaterialFloatingActionButton material_floating_action_button = 120;
    MaterialFloatingActionButtonNamedExtended material_floating_action_button_named_extended = 121;
    MaterialFloatingActionButtonNamedLarge material_floating_action_button_named_large = 122;
    MaterialFloatingActionButtonNamedSmall material_floating_action_button_named_small = 123;
    MaterialFlutterLogo material_flutter_logo = 124;
    MaterialGridTile material_grid_tile = 125;
    MaterialGridTileBar material_grid_tile_bar = 126;
    MaterialIconButton material_icon_button = 127;
    MaterialIconButtonNamedFilled material_icon_button_named_filled = 128;
    MaterialIconButtonNamedFilledTonal material_icon_button_named_filled_tonal = 129;
    MaterialIconButtonNamedOutlined material_icon_button_named_outlined = 130;
    MaterialInkResponse material_ink_response = 131;
    MaterialInkWell material_ink_well = 132;
    MaterialInputChip material_input_chip = 133;
    MaterialListTile material_list_tile = 134;
    MaterialMagnifier material_magnifier = 135;
    MaterialMaterialButton material_material_button = 136;
    MaterialMenuBar material_menu_bar = 137;
    MaterialNavigationBar material_navigation_bar = 138;
    MaterialNavigationDestination material_navigation_destination = 139;
    MaterialNavigationDrawer material_navigation_drawer = 140;
    MaterialNavigationDrawerDestination material_navigation_drawer_destination = 141;
    MaterialScrollbar material_scrollbar = 142;
    MaterialSimpleDialog material_simple_dialog = 143;
    MaterialSimpleDialogOption material_simple_dialog_option = 144;
    MaterialSpellCheckSuggestionsToolbar material_spell_check_suggestions_toolbar = 145;
    MaterialSpellCheckSuggestionsToolbarNamedEditableText material_spell_check_suggestions_toolbar_named_editable_text = 146;
    MaterialSwitch material_switch = 147;
    MaterialSwitchListTile material_switch_list_tile = 148;
    MaterialSwitchListTileNamedAdaptive material_switch_list_tile_named_adaptive = 149;
    MaterialSwitchNamedAdaptive material_switch_named_adaptive = 150;
    MaterialTab material_tab = 151;
    MaterialTabPageSelector material_tab_page_selector = 152;
    MaterialTabPageSelectorIndicator material_tab_page_selector_indicator = 153;
    MaterialTableRowInkWell material_table_row_ink_well = 154;
    MaterialTextSelectionToolbar material_text_selection_toolbar = 155;
    MaterialTextSelectionToolbarTextButton material_text_selection_toolbar_text_button = 156;
    MaterialTheme material_theme = 157;
    MaterialToggleButtons material_toggle_buttons = 158;
    MaterialTooltipVisibility material_tooltip_visibility = 159;
    MaterialVerticalDivider material_vertical_divider = 160;
  }
}

// package:flutter/src/painting/strut_style.dart
//
// Defines the strut, which sets the minimum height a line can be
// relative to the baseline.
//
// Strut applies to all lines in the paragraph. Strut is a feature that
// allows minimum line heights to be set. The effect is as if a zero
// width space was included at the beginning of each line in the
// paragraph. This imaginary space is 'shaped' according the properties
// defined in this class. Flutter's strut is based on
// [typesetting strut](https://en.wikipedia.org/wiki/Strut_(typesetting))
// and CSS's [line-height](https://www.w3.org/TR/CSS2/visudet.html#line-height).
//
// No lines may be shorter than the strut. The ascent and descent of the
// strut are calculated, and any laid out text that has a shorter ascent or
// descent than the strut's ascent or descent will take the ascent and
// descent of the strut. Text with ascents or descents larger than the
// strut's ascent or descent will layout as normal and extend past the strut.
//
// Strut is defined independently from any text content or [TextStyle]s.
//
// The vertical components of strut are as follows:
//
//  * Half the font-defined leading
//  * `ascent * height`
//  * `descent * height`
//  * Half the font-defined leading
//
// The sum of these four values is the total height of the line.
//
// Ascent is the font's spacing above the baseline without leading and
// descent is the spacing below the baseline without leading. Leading is
// split evenly between the top and bottom. The values for `ascent` and
// `descent` are provided by the font named by [fontFamily]. If no
// [fontFamily] or [fontFamilyFallback] is provided, then the platform's
// default family will be used. Many fonts will have leading values of
// zero, so in practice, the leading component is often irrelevant.
//
// When [height] is omitted or null, then the font defined ascent and descent
// will be used. The font's combined ascent and descent may be taller or
// shorter than the [fontSize]. When [height] is provided, the line's EM-square
// ascent and descent (which sums to [fontSize]) will be scaled by [height] to
// achieve a final line height of `fontSize * height + fontSize * leading`
// logical pixels. The proportion of ascent:descent with [height] specified
// is the same as the font metrics defined ascent:descent ratio.
//
// ![Text height diagram](https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_diagram.png)
//
// Each line's spacing above the baseline will be at least as tall as the
// half leading plus ascent. Each line's spacing below the baseline will
// be at least as tall as the half leading plus descent.
//
// See also:
//
//  * [StrutStyle](dart-ui/StrutStyle-class.html), the class in the [dart:ui] library.
//
// ### Fields and their default values.
//
// Omitted or null properties will take the default values specified below:
//
//  * [fontFamily]: the name of the font to use when calculating the strut
//    (e.g., Roboto). No glyphs from the font will be drawn and the font will
//    be used purely for metrics.
//
//  * [fontFamilyFallback]: an ordered list of font family names that will
//    be searched for when the font in [fontFamily] cannot be found. When
//    all specified font families have been exhausted an no match was found,
//    the default platform font will be used.
//
//  * [fontSize]: the size of the ascent plus descent in logical pixels. This
//    is also used as the basis of the custom leading calculation. This value
//    cannot be negative.
//    Default is 14 logical pixels.
//
//  * [height]: the multiple of [fontSize] the line's height should be.
//    The line's height will take the font's ascent and descent values if
//    [height] is omitted or null. If provided, the EM-square ascent and
//    descent (which sum to [fontSize]) is scaled by [height].
//    The [height] will impact the spacing above and below the baseline
//    differently depending on the ratios between the font's ascent and
//    descent. This property is separate from the leading multiplier, which
//    is controlled through [leading].
//    Default is null.
//
//  * [leading]: the custom leading to apply to the strut as a multiple of
//    [fontSize]. Leading is additional spacing between lines. Half of the
//    leading is added to the top and the other half to the bottom of the
//    line height. This differs from [height] since the spacing is equally
//    distributed above and below the baseline.
//    Default is null, which will use the font-specified leading.
//
//  * [fontWeight]: the typeface thickness to use when calculating the strut
//    (e.g., bold).
//    Default is [FontWeight.w400].
//
//  * [fontStyle]: the typeface variant to use when calculating the strut
//    (e.g., italic).
//    Default is [FontStyle.normal].
//
//  * [forceStrutHeight]: when true, all lines will be laid out with the
//    height of the strut. All line and run-specific metrics will be
//    ignored/overridden and only strut metrics will be used instead.
//    This property guarantees uniform line spacing, however text in
//    adjacent lines may overlap. This property should be enabled with
//    caution as it bypasses a large portion of the vertical layout system.
//    The default value is false.
//
// ### Examples
//
// {@tool snippet}
// In this simple case, the text will be rendered at font size 10, however,
// the vertical height of each line will be the strut height (Roboto in
// font size 30 * 1.5) as the text itself is shorter than the strut.
//
// ```dart
// const Text(
//   'Hello, world!\nSecond line!',
//   style: TextStyle(
//     fontSize: 10,
//     fontFamily: 'Raleway',
//   ),
//   strutStyle: StrutStyle(
//     fontFamily: 'Roboto',
//     fontSize: 30,
//     height: 1.5,
//   ),
// )
// ```
// {@end-tool}
//
// {@tool snippet}
// Here, strut is used to absorb the additional line height in the second line.
// The strut [height] was defined as 1.5 (the default font size is 14), which
// caused all lines to be laid out taller than without strut. This extra space
// was able to accommodate the larger font size of `Second line!` without
// causing the line height to change for the second line only. All lines in
// this example are thus the same height (`14 * 1.5`).
//
// ```dart
// const Text.rich(
//   TextSpan(
//     text: 'First line!\n',
//     style: TextStyle(
//       fontSize: 14,
//       fontFamily: 'Roboto'
//     ),
//     children: <TextSpan>[
//       TextSpan(
//         text: 'Second line!\n',
//         style: TextStyle(
//           fontSize: 16,
//           fontFamily: 'Roboto',
//         ),
//       ),
//       TextSpan(
//         text: 'Third line!\n',
//         style: TextStyle(
//           fontSize: 14,
//           fontFamily: 'Roboto',
//         ),
//       ),
//     ],
//   ),
//   strutStyle: StrutStyle(
//     fontFamily: 'Roboto',
//     height: 1.5,
//   ),
// )
// ```
// {@end-tool}
//
// {@tool snippet}
// Here, strut is used to enable strange and overlapping text to achieve unique
// effects. The `M`s in lines 2 and 3 are able to extend above their lines and
// fill empty space in lines above. The [forceStrutHeight] is enabled and functions
// as a 'grid' for the glyphs to draw on.
//
// ![The result of the example below.](https://flutter.github.io/assets-for-api-docs/assets/painting/strut_force_example.png)
//
// ```dart
// const Text.rich(
//   TextSpan(
//     text: '---------         ---------\n',
//     style: TextStyle(
//       fontSize: 14,
//       fontFamily: 'Roboto',
//     ),
//     children: <TextSpan>[
//       TextSpan(
//         text: '^^^M^^^\n',
//         style: TextStyle(
//           fontSize: 30,
//           fontFamily: 'Roboto',
//         ),
//       ),
//       TextSpan(
//         text: 'M------M\n',
//         style: TextStyle(
//           fontSize: 30,
//           fontFamily: 'Roboto',
//         ),
//       ),
//     ],
//   ),
//   strutStyle: StrutStyle(
//     fontFamily: 'Roboto',
//     fontSize: 14,
//     height: 1,
//     forceStrutHeight: true,
//   ),
// )
// ```
// {@end-tool}
//
// {@tool snippet}
// This example uses forceStrutHeight to create a 'drop cap' for the 'T' in 'The'.
// By locking the line heights to the metrics of the 14pt serif font, we are able
// to lay out a large 37pt 'T' on the second line to take up space on both the first
// and second lines.
//
// ![The result of the example below.](https://flutter.github.io/assets-for-api-docs/assets/painting/strut_force_example_2.png)
//
// ```dart
// const Text.rich(
//   TextSpan(
//     text: '      he candle flickered\n',
//     style: TextStyle(
//       fontSize: 14,
//       fontFamily: 'Serif'
//     ),
//     children: <TextSpan>[
//       TextSpan(
//         text: 'T',
//         style: TextStyle(
//           fontSize: 37,
//           fontFamily: 'Serif'
//         ),
//       ),
//       TextSpan(
//         text: 'in the moonlight as\n',
//         style: TextStyle(
//           fontSize: 14,
//           fontFamily: 'Serif'
//         ),
//       ),
//       TextSpan(
//         text: 'Dash the bird fluttered\n',
//         style: TextStyle(
//           fontSize: 14,
//           fontFamily: 'Serif'
//         ),
//       ),
//       TextSpan(
//         text: 'off into the distance.',
//         style: TextStyle(
//           fontSize: 14,
//           fontFamily: 'Serif'
//         ),
//       ),
//     ],
//   ),
//   strutStyle: StrutStyle(
//     fontFamily: 'Serif',
//     fontSize: 14,
//     forceStrutHeight: true,
//   ),
// )
// ```
// {@end-tool}
//
message FlutterStrutStyleType {
  oneof constructor {
    FlutterStrutStyle flutter_strut_style = 2;
    FlutterStrutStyleNamedFromTextStyle flutter_strut_style_named_from_text_style = 3;
  }
}

// package:flutter/src/services/system_chrome.dart
//
// Specifies a preference for the style of the system overlays.
//
// Used by [AppBar.systemOverlayStyle] for declaratively setting the style of
// the system overlays, and by [SystemChrome.setSystemUIOverlayStyle] for
// imperatively setting the style of the systeme overlays.
message FlutterSystemUiOverlayStyleType {
  oneof constructor {
    FlutterSystemUiOverlayStyle flutter_system_ui_overlay_style = 2;
  }
}

// package:flutter/src/rendering/table_border.dart
//
// Border specification for [Table] widgets.
//
// This is like [Border], with the addition of two sides: the inner horizontal
// borders between rows and the inner vertical borders between columns.
//
// The sides are represented by [BorderSide] objects.
message FlutterTableBorderType {
  oneof constructor {
    FlutterTableBorder flutter_table_border = 2;
    FlutterTableBorderNamedAll flutter_table_border_named_all = 3;
    FlutterTableBorderNamedSymmetric flutter_table_border_named_symmetric = 4;
  }
}

// package:flutter/src/rendering/table.dart
//
// Base class to describe how wide a column in a [RenderTable] should be.
//
// To size a column to a specific number of pixels, use a [FixedColumnWidth].
// This is the cheapest way to size a column.
//
// Other algorithms that are relatively cheap include [FlexColumnWidth], which
// distributes the space equally among the flexible columns,
// [FractionColumnWidth], which sizes a column based on the size of the
// table's container.
message FlutterTableColumnWidthType {
  oneof constructor {
    FlutterFixedColumnWidth flutter_fixed_column_width = 2;
    FlutterFlexColumnWidth flutter_flex_column_width = 3;
    FlutterFractionColumnWidth flutter_fraction_column_width = 4;
    FlutterIntrinsicColumnWidth flutter_intrinsic_column_width = 5;
    FlutterMaxColumnWidth flutter_max_column_width = 6;
    FlutterMinColumnWidth flutter_min_column_width = 7;
  }
}

// package:flutter/src/widgets/table.dart
//
// A horizontal group of cells in a [Table].
//
// Every row in a table must have the same number of children.
//
// The alignment of individual cells in a row can be controlled using a
// [TableCell].
message FlutterTableRowType {
  oneof constructor {
    FlutterTableRow flutter_table_row = 2;
  }
}

// package:flutter/src/widgets/tap_region.dart
//
// An interface for registering and unregistering a [RenderTapRegion]
// (typically created with a [TapRegion] widget) with a
// [RenderTapRegionSurface] (typically created with a [TapRegionSurface]
// widget).
message FlutterTapRegionRegistryType {
  oneof constructor {
    FlutterRenderTapRegionSurface flutter_render_tap_region_surface = 2;
  }
}

// package:flutter/src/painting/alignment.dart
//
// The vertical alignment of text within an input box.
//
// A single [y] value that can range from -1.0 to 1.0. -1.0 aligns to the top
// of an input box so that the top of the first line of text fits within the
// box and its padding. 0.0 aligns to the center of the box. 1.0 aligns so that
// the bottom of the last line of text aligns with the bottom interior edge of
// the input box.
//
// See also:
//
//  * [TextField.textAlignVertical], which is passed on to the [InputDecorator].
//  * [CupertinoTextField.textAlignVertical], which behaves in the same way as
//    the parameter in TextField.
//  * [InputDecorator.textAlignVertical], which defines the alignment of
//    prefix, input, and suffix within an [InputDecorator].
message FlutterTextAlignVerticalType {
  oneof constructor {
    FlutterTextAlignVertical flutter_text_align_vertical = 2;
  }
}

// package:flutter/src/widgets/editable_text.dart
//
// A controller for an editable text field.
//
// Whenever the user modifies a text field with an associated
// [TextEditingController], the text field updates [value] and the controller
// notifies its listeners. Listeners can then read the [text] and [selection]
// properties to learn what the user has typed or how the selection has been
// updated.
//
// Similarly, if you modify the [text] or [selection] properties, the text
// field will be notified and will update itself appropriately.
//
// A [TextEditingController] can also be used to provide an initial value for a
// text field. If you build a text field with a controller that already has
// [text], the text field will use that text as its initial value.
//
// The [value] (as well as [text] and [selection]) of this controller can be
// updated from within a listener added to this controller. Be aware of
// infinite loops since the listener will also be notified of the changes made
// from within itself. Modifying the composing region from within a listener
// can also have a bad interaction with some input methods. Gboard, for
// example, will try to restore the composing region of the text if it was
// modified programmatically, creating an infinite loop of communications
// between the framework and the input method. Consider using
// [TextInputFormatter]s instead for as-you-type text modification.
//
// If both the [text] or [selection] properties need to be changed, set the
// controller's [value] instead.
//
// Remember to [dispose] of the [TextEditingController] when it is no longer
// needed. This will ensure we discard any resources used by the object.
// {@tool dartpad}
// This example creates a [TextField] with a [TextEditingController] whose
// change listener forces the entered text to be lower case and keeps the
// cursor at the end of the input.
//
// ** See code in examples/api/lib/widgets/editable_text/text_editing_controller.0.dart **
// {@end-tool}
//
// See also:
//
//  * [TextField], which is a Material Design text field that can be controlled
//    with a [TextEditingController].
//  * [EditableText], which is a raw region of editable text that can be
//    controlled with a [TextEditingController].
//  * Learn how to use a [TextEditingController] in one of our [cookbook recipes](https://flutter.dev/docs/cookbook/forms/text-field-changes#2-use-a-texteditingcontroller).
message FlutterTextEditingControllerType {
  oneof constructor {
    FlutterTextEditingController flutter_text_editing_controller = 2;
    FlutterTextEditingControllerNamedFromValue flutter_text_editing_controller_named_from_value = 3;
    MaterialSearchController material_search_controller = 4;
  }
}

// package:flutter/src/services/text_input.dart
//
// The current text, selection, and composing state for editing a run of text.
message FlutterTextEditingValueType {
  oneof constructor {
    FlutterTextEditingValue flutter_text_editing_value = 2;
  }
}

// package:flutter/src/services/text_formatter.dart
//
// A [TextInputFormatter] can be optionally injected into an [EditableText]
// to provide as-you-type validation and formatting of the text being edited.
//
// Text modification should only be applied when text is being committed by the
// IME and not on text under composition (i.e., only when
// [TextEditingValue.composing] is collapsed).
//
// See also the [FilteringTextInputFormatter], a subclass that
// removes characters that the user tries to enter if they do, or do
// not, match a given pattern (as applicable).
//
// To create custom formatters, extend the [TextInputFormatter] class and
// implement the [formatEditUpdate] method.
//
// ## Handling emojis and other complex characters
// {@macro flutter.widgets.EditableText.onChanged}
//
// See also:
//
//  * [EditableText] on which the formatting apply.
//  * [FilteringTextInputFormatter], a provided formatter for filtering
//    characters.
message FlutterTextInputFormatterType {
  oneof constructor {
    FlutterFilteringTextInputFormatter flutter_filtering_text_input_formatter = 2;
    FlutterFilteringTextInputFormatterNamedAllow flutter_filtering_text_input_formatter_named_allow = 3;
    FlutterFilteringTextInputFormatterNamedDeny flutter_filtering_text_input_formatter_named_deny = 4;
    FlutterLengthLimitingTextInputFormatter flutter_length_limiting_text_input_formatter = 5;
  }
}

// package:flutter/src/services/text_input.dart
//
// The type of information for which to optimize the text input control.
//
// On Android, behavior may vary across device and keyboard provider.
//
// This class stays as close to `Enum` interface as possible, and allows
// for additional flags for some input types. For example, numeric input
// can specify whether it supports decimal numbers and/or signed numbers.
message FlutterTextInputTypeType {
  oneof constructor {
    FlutterTextInputTypeNamedNumberWithOptions flutter_text_input_type_named_number_with_options = 2;
  }
}

// package:flutter/src/widgets/magnifier.dart
//
// {@template flutter.widgets.magnifier.TextMagnifierConfiguration.intro}
// A configuration object for a magnifier.
// {@endtemplate}
//
// {@macro flutter.widgets.magnifier.intro}
//
// {@template flutter.widgets.magnifier.TextMagnifierConfiguration.details}
// In general, most features of the magnifier can be configured through
// [MagnifierBuilder]. [TextMagnifierConfiguration] is used to configure
// the magnifier's behavior through the [SelectionOverlay].
// {@endtemplate}
message FlutterTextMagnifierConfigurationType {
  oneof constructor {
    FlutterTextMagnifierConfiguration flutter_text_magnifier_configuration = 2;
  }
}

// package:flutter/src/painting/text_scaler.dart
//
// A class that describes how textual contents should be scaled for better
// readability.
//
// The [scale] function computes the scaled font size given the original
// unscaled font size specified by app developers.
//
// The [==] operator defines the equality of 2 [TextScaler]s, which the
// framework uses to determine whether text widgets should rebuild when their
// [TextScaler] changes. Consider overridding the [==] operator if applicable
// to avoid unnecessary rebuilds.
message FlutterTextScalerType {
  oneof constructor {
    FlutterTextScalerNamedLinear flutter_text_scaler_named_linear = 2;
  }
}

// package:flutter/src/widgets/text_selection.dart
//
// An interface for building the selection UI, to be provided by the
// implementer of the toolbar widget.
//
// Parts of this class, including [buildToolbar], have been deprecated in favor
// of [EditableText.contextMenuBuilder], which is now the preferred way to
// customize the context menus.
//
// ## Use with [EditableText.contextMenuBuilder]
//
// For backwards compatibility during the deprecation period, when
// [EditableText.selectionControls] is set to an object that does not mix in
// [TextSelectionHandleControls], [EditableText.contextMenuBuilder] is ignored
// in favor of the deprecated [buildToolbar].
//
// To migrate code from [buildToolbar] to the preferred
// [EditableText.contextMenuBuilder], while still using [buildHandle], mix in
// [TextSelectionHandleControls] into the [TextSelectionControls] subclass when
// moving any toolbar code to a callback passed to
// [EditableText.contextMenuBuilder].
//
// In due course, [buildToolbar] will be removed, and the mixin will no longer
// be necessary as a way to flag to the framework that the code has been
// migrated and does not expect [buildToolbar] to be called.
//
// For more information, see <https://docs.flutter.dev/release/breaking-changes/context-menus>.
//
// See also:
//
//  * [SelectionArea], which selects appropriate text selection controls
//    based on the current platform.
message FlutterTextSelectionControlsType {
  oneof constructor {
    CupertinoDesktopTextSelectionControls cupertino_desktop_text_selection_controls = 2;
    CupertinoTextSelectionControls cupertino_text_selection_controls = 3;
    FlutterEmptyTextSelectionControls flutter_empty_text_selection_controls = 4;
    MaterialDesktopTextSelectionControls material_desktop_text_selection_controls = 5;
    MaterialMaterialTextSelectionControls material_material_text_selection_controls = 6;
  }
}

// package:flutter/src/rendering/editable.dart
//
// Represents the coordinates of the point in a selection, and the text
// direction at that point, relative to top left of the [RenderEditable] that
// holds the selection.
message FlutterTextSelectionPointType {
  oneof constructor {
    FlutterTextSelectionPoint flutter_text_selection_point = 2;
  }
}

// package:flutter/src/widgets/text_selection_toolbar_anchors.dart
//
// The position information for a text selection toolbar.
//
// Typically, a menu will attempt to position itself at [primaryAnchor], and
// if that's not possible, then it will use [secondaryAnchor] instead, if it
// exists.
//
// See also:
//
//  * [AdaptiveTextSelectionToolbar.anchors], which is of this type.
message FlutterTextSelectionToolbarAnchorsType {
  oneof constructor {
    FlutterTextSelectionToolbarAnchors flutter_text_selection_toolbar_anchors = 2;
    FlutterTextSelectionToolbarAnchorsNamedFromSelection flutter_text_selection_toolbar_anchors_named_from_selection = 3;
  }
}

// package:flutter/src/services/text_editing.dart
//
// A range of text that represents a selection.
message FlutterTextSelectionType {
  oneof constructor {
    FlutterTextSelection flutter_text_selection = 2;
    FlutterTextSelectionNamedCollapsed flutter_text_selection_named_collapsed = 3;
    FlutterTextSelectionNamedFromPosition flutter_text_selection_named_from_position = 4;
  }
}

// package:flutter/src/painting/text_span.dart
//
// An immutable span of text.
//
// A [TextSpan] object can be styled using its [style] property. The style will
// be applied to the [text] and the [children].
//
// A [TextSpan] object can just have plain text, or it can have children
// [TextSpan] objects with their own styles that (possibly only partially)
// override the [style] of this object. If a [TextSpan] has both [text] and
// [children], then the [text] is treated as if it was an un-styled [TextSpan]
// at the start of the [children] list. Leaving the [TextSpan.text] field null
// results in the [TextSpan] acting as an empty node in the [InlineSpan] tree
// with a list of children.
//
// To paint a [TextSpan] on a [Canvas], use a [TextPainter]. To display a text
// span in a widget, use a [RichText]. For text with a single style, consider
// using the [Text] widget.
//
// {@tool snippet}
//
// The text "Hello world!", in black:
//
// ```dart
// const TextSpan(
//   text: 'Hello world!',
//   style: TextStyle(color: Colors.black),
// )
// ```
// {@end-tool}
//
// _There is some more detailed sample code in the documentation for the
// [recognizer] property._
//
// The [TextSpan.text] will be used as the semantics label unless overridden
// by the [TextSpan.semanticsLabel] property. Any [PlaceholderSpan]s in the
// [TextSpan.children] list will separate the text before and after it into two
// semantics nodes.
//
// See also:
//
//  * [WidgetSpan], a leaf node that represents an embedded inline widget in an
//    [InlineSpan] tree. Specify a widget within the [children] list by
//    wrapping the widget with a [WidgetSpan]. The widget will be laid out
//    inline within the paragraph.
//  * [Text], a widget for showing uniformly-styled text.
//  * [RichText], a widget for finer control of text rendering.
//  * [TextPainter], a class for painting [TextSpan] objects on a [Canvas].
message FlutterTextSpanType {
  oneof constructor {
    FlutterTextSpan flutter_text_span = 2;
  }
}

// package:flutter/src/painting/text_style.dart
//
// An immutable style describing how to format and paint text.
//
// {@youtube 560 315 https://www.youtube.com/watch?v=1z6YP7YmvwA}
//
// ### Bold
//
// {@tool snippet}
// Here, a single line of text in a [Text] widget is given a specific style
// override. The style is mixed with the ambient [DefaultTextStyle] by the
// [Text] widget.
//
// ![Applying the style in this way creates bold text.](https://flutter.github.io/assets-for-api-docs/assets/painting/text_style_bold.png)
//
// ```dart
// const Text(
//   'No, we need bold strokes. We need this plan.',
//   style: TextStyle(fontWeight: FontWeight.bold),
// )
// ```
// {@end-tool}
//
// ### Italics
//
// {@tool snippet}
// As in the previous example, the [Text] widget is given a specific style
// override which is implicitly mixed with the ambient [DefaultTextStyle].
//
// ![This results in italicized text.](https://flutter.github.io/assets-for-api-docs/assets/painting/text_style_italics.png)
//
// ```dart
// const Text(
//   "Welcome to the present, we're running a real nation.",
//   style: TextStyle(fontStyle: FontStyle.italic),
// )
// ```
// {@end-tool}
//
// ### Opacity and Color
//
// Each line here is progressively more opaque. The base color is
// [material.Colors.black], and [Color.withOpacity] is used to create a
// derivative color with the desired opacity. The root [TextSpan] for this
// [RichText] widget is explicitly given the ambient [DefaultTextStyle], since
// [RichText] does not do that automatically. The inner [TextStyle] objects are
// implicitly mixed with the parent [TextSpan]'s [TextSpan.style].
//
// If [color] is specified, [foreground] must be null and vice versa. [color] is
// treated as a shorthand for `Paint()..color = color`.
//
// If [backgroundColor] is specified, [background] must be null and vice versa.
// The [backgroundColor] is treated as a shorthand for
// `background: Paint()..color = backgroundColor`.
//
// ![This results in three lines of text that go from lighter to darker in color.](https://flutter.github.io/assets-for-api-docs/assets/painting/text_style_opacity_and_color.png)
//
// ```dart
// RichText(
//   text: TextSpan(
//     style: DefaultTextStyle.of(context).style,
//     children: <TextSpan>[
//       TextSpan(
//         text: "You don't have the votes.\n",
//         style: TextStyle(color: Colors.black.withOpacity(0.6)),
//       ),
//       TextSpan(
//         text: "You don't have the votes!\n",
//         style: TextStyle(color: Colors.black.withOpacity(0.8)),
//       ),
//       TextSpan(
//         text: "You're gonna need congressional approval and you don't have the votes!\n",
//         style: TextStyle(color: Colors.black.withOpacity(1.0)),
//       ),
//     ],
//   ),
// )
// ```
//
// ### Size
//
// {@tool snippet}
// In this example, the ambient [DefaultTextStyle] is explicitly manipulated to
// obtain a [TextStyle] that doubles the default font size.
//
// ![This results in text that is twice as large as normal.](https://flutter.github.io/assets-for-api-docs/assets/painting/text_style_size.png)
//
// ```dart
// Text(
//   "These are wise words, enterprising men quote 'em.",
//   style: DefaultTextStyle.of(context).style.apply(fontSizeFactor: 2.0),
// )
// ```
// {@end-tool}
//
// ### Line height
//
// By default, text will layout with line height as defined by the font.
// Font-metrics defined line height may be taller or shorter than the font size.
// The [height] property allows manual adjustment of the height of the line as
// a multiple of [fontSize]. For most fonts, setting [height] to 1.0 is not
// the same as omitting or setting height to null. The following diagram
// illustrates the difference between the font-metrics-defined line height and
// the line height produced with `height: 1.0` (also known as the EM-square):
//
// ![With the font-metrics-defined line height, there is space between lines appropriate for the font, whereas the EM-square is only the height required to hold most of the characters.](https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_diagram.png)
//
// {@tool snippet}
// The [height] property can be used to change the line height. Here, the line
// height is set to 5 times the font size, so that the text is very spaced out.
// Since the `fontSize` is set to 10, the final height of the line is
// 50 pixels.
//
// ```dart
// const Text(
//   'Ladies and gentlemen, you coulda been anywhere in the world tonight, but youre here with us in New York City.',
//   style: TextStyle(height: 5, fontSize: 10),
// )
// ```
// {@end-tool}
//
// Examples of the resulting heights from different values of `TextStyle.height`:
//
// ![Since the explicit line height is applied as a scale factor on the font-metrics-defined line height, the gap above the text grows faster, as the height grows, than the gap below the text.](https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_comparison_diagram.png)
//
// See [StrutStyle] for further control of line height at the paragraph level.
//
// ### Leading Distribution and Trimming
//
// [Leading](https://en.wikipedia.org/wiki/Leading) is the vertical space
// between glyphs from adjacent lines. Quantitatively, it is the line height
// (see the previous section) subtracted by the font's ascent and descent.
// It's possible to have a negative `Leading` if [height] is sufficiently
// small.
//
// When the [height] multiplier is null, `leading` and how it is distributed
// is up to the font's
// [metrics](https://en.wikipedia.org/wiki/Typeface#Font_metrics).
// When the [height] multiplier is specified, the exact behavior can be
// configured via [leadingDistribution] and [TextPainter.textHeightBehavior].
//
// ![In configuration 1 the line height is divided by the alphabetic baseline proportionally to the font's ascent and descent, in configuration 3 the glyphs are roughly centered within the line height, configuration 2 is similar to configuration 1 except the Text Top guide on the same line as the font's ascent](https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_breakdown.png)
//
// Above is a side-by-side comparison of different [leadingDistribution] and
// [TextPainter.textHeightBehavior] combinations.
//
//  * Configuration 1: The default. [leadingDistribution] is set to [TextLeadingDistribution.proportional].
//  * Configuration 2: same as Configuration 1, except [TextHeightBehavior.applyHeightToFirstAscent] is set to false.
//  * Configuration 3: [leadingDistribution] is set to [TextLeadingDistribution.even].
//  * Configuration 4: same as Configuration 3, except [TextHeightBehavior.applyHeightToLastDescent] is set to false.
//
// The [leadingDistribution] property controls how leading is distributed over
// and under the text. With [TextLeadingDistribution.proportional]
// (Configuration 1), `Top Leading : Bottom Leading = Font Ascent : Font
// Descent`, which also means the alphabetic baseline divides the line height
// into 2 parts proportional to the font's ascent and descent. With
// [TextLeadingDistribution.even] (Configuration 3), `Top Leading` equals
// `Bottom Leading`, and the glyphs are roughly centered within the allotted
// line height.
//
// The [TextPainter.textHeightBehavior] is a property that controls leading at
// the paragraph level. The `applyHeightToFirstAscent` property is applied
// **after** [height] and [leadingDistribution]. Setting it to false trims the
// "Top Leading" of the text box to match the font's ascent if it's on the
// first line (see Configuration 2). Similarly setting
// `applyHeightToLastDescent` to false reduces "Bottom Leading" to 0 for the
// last line of text (Configuration 4).
//
// ### Wavy red underline with black text
//
// {@tool snippet}
// Styles can be combined. In this example, the misspelled word is drawn in
// black text and underlined with a wavy red line to indicate a spelling error.
// (The remainder is styled according to the Flutter default text styles, not
// the ambient [DefaultTextStyle], since no explicit style is given and
// [RichText] does not automatically use the ambient [DefaultTextStyle].)
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/painting/text_style_wavy_red_underline.png)
//
// ```dart
// RichText(
//   text: const TextSpan(
//     text: "Don't tax the South ",
//     children: <TextSpan>[
//       TextSpan(
//         text: 'cuz',
//         style: TextStyle(
//           color: Colors.black,
//           decoration: TextDecoration.underline,
//           decorationColor: Colors.red,
//           decorationStyle: TextDecorationStyle.wavy,
//         ),
//       ),
//       TextSpan(
//         text: ' we got it made in the shade',
//       ),
//     ],
//   ),
// )
// ```
// {@end-tool}
//
// ### Borders and stroke (Foreground)
//
// {@tool snippet}
// To create bordered text, a [Paint] with [Paint.style] set to [PaintingStyle.stroke]
// should be provided as a [foreground] paint. The following example uses a [Stack]
// to produce a stroke and fill effect.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/widgets/text_border.png)
//
// ```dart
// Stack(
//   children: <Widget>[
//     // Stroked text as border.
//     Text(
//       'Greetings, planet!',
//       style: TextStyle(
//         fontSize: 40,
//         foreground: Paint()
//           ..style = PaintingStyle.stroke
//           ..strokeWidth = 6
//           ..color = Colors.blue[700]!,
//       ),
//     ),
//     // Solid text as fill.
//     Text(
//       'Greetings, planet!',
//       style: TextStyle(
//         fontSize: 40,
//         color: Colors.grey[300],
//       ),
//     ),
//   ],
// )
// ```
// {@end-tool}
//
// ### Gradients (Foreground)
//
// {@tool snippet}
// The [foreground] property also allows effects such as gradients to be
// applied to the text. Here we provide a [Paint] with a [ui.Gradient]
// shader.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/widgets/text_gradient.png)
//
// ```dart
// Text(
//   'Greetings, planet!',
//   style: TextStyle(
//     fontSize: 40,
//     foreground: Paint()
//       ..shader = ui.Gradient.linear(
//         const Offset(0, 20),
//         const Offset(150, 20),
//         <Color>[
//           Colors.red,
//           Colors.yellow,
//         ],
//       )
//   ),
// )
// ```
// {@end-tool}
//
// ### Custom Fonts
//
// Custom fonts can be declared in the `pubspec.yaml` file as shown below:
//
// ```yaml
// flutter:
//   fonts:
//     - family: Raleway
//       fonts:
//         - asset: fonts/Raleway-Regular.ttf
//         - asset: fonts/Raleway-Medium.ttf
//           weight: 500
//         - asset: assets/fonts/Raleway-SemiBold.ttf
//           weight: 600
//      - family: Schyler
//        fonts:
//          - asset: fonts/Schyler-Regular.ttf
//          - asset: fonts/Schyler-Italic.ttf
//            style: italic
// ```
//
// The `family` property determines the name of the font, which you can use in
// the [fontFamily] argument. The `asset` property is a path to the font file,
// relative to the `pubspec.yaml` file. The `weight` property specifies the
// weight of the glyph outlines in the file as an integer multiple of 100
// between 100 and 900. This corresponds to the [FontWeight] class and can be
// used in the [fontWeight] argument. The `style` property specifies whether the
// outlines in the file are `italic` or `normal`. These values correspond to
// the [FontStyle] class and can be used in the [fontStyle] argument.
//
// To select a custom font, create [TextStyle] using the [fontFamily]
// argument as shown in the example below:
//
// {@tool snippet}
// ![](https://flutter.github.io/assets-for-api-docs/assets/painting/text_style_custom_fonts.png)
//
// ```dart
// const TextStyle(fontFamily: 'Raleway')
// ```
// {@end-tool}
//
// To use a font family defined in a package, the `package` argument must be
// provided. For instance, suppose the font declaration above is in the
// `pubspec.yaml` of a package named `my_package` which the app depends on.
// Then creating the TextStyle is done as follows:
//
// ```dart
// const TextStyle(fontFamily: 'Raleway', package: 'my_package')
// ```
//
// If the package internally uses the font it defines, it should still specify
// the `package` argument when creating the text style as in the example above.
//
// A package can also provide font files without declaring a font in its
// `pubspec.yaml`. These files should then be in the `lib/` folder of the
// package. The font files will not automatically be bundled in the app, instead
// the app can use these selectively when declaring a font. Suppose a package
// named `my_package` has:
//
//     lib/fonts/Raleway-Medium.ttf
//
// Then the app can declare a font like in the example below:
//
// ```yaml
// flutter:
//   fonts:
//     - family: Raleway
//       fonts:
//         - asset: assets/fonts/Raleway-Regular.ttf
//         - asset: packages/my_package/fonts/Raleway-Medium.ttf
//           weight: 500
// ```
//
// The `lib/` is implied, so it should not be included in the asset path.
//
// In this case, since the app locally defines the font, the TextStyle is
// created without the `package` argument:
//
// {@tool snippet}
// ```dart
// const TextStyle(fontFamily: 'Raleway')
// ```
// {@end-tool}
//
// #### Supported font formats
//
// Font formats currently supported by Flutter:
//
//  * `.ttc`
//  * `.ttf`
//  * `.otf`
//
// Flutter does not support `.woff` and `.woff2` fonts for all platforms.
//
// ### Custom Font Fallback
//
// A custom [fontFamilyFallback] list can be provided. The list should be an
// ordered list of strings of font family names in the order they will be attempted.
//
// The fonts in [fontFamilyFallback] will be used only if the requested glyph is
// not present in the [fontFamily].
//
// The fallback order is:
//
//  * [fontFamily]
//  * [fontFamilyFallback] in order of first to last.
//  * System fallback fonts which will vary depending on platform.
//
// The glyph used will always be the first matching version in fallback order.
//
// The [fontFamilyFallback] property is commonly used to specify different font
// families for multilingual text spans as well as separate fonts for glyphs such
// as emojis.
//
// {@tool snippet}
// In the following example, any glyphs not present in the font `Raleway` will be attempted
// to be resolved with `Noto Sans CJK SC`, and then with `Noto Color Emoji`:
//
// ```dart
// const TextStyle(
//   fontFamily: 'Raleway',
//   fontFamilyFallback: <String>[
//     'Noto Sans CJK SC',
//     'Noto Color Emoji',
//   ],
// )
// ```
// {@end-tool}
//
// If all custom fallback font families are exhausted and no match was found
// or no custom fallback was provided, the platform font fallback will be used.
//
// ### Inconsistent platform fonts
//
// By default, fonts differ depending on the platform.
//
//  * The default font-family for `Android`,`Fuchsia` and `Linux` is `Roboto`.
//  * The default font-family for `iOS` is `SF Pro Display`/`SF Pro Text`.
//  * The default font-family for `MacOS` is `.AppleSystemUIFont`.
//  * The default font-family for `Windows` is `Segoe UI`.
//
// Since Flutter's font discovery for default fonts depends on the fonts present
// on the device, it is not safe to assume all default fonts will be available or
// consistent across devices.
//
// A known example of this is that Samsung devices ship with a CJK font that has
// smaller line spacing than the Android default. This results in Samsung devices
// displaying more tightly spaced text than on other Android devices when no
// custom font is specified.
//
// To avoid this, a custom font should be specified if absolute font consistency
// is required for your application.
//
// See also:
//
//  * [Text], the widget for showing text in a single style.
//  * [DefaultTextStyle], the widget that specifies the default text styles for
//    [Text] widgets, configured using a [TextStyle].
//  * [RichText], the widget for showing a paragraph of mix-style text.
//  * [TextSpan], the class that wraps a [TextStyle] for the purposes of
//    passing it to a [RichText].
//  * [TextStyle](https://api.flutter.dev/flutter/dart-ui/TextStyle-class.html), the class in the [dart:ui] library.
//  * Cookbook: [Use a custom font](https://flutter.dev/docs/cookbook/design/fonts)
//  * Cookbook: [Use themes to share colors and font styles](https://flutter.dev/docs/cookbook/design/themes)
message FlutterTextStyleType {
  oneof constructor {
    FlutterTextStyle flutter_text_style = 2;
  }
}

// package:flutter/src/widgets/interactive_viewer.dart
//
// A thin wrapper on [ValueNotifier] whose value is a [Matrix4] representing a
// transformation.
//
// The [value] defaults to the identity matrix, which corresponds to no
// transformation.
//
// See also:
//
//  * [InteractiveViewer.transformationController] for detailed documentation
//    on how to use TransformationController with [InteractiveViewer].
message FlutterTransformationControllerType {
  oneof constructor {
    FlutterTransformationController flutter_transformation_controller = 2;
  }
}

// package:flutter/src/widgets/undo_history.dart
//
// A controller for the undo history, for example for an editable text field.
//
// Whenever a change happens to the underlying value that the [UndoHistory]
// widget tracks, that widget updates the [value] and the controller notifies
// it's listeners. Listeners can then read the canUndo and canRedo
// properties of the value to discover whether [undo] or [redo] are possible.
//
// The controller also has [undo] and [redo] methods to modify the undo
// history.
//
// {@tool dartpad}
// This example creates a [TextField] with an [UndoHistoryController]
// which provides undo and redo buttons.
//
// ** See code in examples/api/lib/widgets/undo_history/undo_history_controller.0.dart **
// {@end-tool}
//
// See also:
//
// * [EditableText], which uses the [UndoHistory] widget and allows
//   control of the underlying history using an [UndoHistoryController].
message FlutterUndoHistoryControllerType {
  oneof constructor {
    FlutterUndoHistoryController flutter_undo_history_controller = 2;
  }
}

// package:flutter/src/widgets/undo_history.dart
//
// Represents whether the current undo stack can undo or redo.
message FlutterUndoHistoryValueType {
  oneof constructor {
    FlutterUndoHistoryValue flutter_undo_history_value = 2;
  }
}

// package:flutter/src/rendering/view.dart
//
// The layout constraints for the root render object.
message FlutterViewConfigurationType {
  oneof constructor {
    FlutterViewConfiguration flutter_view_configuration = 2;
  }
}

// package:flutter/src/rendering/viewport_offset.dart
//
// Which part of the content inside the viewport should be visible.
//
// The [pixels] value determines the scroll offset that the viewport uses to
// select which part of its content to display. As the user scrolls the
// viewport, this value changes, which changes the content that is displayed.
//
// This object is a [Listenable] that notifies its listeners when [pixels]
// changes.
//
// See also:
//
//  * [ScrollPosition], which is a commonly used concrete subclass.
//  * [RenderViewportBase], which is a render object that uses viewport
//    offsets.
message FlutterViewportOffsetType {
  oneof constructor {
    FlutterScrollPositionWithSingleContext flutter_scroll_position_with_single_context = 2;
    FlutterViewportOffsetNamedFixed flutter_viewport_offset_named_fixed = 3;
    FlutterViewportOffsetNamedZero flutter_viewport_offset_named_zero = 4;
  }
}

// package:flutter/src/material/action_icons_theme.dart
//
// A [ActionIconThemeData] that overrides the default icons of
// [BackButton], [CloseButton], [DrawerButton], and [EndDrawerButton] with
// [ActionIconTheme.of] or the overall [Theme]'s [ThemeData.actionIconTheme].
message MaterialActionIconThemeDataType {
  oneof constructor {
    MaterialActionIconThemeData material_action_icon_theme_data = 2;
  }
}

// package:flutter/src/material/app_bar_theme.dart
//
// Overrides the default values of visual properties for descendant
// [AppBar] widgets.
//
// Descendant widgets obtain the current [AppBarTheme] object with
// `AppBarTheme.of(context)`. Instances of [AppBarTheme] can be customized
// with [AppBarTheme.copyWith].
//
// Typically an [AppBarTheme] is specified as part of the overall [Theme] with
// [ThemeData.appBarTheme].
//
// All [AppBarTheme] properties are `null` by default. When null, the [AppBar]
// compute its own default values, typically based on the overall theme's
// [ThemeData.colorScheme], [ThemeData.textTheme], and [ThemeData.iconTheme].
message MaterialAppBarThemeType {
  oneof constructor {
    MaterialAppBarTheme material_app_bar_theme = 2;
  }
}

// package:flutter/src/material/badge_theme.dart
//
// Overrides the default properties values for descendant [Badge] widgets.
//
// Descendant widgets obtain the current [BadgeThemeData] object
// using `BadgeTheme.of(context)`. Instances of [BadgeThemeData] can
// be customized with [BadgeThemeData.copyWith].
//
// Typically a [BadgeThemeData] is specified as part of the
// overall [Theme] with [ThemeData.badgeTheme].
//
// All [BadgeThemeData] properties are `null` by default.
// When null, the [Badge] will use the values from [ThemeData]
// if they exist, otherwise it will provide its own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialBadgeThemeDataType {
  oneof constructor {
    MaterialBadgeThemeData material_badge_theme_data = 2;
  }
}

// package:flutter/src/material/bottom_app_bar_theme.dart
//
// Defines default property values for descendant [BottomAppBar] widgets.
//
// Descendant widgets obtain the current [BottomAppBarTheme] object using
// `BottomAppBarTheme.of(context)`. Instances of [BottomAppBarTheme] can be
// customized with [BottomAppBarTheme.copyWith].
//
// Typically a [BottomAppBarTheme] is specified as part of the overall [Theme]
// with [ThemeData.bottomAppBarTheme].
//
// All [BottomAppBarTheme] properties are `null` by default. When null, the
// [BottomAppBar] constructor provides defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialBottomAppBarThemeType {
  oneof constructor {
    MaterialBottomAppBarTheme material_bottom_app_bar_theme = 2;
  }
}

// package:flutter/src/material/bottom_navigation_bar_theme.dart
//
// Defines default property values for descendant [BottomNavigationBar]
// widgets.
//
// Descendant widgets obtain the current [BottomNavigationBarThemeData] object
// using `BottomNavigationBarTheme.of(context)`. Instances of
// [BottomNavigationBarThemeData] can be customized with
// [BottomNavigationBarThemeData.copyWith].
//
// Typically a [BottomNavigationBarThemeData] is specified as part of the
// overall [Theme] with [ThemeData.bottomNavigationBarTheme].
//
// All [BottomNavigationBarThemeData] properties are `null` by default. When
// null, the [BottomNavigationBar]'s build method provides defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialBottomNavigationBarThemeDataType {
  oneof constructor {
    MaterialBottomNavigationBarThemeData material_bottom_navigation_bar_theme_data = 2;
  }
}

// package:flutter/src/material/bottom_sheet_theme.dart
//
// Defines default property values for [BottomSheet]'s [Material].
//
// Descendant widgets obtain the current [BottomSheetThemeData] object
// using `Theme.of(context).bottomSheetTheme`. Instances of
// [BottomSheetThemeData] can be customized with
// [BottomSheetThemeData.copyWith].
//
// Typically a [BottomSheetThemeData] is specified as part of the
// overall [Theme] with [ThemeData.bottomSheetTheme].
//
// All [BottomSheetThemeData] properties are `null` by default.
// When null, the [BottomSheet] will provide its own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialBottomSheetThemeDataType {
  oneof constructor {
    MaterialBottomSheetThemeData material_bottom_sheet_theme_data = 2;
  }
}

// package:flutter/src/material/button_bar_theme.dart
//
// Defines the visual properties of [ButtonBar] widgets.
//
// Used by [ButtonBarTheme] to control the visual properties of [ButtonBar]
// instances in a widget subtree.
//
// To obtain this configuration, use [ButtonBarTheme.of] to access the closest
// ancestor [ButtonBarTheme] of the current [BuildContext].
//
// See also:
//
//  * [ButtonBarTheme], an [InheritedWidget] that propagates the theme down
//    its subtree.
//  * [ButtonBar], which uses this to configure itself and its children
//    button widgets.
message MaterialButtonBarThemeDataType {
  oneof constructor {
    MaterialButtonBarThemeData material_button_bar_theme_data = 2;
  }
}

// package:flutter/src/material/button_style.dart
//
// The visual properties that most buttons have in common.
//
// Buttons and their themes have a ButtonStyle property which defines the visual
// properties whose default values are to be overridden. The default values are
// defined by the individual button widgets and are typically based on overall
// theme's [ThemeData.colorScheme] and [ThemeData.textTheme].
//
// All of the ButtonStyle properties are null by default.
//
// Many of the ButtonStyle properties are [MaterialStateProperty] objects which
// resolve to different values depending on the button's state. For example
// the [Color] properties are defined with `MaterialStateProperty<Color>` and
// can resolve to different colors depending on if the button is pressed,
// hovered, focused, disabled, etc.
//
// These properties can override the default value for just one state or all of
// them. For example to create a [ElevatedButton] whose background color is the
// color schemes primary color with 50% opacity, but only when the button is
// pressed, one could write:
//
// ```dart
// ElevatedButton(
//   style: ButtonStyle(
//     backgroundColor: MaterialStateProperty.resolveWith<Color?>(
//       (Set<MaterialState> states) {
//         if (states.contains(MaterialState.pressed)) {
//           return Theme.of(context).colorScheme.primary.withOpacity(0.5);
//         }
//         return null; // Use the component's default.
//       },
//     ),
//   ),
//   child: const Text('Fly me to the moon'),
//   onPressed: () {
//     // ...
//   },
// ),
// ```
//
// In this case the background color for all other button states would fallback
// to the ElevatedButtons default values. To unconditionally set the button's
// [backgroundColor] for all states one could write:
//
// ```dart
// ElevatedButton(
//   style: const ButtonStyle(
//     backgroundColor: MaterialStatePropertyAll<Color>(Colors.green),
//   ),
//   child: const Text('Let me play among the stars'),
//   onPressed: () {
//     // ...
//   },
// ),
// ```
//
// Configuring a ButtonStyle directly makes it possible to very
// precisely control the buttons visual attributes for all states.
// This level of control is typically required when a custom
// branded look and feel is desirable. However, in many cases its
// useful to make relatively sweeping changes based on a few initial
// parameters with simple values. The button styleFrom() methods
// enable such sweeping changes. See for example:
// [ElevatedButton.styleFrom], [FilledButton.styleFrom],
// [OutlinedButton.styleFrom], [TextButton.styleFrom].
//
// For example, to override the default text and icon colors for a
// [TextButton], as well as its overlay color, with all of the
// standard opacity adjustments for the pressed, focused, and
// hovered states, one could write:
//
// ```dart
// TextButton(
//   style: TextButton.styleFrom(foregroundColor: Colors.green),
//   child: const Text('Let me see what spring is like'),
//   onPressed: () {
//     // ...
//   },
// ),
// ```
//
// To configure all of the application's text buttons in the same
// way, specify the overall theme's `textButtonTheme`:
//
// ```dart
// MaterialApp(
//   theme: ThemeData(
//     textButtonTheme: TextButtonThemeData(
//       style: TextButton.styleFrom(foregroundColor: Colors.green),
//     ),
//   ),
//   home: const MyAppHome(),
// ),
// ```
//
// ## Material 3 button types
//
// Material Design 3 specifies five types of common buttons. Flutter provides
// support for these using the following button classes:
// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
//
// | Type         | Flutter implementation  |
// | :----------- | :---------------------- |
// | Elevated     | [ElevatedButton]        |
// | Filled       | [FilledButton]          |
// | Filled Tonal | [FilledButton.tonal]    |
// | Outlined     | [OutlinedButton]        |
// | Text         | [TextButton]            |
//
// {@tool dartpad}
// This sample shows how to create each of the Material 3 button types with Flutter.
//
// ** See code in examples/api/lib/material/button_style/button_style.0.dart **
// {@end-tool}
//
// See also:
//
//  * [ElevatedButtonTheme], the theme for [ElevatedButton]s.
//  * [FilledButtonTheme], the theme for [FilledButton]s.
//  * [OutlinedButtonTheme], the theme for [OutlinedButton]s.
//  * [TextButtonTheme], the theme for [TextButton]s.
message MaterialButtonStyleType {
  oneof constructor {
    MaterialButtonStyle material_button_style = 2;
  }
}

// package:flutter/src/material/button_theme.dart
//
// Used with [ButtonTheme] to configure the color and geometry of buttons.
//
// This class is planned to be deprecated in a future release.
// Please use one or more of these buttons and associated themes instead:
//
//  * [TextButton], [TextButtonTheme], [TextButtonThemeData],
//  * [ElevatedButton], [ElevatedButtonTheme], [ElevatedButtonThemeData],
//  * [OutlinedButton], [OutlinedButtonTheme], [OutlinedButtonThemeData]
//
// A button theme can be specified as part of the overall Material theme
// using [ThemeData.buttonTheme]. The Material theme's button theme data
// can be overridden with [ButtonTheme].
message MaterialButtonThemeDataType {
  oneof constructor {
    MaterialButtonThemeData material_button_theme_data = 2;
  }
}

// package:flutter/src/material/card_theme.dart
//
// Defines default property values for descendant [Card] widgets.
//
// Descendant widgets obtain the current [CardTheme] object using
// `CardTheme.of(context)`. Instances of [CardTheme] can be
// customized with [CardTheme.copyWith].
//
// Typically a [CardTheme] is specified as part of the overall [Theme]
// with [ThemeData.cardTheme].
//
// All [CardTheme] properties are `null` by default. When null, the [Card]
// will use the values from [ThemeData] if they exist, otherwise it will
// provide its own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialCardThemeType {
  oneof constructor {
    MaterialCardTheme material_card_theme = 2;
  }
}

// package:flutter/src/material/checkbox_theme.dart
//
// Defines default property values for descendant [Checkbox] widgets.
//
// Descendant widgets obtain the current [CheckboxThemeData] object using
// `CheckboxTheme.of(context)`. Instances of [CheckboxThemeData] can be
// customized with [CheckboxThemeData.copyWith].
//
// Typically a [CheckboxThemeData] is specified as part of the overall [Theme]
// with [ThemeData.checkboxTheme].
//
// All [CheckboxThemeData] properties are `null` by default. When null, the
// [Checkbox] will use the values from [ThemeData] if they exist, otherwise it
// will provide its own defaults based on the overall [Theme]'s colorScheme.
// See the individual [Checkbox] properties for details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialCheckboxThemeDataType {
  oneof constructor {
    MaterialCheckboxThemeData material_checkbox_theme_data = 2;
  }
}

// package:flutter/src/material/chip_theme.dart
//
// Holds the color, shape, and text styles for a Material Design chip theme.
//
// Use this class to configure a [ChipTheme] widget, or to set the
// [ThemeData.chipTheme] for a [Theme] widget.
//
// To obtain the current ambient chip theme, use [ChipTheme.of].
//
// The parts of a chip are:
//
//  * The "avatar", which is a widget that appears at the beginning of the
//    chip. This is typically a [CircleAvatar] widget.
//  * The "label", which is the widget displayed in the center of the chip.
//    Typically this is a [Text] widget.
//  * The "delete icon", which is a widget that appears at the end of the chip.
//  * The chip is disabled when it is not accepting user input. Only some chips
//    have a disabled state: [ActionChip], [ChoiceChip], [FilterChip], and
//    [InputChip].
//
// The simplest way to create a ChipThemeData is to use [copyWith] on the one
// you get from [ChipTheme.of], or create an entirely new one with
// [ChipThemeData.fromDefaults].
//
// {@tool snippet}
//
// ```dart
// class CarColor extends StatefulWidget {
//   const CarColor({super.key});
//
//   @override
//   State createState() => _CarColorState();
// }
//
// class _CarColorState extends State<CarColor> {
//   Color _color = Colors.red;
//
//   @override
//   Widget build(BuildContext context) {
//     return ChipTheme(
//       data: ChipTheme.of(context).copyWith(backgroundColor: Colors.lightBlue),
//       child: ChoiceChip(
//         label: const Text('Light Blue'),
//         onSelected: (bool value) {
//           setState(() {
//             _color = value ? Colors.lightBlue : Colors.red;
//           });
//         },
//         selected: _color == Colors.lightBlue,
//       ),
//     );
//   }
// }
// ```
// {@end-tool}
//
// See also:
//
//  * [Chip], a chip that displays information and can be deleted.
//  * [InputChip], a chip that represents a complex piece of information, such
//    as an entity (person, place, or thing) or conversational text, in a
//    compact form.
//  * [ChoiceChip], allows a single selection from a set of options. Choice
//    chips contain related descriptive text or categories.
//  * [FilterChip], uses tags or descriptive words as a way to filter content.
//  * [ActionChip], represents an action related to primary content.
//  * [CircleAvatar], which shows images or initials of entities.
//  * [Wrap], A widget that displays its children in multiple horizontal or
//    vertical runs.
//  * [ChipTheme] widget, which can override the chip theme of its
//    children.
//  * [Theme] widget, which performs a similar function to [ChipTheme],
//    but for overall themes.
//  * [ThemeData], which has a default [ChipThemeData].
message MaterialChipThemeDataType {
  oneof constructor {
    MaterialChipThemeData material_chip_theme_data = 2;
    MaterialChipThemeDataNamedFromDefaults material_chip_theme_data_named_from_defaults = 3;
  }
}

// package:flutter/src/material/color_scheme.dart
//
// {@template flutter.material.color_scheme.ColorScheme}
// A set of 30 colors based on the
// [Material spec](https://m3.material.io/styles/color/the-color-system/color-roles)
// that can be used to configure the color properties of most components.
// {@endtemplate}
//
// ### Colors in Material 3
//
// {@macro flutter.material.colors.colorRoles}
//
// The main accent color groups in the scheme are [primary], [secondary],
// and [tertiary].
//
// * Primary colors are used for key components across the UI, such as the FAB,
//   prominent buttons, and active states.
//
// * Secondary colors are used for less prominent components in the UI, such as
//   filter chips, while expanding the opportunity for color expression.
//
// * Tertiary colors are used for contrasting accents that can be used to
//   balance primary and secondary colors or bring heightened attention to
//   an element, such as an input field. The tertiary colors are left
//   for makers to use at their discretion and are intended to support
//   broader color expression in products.
//
// The remaining colors of the scheme are composed of neutral colors used for
// backgrounds and surfaces, as well as specific colors for errors, dividers
// and shadows.
//
// Many of the colors have matching 'on' colors, which are used for drawing
// content on top of the matching color. For example, if something is using
// [primary] for a background color, [onPrimary] would be used to paint text
// and icons on top of it. For this reason, the 'on' colors should have a
// contrast ratio with their matching colors of at least 4.5:1 in order to
// be readable.
//
// ### Setting Colors in Flutter
//
//{@macro flutter.material.colors.settingColors}
message MaterialColorSchemeType {
  oneof constructor {
    MaterialColorScheme material_color_scheme = 2;
    MaterialColorSchemeNamedDark material_color_scheme_named_dark = 3;
    MaterialColorSchemeNamedFromSeed material_color_scheme_named_from_seed = 4;
    MaterialColorSchemeNamedFromSwatch material_color_scheme_named_from_swatch = 5;
    MaterialColorSchemeNamedHighContrastDark material_color_scheme_named_high_contrast_dark = 6;
    MaterialColorSchemeNamedHighContrastLight material_color_scheme_named_high_contrast_light = 7;
    MaterialColorSchemeNamedLight material_color_scheme_named_light = 8;
  }
}

// package:flutter/src/material/data_table.dart
//
// The data for a cell of a [DataTable].
//
// One list of [DataCell] objects must be provided for each [DataRow]
// in the [DataTable], in the new [DataRow] constructor's `cells`
// argument.
message MaterialDataCellType {
  oneof constructor {
    MaterialDataCell material_data_cell = 2;
  }
}

// package:flutter/src/material/data_table.dart
//
// Column configuration for a [DataTable].
//
// One column configuration must be provided for each column to
// display in the table. The list of [DataColumn] objects is passed
// as the `columns` argument to the [DataTable.new] constructor.
message MaterialDataColumnType {
  oneof constructor {
    MaterialDataColumn material_data_column = 2;
  }
}

// package:flutter/src/material/data_table.dart
//
// Row configuration and cell data for a [DataTable].
//
// One row configuration must be provided for each row to
// display in the table. The list of [DataRow] objects is passed
// as the `rows` argument to the [DataTable.new] constructor.
//
// The data for this row of the table is provided in the [cells]
// property of the [DataRow] object.
message MaterialDataRowType {
  oneof constructor {
    MaterialDataRow material_data_row = 2;
    MaterialDataRowNamedByIndex material_data_row_named_by_index = 3;
  }
}

// package:flutter/src/material/data_table_theme.dart
//
// Defines default property values for descendant [DataTable]
// widgets.
//
// Descendant widgets obtain the current [DataTableThemeData] object
// using `DataTableTheme.of(context)`. Instances of
// [DataTableThemeData] can be customized with
// [DataTableThemeData.copyWith].
//
// Typically a [DataTableThemeData] is specified as part of the
// overall [Theme] with [ThemeData.dataTableTheme].
//
// All [DataTableThemeData] properties are `null` by default. When
// null, the [DataTable] will use the values from [ThemeData] if they exist,
// otherwise it will provide its own defaults based on the overall [Theme]'s
// textTheme and colorScheme. See the individual [DataTable] properties for
// details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialDataTableThemeDataType {
  oneof constructor {
    MaterialDataTableThemeData material_data_table_theme_data = 2;
  }
}

// package:flutter/src/material/date_picker_theme.dart
//
// Overrides the default values of visual properties for descendant
// [DatePickerDialog] widgets.
//
// Descendant widgets obtain the current [DatePickerThemeData] object with
// [DatePickerTheme.of]. Instances of [DatePickerTheme] can
// be customized with [DatePickerThemeData.copyWith].
//
// Typically a [DatePickerTheme] is specified as part of the overall
// [Theme] with [ThemeData.datePickerTheme].
//
// All [DatePickerThemeData] properties are null by default. When null,
// the [DatePickerDialog] computes its own default values, typically based on
// the overall theme's [ThemeData.colorScheme], [ThemeData.textTheme], and
// [ThemeData.iconTheme].
message MaterialDatePickerThemeDataType {
  oneof constructor {
    MaterialDatePickerThemeData material_date_picker_theme_data = 2;
  }
}

// package:flutter/src/material/date.dart
//
// Encapsulates a start and end [DateTime] that represent the range of dates.
//
// The range includes the [start] and [end] dates. The [start] and [end] dates
// may be equal to indicate a date range of a single day. The [start] date must
// not be after the [end] date.
//
// See also:
//  * [showDateRangePicker], which displays a dialog that allows the user to
//    select a date range.
message MaterialDateTimeRangeType {
  oneof constructor {
    MaterialDateTimeRange material_date_time_range = 2;
  }
}

// package:flutter/src/material/dialog_theme.dart
//
// Defines a theme for [Dialog] widgets.
//
// Descendant widgets obtain the current [DialogTheme] object using
// `DialogTheme.of(context)`. Instances of [DialogTheme] can be customized with
// [DialogTheme.copyWith].
//
// [titleTextStyle] and [contentTextStyle] are used in [AlertDialog]s and [SimpleDialog]s.
//
// See also:
//
//  * [Dialog], a dialog that can be customized using this [DialogTheme].
//  * [AlertDialog], a dialog that can be customized using this [DialogTheme].
//  * [SimpleDialog], a dialog that can be customized using this [DialogTheme].
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialDialogThemeType {
  oneof constructor {
    MaterialDialogTheme material_dialog_theme = 2;
  }
}

// package:flutter/src/material/divider_theme.dart
//
// Defines the visual properties of [Divider], [VerticalDivider], dividers
// between [ListTile]s, and dividers between rows in [DataTable]s.
//
// Descendant widgets obtain the current [DividerThemeData] object using
// `DividerTheme.of(context)`. Instances of [DividerThemeData]
// can be customized with [DividerThemeData.copyWith].
//
// Typically a [DividerThemeData] is specified as part of the overall
// [Theme] with [ThemeData.dividerTheme].
//
// All [DividerThemeData] properties are `null` by default. When null,
// the widgets will provide their own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialDividerThemeDataType {
  oneof constructor {
    MaterialDividerThemeData material_divider_theme_data = 2;
  }
}

// package:flutter/src/material/drawer_theme.dart
//
// Defines default property values for descendant [Drawer] widgets.
//
// Descendant widgets obtain the current [DrawerThemeData] object
// using `DrawerTheme.of(context)`. Instances of [DrawerThemeData] can be
// customized with [DrawerThemeData.copyWith].
//
// Typically a [DrawerThemeData] is specified as part of the
// overall [Theme] with [ThemeData.drawerTheme].
//
// All [DrawerThemeData] properties are `null` by default.
//
// See also:
//
//  * [DrawerTheme], an [InheritedWidget] that propagates the theme down its
//    subtree.
//  * [ThemeData], which describes the overall theme information for the
//    application and can customize a drawer using [ThemeData.drawerTheme].
message MaterialDrawerThemeDataType {
  oneof constructor {
    MaterialDrawerThemeData material_drawer_theme_data = 2;
  }
}

// package:flutter/src/material/dropdown_menu_theme.dart
//
// Overrides the default values of visual properties for descendant [DropdownMenu] widgets.
//
// Descendant widgets obtain the current [DropdownMenuThemeData] object with
// [DropdownMenuTheme.of]. Instances of [DropdownMenuTheme] can
// be customized with [DropdownMenuThemeData.copyWith].
//
// Typically a [DropdownMenuTheme] is specified as part of the overall [Theme] with
// [ThemeData.dropdownMenuTheme].
//
// All [DropdownMenuThemeData] properties are null by default. When null, the [DropdownMenu]
// computes its own default values, typically based on the overall
// theme's [ThemeData.colorScheme], [ThemeData.textTheme], and [ThemeData.iconTheme].
message MaterialDropdownMenuThemeDataType {
  oneof constructor {
    MaterialDropdownMenuThemeData material_dropdown_menu_theme_data = 2;
  }
}

// package:flutter/src/material/elevated_button_theme.dart
//
// A [ButtonStyle] that overrides the default appearance of
// [ElevatedButton]s when it's used with [ElevatedButtonTheme] or with the
// overall [Theme]'s [ThemeData.elevatedButtonTheme].
//
// The [style]'s properties override [ElevatedButton]'s default style,
// i.e. the [ButtonStyle] returned by [ElevatedButton.defaultStyleOf]. Only
// the style's non-null property values or resolved non-null
// [MaterialStateProperty] values are used.
//
// See also:
//
//  * [ElevatedButtonTheme], the theme which is configured with this class.
//  * [ElevatedButton.defaultStyleOf], which returns the default [ButtonStyle]
//    for text buttons.
//  * [ElevatedButton.styleFrom], which converts simple values into a
//    [ButtonStyle] that's consistent with [ElevatedButton]'s defaults.
//  * [MaterialStateProperty.resolve], "resolve" a material state property
//    to a simple value based on a set of [MaterialState]s.
//  * [ThemeData.elevatedButtonTheme], which can be used to override the default
//    [ButtonStyle] for [ElevatedButton]s below the overall [Theme].
message MaterialElevatedButtonThemeDataType {
  oneof constructor {
    MaterialElevatedButtonThemeData material_elevated_button_theme_data = 2;
  }
}

// package:flutter/src/material/expansion_tile.dart
//
// Enables control over a single [ExpansionTile]'s expanded/collapsed state.
//
// It can be useful to expand or collapse an [ExpansionTile]
// programatically, for example to reconfigure an existing expansion
// tile based on a system event. To do so, create an [ExpansionTile]
// with an [ExpansionTileController] that's owned by a stateful widget
// or look up the tile's automatically created [ExpansionTileController]
// with [ExpansionTileController.of]
//
// The controller's [expand] and [collapse] methods cause the
// the [ExpansionTile] to rebuild, so they may not be called from
// a build method.
message MaterialExpansionTileControllerType {
  oneof constructor {
    MaterialExpansionTileController material_expansion_tile_controller = 2;
  }
}

// package:flutter/src/material/expansion_tile_theme.dart
//
// Used with [ExpansionTileTheme] to define default property values for
// descendant [ExpansionTile] widgets.
//
// Descendant widgets obtain the current [ExpansionTileThemeData] object
// using `ExpansionTileTheme.of(context)`. Instances of
// [ExpansionTileThemeData] can be customized with
// [ExpansionTileThemeData.copyWith].
//
// A [ExpansionTileThemeData] is often specified as part of the
// overall [Theme] with [ThemeData.expansionTileTheme].
//
// All [ExpansionTileThemeData] properties are `null` by default.
// When a theme property is null, the [ExpansionTile]  will provide its own
// default based on the overall [Theme]'s textTheme and
// colorScheme. See the individual [ExpansionTile] properties for details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
//  * [ExpansionTileTheme] which overrides the default [ExpansionTileTheme]
//    of its [ExpansionTile] descendants.
//  * [ThemeData.textTheme], text with a color that contrasts with the card
//    and canvas colors.
//  * [ThemeData.colorScheme], the thirteen colors that most Material widget
//    default colors are based on.
message MaterialExpansionTileThemeDataType {
  oneof constructor {
    MaterialExpansionTileThemeData material_expansion_tile_theme_data = 2;
  }
}

// package:flutter/src/material/filled_button_theme.dart
//
// A [ButtonStyle] that overrides the default appearance of
// [FilledButton]s when it's used with [FilledButtonTheme] or with the
// overall [Theme]'s [ThemeData.filledButtonTheme].
//
// The [style]'s properties override [FilledButton]'s default style,
// i.e. the [ButtonStyle] returned by [FilledButton.defaultStyleOf]. Only
// the style's non-null property values or resolved non-null
// [MaterialStateProperty] values are used.
//
// See also:
//
//  * [FilledButtonTheme], the theme which is configured with this class.
//  * [FilledButton.defaultStyleOf], which returns the default [ButtonStyle]
//    for text buttons.
//  * [FilledButton.styleFrom], which converts simple values into a
//    [ButtonStyle] that's consistent with [FilledButton]'s defaults.
//  * [MaterialStateProperty.resolve], "resolve" a material state property
//    to a simple value based on a set of [MaterialState]s.
//  * [ThemeData.filledButtonTheme], which can be used to override the default
//    [ButtonStyle] for [FilledButton]s below the overall [Theme].
message MaterialFilledButtonThemeDataType {
  oneof constructor {
    MaterialFilledButtonThemeData material_filled_button_theme_data = 2;
  }
}

// package:flutter/src/material/floating_action_button_theme.dart
//
// Defines default property values for descendant [FloatingActionButton]
// widgets.
//
// Descendant widgets obtain the current [FloatingActionButtonThemeData] object
// using `Theme.of(context).floatingActionButtonTheme`. Instances of
// [FloatingActionButtonThemeData] can be customized with
// [FloatingActionButtonThemeData.copyWith].
//
// Typically a [FloatingActionButtonThemeData] is specified as part of the
// overall [Theme] with [ThemeData.floatingActionButtonTheme].
//
// All [FloatingActionButtonThemeData] properties are `null` by default.
// When null, the [FloatingActionButton] will use the values from [ThemeData]
// if they exist, otherwise it will provide its own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialFloatingActionButtonThemeDataType {
  oneof constructor {
    MaterialFloatingActionButtonThemeData material_floating_action_button_theme_data = 2;
  }
}

// package:flutter/src/material/icon_button_theme.dart
//
// A [ButtonStyle] that overrides the default appearance of
// [IconButton]s when it's used with the [IconButton], the [IconButtonTheme] or the
// overall [Theme]'s [ThemeData.iconButtonTheme].
//
// The [IconButton] will be affected by [IconButtonTheme] and [IconButtonThemeData]
// only if [ThemeData.useMaterial3] is set to true; otherwise, [IconTheme] will be used.
//
// The [style]'s properties override [IconButton]'s default style. Only
// the style's non-null property values or resolved non-null
// [MaterialStateProperty] values are used.
//
// See also:
//
//  * [IconButtonTheme], the theme which is configured with this class.
//  * [IconButton.styleFrom], which converts simple values into a
//    [ButtonStyle] that's consistent with [IconButton]'s defaults.
//  * [MaterialStateProperty.resolve], "resolve" a material state property
//    to a simple value based on a set of [MaterialState]s.
//  * [ThemeData.iconButtonTheme], which can be used to override the default
//    [ButtonStyle] for [IconButton]s below the overall [Theme].
message MaterialIconButtonThemeDataType {
  oneof constructor {
    MaterialIconButtonThemeData material_icon_button_theme_data = 2;
  }
}

// package:flutter/src/material/input_border.dart
//
// Defines the appearance of an [InputDecorator]'s border.
//
// An input decorator's border is specified by [InputDecoration.border].
//
// The border is drawn relative to the input decorator's "container" which
// is the optionally filled area above the decorator's helper, error,
// and counter.
//
// Input border's are decorated with a line whose weight and color are defined
// by [borderSide]. The input decorator's renderer animates the input border's
// appearance in response to state changes, like gaining or losing the focus,
// by creating new copies of its input border with [copyWith].
//
// See also:
//
//  * [UnderlineInputBorder], the default [InputDecorator] border which
//    draws a horizontal line at the bottom of the input decorator's container.
//  * [OutlineInputBorder], an [InputDecorator] border which draws a
//    rounded rectangle around the input decorator's container.
//  * [InputDecoration], which is used to configure an [InputDecorator].
message MaterialInputBorderType {
  oneof constructor {
    MaterialOutlineInputBorder material_outline_input_border = 2;
    MaterialUnderlineInputBorder material_underline_input_border = 3;
  }
}

// package:flutter/src/material/input_decorator.dart
//
// Defines the default appearance of [InputDecorator]s.
//
// This class is used to define the value of [ThemeData.inputDecorationTheme].
// The [InputDecorator], [TextField], and [TextFormField] widgets use
// the current input decoration theme to initialize null [InputDecoration]
// properties.
//
// The [InputDecoration.applyDefaults] method is used to combine a input
// decoration theme with an [InputDecoration] object.
message MaterialInputDecorationThemeType {
  oneof constructor {
    MaterialInputDecorationTheme material_input_decoration_theme = 2;
  }
}

// package:flutter/src/material/input_decorator.dart
//
// The border, labels, icons, and styles used to decorate a Material
// Design text field.
//
// The [TextField] and [InputDecorator] classes use [InputDecoration] objects
// to describe their decoration. (In fact, this class is merely the
// configuration of an [InputDecorator], which does all the heavy lifting.)
//
// {@tool dartpad}
// This sample shows how to style a `TextField` using an `InputDecorator`. The
// TextField displays a "send message" icon to the left of the input area,
// which is surrounded by a border an all sides. It displays the `hintText`
// inside the input area to help the user understand what input is required. It
// displays the `helperText` and `counterText` below the input area.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/material/input_decoration.png)
//
// ** See code in examples/api/lib/material/input_decorator/input_decoration.0.dart **
// {@end-tool}
//
// {@tool dartpad}
// This sample shows how to style a "collapsed" `TextField` using an
// `InputDecorator`. The collapsed `TextField` surrounds the hint text and
// input area with a border, but does not add padding around them.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/material/input_decoration_collapsed.png)
//
// ** See code in examples/api/lib/material/input_decorator/input_decoration.1.dart **
// {@end-tool}
//
// {@tool dartpad}
// This sample shows how to create a `TextField` with hint text, a red border
// on all sides, and an error message. To display a red border and error
// message, provide `errorText` to the [InputDecoration] constructor.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/material/input_decoration_error.png)
//
// ** See code in examples/api/lib/material/input_decorator/input_decoration.2.dart **
// {@end-tool}
//
// {@tool dartpad}
// This sample shows how to style a `TextField` with a round border and
// additional text before and after the input area. It displays "Prefix" before
// the input area, and "Suffix" after the input area.
//
// ![](https://flutter.github.io/assets-for-api-docs/assets/material/input_decoration_prefix_suffix.png)
//
// ** See code in examples/api/lib/material/input_decorator/input_decoration.3.dart **
// {@end-tool}
//
// {@tool dartpad}
// This sample shows how to style a `TextField` with a prefixIcon that changes color
// based on the `MaterialState`. The color defaults to gray, be blue while focused
// and red if in an error state.
//
// ** See code in examples/api/lib/material/input_decorator/input_decoration.material_state.0.dart **
// {@end-tool}
//
// {@tool dartpad}
// This sample shows how to style a `TextField` with a prefixIcon that changes color
// based on the `MaterialState` through the use of `ThemeData`. The color defaults
// to gray, be blue while focused and red if in an error state.
//
// ** See code in examples/api/lib/material/input_decorator/input_decoration.material_state.1.dart **
// {@end-tool}
//
// See also:
//
//  * [TextField], which is a text input widget that uses an
//    [InputDecoration].
//  * [InputDecorator], which is a widget that draws an [InputDecoration]
//    around an input child widget.
//  * [Decoration] and [DecoratedBox], for drawing borders and backgrounds
//    around a child widget.
message MaterialInputDecorationType {
  oneof constructor {
    MaterialInputDecoration material_input_decoration = 2;
    MaterialInputDecorationNamedCollapsed material_input_decoration_named_collapsed = 3;
  }
}

// package:flutter/src/material/list_tile_theme.dart
//
// Used with [ListTileTheme] to define default property values for
// descendant [ListTile] widgets, as well as classes that build
// [ListTile]s, like [CheckboxListTile], [RadioListTile], and
// [SwitchListTile].
//
// Descendant widgets obtain the current [ListTileThemeData] object
// using `ListTileTheme.of(context)`. Instances of
// [ListTileThemeData] can be customized with
// [ListTileThemeData.copyWith].
//
// A [ListTileThemeData] is often specified as part of the
// overall [Theme] with [ThemeData.listTileTheme].
//
// All [ListTileThemeData] properties are `null` by default.
// When a theme property is null, the [ListTile] will provide its own
// default based on the overall [Theme]'s textTheme and
// colorScheme. See the individual [ListTile] properties for details.
//
// The [Drawer] widget specifies a list tile theme for its children that
// defines [style] to be [ListTileStyle.drawer].
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialListTileThemeDataType {
  oneof constructor {
    MaterialListTileThemeData material_list_tile_theme_data = 2;
  }
}

// package:flutter/src/material/banner_theme.dart
//
// Defines the visual properties of [MaterialBanner] widgets.
//
// Descendant widgets obtain the current [MaterialBannerThemeData] object using
// `MaterialBannerTheme.of(context)`. Instances of [MaterialBannerThemeData]
// can be customized with [MaterialBannerThemeData.copyWith].
//
// Typically a [MaterialBannerThemeData] is specified as part of the overall
// [Theme] with [ThemeData.bannerTheme].
//
// All [MaterialBannerThemeData] properties are `null` by default. When null,
// the [MaterialBanner] will provide its own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialMaterialBannerThemeDataType {
  oneof constructor {
    MaterialMaterialBannerThemeData material_material_banner_theme_data = 2;
  }
}

// package:flutter/src/material/material_state.dart
//
// Manages a set of [MaterialState]s and notifies listeners of changes.
//
// Used by widgets that expose their internal state for the sake of
// extensions that add support for additional states. See
// [TextButton] for an example.
//
// The controller's [value] is its current set of states. Listeners
// are notified whenever the [value] changes. The [value] should only be
// changed with [update]; it should not be modified directly.
//
// The controller's [value] represents the set of states that a
// widget's visual properties, typically [MaterialStateProperty]
// values, are resolved against. It is _not_ the intrinsic state of
// the widget. The widget is responsible for ensuring that the
// controller's [value] tracks its intrinsic state. For example one
// cannot request the keyboard focus for a widget by adding
// [MaterialState.focused] to its controller. When the widget gains the
// or loses the focus it will [update] its controller's [value] and
// notify listeners of the change.
message MaterialMaterialStatesControllerType {
  oneof constructor {
    MaterialMaterialStatesController material_material_states_controller = 2;
  }
}

// package:flutter/src/material/menu_bar_theme.dart
//
// A data class that [MenuBarTheme] uses to define the visual properties of
// [MenuBar] widgets.
//
// This class defines the visual properties of [MenuBar] widgets themselves,
// but not their submenus. Those properties are defined by [MenuThemeData] or
// [MenuButtonThemeData] instead.
//
// Descendant widgets obtain the current [MenuBarThemeData] object using
// `MenuBarTheme.of(context)`.
//
// Typically, a [MenuBarThemeData] is specified as part of the overall [Theme]
// with [ThemeData.menuBarTheme]. Otherwise, [MenuTheme] can be used to
// configure its own widget subtree.
//
// All [MenuBarThemeData] properties are `null` by default. If any of these
// properties are null, the menu bar will provide its own defaults.
//
// See also:
//
// * [MenuThemeData], which describes the theme for the submenus of a
//   [MenuBar].
// * [MenuButtonThemeData], which describes the theme for the [MenuItemButton]s
//   in a menu.
// * [ThemeData], which describes the overall theme for the application.
message MaterialMenuBarThemeDataType {
  oneof constructor {
    MaterialMenuBarThemeData material_menu_bar_theme_data = 2;
  }
}

// package:flutter/src/material/menu_button_theme.dart
//
// A [ButtonStyle] theme that overrides the default appearance of
// [SubmenuButton]s and [MenuItemButton]s when it's used with a
// [MenuButtonTheme] or with the overall [Theme]'s [ThemeData.menuTheme].
//
// The [style]'s properties override [MenuItemButton]'s and [SubmenuButton]'s
// default style, i.e. the [ButtonStyle] returned by
// [MenuItemButton.defaultStyleOf] and [SubmenuButton.defaultStyleOf]. Only the
// style's non-null property values or resolved non-null
// [MaterialStateProperty] values are used.
//
// See also:
//
// * [MenuButtonTheme], the theme which is configured with this class.
// * [MenuTheme], the theme used to configure the look of the menus these
//   buttons reside in.
// * [MenuItemButton.defaultStyleOf] and [SubmenuButton.defaultStyleOf] which
//   return the default [ButtonStyle]s for menu buttons.
// * [MenuItemButton.styleFrom] and [SubmenuButton.styleFrom], which converts
//   simple values into a [ButtonStyle] that's consistent with their respective
//   defaults.
// * [MaterialStateProperty.resolve], "resolve" a material state property to a
//   simple value based on a set of [MaterialState]s.
// * [ThemeData.menuButtonTheme], which can be used to override the default
//   [ButtonStyle] for [MenuItemButton]s and [SubmenuButton]s below the overall
//   [Theme].
// * [MenuAnchor], a widget which hosts cascading menus.
// * [MenuBar], a widget which defines a menu bar of buttons hosting cascading
//   menus.
message MaterialMenuButtonThemeDataType {
  oneof constructor {
    MaterialMenuButtonThemeData material_menu_button_theme_data = 2;
  }
}

// package:flutter/src/material/menu_anchor.dart
//
// A controller to manage a menu created by a [MenuBar] or [MenuAnchor].
//
// A [MenuController] is used to control and interrogate a menu after it has
// been created, with methods such as [open] and [close], and state accessors
// like [isOpen].
//
// See also:
//
// * [MenuAnchor], a widget that defines a region that has submenu.
// * [MenuBar], a widget that creates a menu bar, that can take an optional
//   [MenuController].
// * [SubmenuButton], a widget that has a button that manages a submenu.
message MaterialMenuControllerType {
  oneof constructor {
    MaterialMenuController material_menu_controller = 2;
  }
}

// package:flutter/src/material/menu_style.dart
//
// The visual properties that menus have in common.
//
// Menus created by [MenuBar] and [MenuAnchor] and their themes have a
// [MenuStyle] property which defines the visual properties whose default
// values are to be overridden. The default values are defined by the
// individual menu widgets and are typically based on overall theme's
// [ThemeData.colorScheme] and [ThemeData.textTheme].
//
// All of the [MenuStyle] properties are null by default.
//
// Many of the [MenuStyle] properties are [MaterialStateProperty] objects which
// resolve to different values depending on the menu's state. For example the
// [Color] properties are defined with `MaterialStateProperty<Color>` and can
// resolve to different colors depending on if the menu is pressed, hovered,
// focused, disabled, etc.
//
// These properties can override the default value for just one state or all of
// them. For example to create a [SubmenuButton] whose background color is the
// color schemes primary color with 50% opacity, but only when the menu is
// pressed, one could write:
//
// ```dart
// SubmenuButton(
//   menuStyle: MenuStyle(
//     backgroundColor: MaterialStateProperty.resolveWith<Color?>(
//       (Set<MaterialState> states) {
//         if (states.contains(MaterialState.focused)) {
//           return Theme.of(context).colorScheme.primary.withOpacity(0.5);
//         }
//         return null; // Use the component's default.
//       },
//     ),
//   ),
//   menuChildren: const <Widget>[ /* ... */ ],
//   child: const Text('Fly me to the moon'),
// ),
// ```
//
// In this case the background color for all other menu states would fall back
// to the [SubmenuButton]'s default values. To unconditionally set the menu's
// [backgroundColor] for all states one could write:
//
// ```dart
// const SubmenuButton(
//   menuStyle: MenuStyle(
//     backgroundColor: MaterialStatePropertyAll<Color>(Colors.green),
//   ),
//   menuChildren: <Widget>[ /* ... */ ],
//   child: Text('Let me play among the stars'),
// ),
// ```
//
// To configure all of the application's menus in the same way, specify the
// overall theme's `menuTheme`:
//
// ```dart
// MaterialApp(
//   theme: ThemeData(
//     menuTheme: const MenuThemeData(
//       style: MenuStyle(backgroundColor: MaterialStatePropertyAll<Color>(Colors.red)),
//     ),
//   ),
//   home: const MyAppHome(),
// ),
// ```
//
// See also:
//
// * [MenuAnchor], a widget which hosts cascading menus.
// * [MenuBar], a widget which defines a menu bar of buttons hosting cascading
//   menus.
// * [MenuButtonTheme], the theme for [SubmenuButton]s and [MenuItemButton]s.
// * [ButtonStyle], a similar configuration object for button styles.
message MaterialMenuStyleType {
  oneof constructor {
    MaterialMenuStyle material_menu_style = 2;
  }
}

// package:flutter/src/material/menu_theme.dart
//
// Defines the configuration of the submenus created by the [SubmenuButton],
// [MenuBar], or [MenuAnchor] widgets.
//
// Descendant widgets obtain the current [MenuThemeData] object using
// `MenuTheme.of(context)`.
//
// Typically, a [MenuThemeData] is specified as part of the overall [Theme]
// with [ThemeData.menuTheme]. Otherwise, [MenuTheme] can be used to configure
// its own widget subtree.
//
// All [MenuThemeData] properties are `null` by default. If any of these
// properties are null, the menu bar will provide its own defaults.
//
// See also:
//
// * [ThemeData], which describes the overall theme for the application.
// * [MenuBarThemeData], which describes the theme for the menu bar itself in a
//   [MenuBar] widget.
message MaterialMenuThemeDataType {
  oneof constructor {
    MaterialMenuBarThemeData material_menu_bar_theme_data = 2;
    MaterialMenuThemeData material_menu_theme_data = 3;
  }
}

// package:flutter/src/material/mergeable_material.dart
//
// The base type for [MaterialSlice] and [MaterialGap].
//
// All [MergeableMaterialItem] objects need a [LocalKey].
message MaterialMergeableMaterialItemType {
  oneof constructor {
    MaterialMaterialGap material_material_gap = 2;
    MaterialMaterialSlice material_material_slice = 3;
  }
}

// package:flutter/src/material/navigation_bar_theme.dart
//
// Defines default property values for descendant [NavigationBar]
// widgets.
//
// Descendant widgets obtain the current [NavigationBarThemeData] object
// using `NavigationBarTheme.of(context)`. Instances of
// [NavigationBarThemeData] can be customized with
// [NavigationBarThemeData.copyWith].
//
// Typically a [NavigationBarThemeData] is specified as part of the
// overall [Theme] with [ThemeData.navigationBarTheme]. Alternatively, a
// [NavigationBarTheme] inherited widget can be used to theme [NavigationBar]s
// in a subtree of widgets.
//
// All [NavigationBarThemeData] properties are `null` by default.
// When null, the [NavigationBar] will provide its own defaults based on the
// overall [Theme]'s textTheme and colorScheme. See the individual
// [NavigationBar] properties for details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialNavigationBarThemeDataType {
  oneof constructor {
    MaterialNavigationBarThemeData material_navigation_bar_theme_data = 2;
  }
}

// package:flutter/src/material/navigation_drawer_theme.dart
//
// Defines default property values for descendant [NavigationDrawer]
// widgets.
//
// Descendant widgets obtain the current [NavigationDrawerThemeData] object
// using `NavigationDrawerTheme.of(context)`. Instances of
// [NavigationDrawerThemeData] can be customized with
// [NavigationDrawerThemeData.copyWith].
//
// Typically a [NavigationDrawerThemeData] is specified as part of the
// overall [Theme] with [ThemeData.navigationDrawerTheme]. Alternatively, a
// [NavigationDrawerTheme] inherited widget can be used to theme [NavigationDrawer]s
// in a subtree of widgets.
//
// All [NavigationDrawerThemeData] properties are `null` by default.
// When null, the [NavigationDrawer] will provide its own defaults based on the
// overall [Theme]'s textTheme and colorScheme. See the individual
// [NavigationDrawer] properties for details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialNavigationDrawerThemeDataType {
  oneof constructor {
    MaterialNavigationDrawerThemeData material_navigation_drawer_theme_data = 2;
  }
}

// package:flutter/src/material/navigation_rail.dart
//
// Defines a [NavigationRail] button that represents one "destination" view.
//
// See also:
//
//  * [NavigationRail]
message MaterialNavigationRailDestinationType {
  oneof constructor {
    MaterialNavigationRailDestination material_navigation_rail_destination = 2;
  }
}

// package:flutter/src/material/navigation_rail_theme.dart
//
// Defines default property values for descendant [NavigationRail]
// widgets.
//
// Descendant widgets obtain the current [NavigationRailThemeData] object
// using `NavigationRailTheme.of(context)`. Instances of
// [NavigationRailThemeData] can be customized with
// [NavigationRailThemeData.copyWith].
//
// Typically a [NavigationRailThemeData] is specified as part of the
// overall [Theme] with [ThemeData.navigationRailTheme].
//
// All [NavigationRailThemeData] properties are `null` by default.
// When null, the [NavigationRail] will use the values from [ThemeData]
// if they exist, otherwise it will provide its own defaults based on the
// overall [Theme]'s textTheme and colorScheme. See the individual
// [NavigationRail] properties for details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialNavigationRailThemeDataType {
  oneof constructor {
    MaterialNavigationRailThemeData material_navigation_rail_theme_data = 2;
  }
}

// package:flutter/src/material/outlined_button_theme.dart
//
// A [ButtonStyle] that overrides the default appearance of
// [OutlinedButton]s when it's used with [OutlinedButtonTheme] or with the
// overall [Theme]'s [ThemeData.outlinedButtonTheme].
//
// The [style]'s properties override [OutlinedButton]'s default style,
// i.e. the [ButtonStyle] returned by [OutlinedButton.defaultStyleOf]. Only
// the style's non-null property values or resolved non-null
// [MaterialStateProperty] values are used.
//
// See also:
//
//  * [OutlinedButtonTheme], the theme which is configured with this class.
//  * [OutlinedButton.defaultStyleOf], which returns the default [ButtonStyle]
//    for outlined buttons.
//  * [OutlinedButton.styleFrom], which converts simple values into a
//    [ButtonStyle] that's consistent with [OutlinedButton]'s defaults.
//  * [MaterialStateProperty.resolve], "resolve" a material state property
//    to a simple value based on a set of [MaterialState]s.
//  * [ThemeData.outlinedButtonTheme], which can be used to override the default
//    [ButtonStyle] for [OutlinedButton]s below the overall [Theme].
message MaterialOutlinedButtonThemeDataType {
  oneof constructor {
    MaterialOutlinedButtonThemeData material_outlined_button_theme_data = 2;
  }
}

// package:flutter/src/material/page_transitions_theme.dart
//
// Defines the page transition animations used by [MaterialPageRoute]
// for different [TargetPlatform]s.
//
// The [MaterialPageRoute.buildTransitions] method looks up the
// current [PageTransitionsTheme] with `Theme.of(context).pageTransitionsTheme`
// and delegates to [buildTransitions].
//
// If a builder with a matching platform is not found, then the
// [ZoomPageTransitionsBuilder] is used.
//
// {@tool dartpad}
// This example shows a [MaterialApp] that defines a custom [PageTransitionsTheme].
//
// ** See code in examples/api/lib/material/page_transitions_theme/page_transitions_theme.0.dart **
// {@end-tool}
//
// See also:
//
//  * [ThemeData.pageTransitionsTheme], which defines the default page
//    transitions for the overall theme.
//  * [FadeUpwardsPageTransitionsBuilder], which defines a page transition
//    that's similar to the one provided by Android O.
//  * [OpenUpwardsPageTransitionsBuilder], which defines a page transition
//    that's similar to the one provided by Android P.
//  * [ZoomPageTransitionsBuilder], which defines the default page transition
//    that's similar to the one provided by Android Q.
//  * [CupertinoPageTransitionsBuilder], which defines a horizontal page
//    transition that matches native iOS page transitions.
message MaterialPageTransitionsThemeType {
  oneof constructor {
    MaterialPageTransitionsTheme material_page_transitions_theme = 2;
  }
}

// package:flutter/src/material/popup_menu_theme.dart
//
// Defines the visual properties of the routes used to display popup menus
// as well as [PopupMenuItem] and [PopupMenuDivider] widgets.
//
// Descendant widgets obtain the current [PopupMenuThemeData] object
// using `PopupMenuTheme.of(context)`. Instances of
// [PopupMenuThemeData] can be customized with
// [PopupMenuThemeData.copyWith].
//
// Typically, a [PopupMenuThemeData] is specified as part of the
// overall [Theme] with [ThemeData.popupMenuTheme]. Otherwise,
// [PopupMenuTheme] can be used to configure its own widget subtree.
//
// All [PopupMenuThemeData] properties are `null` by default.
// If any of these properties are null, the popup menu will provide its
// own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialPopupMenuThemeDataType {
  oneof constructor {
    MaterialPopupMenuThemeData material_popup_menu_theme_data = 2;
  }
}

// package:flutter/src/material/progress_indicator_theme.dart
//
// Defines the visual properties of [ProgressIndicator] widgets.
//
// Used by [ProgressIndicatorTheme] to control the visual properties of
// progress indicators in a widget subtree.
//
// To obtain this configuration, use [ProgressIndicatorTheme.of] to access
// the closest ancestor [ProgressIndicatorTheme] of the current [BuildContext].
//
// See also:
//
//  * [ProgressIndicatorTheme], an [InheritedWidget] that propagates the
//    theme down its subtree.
//  * [ThemeData.progressIndicatorTheme], which describes the defaults for
//    any progress indicators as part of the application's [ThemeData].
message MaterialProgressIndicatorThemeDataType {
  oneof constructor {
    MaterialProgressIndicatorThemeData material_progress_indicator_theme_data = 2;
  }
}

// package:flutter/src/material/radio_theme.dart
//
// Defines default property values for descendant [Radio] widgets.
//
// Descendant widgets obtain the current [RadioThemeData] object using
// `RadioTheme.of(context)`. Instances of [RadioThemeData] can be customized
// with [RadioThemeData.copyWith].
//
// Typically a [RadioThemeData] is specified as part of the overall [Theme]
// with [ThemeData.radioTheme].
//
// All [RadioThemeData] properties are `null` by default. When null, the
// [Radio] will use the values from [ThemeData] if they exist, otherwise it
// will provide its own defaults based on the overall [Theme]'s colorScheme.
// See the individual [Radio] properties for details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
//  * [RadioTheme], which is used by descendants to obtain the
//    [RadioThemeData].
message MaterialRadioThemeDataType {
  oneof constructor {
    MaterialRadioThemeData material_radio_theme_data = 2;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Object for setting range slider label values that appear in the value
// indicator for each thumb.
//
// Used in combination with [SliderThemeData.showValueIndicator] to display
// labels above the thumbs.
message MaterialRangeLabelsType {
  oneof constructor {
    MaterialRangeLabels material_range_labels = 2;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Base class for [RangeSlider] thumb shapes.
//
// See also:
//
//  * [RoundRangeSliderThumbShape] for the default [RangeSlider]'s thumb shape
//    that paints a solid circle.
//  * [RangeSliderTickMarkShape], which can be used to create custom shapes for
//    the [RangeSlider]'s tick marks.
//  * [RangeSliderTrackShape], which can be used to create custom shapes for
//    the [RangeSlider]'s track.
//  * [RangeSliderValueIndicatorShape], which can be used to create custom
//    shapes for the [RangeSlider]'s value indicator.
//  * [SliderComponentShape], which can be used to create custom shapes for
//    the [Slider]'s thumb, overlay, and value indicator and the
//    [RangeSlider]'s overlay.
message MaterialRangeSliderThumbShapeType {
  oneof constructor {
    MaterialRoundRangeSliderThumbShape material_round_range_slider_thumb_shape = 2;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Base class for [RangeSlider] tick mark shapes.
//
// This is a simplified version of [SliderComponentShape] with a
// [SliderThemeData] passed when getting the preferred size.
//
// See also:
//
//  * [RoundRangeSliderTickMarkShape] for the default [RangeSlider]'s tick mark
//    shape that paints a solid circle.
//  * [RangeSliderThumbShape], which can be used to create custom shapes for
//    the [RangeSlider]'s thumb.
//  * [RangeSliderTrackShape], which can be used to create custom shapes for
//    the [RangeSlider]'s track.
//  * [RangeSliderValueIndicatorShape], which can be used to create custom
//    shapes for the [RangeSlider]'s value indicator.
//  * [SliderComponentShape], which can be used to create custom shapes for
//    the [Slider]'s thumb, overlay, and value indicator and the
//    [RangeSlider]'s overlay.
message MaterialRangeSliderTickMarkShapeType {
  oneof constructor {
    MaterialRoundRangeSliderTickMarkShape material_round_range_slider_tick_mark_shape = 2;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Base class for [RangeSlider] track shapes.
//
// The slider's thumbs move along the track. A discrete slider's tick marks
// are drawn after the track, but before the thumb, and are aligned with the
// track.
//
// The [getPreferredRect] helps position the slider thumbs and tick marks
// relative to the track.
//
// See also:
//
//  * [RoundedRectRangeSliderTrackShape] for the default [RangeSlider]'s track
//    shape that paints a stadium-like track.
//  * [RangeSliderTickMarkShape], which can be used to create custom shapes for
//    the [RangeSlider]'s tick marks.
//  * [RangeSliderThumbShape], which can be used to create custom shapes for
//    the [RangeSlider]'s thumb.
//  * [RangeSliderValueIndicatorShape], which can be used to create custom
//    shapes for the [RangeSlider]'s value indicator.
//  * [SliderComponentShape], which can be used to create custom shapes for
//    the [Slider]'s thumb, overlay, and value indicator and the
//    [RangeSlider]'s overlay.
message MaterialRangeSliderTrackShapeType {
  oneof constructor {
    MaterialRectangularRangeSliderTrackShape material_rectangular_range_slider_track_shape = 2;
    MaterialRoundedRectRangeSliderTrackShape material_rounded_rect_range_slider_track_shape = 3;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Base class for [RangeSlider] value indicator shapes.
//
// See also:
//
//  * [PaddleRangeSliderValueIndicatorShape] for the default [RangeSlider]'s
//    value indicator shape that paints a custom path with text in it.
//  * [RangeSliderTickMarkShape], which can be used to create custom shapes for
//    the [RangeSlider]'s tick marks.
//  * [RangeSliderThumbShape], which can be used to create custom shapes for
//    the [RangeSlider]'s thumb.
//  * [RangeSliderTrackShape], which can be used to create custom shapes for
//    the [RangeSlider]'s track.
//  * [SliderComponentShape], which can be used to create custom shapes for
//    the [Slider]'s thumb, overlay, and value indicator and the
//    [RangeSlider]'s overlay.
message MaterialRangeSliderValueIndicatorShapeType {
  oneof constructor {
    MaterialPaddleRangeSliderValueIndicatorShape material_paddle_range_slider_value_indicator_shape = 2;
    MaterialRectangularRangeSliderValueIndicatorShape material_rectangular_range_slider_value_indicator_shape = 3;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Object for representing range slider thumb values.
//
// This object is passed into [RangeSlider.values] to set its values, and it
// is emitted in [RangeSlider.onChanged], [RangeSlider.onChangeStart], and
// [RangeSlider.onChangeEnd] when the values change.
message MaterialRangeValuesType {
  oneof constructor {
    MaterialRangeValues material_range_values = 2;
  }
}

// package:flutter/src/material/scrollbar_theme.dart
//
// Defines default property values for descendant [Scrollbar] widgets.
//
// Descendant widgets obtain the current [ScrollbarThemeData] object with
// `ScrollbarTheme.of(context)`. Instances of [ScrollbarThemeData] can be
// customized with [ScrollbarThemeData.copyWith].
//
// Typically the [ScrollbarThemeData] of a [ScrollbarTheme] is specified as
// part of the overall [Theme] with [ThemeData.scrollbarTheme].
//
// All [ScrollbarThemeData] properties are `null` by default. When null, the
// [Scrollbar] computes its own default values, typically based on the overall
// theme's [ThemeData.colorScheme].
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialScrollbarThemeDataType {
  oneof constructor {
    MaterialScrollbarThemeData material_scrollbar_theme_data = 2;
  }
}

// package:flutter/src/material/search_bar_theme.dart
//
// Defines default property values for descendant [SearchBar] widgets.
//
// Descendant widgets obtain the current [SearchBarThemeData] object using
// `SearchBarTheme.of(context)`. Instances of [SearchBarThemeData] can be customized
// with [SearchBarThemeData.copyWith].
//
// Typically a [SearchBarThemeData] is specified as part of the overall [Theme]
// with [ThemeData.searchBarTheme].
//
// All [SearchBarThemeData] properties are `null` by default. When null, the
// [SearchBar] will use the values from [ThemeData] if they exist, otherwise it
// will provide its own defaults based on the overall [Theme]'s colorScheme.
// See the individual [SearchBar] properties for details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialSearchBarThemeDataType {
  oneof constructor {
    MaterialSearchBarThemeData material_search_bar_theme_data = 2;
  }
}

// package:flutter/src/material/search_view_theme.dart
//
// Defines the configuration of the search views created by the [SearchAnchor]
// widget.
//
// Descendant widgets obtain the current [SearchViewThemeData] object using
// `SearchViewTheme.of(context)`.
//
// Typically, a [SearchViewThemeData] is specified as part of the overall [Theme]
// with [ThemeData.searchViewTheme]. Otherwise, [SearchViewTheme] can be used
// to configure its own widget subtree.
//
// All [SearchViewThemeData] properties are `null` by default. If any of these
// properties are null, the search view will provide its own defaults.
//
// See also:
//
// * [ThemeData], which describes the overall theme for the application.
// * [SearchBarThemeData], which describes the theme for the search bar itself in a
//   [SearchBar] widget.
// * [SearchAnchor], which is used to open a search view route.
message MaterialSearchViewThemeDataType {
  oneof constructor {
    MaterialSearchViewThemeData material_search_view_theme_data = 2;
  }
}

// package:flutter/src/material/segmented_button_theme.dart
//
// Overrides the default values of visual properties for descendant
// [SegmentedButton] widgets.
//
// Descendant widgets obtain the current [SegmentedButtonThemeData] object with
// [SegmentedButtonTheme.of]. Instances of [SegmentedButtonTheme] can
// be customized with [SegmentedButtonThemeData.copyWith].
//
// Typically a [SegmentedButtonTheme] is specified as part of the overall
// [Theme] with [ThemeData.segmentedButtonTheme].
//
// All [SegmentedButtonThemeData] properties are null by default. When null,
// the [SegmentedButton] computes its own default values, typically based on
// the overall theme's [ThemeData.colorScheme], [ThemeData.textTheme], and
// [ThemeData.iconTheme].
message MaterialSegmentedButtonThemeDataType {
  oneof constructor {
    MaterialSegmentedButtonThemeData material_segmented_button_theme_data = 2;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Base class for slider thumb, thumb overlay, and value indicator shapes.
//
// Create a subclass of this if you would like a custom shape.
//
// All shapes are painted to the same canvas and ordering is important.
// The overlay is painted first, then the value indicator, then the thumb.
//
// The thumb painting can be skipped by specifying [noThumb] for
// [SliderThemeData.thumbShape].
//
// The overlay painting can be skipped by specifying [noOverlay] for
// [SliderThemeData.overlayShape].
//
// See also:
//
//  * [RoundSliderThumbShape], which is the default [Slider]'s thumb shape that
//    paints a solid circle.
//  * [RoundSliderOverlayShape], which is the default [Slider] and
//    [RangeSlider]'s overlay shape that paints a transparent circle.
//  * [PaddleSliderValueIndicatorShape], which is the default [Slider]'s value
//    indicator shape that paints a custom path with text in it.
message MaterialSliderComponentShapeType {
  oneof constructor {
    MaterialDropSliderValueIndicatorShape material_drop_slider_value_indicator_shape = 2;
    MaterialPaddleSliderValueIndicatorShape material_paddle_slider_value_indicator_shape = 3;
    MaterialRectangularSliderValueIndicatorShape material_rectangular_slider_value_indicator_shape = 4;
    MaterialRoundSliderOverlayShape material_round_slider_overlay_shape = 5;
    MaterialRoundSliderThumbShape material_round_slider_thumb_shape = 6;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Holds the color, shape, and typography values for a Material Design slider
// theme.
//
// Use this class to configure a [SliderTheme] widget, or to set the
// [ThemeData.sliderTheme] for a [Theme] widget.
//
// To obtain the current ambient slider theme, use [SliderTheme.of].
//
// This theme is for both the [Slider] and the [RangeSlider]. The properties
// that are only for the [Slider] are: [tickMarkShape], [thumbShape],
// [trackShape], and [valueIndicatorShape]. The properties that are only for
// the [RangeSlider] are [rangeTickMarkShape], [rangeThumbShape],
// [rangeTrackShape], [rangeValueIndicatorShape],
// [overlappingShapeStrokeColor], [minThumbSeparation], and [thumbSelector].
// All other properties are used by both the [Slider] and the [RangeSlider].
//
// The parts of a slider are:
//
//  * The "thumb", which is a shape that slides horizontally when the user
//    drags it.
//  * The "track", which is the line that the slider thumb slides along.
//  * The "tick marks", which are regularly spaced marks that are drawn when
//    using discrete divisions.
//  * The "value indicator", which appears when the user is dragging the thumb
//    to indicate the value being selected.
//  * The "overlay", which appears around the thumb, and is shown when the
//    thumb is pressed, focused, or hovered. It is painted underneath the
//    thumb, so it must extend beyond the bounds of the thumb itself to
//    actually be visible.
//  * The "active" side of the slider is the side between the thumb and the
//    minimum value.
//  * The "inactive" side of the slider is the side between the thumb and the
//    maximum value.
//  * The [Slider] is disabled when it is not accepting user input. See
//    [Slider] for details on when this happens.
//
// The thumb, track, tick marks, value indicator, and overlay can be customized
// by creating subclasses of [SliderTrackShape],
// [SliderComponentShape], and/or [SliderTickMarkShape]. See
// [RoundSliderThumbShape], [RectangularSliderTrackShape],
// [RoundSliderTickMarkShape], [RectangularSliderValueIndicatorShape], and
// [RoundSliderOverlayShape] for examples.
//
// The track painting can be skipped by specifying 0 for [trackHeight].
// The thumb painting can be skipped by specifying
// [SliderComponentShape.noThumb] for [SliderThemeData.thumbShape].
// The overlay painting can be skipped by specifying
// [SliderComponentShape.noOverlay] for [SliderThemeData.overlayShape].
// The tick mark painting can be skipped by specifying
// [SliderTickMarkShape.noTickMark] for [SliderThemeData.tickMarkShape].
// The value indicator painting can be skipped by specifying the
// appropriate [ShowValueIndicator] for [SliderThemeData.showValueIndicator].
//
// See also:
//
//  * [SliderTheme] widget, which can override the slider theme of its
//    children.
//  * [Theme] widget, which performs a similar function to [SliderTheme],
//    but for overall themes.
//  * [ThemeData], which has a default [SliderThemeData].
//  * [SliderComponentShape], which can be used to create custom shapes for
//    the [Slider]'s thumb, overlay, and value indicator and the
//    [RangeSlider]'s overlay.
//  * [SliderTrackShape], which can be used to create custom shapes for the
//    [Slider]'s track.
//  * [SliderTickMarkShape], which can be used to create custom shapes for the
//    [Slider]'s tick marks.
//  * [RangeSliderThumbShape], which can be used to create custom shapes for
//    the [RangeSlider]'s thumb.
//  * [RangeSliderValueIndicatorShape], which can be used to create custom
//    shapes for the [RangeSlider]'s value indicator.
//  * [RangeSliderTrackShape], which can be used to create custom shapes for
//    the [RangeSlider]'s track.
//  * [RangeSliderTickMarkShape], which can be used to create custom shapes for
//    the [RangeSlider]'s tick marks.
message MaterialSliderThemeDataType {
  oneof constructor {
    MaterialSliderThemeData material_slider_theme_data = 2;
    MaterialSliderThemeDataNamedFromPrimaryColors material_slider_theme_data_named_from_primary_colors = 3;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Base class for [Slider] tick mark shapes.
//
// Create a subclass of this if you would like a custom slider tick mark shape.
//
// The tick mark painting can be skipped by specifying [noTickMark] for
// [SliderThemeData.tickMarkShape].
//
// See also:
//
//  * [RoundSliderTickMarkShape], which is the default [Slider]'s tick mark
//    shape that paints a solid circle.
//  * [SliderTrackShape], which can be used to create custom shapes for the
//    [Slider]'s track.
//  * [SliderComponentShape], which can be used to create custom shapes for
//    the [Slider]'s thumb, overlay, and value indicator and the
//    [RangeSlider]'s overlay.
message MaterialSliderTickMarkShapeType {
  oneof constructor {
    MaterialRoundSliderTickMarkShape material_round_slider_tick_mark_shape = 2;
  }
}

// package:flutter/src/material/slider_theme.dart
//
// Base class for slider track shapes.
//
// The slider's thumb moves along the track. A discrete slider's tick marks
// are drawn after the track, but before the thumb, and are aligned with the
// track.
//
// The [getPreferredRect] helps position the slider thumb and tick marks
// relative to the track.
//
// See also:
//
//  * [RoundedRectSliderTrackShape] for the default [Slider]'s track shape that
//    paints a stadium-like track.
//  * [SliderTickMarkShape], which can be used to create custom shapes for the
//    [Slider]'s tick marks.
//  * [SliderComponentShape], which can be used to create custom shapes for
//    the [Slider]'s thumb, overlay, and value indicator and the
//    [RangeSlider]'s overlay.
message MaterialSliderTrackShapeType {
  oneof constructor {
    MaterialRectangularSliderTrackShape material_rectangular_slider_track_shape = 2;
    MaterialRoundedRectSliderTrackShape material_rounded_rect_slider_track_shape = 3;
  }
}

// package:flutter/src/material/snack_bar_theme.dart
//
// Customizes default property values for [SnackBar] widgets.
//
// Descendant widgets obtain the current [SnackBarThemeData] object using
// `Theme.of(context).snackBarTheme`. Instances of [SnackBarThemeData] can be
// customized with [SnackBarThemeData.copyWith].
//
// Typically a [SnackBarThemeData] is specified as part of the overall [Theme]
// with [ThemeData.snackBarTheme]. The default for [ThemeData.snackBarTheme]
// provides all `null` properties.
//
// All [SnackBarThemeData] properties are `null` by default. When null, the
// [SnackBar] will provide its own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialSnackBarThemeDataType {
  oneof constructor {
    MaterialSnackBarThemeData material_snack_bar_theme_data = 2;
  }
}

// package:flutter/src/material/stepper.dart
//
// A material step used in [Stepper]. The step can have a title and subtitle,
// an icon within its circle, some content and a state that governs its
// styling.
//
// See also:
//
//  * [Stepper]
//  * <https://material.io/archive/guidelines/components/steppers.html>
message MaterialStepType {
  oneof constructor {
    MaterialStep material_step = 2;
  }
}

// package:flutter/src/material/switch_theme.dart
//
// Defines default property values for descendant [Switch] widgets.
//
// Descendant widgets obtain the current [SwitchThemeData] object using
// `SwitchTheme.of(context)`. Instances of [SwitchThemeData] can be customized
// with [SwitchThemeData.copyWith].
//
// Typically a [SwitchThemeData] is specified as part of the overall [Theme]
// with [ThemeData.switchTheme].
//
// All [SwitchThemeData] properties are `null` by default. When null, the
// [Switch] will use the values from [ThemeData] if they exist, otherwise it
// will provide its own defaults based on the overall [Theme]'s colorScheme.
// See the individual [Switch] properties for details.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialSwitchThemeDataType {
  oneof constructor {
    MaterialSwitchThemeData material_switch_theme_data = 2;
  }
}

// package:flutter/src/material/tab_bar_theme.dart
//
// Defines a theme for [TabBar] widgets.
//
// A tab bar theme describes the color of the tab label and the size/shape of
// the [TabBar.indicator].
//
// Descendant widgets obtain the current theme's [TabBarTheme] object using
// `TabBarTheme.of(context)`. Instances of [TabBarTheme] can be customized with
// [TabBarTheme.copyWith].
//
// See also:
//
//  * [TabBar], a widget that displays a horizontal row of tabs.
//  * [ThemeData], which describes the overall theme information for the
//    application.
message MaterialTabBarThemeType {
  oneof constructor {
    MaterialTabBarTheme material_tab_bar_theme = 2;
  }
}

// package:flutter/src/material/tab_controller.dart
//
// Coordinates tab selection between a [TabBar] and a [TabBarView].
//
// The [index] property is the index of the selected tab and the [animation]
// represents the current scroll positions of the tab bar and the tab bar view.
// The selected tab's index can be changed with [animateTo].
//
// A stateful widget that builds a [TabBar] or a [TabBarView] can create
// a [TabController] and share it directly.
//
// When the [TabBar] and [TabBarView] don't have a convenient stateful
// ancestor, a [TabController] can be shared by providing a
// [DefaultTabController] inherited widget.
//
// {@animation 700 540 https://flutter.github.io/assets-for-api-docs/assets/material/tabs.mp4}
//
// {@tool snippet}
//
// This widget introduces a [Scaffold] with an [AppBar] and a [TabBar].
//
// ```dart
// class MyTabbedPage extends StatefulWidget {
//   const MyTabbedPage({ super.key });
//   @override
//   State<MyTabbedPage> createState() => _MyTabbedPageState();
// }
//
// class _MyTabbedPageState extends State<MyTabbedPage> with SingleTickerProviderStateMixin {
//   static const List<Tab> myTabs = <Tab>[
//     Tab(text: 'LEFT'),
//     Tab(text: 'RIGHT'),
//   ];
//
//   late TabController _tabController;
//
//   @override
//   void initState() {
//     super.initState();
//     _tabController = TabController(vsync: this, length: myTabs.length);
//   }
//
//  @override
//  void dispose() {
//    _tabController.dispose();
//    super.dispose();
//  }
//
//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       appBar: AppBar(
//         bottom: TabBar(
//           controller: _tabController,
//           tabs: myTabs,
//         ),
//       ),
//       body: TabBarView(
//         controller: _tabController,
//         children: myTabs.map((Tab tab) {
//           final String label = tab.text!.toLowerCase();
//           return Center(
//             child: Text(
//               'This is the $label tab',
//               style: const TextStyle(fontSize: 36),
//             ),
//           );
//         }).toList(),
//       ),
//     );
//   }
// }
// ```
// {@end-tool}
//
// {@tool dartpad}
// This example shows how to listen to page updates in [TabBar] and [TabBarView]
// when using [DefaultTabController].
//
// ** See code in examples/api/lib/material/tab_controller/tab_controller.1.dart **
// {@end-tool}
//
message MaterialTabControllerType {
  oneof constructor {
    MaterialTabController material_tab_controller = 2;
  }
}

// package:flutter/src/material/text_button_theme.dart
//
// A [ButtonStyle] that overrides the default appearance of
// [TextButton]s when it's used with [TextButtonTheme] or with the
// overall [Theme]'s [ThemeData.textButtonTheme].
//
// The [style]'s properties override [TextButton]'s default style,
// i.e. the [ButtonStyle] returned by [TextButton.defaultStyleOf]. Only
// the style's non-null property values or resolved non-null
// [MaterialStateProperty] values are used.
//
// See also:
//
//  * [TextButtonTheme], the theme which is configured with this class.
//  * [TextButton.defaultStyleOf], which returns the default [ButtonStyle]
//    for text buttons.
//  * [TextButton.styleFrom], which converts simple values into a
//    [ButtonStyle] that's consistent with [TextButton]'s defaults.
//  * [MaterialStateProperty.resolve], "resolve" a material state property
//    to a simple value based on a set of [MaterialState]s.
//  * [ThemeData.textButtonTheme], which can be used to override the default
//    [ButtonStyle] for [TextButton]s below the overall [Theme].
message MaterialTextButtonThemeDataType {
  oneof constructor {
    MaterialTextButtonThemeData material_text_button_theme_data = 2;
  }
}

// package:flutter/src/material/text_selection_theme.dart
//
// Defines the visual properties needed for text selection in [TextField] and
// [SelectableText] widgets.
//
// Used by [TextSelectionTheme] to control the visual properties of text
// selection in a widget subtree.
//
// Use [TextSelectionTheme.of] to access the closest ancestor
// [TextSelectionTheme] of the current [BuildContext].
//
// See also:
//
//  * [TextSelectionTheme], an [InheritedWidget] that propagates the theme down its
//    subtree.
//  * [InputDecorationTheme], which defines most other visual properties of
//    text fields.
message MaterialTextSelectionThemeDataType {
  oneof constructor {
    MaterialTextSelectionThemeData material_text_selection_theme_data = 2;
  }
}

// package:flutter/src/material/text_theme.dart
//
// Material design text theme.
//
// Definitions for the various typographical styles found in Material Design
// (e.g., labelLarge, bodySmall). Rather than creating a [TextTheme] directly,
// you can obtain an instance as [Typography.black] or [Typography.white].
//
// To obtain the current text theme, call [Theme.of] with the current
// [BuildContext] and read the [ThemeData.textTheme] property.
//
// The names of the TextTheme properties match this table from the
// [Material Design spec](https://m3.material.io/styles/typography/tokens).
//
// ![](https://lh3.googleusercontent.com/Yvngs5mQSjXa_9T4X3JDucO62c5hdZHPDa7qeRH6DsJQvGr_q7EBrTkhkPiQd9OeR1v_Uk38Cjd9nUpP3nevDyHpKWuXSfQ1Gq78bOnBN7sr=s0)
//
// The Material Design typography scheme was significantly changed in the
// current (2021) version of the specification
// ([https://m3.material.io/styles/typography/tokens](https://m3.material.io/styles/typography/tokens)).
//
// The names of the 2018 TextTheme properties match this table from the
// [Material Design spec](https://material.io/design/typography/the-type-system.html#type-scale)
// with two exceptions: the styles called H1-H6 in the spec are
// headline1-headline6 in the API, and body1,body2 are called
// bodyText1 and bodyText2.
//
// The 2018 spec has thirteen text styles:
//
// | NAME       | SIZE |  WEIGHT |  SPACING |             |
// |------------|------|---------|----------|-------------|
// | headline1  | 96.0 | light   | -1.5     |             |
// | headline2  | 60.0 | light   | -0.5     |             |
// | headline3  | 48.0 | regular |  0.0     |             |
// | headline4  | 34.0 | regular |  0.25    |             |
// | headline5  | 24.0 | regular |  0.0     |             |
// | headline6  | 20.0 | medium  |  0.15    |             |
// | subtitle1  | 16.0 | regular |  0.15    |             |
// | subtitle2  | 14.0 | medium  |  0.1     |             |
// | body1      | 16.0 | regular |  0.5     | (bodyText1) |
// | body2      | 14.0 | regular |  0.25    | (bodyText2) |
// | button     | 14.0 | medium  |  1.25    |             |
// | caption    | 12.0 | regular |  0.4     |             |
// | overline   | 10.0 | regular |  1.5     |             |
//
// ...where "light" is `FontWeight.w300`, "regular" is `FontWeight.w400` and
// "medium" is `FontWeight.w500`.
//
// By default, text styles are initialized to match the 2018 Material Design
// specification as listed above. To provide backwards compatibility, the 2014
// specification is also available.
//
// To explicitly configure a [Theme] for the 2018 sizes, weights, and letter
// spacings, you can initialize its [ThemeData.typography] value using
// [Typography.material2018]. The [Typography] constructor defaults to this
// configuration. To configure a [Theme] for the 2014 sizes, weights, and letter
// spacings, initialize its [ThemeData.typography] value using
// [Typography.material2014].
//
// See also:
//
//  * [Typography], the class that generates [TextTheme]s appropriate for a platform.
//  * [Theme], for other aspects of a Material Design application that can be
//    globally adjusted, such as the color scheme.
//  * <https://material.io/design/typography/>
message MaterialTextThemeType {
  oneof constructor {
    MaterialTextTheme material_text_theme = 2;
  }
}

// package:flutter/src/material/theme_data.dart
//
// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
// or a widget subtree within the app.
//
// The [MaterialApp] theme property can be used to configure the appearance
// of the entire app. Widget subtrees within an app can override the app's
// theme by including a [Theme] widget at the top of the subtree.
//
// Widgets whose appearance should align with the overall theme can obtain the
// current theme's configuration with [Theme.of]. Material components typically
// depend exclusively on the [colorScheme] and [textTheme]. These properties
// are guaranteed to have non-null values.
//
// The static [Theme.of] method finds the [ThemeData] value specified for the
// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
// just a single HashMap access. It can sometimes be a little confusing
// because [Theme.of] can not see a [Theme] widget that is defined in the
// current build method's context. To overcome that, create a new custom widget
// for the subtree that appears below the new [Theme], or insert a widget
// that creates a new BuildContext, like [Builder].
//
// {@tool dartpad}
// This example demonstrates how a typical [MaterialApp] specifies
// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
// single "seed" color and configures itself to match the platform's
// current light or dark color configuration. The theme overrides the
// default configuration of [FloatingActionButton] to show how to
// customize the appearance a class of components.
//
// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
// {@end-tool}
//
// See <https://material.io/design/color/> for
// more discussion on how to pick the right colors.
message MaterialThemeDataType {
  oneof constructor {
    MaterialThemeData material_theme_data = 2;
    MaterialThemeDataNamedDark material_theme_data_named_dark = 3;
    MaterialThemeDataNamedFallback material_theme_data_named_fallback = 4;
    MaterialThemeDataNamedFrom material_theme_data_named_from = 5;
    MaterialThemeDataNamedLight material_theme_data_named_light = 6;
  }
}

// package:flutter/src/material/time.dart
//
// A value representing a time during the day, independent of the date that
// day might fall on or the time zone.
//
// The time is represented by [hour] and [minute] pair. Once created, both
// values cannot be changed.
//
// You can create TimeOfDay using the constructor which requires both hour and
// minute or using [DateTime] object.
// Hours are specified between 0 and 23, as in a 24-hour clock.
//
// {@tool snippet}
//
// ```dart
// TimeOfDay now = TimeOfDay.now();
// const TimeOfDay releaseTime = TimeOfDay(hour: 15, minute: 0); // 3:00pm
// TimeOfDay roomBooked = TimeOfDay.fromDateTime(DateTime.parse('2018-10-20 16:30:04Z')); // 4:30pm
// ```
// {@end-tool}
//
// See also:
//
//  * [showTimePicker], which returns this type.
//  * [MaterialLocalizations], which provides methods for formatting values of
//    this type according to the chosen [Locale].
//  * [DateTime], which represents date and time, and is subject to eras and
//    time zones.
message MaterialTimeOfDayType {
  oneof constructor {
    MaterialTimeOfDay material_time_of_day = 2;
    MaterialTimeOfDayNamedFromDateTime material_time_of_day_named_from_date_time = 3;
    MaterialTimeOfDayNamedNow material_time_of_day_named_now = 4;
  }
}

// package:flutter/src/material/time_picker_theme.dart
//
// Defines the visual properties of the widget displayed with [showTimePicker].
//
// Descendant widgets obtain the current [TimePickerThemeData] object using
// `TimePickerTheme.of(context)`. Instances of [TimePickerThemeData]
// can be customized with [TimePickerThemeData.copyWith].
//
// Typically a [TimePickerThemeData] is specified as part of the overall
// [Theme] with [ThemeData.timePickerTheme].
//
// All [TimePickerThemeData] properties are `null` by default. When null,
// [showTimePicker] will provide its own defaults.
//
// See also:
//
//  * [ThemeData], which describes the overall theme information for the
//    application.
//  * [TimePickerTheme], which describes the actual configuration of a time
//    picker theme.
message MaterialTimePickerThemeDataType {
  oneof constructor {
    MaterialTimePickerThemeData material_time_picker_theme_data = 2;
  }
}

// package:flutter/src/material/toggle_buttons_theme.dart
//
// Defines the color and border properties of [ToggleButtons] widgets.
//
// Used by [ToggleButtonsTheme] to control the color and border properties
// of toggle buttons in a widget subtree.
//
// To obtain the current [ToggleButtonsTheme], use [ToggleButtonsTheme.of].
//
// Values specified here are used for [ToggleButtons] properties that are not
// given an explicit non-null value.
//
// See also:
//
//  * [ToggleButtonsTheme], which describes the actual configuration of a
//    toggle buttons theme.
message MaterialToggleButtonsThemeDataType {
  oneof constructor {
    MaterialToggleButtonsThemeData material_toggle_buttons_theme_data = 2;
  }
}

// package:flutter/src/material/tooltip_theme.dart
//
// Defines the visual properties of [Tooltip] widgets.
//
// Used by [TooltipTheme] to control the visual properties of tooltips in a
// widget subtree.
//
// To obtain this configuration, use [TooltipTheme.of] to access the closest
// ancestor [TooltipTheme] of the current [BuildContext].
//
// See also:
//
//  * [TooltipTheme], an [InheritedWidget] that propagates the theme down its
//    subtree.
//  * [TooltipThemeData], which describes the actual configuration of a
//    tooltip theme.
message MaterialTooltipThemeDataType {
  oneof constructor {
    MaterialTooltipThemeData material_tooltip_theme_data = 2;
  }
}

// package:flutter/src/material/typography.dart
//
// The color and geometry [TextTheme]s for Material apps.
//
// The text theme provided by the overall [Theme],
// [ThemeData.textTheme], is based on the current locale's
// [MaterialLocalizations.scriptCategory] and is created
// by merging a color text theme - [black] for
// [Brightness.light] themes and [white] for [Brightness.dark]
// themes - and a geometry text theme, one of [englishLike], [dense],
// or [tall], depending on the locale.
//
// To lookup the localized text theme use
// `Theme.of(context).textTheme`.
//
// The color text themes are [blackMountainView], [whiteMountainView],
// [blackCupertino], and [whiteCupertino]. The Mountain View theme [TextStyle]s
// are based on the Roboto fonts as used on Android. The Cupertino themes are
// based on the [San Francisco
// font](https://developer.apple.com/ios/human-interface-guidelines/visual-design/typography/)
// fonts as used by Apple on iOS.
//
// Two sets of geometry themes are provided: 2014 and 2018. The 2014 themes
// correspond to the original version of the Material Design spec and are
// the defaults. The 2018 themes correspond the second iteration of the
// specification and feature different font sizes, font weights, and
// letter spacing values.
//
// By default, [ThemeData.typography] is `Typography.material2014(platform:
// platform)` which uses [englishLike2014], [dense2014] and [tall2014]. To use
// the 2018 text theme geometries, specify a value using the [material2018]
// constructor:
//
// ```dart
// typography: Typography.material2018(platform: platform)
// ```
//
// See also:
//
//  * <https://material.io/design/typography/>
//  * <https://m3.material.io/styles/typography>
message MaterialTypographyType {
  oneof constructor {
    MaterialTypography material_typography = 2;
    MaterialTypographyNamedMaterial2014 material_typography_named_material2014 = 3;
    MaterialTypographyNamedMaterial2018 material_typography_named_material2018 = 4;
    MaterialTypographyNamedMaterial2021 material_typography_named_material2021 = 5;
  }
}

// package:flutter/src/material/theme_data.dart
//
// Defines the visual density of user interface components.
//
// Density, in the context of a UI, is the vertical and horizontal
// "compactness" of the components in the UI. It is unitless, since it means
// different things to different UI components.
//
// The default for visual densities is zero for both vertical and horizontal
// densities, which corresponds to the default visual density of components in
// the Material Design specification. It does not affect text sizes, icon
// sizes, or padding values.
//
// For example, for buttons, it affects the spacing around the child of the
// button. For lists, it affects the distance between baselines of entries in
// the list. For chips, it only affects the vertical size, not the horizontal
// size.
//
// Here are some examples of widgets that respond to density changes:
//
//  * [Checkbox]
//  * [Chip]
//  * [ElevatedButton]
//  * [IconButton]
//  * [InputDecorator] (which gives density support to [TextField], etc.)
//  * [ListTile]
//  * [MaterialButton]
//  * [OutlinedButton]
//  * [Radio]
//  * [RawMaterialButton]
//  * [TextButton]
//
// See also:
//
//  * [ThemeData.visualDensity], where this property is used to specify the base
//    horizontal density of Material components.
//  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
message MaterialVisualDensityType {
  oneof constructor {
    MaterialVisualDensity material_visual_density = 2;
  }
}

// package:flutter/src/cupertino/theme.dart
//
// Styling specifications for a cupertino theme without default values for
// unspecified properties.
//
// Unlike [CupertinoThemeData] instances of this class do not return default
// values for properties that have been left unspecified in the constructor.
// Instead, unspecified properties will return null. This is used by
// Material's [ThemeData.cupertinoOverrideTheme].
//
// See also:
//
//  * [CupertinoThemeData], which uses reasonable default values for
//    unspecified theme properties.
message NoDefaultCupertinoThemeDataType {
  oneof constructor {
    CupertinoThemeData cupertino_theme_data = 2;
    CupertinoThemeDataNamedRaw cupertino_theme_data_named_raw = 3;
    MaterialMaterialBasedCupertinoThemeData material_material_based_cupertino_theme_data = 4;
    NoDefaultCupertinoThemeData no_default_cupertino_theme_data = 5;
  }
}

// package:flutter/src/cupertino/page_scaffold.dart
//
// Widget that has a preferred size and reports whether it fully obstructs
// widgets behind it.
//
// Used by [CupertinoPageScaffold] to either shift away fully obstructed content
// or provide a padding guide to partially obstructed content.
message ObstructingPreferredSizeWidgetType {
  oneof constructor {
    CupertinoNavigationBar cupertino_navigation_bar = 2;
  }
}

// package:vector_math/vector_math_64.dart
//
// 3D Matrix.
// Values are stored in column major order.
message VectorMathMatrix3Type {
  oneof constructor {
    VectorMathMatrix3 vector_math_matrix3 = 2;
    VectorMathMatrix3NamedColumns vector_math_matrix3_named_columns = 3;
    VectorMathMatrix3NamedCopy vector_math_matrix3_named_copy = 4;
    VectorMathMatrix3NamedFromList vector_math_matrix3_named_from_list = 5;
    VectorMathMatrix3NamedIdentity vector_math_matrix3_named_identity = 6;
    VectorMathMatrix3NamedOuter vector_math_matrix3_named_outer = 7;
    VectorMathMatrix3NamedRotationX vector_math_matrix3_named_rotation_x = 8;
    VectorMathMatrix3NamedRotationY vector_math_matrix3_named_rotation_y = 9;
    VectorMathMatrix3NamedRotationZ vector_math_matrix3_named_rotation_z = 10;
    VectorMathMatrix3NamedZero vector_math_matrix3_named_zero = 11;
  }
}

// package:vector_math/vector_math_64.dart
//
// 4D Matrix.
// Values are stored in column major order.
message VectorMathMatrix4Type {
  oneof constructor {
    VectorMathMatrix4 vector_math_matrix4 = 2;
    VectorMathMatrix4NamedColumns vector_math_matrix4_named_columns = 3;
    VectorMathMatrix4NamedCompose vector_math_matrix4_named_compose = 4;
    VectorMathMatrix4NamedCopy vector_math_matrix4_named_copy = 5;
    VectorMathMatrix4NamedDiagonal3 vector_math_matrix4_named_diagonal3 = 6;
    VectorMathMatrix4NamedDiagonal3Values vector_math_matrix4_named_diagonal3_values = 7;
    VectorMathMatrix4NamedFromBuffer vector_math_matrix4_named_from_buffer = 8;
    VectorMathMatrix4NamedFromFloat64List vector_math_matrix4_named_from_float64_list = 9;
    VectorMathMatrix4NamedFromList vector_math_matrix4_named_from_list = 10;
    VectorMathMatrix4NamedIdentity vector_math_matrix4_named_identity = 11;
    VectorMathMatrix4NamedInverted vector_math_matrix4_named_inverted = 12;
    VectorMathMatrix4NamedOuter vector_math_matrix4_named_outer = 13;
    VectorMathMatrix4NamedRotationX vector_math_matrix4_named_rotation_x = 14;
    VectorMathMatrix4NamedRotationY vector_math_matrix4_named_rotation_y = 15;
    VectorMathMatrix4NamedRotationZ vector_math_matrix4_named_rotation_z = 16;
    VectorMathMatrix4NamedSkew vector_math_matrix4_named_skew = 17;
    VectorMathMatrix4NamedSkewX vector_math_matrix4_named_skew_x = 18;
    VectorMathMatrix4NamedSkewY vector_math_matrix4_named_skew_y = 19;
    VectorMathMatrix4NamedTranslation vector_math_matrix4_named_translation = 20;
    VectorMathMatrix4NamedTranslationValues vector_math_matrix4_named_translation_values = 21;
    VectorMathMatrix4NamedZero vector_math_matrix4_named_zero = 22;
  }
}

// package:vector_math/vector_math_64.dart
//
// Defines a [Quaternion] (a four-dimensional vector) for efficient rotation
// calculations.
//
// Quaternion are better for interpolating between rotations and avoid the
// [gimbal lock](http://de.wikipedia.org/wiki/Gimbal_Lock) problem compared to
// euler rotations.
message VectorMathQuaternionType {
  oneof constructor {
    VectorMathQuaternion vector_math_quaternion = 2;
    VectorMathQuaternionNamedAxisAngle vector_math_quaternion_named_axis_angle = 3;
    VectorMathQuaternionNamedCopy vector_math_quaternion_named_copy = 4;
    VectorMathQuaternionNamedDq vector_math_quaternion_named_dq = 5;
    VectorMathQuaternionNamedEuler vector_math_quaternion_named_euler = 6;
    VectorMathQuaternionNamedFromBuffer vector_math_quaternion_named_from_buffer = 7;
    VectorMathQuaternionNamedFromFloat64List vector_math_quaternion_named_from_float64_list = 8;
    VectorMathQuaternionNamedFromRotation vector_math_quaternion_named_from_rotation = 9;
    VectorMathQuaternionNamedFromTwoVectors vector_math_quaternion_named_from_two_vectors = 10;
    VectorMathQuaternionNamedIdentity vector_math_quaternion_named_identity = 11;
    VectorMathQuaternionNamedRandom vector_math_quaternion_named_random = 12;
  }
}

// package:vector_math/vector_math_64.dart
//
// 3D column vector.
message VectorMathVector3Type {
  oneof constructor {
    VectorMathVector3 vector_math_vector3 = 2;
    VectorMathVector3NamedAll vector_math_vector3_named_all = 3;
    VectorMathVector3NamedArray vector_math_vector3_named_array = 4;
    VectorMathVector3NamedCopy vector_math_vector3_named_copy = 5;
    VectorMathVector3NamedFromBuffer vector_math_vector3_named_from_buffer = 6;
    VectorMathVector3NamedFromFloat64List vector_math_vector3_named_from_float64_list = 7;
    VectorMathVector3NamedRandom vector_math_vector3_named_random = 8;
    VectorMathVector3NamedZero vector_math_vector3_named_zero = 9;
  }
}

// package:vector_math/vector_math_64.dart
//
// 4D column vector.
message VectorMathVector4Type {
  oneof constructor {
    VectorMathVector4 vector_math_vector4 = 2;
    VectorMathVector4NamedAll vector_math_vector4_named_all = 3;
    VectorMathVector4NamedArray vector_math_vector4_named_array = 4;
    VectorMathVector4NamedCopy vector_math_vector4_named_copy = 5;
    VectorMathVector4NamedFromBuffer vector_math_vector4_named_from_buffer = 6;
    VectorMathVector4NamedFromFloat64List vector_math_vector4_named_from_float64_list = 7;
    VectorMathVector4NamedIdentity vector_math_vector4_named_identity = 8;
    VectorMathVector4NamedRandom vector_math_vector4_named_random = 9;
    VectorMathVector4NamedZero vector_math_vector4_named_zero = 10;
  }
}

// package:flutter/src/widgets/framework.dart
//
// Describes the configuration for an [Element].
//
// Widgets are the central class hierarchy in the Flutter framework. A widget
// is an immutable description of part of a user interface. Widgets can be
// inflated into elements, which manage the underlying render tree.
//
// Widgets themselves have no mutable state (all their fields must be final).
// If you wish to associate mutable state with a widget, consider using a
// [StatefulWidget], which creates a [State] object (via
// [StatefulWidget.createState]) whenever it is inflated into an element and
// incorporated into the tree.
//
// A given widget can be included in the tree zero or more times. In particular
// a given widget can be placed in the tree multiple times. Each time a widget
// is placed in the tree, it is inflated into an [Element], which means a
// widget that is incorporated into the tree multiple times will be inflated
// multiple times.
//
// The [key] property controls how one widget replaces another widget in the
// tree. If the [runtimeType] and [key] properties of the two widgets are
// [operator==], respectively, then the new widget replaces the old widget by
// updating the underlying element (i.e., by calling [Element.update] with the
// new widget). Otherwise, the old element is removed from the tree, the new
// widget is inflated into an element, and the new element is inserted into the
// tree.
//
// See also:
//
//  * [StatefulWidget] and [State], for widgets that can build differently
//    several times over their lifetime.
//  * [InheritedWidget], for widgets that introduce ambient state that can
//    be read by descendant widgets.
//  * [StatelessWidget], for widgets that always build the same way given a
//    particular configuration and ambient state.
message WidgetType {
  oneof constructor {
    CupertinoActionSheet cupertino_action_sheet = 2;
    CupertinoActivityIndicator cupertino_activity_indicator = 3;
    CupertinoActivityIndicatorNamedPartiallyRevealed cupertino_activity_indicator_named_partially_revealed = 4;
    CupertinoAdaptiveTextSelectionToolbar cupertino_adaptive_text_selection_toolbar = 5;
    CupertinoAdaptiveTextSelectionToolbarNamedButtonItems cupertino_adaptive_text_selection_toolbar_named_button_items = 6;
    CupertinoAdaptiveTextSelectionToolbarNamedEditable cupertino_adaptive_text_selection_toolbar_named_editable = 7;
    CupertinoAdaptiveTextSelectionToolbarNamedEditableText cupertino_adaptive_text_selection_toolbar_named_editable_text = 8;
    CupertinoAlertDialog cupertino_alert_dialog = 9;
    CupertinoApp cupertino_app = 10;
    CupertinoAppNamedRouter cupertino_app_named_router = 11;
    CupertinoButton cupertino_button = 12;
    CupertinoButtonNamedFilled cupertino_button_named_filled = 13;
    CupertinoCheckbox cupertino_checkbox = 14;
    CupertinoContextMenu cupertino_context_menu = 15;
    CupertinoContextMenuAction cupertino_context_menu_action = 16;
    CupertinoDesktopTextSelectionToolbar cupertino_desktop_text_selection_toolbar = 17;
    CupertinoDesktopTextSelectionToolbarButton cupertino_desktop_text_selection_toolbar_button = 18;
    CupertinoDesktopTextSelectionToolbarButtonNamedButtonItem cupertino_desktop_text_selection_toolbar_button_named_button_item = 19;
    CupertinoDesktopTextSelectionToolbarButtonNamedText cupertino_desktop_text_selection_toolbar_button_named_text = 20;
    CupertinoDialogAction cupertino_dialog_action = 21;
    CupertinoFormRow cupertino_form_row = 22;
    CupertinoFormSection cupertino_form_section = 23;
    CupertinoFormSectionNamedInsetGrouped cupertino_form_section_named_inset_grouped = 24;
    CupertinoListSection cupertino_list_section = 25;
    CupertinoListSectionNamedInsetGrouped cupertino_list_section_named_inset_grouped = 26;
    CupertinoListTile cupertino_list_tile = 27;
    CupertinoListTileChevron cupertino_list_tile_chevron = 28;
    CupertinoListTileNamedNotched cupertino_list_tile_named_notched = 29;
    CupertinoMagnifier cupertino_magnifier = 30;
    CupertinoNavigationBar cupertino_navigation_bar = 31;
    CupertinoNavigationBarBackButton cupertino_navigation_bar_back_button = 32;
    CupertinoPageScaffold cupertino_page_scaffold = 33;
    CupertinoPicker cupertino_picker = 34;
    CupertinoPickerDefaultSelectionOverlay cupertino_picker_default_selection_overlay = 35;
    CupertinoPopupSurface cupertino_popup_surface = 36;
    CupertinoScrollbar cupertino_scrollbar = 37;
    CupertinoSearchTextField cupertino_search_text_field = 38;
    CupertinoSlider cupertino_slider = 39;
    CupertinoSliverNavigationBar cupertino_sliver_navigation_bar = 40;
    CupertinoSliverRefreshControl cupertino_sliver_refresh_control = 41;
    CupertinoSpellCheckSuggestionsToolbar cupertino_spell_check_suggestions_toolbar = 42;
    CupertinoSpellCheckSuggestionsToolbarNamedEditableText cupertino_spell_check_suggestions_toolbar_named_editable_text = 43;
    CupertinoSwitch cupertino_switch = 44;
    CupertinoTabBar cupertino_tab_bar = 45;
    CupertinoTabView cupertino_tab_view = 46;
    CupertinoTextField cupertino_text_field = 47;
    CupertinoTextFieldNamedBorderless cupertino_text_field_named_borderless = 48;
    CupertinoTextFormFieldRow cupertino_text_form_field_row = 49;
    CupertinoTextSelectionToolbar cupertino_text_selection_toolbar = 50;
    CupertinoTextSelectionToolbarButton cupertino_text_selection_toolbar_button = 51;
    CupertinoTextSelectionToolbarButtonNamedButtonItem cupertino_text_selection_toolbar_button_named_button_item = 52;
    CupertinoTextSelectionToolbarButtonNamedText cupertino_text_selection_toolbar_button_named_text = 53;
    CupertinoTheme cupertino_theme = 54;
    CupertinoUserInterfaceLevel cupertino_user_interface_level = 55;
    FlutterAbsorbPointer flutter_absorb_pointer = 56;
    FlutterAlign flutter_align = 57;
    FlutterAndroidView flutter_android_view = 58;
    FlutterAnimatedAlign flutter_animated_align = 59;
    FlutterAnimatedContainer flutter_animated_container = 60;
    FlutterAnimatedCrossFade flutter_animated_cross_fade = 61;
    FlutterAnimatedDefaultTextStyle flutter_animated_default_text_style = 62;
    FlutterAnimatedFractionallySizedBox flutter_animated_fractionally_sized_box = 63;
    FlutterAnimatedOpacity flutter_animated_opacity = 64;
    FlutterAnimatedPadding flutter_animated_padding = 65;
    FlutterAnimatedPhysicalModel flutter_animated_physical_model = 66;
    FlutterAnimatedPositioned flutter_animated_positioned = 67;
    FlutterAnimatedPositionedDirectional flutter_animated_positioned_directional = 68;
    FlutterAnimatedPositionedNamedFromRect flutter_animated_positioned_named_from_rect = 69;
    FlutterAnimatedRotation flutter_animated_rotation = 70;
    FlutterAnimatedScale flutter_animated_scale = 71;
    FlutterAnimatedSize flutter_animated_size = 72;
    FlutterAnimatedSlide flutter_animated_slide = 73;
    FlutterAnimatedSwitcher flutter_animated_switcher = 74;
    FlutterAppKitView flutter_app_kit_view = 75;
    FlutterAspectRatio flutter_aspect_ratio = 76;
    FlutterAutofillGroup flutter_autofill_group = 77;
    FlutterAutomaticKeepAlive flutter_automatic_keep_alive = 78;
    FlutterBackdropFilter flutter_backdrop_filter = 79;
    FlutterBanner flutter_banner = 80;
    FlutterBaseline flutter_baseline = 81;
    FlutterBlockSemantics flutter_block_semantics = 82;
    FlutterCenter flutter_center = 83;
    FlutterCheckedModeBanner flutter_checked_mode_banner = 84;
    FlutterClipOval flutter_clip_oval = 85;
    FlutterClipPath flutter_clip_path = 86;
    FlutterClipRRect flutter_clip_r_rect = 87;
    FlutterClipRect flutter_clip_rect = 88;
    FlutterColorFiltered flutter_color_filtered = 89;
    FlutterColoredBox flutter_colored_box = 90;
    FlutterColumn flutter_column = 91;
    FlutterCompositedTransformFollower flutter_composited_transform_follower = 92;
    FlutterCompositedTransformTarget flutter_composited_transform_target = 93;
    FlutterConstrainedBox flutter_constrained_box = 94;
    FlutterContainer flutter_container = 95;
    FlutterCustomMultiChildLayout flutter_custom_multi_child_layout = 96;
    FlutterCustomPaint flutter_custom_paint = 97;
    FlutterCustomScrollView flutter_custom_scroll_view = 98;
    FlutterCustomSingleChildLayout flutter_custom_single_child_layout = 99;
    FlutterDecoratedBox flutter_decorated_box = 100;
    FlutterDecoratedSliver flutter_decorated_sliver = 101;
    FlutterDefaultAssetBundle flutter_default_asset_bundle = 102;
    FlutterDefaultSelectionStyle flutter_default_selection_style = 103;
    FlutterDefaultSelectionStyleNamedFallback flutter_default_selection_style_named_fallback = 104;
    FlutterDefaultTextEditingShortcuts flutter_default_text_editing_shortcuts = 105;
    FlutterDefaultTextHeightBehavior flutter_default_text_height_behavior = 106;
    FlutterDefaultTextStyle flutter_default_text_style = 107;
    FlutterDefaultTextStyleNamedFallback flutter_default_text_style_named_fallback = 108;
    FlutterDirectionality flutter_directionality = 109;
    FlutterDismissible flutter_dismissible = 110;
    FlutterDisplayFeatureSubScreen flutter_display_feature_sub_screen = 111;
    FlutterDraggable flutter_draggable = 112;
    FlutterDraggableScrollableActuator flutter_draggable_scrollable_actuator = 113;
    FlutterEditableText flutter_editable_text = 114;
    FlutterErrorWidgetNamedWithDetails flutter_error_widget_named_with_details = 115;
    FlutterExcludeFocus flutter_exclude_focus = 116;
    FlutterExcludeFocusTraversal flutter_exclude_focus_traversal = 117;
    FlutterExcludeSemantics flutter_exclude_semantics = 118;
    FlutterExpanded flutter_expanded = 119;
    FlutterFadeInImageNamedAssetNetwork flutter_fade_in_image_named_asset_network = 120;
    FlutterFadeInImageNamedMemoryNetwork flutter_fade_in_image_named_memory_network = 121;
    FlutterFittedBox flutter_fitted_box = 122;
    FlutterFlex flutter_flex = 123;
    FlutterFlexible flutter_flexible = 124;
    FlutterFlow flutter_flow = 125;
    FlutterFlowNamedUnwrapped flutter_flow_named_unwrapped = 126;
    FlutterFocus flutter_focus = 127;
    FlutterFocusNamedWithExternalFocusNode flutter_focus_named_with_external_focus_node = 128;
    FlutterFocusScope flutter_focus_scope = 129;
    FlutterFocusScopeNamedWithExternalFocusNode flutter_focus_scope_named_with_external_focus_node = 130;
    FlutterFocusTraversalGroup flutter_focus_traversal_group = 131;
    FlutterFocusTraversalOrder flutter_focus_traversal_order = 132;
    FlutterFocusableActionDetector flutter_focusable_action_detector = 133;
    FlutterForm flutter_form = 134;
    FlutterFractionalTranslation flutter_fractional_translation = 135;
    FlutterFractionallySizedBox flutter_fractionally_sized_box = 136;
    FlutterGestureDetector flutter_gesture_detector = 137;
    FlutterGlowingOverscrollIndicator flutter_glowing_overscroll_indicator = 138;
    FlutterGridPaper flutter_grid_paper = 139;
    FlutterGridView flutter_grid_view = 140;
    FlutterGridViewNamedCount flutter_grid_view_named_count = 141;
    FlutterGridViewNamedCustom flutter_grid_view_named_custom = 142;
    FlutterGridViewNamedExtent flutter_grid_view_named_extent = 143;
    FlutterHeroControllerScope flutter_hero_controller_scope = 144;
    FlutterHeroControllerScopeNamedNone flutter_hero_controller_scope_named_none = 145;
    FlutterHeroMode flutter_hero_mode = 146;
    FlutterHtmlElementView flutter_html_element_view = 147;
    FlutterHtmlElementViewNamedFromTagName flutter_html_element_view_named_from_tag_name = 148;
    FlutterIcon flutter_icon = 149;
    FlutterIconTheme flutter_icon_theme = 150;
    FlutterIgnoreBaseline flutter_ignore_baseline = 151;
    FlutterIgnorePointer flutter_ignore_pointer = 152;
    FlutterImageFiltered flutter_image_filtered = 153;
    FlutterImageIcon flutter_image_icon = 154;
    FlutterImageNamedAsset flutter_image_named_asset = 155;
    FlutterImageNamedFile flutter_image_named_file = 156;
    FlutterImageNamedMemory flutter_image_named_memory = 157;
    FlutterImageNamedNetwork flutter_image_named_network = 158;
    FlutterIndexedSemantics flutter_indexed_semantics = 159;
    FlutterIndexedStack flutter_indexed_stack = 160;
    FlutterInteractiveViewer flutter_interactive_viewer = 161;
    FlutterIntrinsicHeight flutter_intrinsic_height = 162;
    FlutterIntrinsicWidth flutter_intrinsic_width = 163;
    FlutterKeepAlive flutter_keep_alive = 164;
    FlutterKeyboardListener flutter_keyboard_listener = 165;
    FlutterKeyedSubtree flutter_keyed_subtree = 166;
    FlutterKeyedSubtreeNamedWrap flutter_keyed_subtree_named_wrap = 167;
    FlutterLimitedBox flutter_limited_box = 168;
    FlutterListBody flutter_list_body = 169;
    FlutterListView flutter_list_view = 170;
    FlutterListViewNamedCustom flutter_list_view_named_custom = 171;
    FlutterListWheelScrollView flutter_list_wheel_scroll_view = 172;
    FlutterListWheelScrollViewNamedUseDelegate flutter_list_wheel_scroll_view_named_use_delegate = 173;
    FlutterListWheelViewport flutter_list_wheel_viewport = 174;
    FlutterListener flutter_listener = 175;
    FlutterLocalizationsNamedOverride flutter_localizations_named_override = 176;
    FlutterLongPressDraggable flutter_long_press_draggable = 177;
    FlutterLookupBoundary flutter_lookup_boundary = 178;
    FlutterMediaQuery flutter_media_query = 179;
    FlutterMediaQueryNamedRemovePadding flutter_media_query_named_remove_padding = 180;
    FlutterMediaQueryNamedRemoveViewInsets flutter_media_query_named_remove_view_insets = 181;
    FlutterMediaQueryNamedRemoveViewPadding flutter_media_query_named_remove_view_padding = 182;
    FlutterMergeSemantics flutter_merge_semantics = 183;
    FlutterMetaData flutter_meta_data = 184;
    FlutterModalBarrier flutter_modal_barrier = 185;
    FlutterMouseRegion flutter_mouse_region = 186;
    FlutterNavigationToolbar flutter_navigation_toolbar = 187;
    FlutterNavigator flutter_navigator = 188;
    FlutterNavigatorPopHandler flutter_navigator_pop_handler = 189;
    FlutterNestedScrollViewViewport flutter_nested_scroll_view_viewport = 190;
    FlutterNotificationListener flutter_notification_listener = 191;
    FlutterOffstage flutter_offstage = 192;
    FlutterOpacity flutter_opacity = 193;
    FlutterOverflowBar flutter_overflow_bar = 194;
    FlutterOverflowBox flutter_overflow_box = 195;
    FlutterOverlay flutter_overlay = 196;
    FlutterPadding flutter_padding = 197;
    FlutterPageStorage flutter_page_storage = 198;
    FlutterPageView flutter_page_view = 199;
    FlutterPageViewNamedCustom flutter_page_view_named_custom = 200;
    FlutterPerformanceOverlay flutter_performance_overlay = 201;
    FlutterPerformanceOverlayNamedAllEnabled flutter_performance_overlay_named_all_enabled = 202;
    FlutterPhysicalModel flutter_physical_model = 203;
    FlutterPlaceholder flutter_placeholder = 204;
    FlutterPlatformMenuBar flutter_platform_menu_bar = 205;
    FlutterPlatformSelectableRegionContextMenu flutter_platform_selectable_region_context_menu = 206;
    FlutterPopScope flutter_pop_scope = 207;
    FlutterPositioned flutter_positioned = 208;
    FlutterPositionedDirectional flutter_positioned_directional = 209;
    FlutterPositionedNamedDirectional flutter_positioned_named_directional = 210;
    FlutterPositionedNamedFill flutter_positioned_named_fill = 211;
    FlutterPositionedNamedFromRect flutter_positioned_named_from_rect = 212;
    FlutterPositionedNamedFromRelativeRect flutter_positioned_named_from_relative_rect = 213;
    FlutterPreferredSize flutter_preferred_size = 214;
    FlutterPrimaryScrollController flutter_primary_scroll_controller = 215;
    FlutterPrimaryScrollControllerNamedNone flutter_primary_scroll_controller_named_none = 216;
    FlutterProjectMyApp flutter_project_my_app = 217;
    FlutterProjectMyHomePage flutter_project_my_home_page = 218;
    FlutterRawGestureDetector flutter_raw_gesture_detector = 219;
    FlutterRawImage flutter_raw_image = 220;
    FlutterRawMagnifier flutter_raw_magnifier = 221;
    FlutterRawScrollbar flutter_raw_scrollbar = 222;
    FlutterReorderableDelayedDragStartListener flutter_reorderable_delayed_drag_start_listener = 223;
    FlutterReorderableDragStartListener flutter_reorderable_drag_start_listener = 224;
    FlutterRepaintBoundary flutter_repaint_boundary = 225;
    FlutterRepaintBoundaryNamedWrap flutter_repaint_boundary_named_wrap = 226;
    FlutterRestorationScope flutter_restoration_scope = 227;
    FlutterRichText flutter_rich_text = 228;
    FlutterRootRestorationScope flutter_root_restoration_scope = 229;
    FlutterRootWidget flutter_root_widget = 230;
    FlutterRotatedBox flutter_rotated_box = 231;
    FlutterRow flutter_row = 232;
    FlutterSafeArea flutter_safe_area = 233;
    FlutterScrollConfiguration flutter_scroll_configuration = 234;
    FlutterScrollNotificationObserver flutter_scroll_notification_observer = 235;
    FlutterSelectableRegion flutter_selectable_region = 236;
    FlutterSelectionContainer flutter_selection_container = 237;
    FlutterSelectionContainerNamedDisabled flutter_selection_container_named_disabled = 238;
    FlutterSelectionRegistrarScope flutter_selection_registrar_scope = 239;
    FlutterSemantics flutter_semantics = 240;
    FlutterSemanticsDebugger flutter_semantics_debugger = 241;
    FlutterSemanticsNamedFromProperties flutter_semantics_named_from_properties = 242;
    FlutterSharedAppData flutter_shared_app_data = 243;
    FlutterShortcutRegistrar flutter_shortcut_registrar = 244;
    FlutterShortcutsNamedManager flutter_shortcuts_named_manager = 245;
    FlutterShrinkWrappingViewport flutter_shrink_wrapping_viewport = 246;
    FlutterSingleChildScrollView flutter_single_child_scroll_view = 247;
    FlutterSizeChangedLayoutNotifier flutter_size_changed_layout_notifier = 248;
    FlutterSizedBox flutter_sized_box = 249;
    FlutterSizedBoxNamedExpand flutter_sized_box_named_expand = 250;
    FlutterSizedBoxNamedFromSize flutter_sized_box_named_from_size = 251;
    FlutterSizedBoxNamedShrink flutter_sized_box_named_shrink = 252;
    FlutterSizedBoxNamedSquare flutter_sized_box_named_square = 253;
    FlutterSizedOverflowBox flutter_sized_overflow_box = 254;
    FlutterSliverAnimatedOpacity flutter_sliver_animated_opacity = 255;
    FlutterSliverConstrainedCrossAxis flutter_sliver_constrained_cross_axis = 256;
    FlutterSliverCrossAxisExpanded flutter_sliver_cross_axis_expanded = 257;
    FlutterSliverCrossAxisGroup flutter_sliver_cross_axis_group = 258;
    FlutterSliverFillRemaining flutter_sliver_fill_remaining = 259;
    FlutterSliverFillViewport flutter_sliver_fill_viewport = 260;
    FlutterSliverFixedExtentList flutter_sliver_fixed_extent_list = 261;
    FlutterSliverFixedExtentListNamedList flutter_sliver_fixed_extent_list_named_list = 262;
    FlutterSliverGrid flutter_sliver_grid = 263;
    FlutterSliverGridNamedCount flutter_sliver_grid_named_count = 264;
    FlutterSliverGridNamedExtent flutter_sliver_grid_named_extent = 265;
    FlutterSliverIgnorePointer flutter_sliver_ignore_pointer = 266;
    FlutterSliverList flutter_sliver_list = 267;
    FlutterSliverListNamedList flutter_sliver_list_named_list = 268;
    FlutterSliverMainAxisGroup flutter_sliver_main_axis_group = 269;
    FlutterSliverOffstage flutter_sliver_offstage = 270;
    FlutterSliverOpacity flutter_sliver_opacity = 271;
    FlutterSliverOverlapAbsorber flutter_sliver_overlap_absorber = 272;
    FlutterSliverOverlapInjector flutter_sliver_overlap_injector = 273;
    FlutterSliverPadding flutter_sliver_padding = 274;
    FlutterSliverPersistentHeader flutter_sliver_persistent_header = 275;
    FlutterSliverPrototypeExtentList flutter_sliver_prototype_extent_list = 276;
    FlutterSliverPrototypeExtentListNamedList flutter_sliver_prototype_extent_list_named_list = 277;
    FlutterSliverSafeArea flutter_sliver_safe_area = 278;
    FlutterSliverToBoxAdapter flutter_sliver_to_box_adapter = 279;
    FlutterSliverVisibility flutter_sliver_visibility = 280;
    FlutterSliverVisibilityNamedMaintain flutter_sliver_visibility_named_maintain = 281;
    FlutterSnapshotWidget flutter_snapshot_widget = 282;
    FlutterSpacer flutter_spacer = 283;
    FlutterStack flutter_stack = 284;
    FlutterStretchingOverscrollIndicator flutter_stretching_overscroll_indicator = 285;
    FlutterTable flutter_table = 286;
    FlutterTableCell flutter_table_cell = 287;
    FlutterTapRegion flutter_tap_region = 288;
    FlutterTapRegionSurface flutter_tap_region_surface = 289;
    FlutterText flutter_text = 290;
    FlutterTextFieldTapRegion flutter_text_field_tap_region = 291;
    FlutterTextNamedRich flutter_text_named_rich = 292;
    FlutterTextSelectionGestureDetector flutter_text_selection_gesture_detector = 293;
    FlutterTexture flutter_texture = 294;
    FlutterTickerMode flutter_ticker_mode = 295;
    FlutterTitle flutter_title = 296;
    FlutterTransform flutter_transform = 297;
    FlutterTransformNamedFlip flutter_transform_named_flip = 298;
    FlutterTransformNamedRotate flutter_transform_named_rotate = 299;
    FlutterTransformNamedScale flutter_transform_named_scale = 300;
    FlutterTransformNamedTranslate flutter_transform_named_translate = 301;
    FlutterUiKitView flutter_ui_kit_view = 302;
    FlutterUnconstrainedBox flutter_unconstrained_box = 303;
    FlutterUnmanagedRestorationScope flutter_unmanaged_restoration_scope = 304;
    FlutterView flutter_view = 305;
    FlutterViewAnchor flutter_view_anchor = 306;
    FlutterViewCollection flutter_view_collection = 307;
    FlutterViewport flutter_viewport = 308;
    FlutterVisibility flutter_visibility = 309;
    FlutterVisibilityNamedMaintain flutter_visibility_named_maintain = 310;
    FlutterWidgetInspector flutter_widget_inspector = 311;
    FlutterWidgetToRenderBoxAdapter flutter_widget_to_render_box_adapter = 312;
    FlutterWidgetsApp flutter_widgets_app = 313;
    FlutterWidgetsAppNamedRouter flutter_widgets_app_named_router = 314;
    FlutterWrap flutter_wrap = 315;
    MaterialAboutDialog material_about_dialog = 316;
    MaterialAboutListTile material_about_list_tile = 317;
    MaterialActionChip material_action_chip = 318;
    MaterialActionChipNamedElevated material_action_chip_named_elevated = 319;
    MaterialActionIconTheme material_action_icon_theme = 320;
    MaterialAdaptiveTextSelectionToolbar material_adaptive_text_selection_toolbar = 321;
    MaterialAdaptiveTextSelectionToolbarNamedButtonItems material_adaptive_text_selection_toolbar_named_button_items = 322;
    MaterialAdaptiveTextSelectionToolbarNamedEditable material_adaptive_text_selection_toolbar_named_editable = 323;
    MaterialAdaptiveTextSelectionToolbarNamedEditableText material_adaptive_text_selection_toolbar_named_editable_text = 324;
    MaterialAdaptiveTextSelectionToolbarNamedSelectableRegion material_adaptive_text_selection_toolbar_named_selectable_region = 325;
    MaterialAlertDialog material_alert_dialog = 326;
    MaterialAlertDialogNamedAdaptive material_alert_dialog_named_adaptive = 327;
    MaterialAnimatedTheme material_animated_theme = 328;
    MaterialAppBar material_app_bar = 329;
    MaterialBackButton material_back_button = 330;
    MaterialBackButtonIcon material_back_button_icon = 331;
    MaterialBadge material_badge = 332;
    MaterialBadgeNamedCount material_badge_named_count = 333;
    MaterialBadgeTheme material_badge_theme = 334;
    MaterialBottomAppBar material_bottom_app_bar = 335;
    MaterialBottomNavigationBar material_bottom_navigation_bar = 336;
    MaterialBottomNavigationBarTheme material_bottom_navigation_bar_theme = 337;
    MaterialButtonBar material_button_bar = 338;
    MaterialButtonBarTheme material_button_bar_theme = 339;
    MaterialButtonTheme material_button_theme = 340;
    MaterialButtonThemeNamedFromButtonThemeData material_button_theme_named_from_button_theme_data = 341;
    MaterialCard material_card = 342;
    MaterialCardNamedFilled material_card_named_filled = 343;
    MaterialCardNamedOutlined material_card_named_outlined = 344;
    MaterialCheckbox material_checkbox = 345;
    MaterialCheckboxListTile material_checkbox_list_tile = 346;
    MaterialCheckboxListTileNamedAdaptive material_checkbox_list_tile_named_adaptive = 347;
    MaterialCheckboxMenuButton material_checkbox_menu_button = 348;
    MaterialCheckboxNamedAdaptive material_checkbox_named_adaptive = 349;
    MaterialCheckboxTheme material_checkbox_theme = 350;
    MaterialCheckedPopupMenuItem material_checked_popup_menu_item = 351;
    MaterialChip material_chip = 352;
    MaterialChipTheme material_chip_theme = 353;
    MaterialChoiceChip material_choice_chip = 354;
    MaterialChoiceChipNamedElevated material_choice_chip_named_elevated = 355;
    MaterialCircleAvatar material_circle_avatar = 356;
    MaterialCircularProgressIndicator material_circular_progress_indicator = 357;
    MaterialCircularProgressIndicatorNamedAdaptive material_circular_progress_indicator_named_adaptive = 358;
    MaterialCloseButton material_close_button = 359;
    MaterialCloseButtonIcon material_close_button_icon = 360;
    MaterialDataTable material_data_table = 361;
    MaterialDataTableTheme material_data_table_theme = 362;
    MaterialDatePickerDialog material_date_picker_dialog = 363;
    MaterialDatePickerTheme material_date_picker_theme = 364;
    MaterialDateRangePickerDialog material_date_range_picker_dialog = 365;
    MaterialDefaultTabController material_default_tab_controller = 366;
    MaterialDesktopTextSelectionToolbar material_desktop_text_selection_toolbar = 367;
    MaterialDesktopTextSelectionToolbarButton material_desktop_text_selection_toolbar_button = 368;
    MaterialDesktopTextSelectionToolbarButtonNamedText material_desktop_text_selection_toolbar_button_named_text = 369;
    MaterialDialog material_dialog = 370;
    MaterialDialogNamedFullscreen material_dialog_named_fullscreen = 371;
    MaterialDivider material_divider = 372;
    MaterialDividerTheme material_divider_theme = 373;
    MaterialDrawer material_drawer = 374;
    MaterialDrawerButton material_drawer_button = 375;
    MaterialDrawerButtonIcon material_drawer_button_icon = 376;
    MaterialDrawerController material_drawer_controller = 377;
    MaterialDrawerHeader material_drawer_header = 378;
    MaterialDrawerTheme material_drawer_theme = 379;
    MaterialDropdownButton material_dropdown_button = 380;
    MaterialDropdownButtonFormField material_dropdown_button_form_field = 381;
    MaterialDropdownButtonHideUnderline material_dropdown_button_hide_underline = 382;
    MaterialDropdownMenuItem material_dropdown_menu_item = 383;
    MaterialDropdownMenuTheme material_dropdown_menu_theme = 384;
    MaterialElevatedButton material_elevated_button = 385;
    MaterialElevatedButtonNamedIcon material_elevated_button_named_icon = 386;
    MaterialElevatedButtonTheme material_elevated_button_theme = 387;
    MaterialEndDrawerButton material_end_drawer_button = 388;
    MaterialEndDrawerButtonIcon material_end_drawer_button_icon = 389;
    MaterialExpandIcon material_expand_icon = 390;
    MaterialExpansionPanelList material_expansion_panel_list = 391;
    MaterialExpansionPanelListNamedRadio material_expansion_panel_list_named_radio = 392;
    MaterialExpansionTile material_expansion_tile = 393;
    MaterialExpansionTileTheme material_expansion_tile_theme = 394;
    MaterialFilledButton material_filled_button = 395;
    MaterialFilledButtonNamedIcon material_filled_button_named_icon = 396;
    MaterialFilledButtonNamedTonal material_filled_button_named_tonal = 397;
    MaterialFilledButtonNamedTonalIcon material_filled_button_named_tonal_icon = 398;
    MaterialFilledButtonTheme material_filled_button_theme = 399;
    MaterialFilterChip material_filter_chip = 400;
    MaterialFilterChipNamedElevated material_filter_chip_named_elevated = 401;
    MaterialFlexibleSpaceBar material_flexible_space_bar = 402;
    MaterialFlexibleSpaceBarSettings material_flexible_space_bar_settings = 403;
    MaterialFloatingActionButton material_floating_action_button = 404;
    MaterialFloatingActionButtonNamedExtended material_floating_action_button_named_extended = 405;
    MaterialFloatingActionButtonNamedLarge material_floating_action_button_named_large = 406;
    MaterialFloatingActionButtonNamedSmall material_floating_action_button_named_small = 407;
    MaterialFlutterLogo material_flutter_logo = 408;
    MaterialGridTile material_grid_tile = 409;
    MaterialGridTileBar material_grid_tile_bar = 410;
    MaterialIconButton material_icon_button = 411;
    MaterialIconButtonNamedFilled material_icon_button_named_filled = 412;
    MaterialIconButtonNamedFilledTonal material_icon_button_named_filled_tonal = 413;
    MaterialIconButtonNamedOutlined material_icon_button_named_outlined = 414;
    MaterialIconButtonTheme material_icon_button_theme = 415;
    MaterialInk material_ink = 416;
    MaterialInkResponse material_ink_response = 417;
    MaterialInkWell material_ink_well = 418;
    MaterialInputChip material_input_chip = 419;
    MaterialInputDatePickerFormField material_input_date_picker_form_field = 420;
    MaterialInputDecorator material_input_decorator = 421;
    MaterialLicensePage material_license_page = 422;
    MaterialLinearProgressIndicator material_linear_progress_indicator = 423;
    MaterialListTile material_list_tile = 424;
    MaterialListTileTheme material_list_tile_theme = 425;
    MaterialMagnifier material_magnifier = 426;
    MaterialMaterial material_material = 427;
    MaterialMaterialApp material_material_app = 428;
    MaterialMaterialAppNamedRouter material_material_app_named_router = 429;
    MaterialMaterialBanner material_material_banner = 430;
    MaterialMaterialBannerTheme material_material_banner_theme = 431;
    MaterialMaterialButton material_material_button = 432;
    MaterialMenuAcceleratorCallbackBinding material_menu_accelerator_callback_binding = 433;
    MaterialMenuAcceleratorLabel material_menu_accelerator_label = 434;
    MaterialMenuAnchor material_menu_anchor = 435;
    MaterialMenuBar material_menu_bar = 436;
    MaterialMenuBarTheme material_menu_bar_theme = 437;
    MaterialMenuButtonTheme material_menu_button_theme = 438;
    MaterialMenuItemButton material_menu_item_button = 439;
    MaterialMenuTheme material_menu_theme = 440;
    MaterialMergeableMaterial material_mergeable_material = 441;
    MaterialNavigationBar material_navigation_bar = 442;
    MaterialNavigationBarTheme material_navigation_bar_theme = 443;
    MaterialNavigationDestination material_navigation_destination = 444;
    MaterialNavigationDrawer material_navigation_drawer = 445;
    MaterialNavigationDrawerDestination material_navigation_drawer_destination = 446;
    MaterialNavigationDrawerTheme material_navigation_drawer_theme = 447;
    MaterialNavigationRail material_navigation_rail = 448;
    MaterialNavigationRailTheme material_navigation_rail_theme = 449;
    MaterialOutlinedButton material_outlined_button = 450;
    MaterialOutlinedButtonNamedIcon material_outlined_button_named_icon = 451;
    MaterialOutlinedButtonTheme material_outlined_button_theme = 452;
    MaterialPaginatedDataTable material_paginated_data_table = 453;
    MaterialPopupMenuDivider material_popup_menu_divider = 454;
    MaterialPopupMenuItem material_popup_menu_item = 455;
    MaterialPopupMenuTheme material_popup_menu_theme = 456;
    MaterialProgressIndicatorTheme material_progress_indicator_theme = 457;
    MaterialRadioTheme material_radio_theme = 458;
    MaterialRangeSlider material_range_slider = 459;
    MaterialRawChip material_raw_chip = 460;
    MaterialRawMaterialButton material_raw_material_button = 461;
    MaterialRefreshProgressIndicator material_refresh_progress_indicator = 462;
    MaterialScaffold material_scaffold = 463;
    MaterialScaffoldMessenger material_scaffold_messenger = 464;
    MaterialScrollbar material_scrollbar = 465;
    MaterialScrollbarTheme material_scrollbar_theme = 466;
    MaterialSearchBar material_search_bar = 467;
    MaterialSearchBarTheme material_search_bar_theme = 468;
    MaterialSearchViewTheme material_search_view_theme = 469;
    MaterialSegmentedButtonTheme material_segmented_button_theme = 470;
    MaterialSelectableText material_selectable_text = 471;
    MaterialSelectableTextNamedRich material_selectable_text_named_rich = 472;
    MaterialSelectionArea material_selection_area = 473;
    MaterialSimpleDialog material_simple_dialog = 474;
    MaterialSimpleDialogOption material_simple_dialog_option = 475;
    MaterialSlider material_slider = 476;
    MaterialSliderNamedAdaptive material_slider_named_adaptive = 477;
    MaterialSliderTheme material_slider_theme = 478;
    MaterialSliverAppBar material_sliver_app_bar = 479;
    MaterialSliverAppBarNamedLarge material_sliver_app_bar_named_large = 480;
    MaterialSliverAppBarNamedMedium material_sliver_app_bar_named_medium = 481;
    MaterialSnackBar material_snack_bar = 482;
    MaterialSpellCheckSuggestionsToolbar material_spell_check_suggestions_toolbar = 483;
    MaterialSpellCheckSuggestionsToolbarNamedEditableText material_spell_check_suggestions_toolbar_named_editable_text = 484;
    MaterialStepper material_stepper = 485;
    MaterialSubmenuButton material_submenu_button = 486;
    MaterialSwitch material_switch = 487;
    MaterialSwitchListTile material_switch_list_tile = 488;
    MaterialSwitchListTileNamedAdaptive material_switch_list_tile_named_adaptive = 489;
    MaterialSwitchNamedAdaptive material_switch_named_adaptive = 490;
    MaterialSwitchTheme material_switch_theme = 491;
    MaterialTab material_tab = 492;
    MaterialTabBar material_tab_bar = 493;
    MaterialTabBarNamedSecondary material_tab_bar_named_secondary = 494;
    MaterialTabBarView material_tab_bar_view = 495;
    MaterialTabPageSelector material_tab_page_selector = 496;
    MaterialTabPageSelectorIndicator material_tab_page_selector_indicator = 497;
    MaterialTableRowInkWell material_table_row_ink_well = 498;
    MaterialTextButton material_text_button = 499;
    MaterialTextButtonNamedIcon material_text_button_named_icon = 500;
    MaterialTextButtonTheme material_text_button_theme = 501;
    MaterialTextField material_text_field = 502;
    MaterialTextFormField material_text_form_field = 503;
    MaterialTextSelectionTheme material_text_selection_theme = 504;
    MaterialTextSelectionToolbar material_text_selection_toolbar = 505;
    MaterialTextSelectionToolbarTextButton material_text_selection_toolbar_text_button = 506;
    MaterialTheme material_theme = 507;
    MaterialTimePickerDialog material_time_picker_dialog = 508;
    MaterialTimePickerTheme material_time_picker_theme = 509;
    MaterialToggleButtons material_toggle_buttons = 510;
    MaterialToggleButtonsTheme material_toggle_buttons_theme = 511;
    MaterialTooltip material_tooltip = 512;
    MaterialTooltipTheme material_tooltip_theme = 513;
    MaterialTooltipVisibility material_tooltip_visibility = 514;
    MaterialUserAccountsDrawerHeader material_user_accounts_drawer_header = 515;
    MaterialVerticalDivider material_vertical_divider = 516;
  }
}

